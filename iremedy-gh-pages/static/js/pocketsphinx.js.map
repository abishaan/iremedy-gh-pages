{"version":3,"file":"pocketsphinx.js","sources":["/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/src/psRecognizer.h","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/emscripten/bind.h","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/emscripten/wire.h","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/src/psRecognizer.cpp","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/vector","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/string","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/sstream","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/ostream","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/ios","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/memory","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/src/emprint.h","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/algorithm","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/__split_buffer","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/new","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/type_traits","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/streambuf","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/iosfwd","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/iterator","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/map","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/__tree","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/utility","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/tuple","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/set","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/emscripten/val.h","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ps_alignment.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/state_align_search.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/acmod.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/bin_mdef.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/blkarray_list.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/dict.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/dict2pid.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/fsg_history.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/fsg_lextree.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/fsg_search.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/hmm.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/mdef.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ms_gauden.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ms_mgau.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ms_senone.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ngram_search.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ngram_search_fwdtree.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ngram_search_fwdflat.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/phone_loop_search.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/pocketsphinx.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ps_lattice.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ps_mllr.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/ptm_mgau.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/tied_mgau_common.h","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/s2_semi_mgau.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/tmat.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/vector.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/kws_search.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/kws_detections.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/pocketsphinx/src/libpocketsphinx/allphone_search.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_interface.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_sigproc.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_warp_affine.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_warp.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_warp_inverse_linear.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_warp_piecewise_linear.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_noise.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/fe/fe_prespch_buf.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/feat/agc.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/feat/cmn.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/feat/cmn_live.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/feat/feat.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/feat/lda.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/fsg_model.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/jsgf.c","jsgf_parser.c","jsgf_parser.y","jsgf_scanner.c","_jsgf_scanner.l","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/ngrams_raw.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/lm_trie.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/lm_trie_quant.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/ngram_model_set.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/ngram_model_trie.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/lm/ngram_model.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/bio.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/bitvec.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/case.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/ckd_alloc.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/cmd_ln.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/dtoa.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/err.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/filename.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/genrand.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/glist.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/hash_table.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/listelem_alloc.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/logmath.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/mmio.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/pio.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/profile.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/strfuncs.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/bitarr.c","/home/brij/Documents/Project/Gsoc2017_CMU/pocketsphinx.js/sphinxbase/src/libsphinxbase/util/priority_queue.c","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/lib/embind/bind.cpp","/home/brij/Documents/Project/Gsoc2017_CMU/emsdk-portable/emscripten/1.37.16/system/include/libcxx/typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8JA;AAAA;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;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;AAEA;AAAA;;;;AAEA;;;;;;;AAYA;;;;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAEA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;;;;AAKA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;AAEA;;;;;;AAjCA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiEA;AAAA;;;AAGA;AAAA;AACA;AAAA;;;;AAGA;AAAA;;AACA;AACA;AAAA;;;;AAKA;AAAA;;AAEA;AAAA;;;;;AAEA;AAAA;;AACA;AACA;AAAA;;;;AAGA;;;AACA;AAAA;;;;;AACA;;AACA;AAAA;AAAA;AAAA;AAEA;;;;AAGA;AAAA;;AACA;AACA;AAAA;;;;;;AAIA;AAAA;;;;;AAEA;AAGA;AACA;AAYA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;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","sourcesContent":["#ifndef _PSRECOGNIZER_H_\n#define _PSRECOGNIZER_H_\n\n#include <stdint.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <iostream>\n#include <emscripten/bind.h>\n#include \"pocketsphinx.h\"\n\n// For state alignment\n#include \"ps_alignment.h\"\n#include \"state_align_search.h\"\n#include \"pocketsphinx_internal.h\"\n\nnamespace pocketsphinxjs {\n\n  enum ReturnType {\n    SUCCESS,\n    BAD_STATE,\n    BAD_ARGUMENT,\n    RUNTIME_ERROR\n  };\n\n  struct Transition {\n    int from;\n    int to;\n    int logp;\n    std::string word;\n  };\n\n  struct Grammar {\n    int start;\n    int end;\n    int numStates;\n    std::vector<Transition> transitions;\n  };\n\n  typedef std::map<std::string, std::string> Dictionary;\n  \n  struct Word {\n    std::string word;\n    std::string pronunciation;\n  };\n\n  struct ConfigItem {\n    std::string key;\n    std::string value;\n  };\n\n  struct SegItem {\n    std::string word;\n    int start;\n    int end;\n    int ascr;\n    int lscr;\n  };\n\n  typedef std::vector<std::string> StringsListType;\n  typedef std::set<std::string> StringsSetType;\n  typedef std::vector<ConfigItem> Config;\n  typedef std::vector<int> Integers;\n  typedef std::vector<SegItem> Segmentation;\n\n  class Recognizer {\n\n  public:\n    Recognizer();\n    Recognizer(const Config&);\n    ReturnType reInit(const Config&);\n    ReturnType addWords(const std::vector<Word>&);\n    ReturnType addGrammar(Integers&, const Grammar&);\n    ReturnType addKeyword(Integers&, const std::string&);\n    // Kept for backward compatibility, use switchSearch\n    // instead\n    ReturnType switchGrammar(int);\n    ReturnType switchSearch(int);\n    std::string getHyp();\n    ReturnType getHypseg(Segmentation&);\n    ReturnType getWordAlignSeg(Segmentation&);\n    ReturnType start();\n    ReturnType stop();\n    ReturnType process(const std::vector<int16_t>&);\n    ReturnType wordAlign(const std::vector<int16_t>&, const std::string&);\n    std::string lookupWord(const std::string&);\n    ~Recognizer();\n    \n  private:\n    ReturnType init(const Config&);\n    bool isValidParameter(const std::string&, const std::string&);\n    void cleanup();\n    StringsListType grammar_names;\n    bool is_fsg;\n    bool is_recording;\n    std::string current_hyp;\n    int32_t grammar_index;\n    fsg_model_t * current_grammar;\n    ps_decoder_t * decoder;\n    logmath_t * logmath;\n    StringsSetType acoustic_models;\n    std::string default_acoustic_model;\n    StringsSetType language_models;\n    StringsSetType dictionaries;\n    std::string default_language_model;\n    std::string default_dictionary;\n\n    // state alignment variables\n    cmd_ln_t * cmd_line;\n    dict_t *dict;\n    dict2pid_t *d2p;\n    acmod_t *acmod;\n    ps_alignment_t *al;\n    ps_search_t *search;\n    ps_alignment_entry_t *ae;\n \n  };\n  \n} // namespace pocketsphinxjs\n\n\n\n\n/**********************************************\n *\n * Usage:\n *\n * var recognizer = new Module.Recognizer();\n * var words = new Module.VectorWords();\n * words.push_back([\"HELLO\", \"HH AH L OW\"]);\n * words.push_back([\"WORLD\", \"W ER L D\"]);\n * recognizer.addWords(words);\n * words.delete()\n * var transitions = new Module.VectorTransitions();\n * transitions.push_back({from: 0, to: 1, word: \"HELLO\"});\n * transitions.push_back({from: 1, to: 2, word: \"WORLD\"});\n * var ids = new Module.Integers();\n * recognizer.addGrammar(ids, {start: 1, end: 2, numStates: 3, transitions: transitions});\n * transitions.delete();\n * var id = ids.get(0);\n * ids.delete();\n * var length = 100;\n * recognizer.start();\n * var buffer = new Module.AudioBuffer();\n * for (var i = 0 ; i < length ; i++)\n *    buffer.push_back(i*100);\n * recognizer.process(buffer);\n * recognizer.process(buffer);\n * recognizer.process(buffer);\n * buffer.delete();\n * recognizer.stop();\n * recognizer.delete();\n *\n *********************************************/\n\nnamespace ps = pocketsphinxjs;\nEMSCRIPTEN_BINDINGS(recognizer) {\n\n  emscripten::enum_<ps::ReturnType>(\"ReturnType\")\n    .value(\"SUCCESS\", ps::SUCCESS)\n    .value(\"BAD_STATE\", ps::BAD_STATE)\n    .value(\"BAD_ARGUMENT\", ps::BAD_ARGUMENT)\n    .value(\"RUNTIME_ERROR\", ps::RUNTIME_ERROR);\n\n  emscripten::value_array<ps::Word>(\"Word\")\n    .element(&ps::Word::word)\n    .element(&ps::Word::pronunciation);\n\n  emscripten::value_array<ps::ConfigItem>(\"ConfigItem\")\n    .element(&ps::ConfigItem::key)\n    .element(&ps::ConfigItem::value);\n\n  emscripten::value_object<ps::SegItem>(\"SegItem\")\n    .field(\"word\", &ps::SegItem::word)\n    .field(\"start\", &ps::SegItem::start)\n    .field(\"end\", &ps::SegItem::end)\n    .field(\"ascr\", &ps::SegItem::ascr)\n    .field(\"lscr\", &ps::SegItem::lscr);\n\n  emscripten::value_object<ps::Transition>(\"Transition\")\n    .field(\"from\", &ps::Transition::from)\n    .field(\"to\", &ps::Transition::to)\n    .field(\"logp\", &ps::Transition::logp)\n    .field(\"word\", &ps::Transition::word);\n\n\n  emscripten::register_vector<int16_t>(\"AudioBuffer\");\n  emscripten::register_vector<ps::Transition>(\"VectorTransitions\");\n  emscripten::register_vector<ps::Word>(\"VectorWords\");\n  emscripten::register_vector<ps::ConfigItem>(\"Config\");\n  emscripten::register_vector<ps::SegItem>(\"Segmentation\");\n  emscripten::register_vector<int>(\"Integers\");\n\n  emscripten::value_object<ps::Grammar>(\"Grammar\")\n    .field(\"start\", &ps::Grammar::start)\n    .field(\"end\", &ps::Grammar::end)\n    .field(\"numStates\", &ps::Grammar::numStates)\n    .field(\"transitions\", &ps::Grammar::transitions);\n\n  emscripten::class_<ps::Recognizer>(\"Recognizer\")\n    .constructor<>()\n    .constructor<const ps::Config&>()\n    .function(\"reInit\", &ps::Recognizer::reInit)\n    .function(\"addWords\", &ps::Recognizer::addWords)\n    .function(\"addGrammar\", &ps::Recognizer::addGrammar)\n    .function(\"addKeyword\", &ps::Recognizer::addKeyword)\n    .function(\"switchGrammar\", &ps::Recognizer::switchGrammar)\n    .function(\"switchSearch\", &ps::Recognizer::switchSearch)\n    .function(\"getHyp\", &ps::Recognizer::getHyp)\n    .function(\"getHypseg\", &ps::Recognizer::getHypseg)\n    .function(\"getWordAlignSeg\", &ps::Recognizer::getWordAlignSeg)\n    .function(\"start\", &ps::Recognizer::start)\n    .function(\"stop\", &ps::Recognizer::stop)\n    .function(\"lookupWord\", &ps::Recognizer::lookupWord)\n    .function(\"process\", &ps::Recognizer::process)\n    .function(\"wordAlign\", &ps::Recognizer::wordAlign);\n}\n\n#endif /* _PSRECOGNIZER_H_ */\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/bind.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void* GenericFunction;\n        typedef void (*VoidFunctionPtr)(void);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename InstanceType, typename ElementType, int N>\n        value_object& field(const char* fieldName, ElementType (InstanceType::*field)[N]) {\n            using namespace internal;\n\n            typedef std::array<ElementType, N> FieldType;\n            static_assert(sizeof(FieldType) == sizeof(ElementType[N]));\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static VoidFunctionPtr getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast   = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n\n#endif // ~C++11 version check\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/wire.h> requires building with -std=c++11 or newer!\n#else\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                    ? &typeid(C)\n                    : CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                ? &typeid(value)\n                : LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n\n        template<typename T>\n        constexpr bool typeSupportsMemoryView() {\n            return (std::is_floating_point<T>::value &&\n                        (sizeof(T) == 4 || sizeof(T) == 8)) ||\n                    (std::is_integral<T>::value &&\n                        (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type of typed_memory_view is invalid\");\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n\n#endif // ~C++11 version check\n","#include \"psRecognizer.h\"\n#include \"pocketsphinx.h\"\n#include \"pocketsphinxjs-config.h\"\n\n#include \"emprint.h\"\n\nnamespace pocketsphinxjs {\n  typedef std::map<std::string, std::string> StringsMapType;\n  typedef std::map<std::string, std::string>::iterator StringsMapIterator;\n\n  // Implemented later in this file\n  ReturnType parseStringList(const std::string &, StringsSetType*, std::string*);\n\n  Recognizer::Recognizer(): is_fsg(true), is_recording(false), current_hyp(\"\"), grammar_index(0) {\n    Config c;\n    if (init(c) != SUCCESS) cleanup();\n  }\n\n  Recognizer::Recognizer(const Config& config) : is_fsg(true), is_recording(false), current_hyp(\"\"), grammar_index(0) {\n    if (init(config) != SUCCESS) cleanup();\n  }\n\n  ReturnType Recognizer::reInit(const Config& config) {\n    ReturnType r = init(config);\n    if (r != SUCCESS) cleanup();\n    return r;\n  }\n\n  ReturnType Recognizer::addWords(const std::vector<Word>& words) {\n    if (decoder == NULL) return BAD_STATE;\n    for (int i=0 ; i<words.size() ; ++i) {\n      // This case is not properly handeled by ps_add_word, so we treat it separately\n      if (words.at(i).pronunciation.size() == 0) return RUNTIME_ERROR;\n      if (ps_add_word(decoder, words.at(i).word.c_str(), words.at(i).pronunciation.c_str(), 1) < 0) return RUNTIME_ERROR;\n    }\n    return SUCCESS;\n  }\n\n  ReturnType Recognizer::addGrammar(Integers& id, const Grammar& grammar) {\n    if (decoder == NULL) return BAD_STATE;\n    std::ostringstream grammar_name;\n    grammar_name << grammar_index;\n    grammar_names.push_back(grammar_name.str());\n    current_grammar = fsg_model_init(grammar_names.back().c_str(), logmath, 1.0, grammar.numStates);\n    if (current_grammar == NULL)\n      return RUNTIME_ERROR;\n    current_grammar->start_state = grammar.start;\n    current_grammar->final_state = grammar.end;\n    for (int i=0;i<grammar.transitions.size();i++) {\n      if ((grammar.transitions.at(i).word.size() > 0) && (ps_lookup_word(decoder, grammar.transitions.at(i).word.c_str())))\n\tfsg_model_trans_add(current_grammar, grammar.transitions.at(i).from, grammar.transitions.at(i).to, grammar.transitions.at(i).logp, fsg_model_word_add(current_grammar, grammar.transitions.at(i).word.c_str()));\n      else\n\tfsg_model_null_trans_add(current_grammar, grammar.transitions.at(i).from, grammar.transitions.at(i).to, grammar.transitions.at(i).logp);\n    }\n    fsg_model_add_silence(current_grammar, \"<sil>\", -1, 1.0);\n\n    if(ps_set_fsg(decoder, grammar_names.back().c_str(), current_grammar)) {\n      return RUNTIME_ERROR;\n    }\n    if (id.size() == 0) id.push_back(grammar_index);\n    else id.at(0) = grammar_index;\n    grammar_index++;\n    // We switch to the newly added grammar right away\n    if (ps_set_search(decoder, grammar_names.back().c_str())) {\n      return RUNTIME_ERROR;\n    }\n    return SUCCESS;\n  }\n\n\n  ReturnType Recognizer::addKeyword(Integers& id, const std::string& keyphrase) {\n    if (decoder == NULL) return BAD_STATE;\n    std::ostringstream search_name;\n    search_name << grammar_index;\n    grammar_names.push_back(search_name.str());\n    if(ps_set_keyphrase(decoder, grammar_names.back().c_str(), keyphrase.c_str())) {\n      return RUNTIME_ERROR;\n    }\n    if (id.size() == 0) id.push_back(grammar_index);\n    else id.at(0) = grammar_index;\n    grammar_index++;\n    // We switch to the newly added search right away\n    if (ps_set_search(decoder, grammar_names.back().c_str())) {\n      return RUNTIME_ERROR;\n    }\n    return SUCCESS;\n  }\n\n\n  ReturnType Recognizer::switchGrammar(int id) {\n    return switchSearch(id);\n  }\n\n  ReturnType Recognizer::switchSearch(int id) {\n    if (decoder == NULL) return BAD_STATE;\n    if ((id < 0) || (id >= grammar_names.size())) return BAD_ARGUMENT;\n    if(ps_set_search(decoder, grammar_names.at(id).c_str())) {\n      return RUNTIME_ERROR;\n    }\n    return SUCCESS;\n  }\n\n  ReturnType Recognizer::start() {\n    if ((decoder == NULL) || (is_recording)) return BAD_STATE;\n    if ((ps_start_utt(decoder) < 0) || (ps_start_stream(decoder) < 0)) {\n      return RUNTIME_ERROR;\n    }\n    current_hyp = \"\";\n    is_recording = true;\n    return SUCCESS;\n  }\n\n  ReturnType Recognizer::stop() {\n    if ((decoder == NULL) || (!is_recording)) return BAD_STATE;\n    if (ps_end_utt(decoder) < 0) {\n      return RUNTIME_ERROR;\n    }\n    const char* h = ps_get_hyp(decoder, NULL);\n    current_hyp = (h == NULL) ? \"\" : h;\n    is_recording = false;\n    return SUCCESS;\n  }\n\n  ReturnType Recognizer::process(const std::vector<int16_t>& buffer) {\n    if ((decoder == NULL) || (!is_recording)) return BAD_STATE;\n    if (buffer.size() == 0)\n      return RUNTIME_ERROR;\n    ps_process_raw(decoder, (short int *) &buffer[0], buffer.size(), 0, 0);\n    const char* h = ps_get_hyp(decoder, NULL);\n    current_hyp = (h == NULL) ? \"\" : h;\n    return SUCCESS;\n  }\n\n  ReturnType Recognizer::wordAlign(const std::vector<int16_t>& buffer, const std::string& word) {\n\n  \tsize_t bufsize = 2048;\n\n\n    if ((decoder == NULL) || (!is_recording)) return BAD_STATE;\n    if (buffer.size() == 0)\n      return RUNTIME_ERROR;\n    //ps_process_raw(decoder, (short int *) &buffer[0], buffer.size(), 0, 0);\n    //const char* h = ps_get_hyp(decoder, NULL);\n    //current_hyp = (h == NULL) ? \"\" : h;\n\n    int16 buf[bufsize];\n    size_t nread;\n    int16 const *bptr;\n    int nfr;\n\n    dict = decoder->dict;\n    d2p = decoder->d2p;\n    acmod = decoder->acmod;\n\n    const char * wordc = word.c_str();\n\n  \temprintf(\"Decoding word ==> %s\", wordc);\n\n  \tprintf(\"\\nDecoding word ==>\\n\");\n  \tE_INFO(\"\\nDecoding word ==>\\n\");\n  \tprintf(\"\\nDecoding word ==> %s\\n\", wordc);\n  \tE_INFO(\"\\nDecoding word ==> %s\\n\", wordc);\n\n    al = ps_alignment_init(d2p);\n    ps_alignment_add_word(al, dict_wordid(dict, \"<s>\"), 0);\n    ps_alignment_add_word(al, dict_wordid(dict, wordc), 0);\n    ps_alignment_add_word(al, dict_wordid(dict, \"</s>\"), 0);\n    ps_alignment_populate(al);\n\n    search = state_align_search_init(\"state_align\", cmd_line, acmod, al);\n\n    acmod_start_utt(acmod);\n    ps_search_start(search);\n\n    size_t arrsize = buffer.size();\n\n  \temprintf(\"Buffer size: %u\", arrsize);\n\n    size_t start = 0, end = bufsize;\n\n    while (start < end && end <= arrsize) {\n\t  \temprintf(\"start : %u, end : %u\", start, end);\n\n    \tmemset(buf, 0, sizeof(int16) * bufsize);\n    \t\n    \tfor (int i = start, j = 0; i < end; i++, j++) {\n    \t\tbuf[j] = buffer[i];\n    \t}\n    \tnread = end - start;\n    \tbptr = buf; \n        while ((nfr = acmod_process_raw(acmod, &bptr, &nread, FALSE)) > 0) {\n            while (acmod->n_feat_frame > 0) {\n                ps_search_step(search, acmod->output_frame);\n                acmod_advance(acmod);\n            }\n        \temprintf(\"processed %d frames\", nfr);\n        }\n\n        start += bufsize;\n        end += bufsize;\n        if (end > arrsize) {\n        \tend = arrsize;\n        }\n    }\n\n    acmod_end_utt(acmod);\n    ps_search_finish(search);\n\n    emprintf(\"aligned %d words, %d phones, and %d states\", \n        ps_alignment_n_words(al), ps_alignment_n_phones(al),\n        ps_alignment_n_states(al));\n\n    return SUCCESS;\n  }\n\n  ReturnType Recognizer::getWordAlignSeg(Segmentation& seg) {\n    if (decoder == NULL) return BAD_STATE;\n    seg.clear();\n\n    // METADATA\n    SegItem segItem;\n  \tsegItem.word = \"METADATA\";\n    segItem.start = ps_alignment_n_words(al);\n    segItem.end = ps_alignment_n_phones(al);\n    segItem.ascr = ps_alignment_n_states(al);\n    segItem.lscr = 0;\n    seg.push_back(segItem);\n\n    ps_alignment_iter_t *itor = ps_alignment_phones(al);\n    while (itor) {\n        ae = ps_alignment_iter_get(itor);\n        SegItem segItem;\n      \tsegItem.word = ae->id.pid.cipid;\n        segItem.start = ae->start / 100.0;\n        segItem.end = ae->duration / 100.0;\n        segItem.ascr = ae->score;\n        segItem.lscr = 0;\n        seg.push_back(segItem);\n        itor = ps_alignment_iter_next(itor);\n    }\n\n    return SUCCESS;\n  }\n\n  std::string Recognizer::lookupWord(const std::string& word) {\n    std::string output = \"\";\n    if (word.size() > 0) {\n      char * result = ps_lookup_word(decoder, word.c_str());\n      if (result != NULL)\n\toutput = result;\n    }\n    return output;\n  }\n\n  Recognizer::~Recognizer() {\n    cleanup();\n  }\n\n  std::string Recognizer::getHyp() {\n    return current_hyp;\n  }\n\n  ReturnType Recognizer::getHypseg(Segmentation& seg) {\n    if (decoder == NULL) return BAD_STATE;\n    seg.clear();\n    int32 sfh=0, efh=0;\n    int32 ascr=0, lscr=0, lback=0;\n    std::string hseg;\n    ps_seg_t *itor = ps_seg_iter(decoder);\n    while (itor) {\n      SegItem segItem;\n      segItem.word = ps_seg_word(itor);\n      ps_seg_frames(itor, &sfh, &efh);\n      ps_seg_prob(itor, &ascr, &lscr, &lback);\n      segItem.start = sfh;\n      segItem.end = efh;\n      segItem.ascr = ascr;\n      segItem.lscr = lscr;\n      seg.push_back(segItem);\n      itor = ps_seg_next(itor);\n    }\n    return SUCCESS;\n  }\n\n  void Recognizer::cleanup() {\n    if (decoder) ps_free(decoder);\n    if (logmath) logmath_free(logmath);\n    if (search) ps_search_free(search);\n    if (al) ps_alignment_free(al);\n    decoder = NULL;\n    logmath = NULL;\n    search = NULL;\n    al = NULL;\n  }\n\n  ReturnType Recognizer::init(const Config& config) {\n#ifdef HMM_FOLDERS\n    parseStringList(HMM_FOLDERS, &acoustic_models, &default_acoustic_model);\n#endif /* HMM_FOLDERS */\n#ifdef LM_FILES\n    parseStringList(LM_FILES, &language_models, &default_language_model);\n#endif /* LM_FILES */\n#ifdef DICT_FILES\n    parseStringList(DICT_FILES, &dictionaries, &default_dictionary);\n#endif /* DICT_FILES */\n\n    const arg_t cont_args_def[] = {\n      POCKETSPHINX_OPTIONS,\n      { \"-argfile\",\n\tARG_STRING,\n\tNULL,\n\t\"Argument file giving extra arguments.\" },\n      { \"-adcdev\",\n\tARG_STRING,\n\tNULL,\n\t\"Name of audio device to use for input.\" },\n      { \"-infile\",\n\tARG_STRING,\n\tNULL,\n\t\"Audio file to transcribe.\" },\n      { \"-time\",\n\tARG_BOOLEAN,\n\t\"no\",\n\t\"Print word times in file transcription.\" },\n      CMDLN_EMPTY_OPTION\n    };\n    grammar_names.push_back(\"_default\");\n    grammar_index++;\n    std::map<std::string, std::string> parameters;\n    for (int i=0 ; i< config.size() ; ++i)\n      parameters[config[i].key] = config[i].value;\n    \n    if (parameters.find(\"-hmm\") == parameters.end())\n      parameters[\"-hmm\"] = default_acoustic_model;\n    if (parameters.find(\"-bestpath\") == parameters.end())\n      parameters[\"-bestpath\"] = \"yes\";\n    if (parameters.find(\"-remove_noise\") == parameters.end())\n      parameters[\"-remove_noise\"] = \"no\";\n    if (parameters.find(\"-remove_silence\") == parameters.end())\n      parameters[\"-remove_silence\"] = \"no\";\n\n    int argc = 2 * parameters.size();\n    char ** argv = new char*[argc];\n    int index = 0;\n    for (StringsMapIterator i = parameters.begin() ; i != parameters.end(); ++i) {\n      if (i->first == \"-lm\") is_fsg = false;\n      argv[index++] = (char*) i->first.c_str();\n      argv[index++] = (char*) i->second.c_str();\n    }\n\n    cmd_line = cmd_ln_parse_r(NULL, cont_args_def, argc, argv, FALSE);\n    if (cmd_line == NULL) {\n      delete [] argv;\n      return RUNTIME_ERROR;\n    }\n    decoder = ps_init(cmd_line);\n    delete [] argv;\n    if (decoder == NULL) {\n      return RUNTIME_ERROR;\n    }\n    logmath = logmath_init(1.0001, 0, 0);\n    if (logmath == NULL) {\n      return RUNTIME_ERROR;\n    }\n    return SUCCESS;\n  }\n\n  /*******************************************\n   *\n   * Parses the string with available models and fills in\n   * the default model and the available models\n   * @param string to parse, the models are separated with \";\"\n   * @return 0 if successful, always successful\n   *\n   *****************************************/\n  ReturnType parseStringList(const std::string & list, StringsSetType* strings_set, std::string* default_string = NULL) {\n    if ((strings_set == NULL) || (list.size() == 0))\n      return BAD_ARGUMENT;\n    std::string separator = \";\";\n    std::string::size_type index;\n    std::string first_string = list.substr(0, index = list.find(separator));\n    if (default_string != NULL)\n      *default_string = first_string;\n    strings_set->insert(first_string);\n    while((index != std::string::npos) && (index != list.size() -1))\n      strings_set->insert(list.substr(index+1, -1 -index +(index = list.find(separator, index + 1))));\n    return SUCCESS;\n  }\n} // namespace pocketsphinxjs\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n    void __annotate_contiguous_container\n    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const\n    {\n#ifndef _LIBCPP_HAS_NO_ASAN\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n#endif\n    }\n\n    void __annotate_new(size_type __current_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n    void __annotate_delete() const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}\n      inline void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());             \n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? 0 : memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return __n == 0 ? NULL : (const char_type*) memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return __n == 0 ? NULL : (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag()).first;\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value\n             || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n\tbasic_string __temp (__first, __last, __alloc());\n\tappend(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n          && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===--------------------------- sstream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SSTREAM\n#define _LIBCPP_SSTREAM\n\n/*\n    sstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringbuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    basic_stringbuf(basic_stringbuf&& rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& rhs);\n    void swap(basic_stringbuf& rhs);\n\n    // 27.8.1.3 Get and set:\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringbuf<charT, traits, Allocator>& x,\n            basic_stringbuf<charT, traits, Allocator>& y);\n\ntypedef basic_stringbuf<char>    stringbuf;\ntypedef basic_stringbuf<wchar_t> wstringbuf;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_istringstream\n    : public basic_istream<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode which = ios_base::in);\n    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,\n                                 ios_base::openmode which = ios_base::in);\n    basic_istringstream(basic_istringstream&& rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& rhs);\n    void swap(basic_istringstream& rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_istringstream<charT, traits, Allocator>& x,\n            basic_istringstream<charT, traits, Allocator>& y);\n\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_istringstream<wchar_t> wistringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_ostringstream\n    : public basic_ostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.3.1 Constructors/destructor:\n    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);\n    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                 ios_base::openmode which = ios_base::out);\n    basic_ostringstream(basic_ostringstream&& rhs);\n\n    // 27.8.3.2 Assign/swap:\n    basic_ostringstream& operator=(basic_ostringstream&& rhs);\n    void swap(basic_ostringstream& rhs);\n\n    // 27.8.3.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_ostringstream<charT, traits, Allocator>& x,\n            basic_ostringstream<charT, traits, Allocator>& y);\n\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringstream\n    : public basic_iostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // constructors/destructor\n    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);\n    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                ios_base::openmode which = ios_base::out|ios_base::in);\n    basic_stringstream(basic_stringstream&& rhs);\n\n    // 27.8.5.1 Assign/swap:\n    basic_stringstream& operator=(basic_stringstream&& rhs);\n    void swap(basic_stringstream& rhs);\n\n    // Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& str);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringstream<charT, traits, Allocator>& x,\n            basic_stringstream<charT, traits, Allocator>& y);\n\ntypedef basic_stringstream<char>    stringstream;\ntypedef basic_stringstream<wchar_t> wstringstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <string>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// basic_stringbuf\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_stringbuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n\n    string_type __str_;\n    mutable char_type* __hm_;\n    ios_base::openmode __mode_;\n\npublic:\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf(basic_stringbuf&& __rhs);\n#endif\n\n    // 27.8.1.2 Assign and swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf& operator=(basic_stringbuf&& __rhs);\n#endif\n    void swap(basic_stringbuf& __rhs);\n\n    // 27.8.1.3 Get and set:\n    string_type str() const;\n    void str(const string_type& __s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(string_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(__s);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)\n    : __mode_(__rhs.__mode_)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>&\nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __mode_ = __rhs.__mode_;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __rbinp = -1;\n    ptrdiff_t __rninp = -1;\n    ptrdiff_t __reinp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __rbinp = __rhs.eback() - __p;\n        __rninp = __rhs.gptr() - __p;\n        __reinp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __rbout = -1;\n    ptrdiff_t __rnout = -1;\n    ptrdiff_t __reout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __rbout = __rhs.pbase() - __p;\n        __rnout = __rhs.pptr() - __p;\n        __reout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __p = const_cast<char_type*>(__str_.data());\n    ptrdiff_t __lbinp = -1;\n    ptrdiff_t __lninp = -1;\n    ptrdiff_t __leinp = -1;\n    if (this->eback() != nullptr)\n    {\n        __lbinp = this->eback() - __p;\n        __lninp = this->gptr() - __p;\n        __leinp = this->egptr() - __p;\n    }\n    ptrdiff_t __lbout = -1;\n    ptrdiff_t __lnout = -1;\n    ptrdiff_t __leout = -1;\n    if (this->pbase() != nullptr)\n    {\n        __lbout = this->pbase() - __p;\n        __lnout = this->pptr() - __p;\n        __leout = this->epptr() - __p;\n    }\n    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;\n    _VSTD::swap(__mode_, __rhs.__mode_);\n    __str_.swap(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__rbinp != -1)\n        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__rbout != -1)\n    {\n        this->setp(__p + __rbout, __p + __reout);\n        this->pbump(__rnout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    if (__lbinp != -1)\n        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);\n    else\n        __rhs.setg(nullptr, nullptr, nullptr);\n    if (__lbout != -1)\n    {\n        __rhs.setp(__p + __lbout, __p + __leout);\n        __rhs.pbump(__lnout);\n    }\n    else\n        __rhs.setp(nullptr, nullptr);\n    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;\n    locale __tl = __rhs.getloc();\n    __rhs.pubimbue(this->getloc());\n    this->pubimbue(__tl);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const\n{\n    if (__mode_ & ios_base::out)\n    {\n        if (__hm_ < this->pptr())\n            __hm_ = this->pptr();\n        return string_type(this->pbase(), __hm_, __str_.get_allocator());\n    }\n    else if (__mode_ & ios_base::in)\n        return string_type(this->eback(), this->egptr(), __str_.get_allocator());\n    return string_type(__str_.get_allocator());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __str_ = __s;\n    __hm_ = 0;\n    if (__mode_ & ios_base::in)\n    {\n        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();\n        this->setg(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()),\n                   __hm_);\n    }\n    if (__mode_ & ios_base::out)\n    {\n        typename string_type::size_type __sz = __str_.size();\n        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;\n        __str_.resize(__str_.capacity());\n        this->setp(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()) + __str_.size());\n        if (__mode_ & (ios_base::app | ios_base::ate))\n            this->pbump(__sz);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (__mode_ & ios_base::in)\n    {\n        if (this->egptr() < __hm_)\n            this->setg(this->eback(), this->gptr(), __hm_);\n        if (this->gptr() < this->egptr())\n            return traits_type::to_int_type(*this->gptr());\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            return traits_type::not_eof(__c);\n        }\n        if ((__mode_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)\n{\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        ptrdiff_t __ninp = this->gptr()  - this->eback();\n        if (this->pptr() == this->epptr())\n        {\n            if (!(__mode_ & ios_base::out))\n                return traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                ptrdiff_t __nout = this->pptr()  - this->pbase();\n                ptrdiff_t __hm = __hm_ - this->pbase();\n                __str_.push_back(char_type());\n                __str_.resize(__str_.capacity());\n                char_type* __p = const_cast<char_type*>(__str_.data());\n                this->setp(__p, __p + __str_.size());\n                this->pbump(__nout);\n                __hm_ = this->pbase() + __hm;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                return traits_type::eof();\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        }\n        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);\n        if (__mode_ & ios_base::in)\n        {\n            char_type* __p = const_cast<char_type*>(__str_.data());\n            this->setg(__p, __p + __ninp, __hm_);\n        }\n        return this->sputc(__c);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,\n                                                      ios_base::seekdir __way,\n                                                      ios_base::openmode __wch)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if ((__wch & (ios_base::in | ios_base::out)) == 0)\n        return pos_type(-1);\n    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)\n        && __way == ios_base::cur)\n        return pos_type(-1);\n    off_type __noff;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __noff = 0;\n        break;\n    case ios_base::cur:\n        if (__wch & ios_base::in)\n            __noff = this->gptr() - this->eback();\n        else\n            __noff = this->pptr() - this->pbase();\n        break;\n    case ios_base::end:\n        __noff = __hm_ - __str_.data();\n        break;\n    default:\n        return pos_type(-1);\n    }\n    __noff += __off;\n    if (__noff < 0 || __hm_ - __str_.data() < __noff)\n        return pos_type(-1);\n    if (__noff != 0)\n    {\n        if ((__wch & ios_base::in) && this->gptr() == 0)\n            return pos_type(-1);\n        if ((__wch & ios_base::out) && this->pptr() == 0)\n            return pos_type(-1);\n    }\n    if (__wch & ios_base::in)\n        this->setg(this->eback(), this->eback() + __noff, __hm_);\n    if (__wch & ios_base::out)\n    {\n        this->setp(this->pbase(), this->epptr());\n        this->pbump(__noff);\n    }\n    return pos_type(__noff);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,\n                                                      ios_base::openmode __wch)\n{\n    return seekoff(__sp, ios_base::beg, __wch);\n}\n\n// basic_istringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istringstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);\n    explicit basic_istringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_istringstream(basic_istringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_istringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::in)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::in)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>&\nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_ostringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostringstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);\n    explicit basic_ostringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ostringstream(basic_ostringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_ostringstream& operator=(basic_ostringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_ostringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::out)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::out)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)\n    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>&\nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_stringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_stringstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringstream(const string_type& __s,\n                                ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringstream(basic_stringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_stringstream& operator=(basic_stringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_stringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,\n                                                                    ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)\n    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>&\nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SSTREAM\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\n\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n#include <__undef___deallocate>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            throw bad_alloc();\n#else\n            assert(!\"allocator<T>::allocate::bad_alloc\");\n#endif\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            throw bad_alloc();\n#else\n            assert(!\"allocator<const T>::allocate::bad_alloc\");\n#endif\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n            {\n                __e->__weak_this_.__ptr_ = const_cast<_Yp*>(static_cast<const _Yp*>(__e));\n                __e->__weak_this_.__cntrl_ = __cntrl_;\n                __cntrl_->__add_weak();\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","#ifndef EMPRINTF_H\n#define EMPRINTF_H\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <emscripten.h>\n\n#define MAX_MSG_LEN 1000\n\n/* NOTE: Don't pass format strings that contain single quote (') or newline\n* characters. */\nstatic void emprintf(const char *format, ...)\n{\n    char msg[MAX_MSG_LEN];\n    char consoleMsg[MAX_MSG_LEN + 16];\n    va_list args;\n\n    /* create the string */\n    va_start(args, format);\n    vsnprintf(msg, MAX_MSG_LEN, format, args);\n    va_end(args);\n\n    /* wrap the string in a console.log('') statement */\n    snprintf(consoleMsg, MAX_MSG_LEN + 16, \"console.log('%s')\", msg);\n\n    /* send the final string to the JavaScript console */\n    emscripten_run_script(consoleMsg);\n}\n\n#endif  /* EMPRINTF_H */","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _LIBCPP_EXPLICIT_MOVE(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 \npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return make_pair(__last1, __last1);\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return make_pair(__first1, __first1 + __len2);\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff), \n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#include <__undef___deallocate>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#if defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309)\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#if defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309)\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY pair;\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TYPE_VIS_ONLY __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#if __has_builtin(__builtin_addressof)\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#endif // __has_builtin(__builtin_addressof)\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : std::integral_constant<bool,\n    !std::is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<const _T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2 {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n    typedef typename common_type<\n        typename common_type<_Tp, _Up>::type, _Vp...\n    >::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(_VSTD::__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TYPE_VIS_ONLY is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TYPE_VIS_ONLY is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    typedef decltype(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>())) __swap1;\n    typedef decltype(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>())) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = std::is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS_ONLY char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS_ONLY allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS_ONLY fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n#if defined(_NEWLIB_VERSION)\n// On newlib, off_t is 'long int'\ntypedef long int streamoff;         // for char_traits in <string>\n#else\ntypedef long long streamoff;        // for char_traits in <string>\n#endif\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n\n// Include other forward declarations here\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n    \t __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n    \t!__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIter\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1,\n     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TYPE_VIS_ONLY vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n\t: public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n\t\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n\t: public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n\t: public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n\t: public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Cont>\nconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr size_t size(const _Tp (&__array)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\nconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr bool empty(const _Tp (&__array)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\nauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Cont> constexpr\nauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    pair<iterator, bool> insert(      value_type&& v);                                // C++17\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(      value_type&& v);                                            // C++17\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare,\n          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Compare&>(*this), static_cast<const _Compare&>(__y));\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(comp, __y.comp);\n    }\n    \n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,\n     __map_value_compare<_Key, _CP, _Compare, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\n\nprivate:\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = _VSTD::move(__v.__nc); return *this;}\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(_ValueTp&& __v) {\n        __nc = _VSTD::forward<_ValueTp>(__v); return *this;\n    }\n\nprivate:\n    __value_type() _LIBCPP_EQUAL_DELETE;\n    ~__value_type() _LIBCPP_EQUAL_DELETE;\n    __value_type(const __value_type& __v) _LIBCPP_EQUAL_DELETE;\n    __value_type(__value_type&& __v) _LIBCPP_EQUAL_DELETE;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\nprivate:\n   __value_type();\n   __value_type(__value_type const&);\n   __value_type& operator=(__value_type const&);\n   ~__value_type();\n};\n\n#endif\n\ntemplate <class _Tp>\nstruct __extract_key_value_types;\n\ntemplate <class _Key, class _Tp>\nstruct __extract_key_value_types<__value_type<_Key, _Tp> >\n{\n  typedef _Key const __key_type;\n  typedef _Tp        __mapped_type;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer        pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(__map_iterator<\n        typename _TreeIterator::__non_const_iterator> __i) _NOEXCEPT\n        : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>             iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&& ...__args) {\n        return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_unique(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    insert(value_type&& __v) {return __tree_.__insert_unique(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p,  value_type&& __v)\n    {return __tree_.__insert_unique(__p.__i_, _VSTD::move(__v));}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, __k, _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, _VSTD::move(__k), _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, const key_type& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, __k, _VSTD::forward<_Vp>(__v));\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n     }\n\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n\n    __node_base_pointer const&\n    __find_equal_key(__node_base_pointer& __parent, const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_base_pointer&\n    __find_equal_key(__node_base_pointer& __parent, const key_type& __k) {\n        map const* __const_this = this;\n        return const_cast<__node_base_pointer&>(\n            __const_this->__find_equal_key(__parent, __k));\n    }\n};\n\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer const&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n\n#ifdef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#else\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(__k),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(_VSTD::move(__k)),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_pointer __parent;\n    __node_base_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace(_Args&& ...__args) {\n        return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(__p.__i_, _VSTD::move(__v));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n\ntemplate <class _Pointer> class __tree_end_node;\ntemplate <class _VoidPtr> class __tree_node_base;\ntemplate <class _Tp, class _VoidPtr> class __tree_node;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Value>\nunion __value_type;\n#else\ntemplate <class _Key, class _Value>\nstruct __value_type;\n#endif\n\ntemplate <class _Allocator> class __map_node_destructor;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// node traits\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_tree_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_tree_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\ntemplate <class _Tp>\nstruct __tree_key_value_types {\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __tree_key_value_types<__value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __value_type<_Key, _Tp>                      __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef pair<_Key, _Tp>                              __nc_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const&\n  __get_key(__node_value_type const& __t) {\n    return __t.__cc.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      key_type const&>::type\n  __get_key(_Up& __t) {\n    return __t.first;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const&\n  __get_value(__node_value_type const& __t) {\n    return __t.__cc;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__cc);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __nc_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v.__nc);\n  }\n#endif\n};\n\ntemplate <class _VoidPtr>\nstruct __tree_node_base_types {\n  typedef _VoidPtr                                               __void_pointer;\n\n  typedef __tree_node_base<__void_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef __tree_end_node<__node_base_pointer>                  __end_node_type;\n  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type\n                                                             __end_node_pointer;\nprivate:\n  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,\n         bool = _KVTypes::__is_map>\nstruct __tree_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __tree_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >\n    : public __tree_node_base_types<_VoidPtr>,\n             __tree_key_value_types<_Tp>,\n             __tree_map_pointer_types<_Tp, _VoidPtr>\n{\n  typedef __tree_node_base_types<_VoidPtr> __base;\n  typedef __tree_key_value_types<_Tp>      __key_base;\n  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;\npublic:\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _ValueTp, class _VoidPtr>\nstruct __make_tree_node_types {\n  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type\n                                                                        _NodePtr;\n  typedef __tree_node_types<_NodePtr> type;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_node_base_types<_VoidPtr>::__end_node_type\n{\n    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;\n\npublic:\n    typedef typename _NodeBaseTypes::__node_base_pointer pointer;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\nprivate:\n  ~__tree_node_base() _LIBCPP_EQUAL_DELETE;\n  __tree_node_base(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node_base& operator=(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef _Tp __node_value_type;\n\n    __node_value_type __value_;\n\nprivate:\n  ~__tree_node() _LIBCPP_EQUAL_DELETE;\n  __tree_node(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node& operator=(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n};\n\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __tree_node_types<pointer> _NodeTypes;\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__val)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef _NodePtr                                        __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __node_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                     iterator_category;\n    typedef _Tp                                            value_type;\n    typedef _DiffType                                      difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_next(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef typename _NodeTypes::__node_pointer             __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __node_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef _Tp                                                  value_type;\n    typedef _DiffType                                            difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>\n                                                           __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_next(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __make_tree_node_types<value_type,\n        typename __alloc_traits::void_pointer>::type\n                                                    _NodeTypes;\n    typedef typename _NodeTypes::key_type           key_type;\npublic:\n    typedef typename _NodeTypes::__node_value_type      __node_value_type;\n    typedef typename _NodeTypes::__container_value_type __container_value_type;\n\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\npublic:\n    typedef typename _NodeTypes::__void_pointer        __void_pointer;\n\n    typedef typename _NodeTypes::__node_type           __node;\n    typedef typename _NodeTypes::__node_pointer        __node_pointer;\n\n    typedef typename _NodeTypes::__node_base_type      __node_base;\n    typedef typename _NodeTypes::__node_base_pointer   __node_base_pointer;\n\n    typedef typename _NodeTypes::__end_node_type       __end_node_t;\n    typedef typename _NodeTypes::__end_node_pointer    __end_node_ptr;\n\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>         __node_traits;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n    __node_pointer                                     __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>(\n                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_pointer>(\n            pointer_traits<__end_node_ptr>::pointer_to(\n                const_cast<__end_node_t&>(__pair1_.first())\n            )\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n#if _LIBCPP_STD_VER <= 11\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n#endif\n            );\n\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    pair<iterator, bool>\n    __emplace_unique_key_args(_Key const&, _Args&&... __args);\n    template <class _Key, class ..._Args>\n    iterator\n    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);\n\n    template <class... _Args>\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n        return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n        return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_unique_extract_key(__p, _VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        iterator\n    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {\n        return __emplace_hint_unique_key_args(__p, __f,\n                                              _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {\n        return __emplace_hint_unique_impl(__p, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_hint_unique_impl(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {\n      return __emplace_hint_unique_key_args(__p, __x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {\n      return __emplace_hint_unique_key_args(__p, __x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n#else\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);\n    }\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const __container_value_type& __v);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __v);\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Vp&& __v) {\n        return __emplace_unique(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_unique(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(__container_value_type&& __v) {\n        return __emplace_multi(_VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::move(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Vp&& __v) {\n        return __emplace_multi(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n#endif // !_LIBCPP_CXX03_LANG\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __node_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __node_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const key_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const key_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const key_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n#else\n    __node_holder __construct_node(const __container_value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n#if _LIBCPP_STD_VER <= 11\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n#endif\n            )\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_allocator(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const key_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    // __new_node->__is_black_ is initialized in __tree_balance_after_insert\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args& __args)\n#endif\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_tree_value_type<_Args...>::value,\n                  \"Cannot construct from __value_type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const __container_value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const __container_value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n#endif\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, _NodeTypes::__get_ptr(\n        const_cast<__node_value_type&>(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> constexpr add_const<T>_t& as_const(T& t) noexcept;      // C++17\ntemplate <class T>                      void as_const(const T&&) = delete; // C++17\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&\n                                is_nothrow_swappable_v<T2>);\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&&\n    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, (void) ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\n// forward declared in <type_traits>\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }\ntemplate <class _Tp>                        void as_const(const _Tp&&) = delete;\n#endif\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n#ifndef _LIBCPP_HAS_NO_DEFAULT_FUNCTION_TEMPLATE_ARGS\n    template <bool _Dummy = true, class = typename enable_if<\n        __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&\n        __dependent_type<is_default_constructible<_T2>, _Dummy>::value\n      >::type>\n#endif\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        using _VSTD::swap;\n        swap(first,  __p.first);\n        swap(second, __p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(const pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\n#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    typedef __make_integer_seq<integer_sequence, _Tp, _Ep> type;\n};\n\n#else\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence must have a non-negative sequence length\");\n    // Workaround GCC bug by preventing bad installations when 0 <= _Ep\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929\n    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;\n};\n\n#endif\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n  \n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <size_t I, class T> class tuple_element; // undefined\ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t I, class T>\n  using tuple_element_t = typename tuple_element <I, T>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&&\n    get(const tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// tuple_size\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<tuple<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\n// tuple_element\n\ntemplate <size_t _Ip, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, tuple<_Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Ip, class ..._Tp>\nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;\n#endif\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp,\n          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)) ||\n                        (is_rvalue_reference<_Hp>::value &&\n                         !is_lvalue_reference<_Tp>::value),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <bool ..._Pred>\nstruct __all\n    : is_same<__all<_Pred...>, __all<(_Pred, true)...>>\n{ };\n\ntemplate <class ..._Tp>\nstruct __lazy_all : __all<_Tp::value...> {};\n\ntemplate <class _Tp>\nstruct __all_default_constructible;\n\ntemplate <class ..._Tp>\nstruct __all_default_constructible<__tuple_types<_Tp...>>\n    : __all<is_default_constructible<_Tp>::value...>\n{ };\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\ntemplate <bool _IsTuple, class _SizeTrait, size_t _Expected>\nstruct __tuple_like_with_size_imp : false_type {};\n\ntemplate <class _SizeTrait, size_t _Expected>\nstruct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>\n    : integral_constant<bool, _SizeTrait::value == _Expected> {};\n\ntemplate <class _Tuple, size_t _ExpectedSize,\n          class _RawTuple = typename __uncvref<_Tuple>::type>\nusing __tuple_like_with_size = __tuple_like_with_size_imp<\n                                   __tuple_like<_RawTuple>::value,\n                                   tuple_size<_RawTuple>, _ExpectedSize\n                              >;\n\n\nstruct _LIBCPP_TYPE_VIS __check_tuple_constructor_fail {\n    template <class ...>\n    static constexpr bool __enable_explicit() { return false; }\n    template <class ...>\n    static constexpr bool __enable_implicit() { return false; }\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n    template <class ..._Args>\n    struct _PackExpandsToThisTuple : false_type {};\n\n    template <class _Arg>\n    struct _PackExpandsToThisTuple<_Arg>\n        : is_same<typename __uncvref<_Arg>::type, tuple> {};\n\n    template <bool _MaybeEnable, class _Dummy = void>\n    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckArgsConstructor<true, _Dummy>\n    {\n        template <class ..._Args>\n        static constexpr bool __enable_explicit() {\n            return\n                __tuple_constructible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                !__tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_implicit() {\n            return\n                __tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n    };\n\n    template <bool _MaybeEnable,\n              bool = sizeof...(_Tp) == 1,\n              class _Dummy = void>\n    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, false, _Dummy>\n    {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, tuple>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, tuple>::value\n               && !__tuple_convertible<_Tuple, tuple>::value;\n        }\n    };\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, true, _Dummy>\n    {\n        // This trait is used to disable the tuple-like constructor when\n        // the UTypes... constructor should be selected instead.\n        // See LWG issue #2549.\n        template <class _Tuple>\n        using _PreferTupleLikeConstructor = __lazy_or<\n            // Don't attempt the two checks below if the tuple we are given\n            // has the same type as this tuple.\n            is_same<typename __uncvref<_Tuple>::type, tuple>,\n            __lazy_and<\n                __lazy_not<is_constructible<_Tp..., _Tuple>>,\n                __lazy_not<is_convertible<_Tuple, _Tp...>>\n            >\n        >;\n\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __lazy_and<\n                __tuple_convertible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>\n            >::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __lazy_and<\n                __tuple_constructible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>,\n                __lazy_not<__tuple_convertible<_Tuple, tuple>>\n            >::value;\n        }\n    };\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    template <bool _Dummy = true, class = typename enable_if<\n        __all<__dependent_type<is_default_constructible<_Tp>, _Dummy>::value...>::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<\n        __lazy_and<\n            is_base_of<allocator_arg_t, _AllocArgT>,\n            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>\n       >::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    tuple(_AllocArgT, _Alloc const& __a)\n      : base_(allocator_arg_t(), __a,\n                    __tuple_indices<>(), __tuple_types<>(),\n                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),\n                    __tuple_types<_Tp...>()) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      explicit\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(const tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const type&&>(\n             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n// get by type\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_helper;\n\n// -- find exactly one\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_checker {\n    static constexpr size_t value = _Idx;\n//  Check the rest of the list to make sure there's only one\n    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, \"type can only occur once in type list\" );\n    };\n\n\ntemplate <typename _T1, size_t _Idx>\nstruct __find_exactly_one_t_helper <_T1, _Idx> {\n    static constexpr size_t value = -1;\n    };\n\ntemplate <typename _T1, size_t _Idx, typename _Head, typename... _Args>\nstruct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {\n    static constexpr size_t value =\n        std::conditional<\n            std::is_same<_T1, _Head>::value,\n            __find_exactly_one_t_checker<_T1, _Idx,   _Args...>,\n            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>\n        >::type::value;\n    };\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t {\n    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;\n    static_assert ( value != -1, \"type not found in type list\" );\n    };\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        const size_t __idx = tuple_size<_Tp>::value - _Ip;\n        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))\n            return true;\n        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))\n            return false;\n        return __tuple_less<_Ip-1>()(__x, __y);\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","// -*- C++ -*-\n//===---------------------------- set -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SET\n#define _LIBCPP_SET\n\n/*\n\n    set synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass set\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    set()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit set(const value_compare& comp);\n    set(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last,\n            const value_compare& comp = value_compare());\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const value_compare& comp,\n            const allocator_type& a);\n    set(const set& s);\n    set(set&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit set(const allocator_type& a);\n    set(const set& s, const allocator_type& a);\n    set(set&& s, const allocator_type& a);\n    set(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    set(initializer_list<value_type> il, const value_compare& comp,\n        const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    set(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~set();\n\n    set& operator=(const set& s);\n    set& operator=(set&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    set& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator,bool> insert(const value_type& v);\n    pair<iterator,bool> insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(set& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass multiset\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    multiset()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multiset(const value_compare& comp);\n    multiset(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp = value_compare());\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp, const allocator_type& a);\n    multiset(const multiset& s);\n    multiset(multiset&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multiset(const allocator_type& a);\n    multiset(const multiset& s, const allocator_type& a);\n    multiset(multiset&& s, const allocator_type& a);\n    multiset(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    multiset(initializer_list<value_type> il, const value_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    multiset(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~multiset();\n\n    multiset& operator=(const multiset& s);\n    multiset& operator=(multiset&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multiset& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multiset& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <functional>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY set\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                 key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    set()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l,\n            const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,\n            const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : set(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s)\n        : __tree_(__s.__tree_)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(const set& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const allocator_type& __a)\n        : __tree_(__a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    set(set&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    set(initializer_list<value_type> __il, const allocator_type& __a)\n        : set(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(const value_type& __v)\n        {return __tree_.__insert_unique(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(value_type&& __v)\n        {return __tree_.__insert_unique(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_unique(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_unique(__p, _VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_unique(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(set& __s) _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nset<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\n// specialized algorithms:\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(set<_Key, _Compare, _Allocator>& __x,\n     set<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY multiset\n{\npublic:\n    // types:\n    typedef _Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                                allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    multiset()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : multiset(__f, __l, key_compare(), __a) {}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s)\n        : __tree_(__s.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(const multiset& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const allocator_type& __a)\n        : __tree_(__a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    multiset(multiset&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multiset(initializer_list<value_type> __il, const allocator_type& __a)\n        : multiset(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v)\n        {return __tree_.__insert_multi(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_multi(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multiset& __s)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_multi(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nmultiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multiset<_Key, _Compare, _Allocator>& __x,\n     multiset<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SET\n","#pragma once\n\n#if __cplusplus < 201103L\n#error Including <emscripten/val.h> requires building with -std=c++11 or newer!\n#else\n\n#include <stdint.h> // uintptr_t\n#include <emscripten/wire.h>\n#include <array>\n#include <vector>\n\n\nnamespace emscripten {\n\n    class val;\n\n    namespace internal {\n\n        template<typename WrapperType>\n        val wrapped_extend(const std::string&, const val&);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _emval_register_symbol(const char*);\n\n            enum {\n                _EMVAL_UNDEFINED = 1,\n                _EMVAL_NULL = 2,\n                _EMVAL_TRUE = 3,\n                _EMVAL_FALSE = 4\n            };\n\n            typedef struct _EM_VAL* EM_VAL;\n            typedef struct _EM_DESTRUCTORS* EM_DESTRUCTORS;\n            typedef struct _EM_METHOD_CALLER* EM_METHOD_CALLER;\n            typedef double EM_GENERIC_WIRE_TYPE;\n            typedef const void* EM_VAR_ARGS;\n\n            void _emval_incref(EM_VAL value);\n            void _emval_decref(EM_VAL value);\n\n            void _emval_run_destructors(EM_DESTRUCTORS handle);\n\n            EM_VAL _emval_new_array();\n            EM_VAL _emval_new_object();\n            EM_VAL _emval_new_cstring(const char*);\n\n            EM_VAL _emval_take_value(TYPEID type, EM_VAR_ARGS argv);\n\n            EM_VAL _emval_new(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            EM_VAL _emval_get_global(const char* name);\n            EM_VAL _emval_get_module_property(const char* name);\n            EM_VAL _emval_get_property(EM_VAL object, EM_VAL key);\n            void _emval_set_property(EM_VAL object, EM_VAL key, EM_VAL value);\n            EM_GENERIC_WIRE_TYPE _emval_as(EM_VAL value, TYPEID returnType, EM_DESTRUCTORS* destructors);\n\n            bool _emval_equals(EM_VAL first, EM_VAL second);\n            bool _emval_strictly_equals(EM_VAL first, EM_VAL second);\n\n            EM_VAL _emval_call(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            // DO NOT call this more than once per signature. It will\n            // leak generated function objects!\n            EM_METHOD_CALLER _emval_get_method_caller(\n                unsigned argCount, // including return value\n                const TYPEID argTypes[]);\n            EM_GENERIC_WIRE_TYPE _emval_call_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                EM_VAR_ARGS argv);\n            void _emval_call_void_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_VAR_ARGS argv);\n            EM_VAL _emval_typeof(EM_VAL value);\n        }\n\n        template<const char* address>\n        struct symbol_registrar {\n            symbol_registrar() {\n                internal::_emval_register_symbol(address);\n            }\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct Signature {\n            /*\n            typedef typename BindingType<ReturnType>::WireType (*MethodCaller)(\n                EM_VAL value,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                typename BindingType<Args>::WireType...);\n            */\n\n            static EM_METHOD_CALLER get_method_caller() {\n                static EM_METHOD_CALLER mc = init_method_caller();\n                return mc;\n            }\n\n        private:\n            static EM_METHOD_CALLER init_method_caller() {\n                WithPolicies<>::ArgTypeList<ReturnType, Args...> args;\n                return _emval_get_method_caller(args.getCount(), args.getTypes());\n            }\n        };\n\n        struct DestructorsRunner {\n        public:\n            explicit DestructorsRunner(EM_DESTRUCTORS d)\n                : destructors(d)\n            {}\n            ~DestructorsRunner() {\n                _emval_run_destructors(destructors);\n            }\n\n            DestructorsRunner(const DestructorsRunner&) = delete;\n            void operator=(const DestructorsRunner&) = delete;\n\n        private:\n            EM_DESTRUCTORS destructors;\n        };\n\n        template<typename WireType>\n        struct GenericWireTypeConverter {\n            static WireType from(double wt) {\n                return static_cast<WireType>(wt);\n            }\n        };\n\n        template<typename Pointee>\n        struct GenericWireTypeConverter<Pointee*> {\n            static Pointee* from(double wt) {\n                return reinterpret_cast<Pointee*>(static_cast<uintptr_t>(wt));\n            }\n        };\n\n        template<typename T>\n        T fromGenericWireType(double g) {\n            typedef typename BindingType<T>::WireType WireType;\n            WireType wt = GenericWireTypeConverter<WireType>::from(g);\n            return BindingType<T>::fromWireType(wt);\n        }\n\n        template<typename... Args>\n        struct PackSize;\n\n        template<>\n        struct PackSize<> {\n            static constexpr size_t value = 0;\n        };\n\n        template<typename Arg, typename... Args>\n        struct PackSize<Arg, Args...> {\n            static constexpr size_t value = (sizeof(typename BindingType<Arg>::WireType) + 7) / 8 + PackSize<Args...>::value;\n        };\n\n        union GenericWireType {\n            union {\n                unsigned u;\n                float f;\n                const void* p;\n            } w[2];\n            double d;\n        };\n        static_assert(sizeof(GenericWireType) == 8, \"GenericWireType must be 8 bytes\");\n        static_assert(alignof(GenericWireType) == 8, \"GenericWireType must be 8-byte-aligned\");\n\n        inline void writeGenericWireType(GenericWireType*& cursor, float wt) {\n            cursor->w[0].f = wt;\n            ++cursor;\n        }\n\n        inline void writeGenericWireType(GenericWireType*& cursor, double wt) {\n            cursor->d = wt;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T* wt) {\n            cursor->w[0].p = wt;\n            ++cursor;\n        }\n\n        template<typename ElementType>\n        inline void writeGenericWireType(GenericWireType*& cursor, const memory_view<ElementType>& wt) {\n            cursor->w[0].u = wt.size;\n            cursor->w[1].p = wt.data;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T wt) {\n            cursor->w[0].u = static_cast<unsigned>(wt);\n            ++cursor;\n        }\n\n        inline void writeGenericWireTypes(GenericWireType*&) {\n        }\n\n        template<typename First, typename... Rest>\n        EMSCRIPTEN_ALWAYS_INLINE void writeGenericWireTypes(GenericWireType*& cursor, First&& first, Rest&&... rest) {\n            writeGenericWireType(cursor, BindingType<First>::toWireType(std::forward<First>(first)));\n            writeGenericWireTypes(cursor, std::forward<Rest>(rest)...);\n        }\n\n        template<typename... Args>\n        struct WireTypePack {\n            WireTypePack(Args&&... args) {\n                GenericWireType* cursor = elements.data();\n                writeGenericWireTypes(cursor, std::forward<Args>(args)...);\n            }\n\n            operator EM_VAR_ARGS() const {\n                return elements.data();\n            }\n\n        private:\n            std::array<GenericWireType, PackSize<Args...>::value> elements;\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct MethodCaller {\n            static ReturnType call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<ReturnType, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                EM_DESTRUCTORS destructors;\n                EM_GENERIC_WIRE_TYPE result = _emval_call_method(\n                    caller,\n                    handle,\n                    methodName,\n                    &destructors,\n                    argv);\n                DestructorsRunner rd(destructors);\n                return fromGenericWireType<ReturnType>(result);\n            }\n        };\n\n        template<typename... Args>\n        struct MethodCaller<void, Args...> {\n            static void call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<void, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                _emval_call_void_method(\n                    caller,\n                    handle,\n                    methodName,\n                    argv);\n            }\n        };\n    }\n\n#define EMSCRIPTEN_SYMBOL(name)                                         \\\n    static const char name##_symbol[] = #name;                          \\\n    static const ::emscripten::internal::symbol_registrar<name##_symbol> name##_registrar\n\n    class val {\n    public:\n        // missing operators:\n        // * delete\n        // * in\n        // * instanceof\n        // * ! ~ - + ++ --\n        // * * / %\n        // * + -\n        // * << >> >>>\n        // * < <= > >=\n        // * == != === !==\n        // * & ^ | && || ?:\n        //\n        // exposing void, comma, and conditional is unnecessary\n        // same with: = += -= *= /= %= <<= >>= >>>= &= ^= |=\n\n        static val array() {\n            return val(internal::_emval_new_array());\n        }\n\n        static val object() {\n            return val(internal::_emval_new_object());\n        }\n\n        static val undefined() {\n            return val(internal::EM_VAL(internal::_EMVAL_UNDEFINED));\n        }\n\n        static val null() {\n            return val(internal::EM_VAL(internal::_EMVAL_NULL));\n        }\n\n        static val take_ownership(internal::EM_VAL e) {\n            return val(e);\n        }\n\n        static val global(const char* name = 0) {\n            return val(internal::_emval_get_global(name));\n        }\n\n        static val module_property(const char* name) {\n            return val(internal::_emval_get_module_property(name));\n        }\n\n        template<typename T>\n        explicit val(T&& value) {\n            using namespace internal;\n\n            typedef internal::BindingType<T> BT;\n            WireTypePack<T> argv(std::forward<T>(value));\n            handle = _emval_take_value(\n                internal::TypeID<T>::get(),\n                argv);\n        }\n\n        val() = delete;\n\n        explicit val(const char* v)\n            : handle(internal::_emval_new_cstring(v))\n        {}\n\n        val(val&& v)\n            : handle(v.handle)\n        {\n            v.handle = 0;\n        }\n\n        val(const val& v)\n            : handle(v.handle)\n        {\n            internal::_emval_incref(handle);\n        }\n\n        ~val() {\n            internal::_emval_decref(handle);\n        }\n\n        val& operator=(val&& v) {\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            v.handle = 0;\n            return *this;\n        }\n\n        val& operator=(const val& v) {\n            internal::_emval_incref(v.handle);\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            return *this;\n        }\n\n        bool hasOwnProperty(const char* key) const {\n            return val::global(\"Object\")[\"prototype\"][\"hasOwnProperty\"].call<bool>(\"call\", *this, val(key));\n        }\n\n        bool isNull() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_NULL);\n        }\n\n        bool isUndefined() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_UNDEFINED);\n        }\n\n        bool isTrue() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_TRUE);\n        }\n\n        bool isFalse() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_FALSE);\n        }\n\n        bool equals(const val& v) const {\n            return internal::_emval_equals(handle, v.handle);\n        }\n\n        bool strictlyEquals(const val& v) const {\n            return internal::_emval_strictly_equals(handle, v.handle);\n        }\n\n        template<typename... Args>\n        val new_(Args&&... args) const {\n            return internalCall(internal::_emval_new,std::forward<Args>(args)...);\n        }\n\n        template<typename T>\n        val operator[](const T& key) const {\n            return val(internal::_emval_get_property(handle, val(key).handle));\n        }\n\n        template<typename K>\n        void set(const K& key, const val& v) {\n            internal::_emval_set_property(handle, val(key).handle, v.handle);\n        }\n\n        template<typename K, typename V>\n        void set(const K& key, const V& value) {\n            internal::_emval_set_property(handle, val(key).handle, val(value).handle);\n        }\n\n        template<typename... Args>\n        val operator()(Args&&... args) {\n            return internalCall(internal::_emval_call, std::forward<Args>(args)...);\n        }\n\n        template<typename ReturnValue, typename... Args>\n        ReturnValue call(const char* name, Args&&... args) const {\n            using namespace internal;\n\n            return MethodCaller<ReturnValue, Args...>::call(handle, name, std::forward<Args>(args)...);\n        }\n\n        template<typename T, typename ...Policies>\n        T as(Policies...) const {\n            using namespace internal;\n\n            typedef BindingType<T> BT;\n            typename WithPolicies<Policies...>::template ArgTypeList<T> targetType;\n\n            EM_DESTRUCTORS destructors;\n            EM_GENERIC_WIRE_TYPE result = _emval_as(\n                handle,\n                targetType.getTypes()[0],\n                &destructors);\n            DestructorsRunner dr(destructors);\n            return fromGenericWireType<T>(result);\n        }\n\n// If code is not being compiled with GNU extensions enabled, typeof() is not a reserved keyword, so support that as a member function.\n#if __STRICT_ANSI__\n        val typeof() const {\n            return val(_emval_typeof(handle));\n        }\n#endif\n\n// Prefer calling val::typeOf() over val::typeof(), since this form works in both C++11 and GNU++11 build modes. \"typeof\" is a reserved word in GNU++11 extensions.\n        val typeOf() const {\n            return val(_emval_typeof(handle));\n        }\n\n    private:\n        // takes ownership, assumes handle already incref'd\n        explicit val(internal::EM_VAL handle)\n            : handle(handle)\n        {}\n\n        template<typename WrapperType>\n        friend val internal::wrapped_extend(const std::string& , const val& );\n\n        internal::EM_VAL __get_handle() const {\n            return handle;\n        }\n\n        template<typename Implementation, typename... Args>\n        val internalCall(Implementation impl, Args&&... args)const {\n            using namespace internal;\n\n            WithPolicies<>::ArgTypeList<Args...> argList;\n            WireTypePack<Args...> argv(std::forward<Args>(args)...);\n            return val(\n                impl(\n                    handle,\n                    argList.getCount(),\n                    argList.getTypes(),\n                    argv));\n        }\n\n        internal::EM_VAL handle;\n\n        friend struct internal::BindingType<val>;\n    };\n\n    namespace internal {\n        template<>\n        struct BindingType<val> {\n            typedef internal::EM_VAL WireType;\n            static WireType toWireType(const val& v) {\n                _emval_incref(v.handle);\n                return v.handle;\n            }\n            static val fromWireType(WireType v) {\n                return val::take_ownership(v);\n            }\n        };\n    }\n\n    template<typename T>\n    std::vector<T> vecFromJSArray(val v) {\n        auto l = v[\"length\"].as<unsigned>();\n\n        std::vector<T> rv;\n        for(unsigned i = 0; i < l; ++i) {\n            rv.push_back(v[i].as<T>());\n        }\n\n        return rv;\n    };\n}\n\n#endif // ~C++11 version check\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2010 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file ps_alignment.c Multi-level alignment structure\n */\n\n/* System headers. */\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n\n/* Local headers. */\n#include \"ps_alignment.h\"\n\nps_alignment_t *\nps_alignment_init(dict2pid_t *d2p)\n{\n    ps_alignment_t *al = ckd_calloc(1, sizeof(*al));\n    al->d2p = dict2pid_retain(d2p);\n    return al;\n}\n\nint\nps_alignment_free(ps_alignment_t *al)\n{\n    if (al == NULL)\n        return 0;\n    dict2pid_free(al->d2p);\n    ckd_free(al->word.seq);\n    ckd_free(al->sseq.seq);\n    ckd_free(al->state.seq);\n    ckd_free(al);\n    return 0;\n}\n\n#define VECTOR_GROW 10\nstatic void *\nvector_grow_one(void *ptr, uint16 *n_alloc, uint16 *n, size_t item_size)\n{\n    int newsize = *n + 1;\n    if (newsize < *n_alloc) {\n        *n += 1;\n        return ptr;\n    }\n    newsize += VECTOR_GROW;\n    if (newsize > 0xffff)\n        return NULL;\n    ptr = ckd_realloc(ptr, newsize * item_size);\n    *n += 1;\n    *n_alloc = newsize;\n    return ptr;\n}\n\nstatic ps_alignment_entry_t *\nps_alignment_vector_grow_one(ps_alignment_vector_t *vec)\n{\n    void *ptr;\n    ptr = vector_grow_one(vec->seq, &vec->n_alloc,\n                          &vec->n_ent, sizeof(*vec->seq));\n    if (ptr == NULL)\n        return NULL;\n    vec->seq = ptr;\n    return vec->seq + vec->n_ent - 1;\n}\n\nstatic void\nps_alignment_vector_empty(ps_alignment_vector_t *vec)\n{\n    vec->n_ent = 0;\n}\n\nint\nps_alignment_add_word(ps_alignment_t *al,\n                      int32 wid, int duration)\n{\n    ps_alignment_entry_t *ent;\n\n    if ((ent = ps_alignment_vector_grow_one(&al->word)) == NULL)\n        return 0;\n    ent->id.wid = wid;\n    if (al->word.n_ent > 1)\n        ent->start = ent[-1].start + ent[-1].duration;\n    else\n        ent->start = 0;\n    ent->duration = duration;\n    ent->score = 0;\n    ent->parent = PS_ALIGNMENT_NONE;\n    ent->child = PS_ALIGNMENT_NONE;\n\n    return al->word.n_ent;\n}\n\nint\nps_alignment_populate(ps_alignment_t *al)\n{\n    dict2pid_t *d2p;\n    dict_t *dict;\n    bin_mdef_t *mdef;\n    int i, lc;\n\n    /* Clear phone and state sequences. */\n    ps_alignment_vector_empty(&al->sseq);\n    ps_alignment_vector_empty(&al->state);\n\n    /* For each word, expand to phones/senone sequences. */\n    d2p = al->d2p;\n    dict = d2p->dict;\n    mdef = d2p->mdef;\n    lc = bin_mdef_silphone(mdef);\n    for (i = 0; i < al->word.n_ent; ++i) {\n        ps_alignment_entry_t *went = al->word.seq + i;\n        ps_alignment_entry_t *sent;\n        int wid = went->id.wid;\n        int len = dict_pronlen(dict, wid);\n        int j, rc;\n\n        if (i < al->word.n_ent - 1)\n            rc = dict_first_phone(dict, al->word.seq[i+1].id.wid);\n        else\n            rc = bin_mdef_silphone(mdef);\n\n        /* First phone. */\n        if ((sent = ps_alignment_vector_grow_one(&al->sseq)) == NULL) {\n            E_ERROR(\"Failed to add phone entry!\\n\");\n            return -1;\n        }\n        sent->id.pid.cipid = dict_first_phone(dict, wid);\n        sent->id.pid.tmatid = bin_mdef_pid2tmatid(mdef, sent->id.pid.cipid);\n        sent->start = went->start;\n        sent->duration = went->duration;\n        sent->score = 0;\n        sent->parent = i;\n        went->child = (uint16)(sent - al->sseq.seq);\n        if (len == 1)\n            sent->id.pid.ssid\n                = dict2pid_lrdiph_rc(d2p, sent->id.pid.cipid, lc, rc);\n        else\n            sent->id.pid.ssid\n                = dict2pid_ldiph_lc(d2p, sent->id.pid.cipid,\n                                    dict_second_phone(dict, wid), lc);\n        assert(sent->id.pid.ssid != BAD_SSID);\n\n        /* Internal phones. */\n        for (j = 1; j < len - 1; ++j) {\n            if ((sent = ps_alignment_vector_grow_one(&al->sseq)) == NULL) {\n                E_ERROR(\"Failed to add phone entry!\\n\");\n                return -1;\n            }\n            sent->id.pid.cipid = dict_pron(dict, wid, j);\n            sent->id.pid.tmatid = bin_mdef_pid2tmatid(mdef, sent->id.pid.cipid);\n            sent->id.pid.ssid = dict2pid_internal(d2p, wid, j);\n            assert(sent->id.pid.ssid != BAD_SSID);\n            sent->start = went->start;\n            sent->duration = went->duration;\n            sent->score = 0;\n            sent->parent = i;\n        }\n\n        /* Last phone. */\n        if (j < len) {\n            xwdssid_t *rssid;\n            assert(j == len - 1);\n            if ((sent = ps_alignment_vector_grow_one(&al->sseq)) == NULL) {\n                E_ERROR(\"Failed to add phone entry!\\n\");\n                return -1;\n            }\n            sent->id.pid.cipid = dict_last_phone(dict, wid);\n            sent->id.pid.tmatid = bin_mdef_pid2tmatid(mdef, sent->id.pid.cipid);\n            rssid = dict2pid_rssid(d2p, sent->id.pid.cipid,\n                                   dict_second_last_phone(dict, wid));\n            sent->id.pid.ssid = rssid->ssid[rssid->cimap[rc]];\n            assert(sent->id.pid.ssid != BAD_SSID);\n            sent->start = went->start;\n            sent->duration = went->duration;\n            sent->score = 0;\n            sent->parent = i;\n        }\n        /* Update lc.  Could just use sent->id.pid.cipid here but that\n         * seems needlessly obscure. */\n        lc = dict_last_phone(dict, wid);\n    }\n\n    /* For each senone sequence, expand to senones.  (we could do this\n     * nested above but this makes it more clear and easier to\n     * refactor) */\n    for (i = 0; i < al->sseq.n_ent; ++i) {\n        ps_alignment_entry_t *pent = al->sseq.seq + i;\n        ps_alignment_entry_t *sent;\n        int j;\n\n        for (j = 0; j < bin_mdef_n_emit_state(mdef); ++j) {\n            if ((sent = ps_alignment_vector_grow_one(&al->state)) == NULL) {\n                E_ERROR(\"Failed to add state entry!\\n\");\n                return -1;\n            }\n            sent->id.senid = bin_mdef_sseq2sen(mdef, pent->id.pid.ssid, j);\n            assert(sent->id.senid != BAD_SENID);\n            sent->start = pent->start;\n            sent->duration = pent->duration;\n            sent->score = 0;\n            sent->parent = i;\n            if (j == 0)\n                pent->child = (uint16)(sent - al->state.seq);\n        }\n    }\n\n    return 0;\n}\n\n/* FIXME: Somewhat the same as the above function, needs refactoring */\nint\nps_alignment_populate_ci(ps_alignment_t *al)\n{\n    dict2pid_t *d2p;\n    dict_t *dict;\n    bin_mdef_t *mdef;\n    int i;\n\n    /* Clear phone and state sequences. */\n    ps_alignment_vector_empty(&al->sseq);\n    ps_alignment_vector_empty(&al->state);\n\n    /* For each word, expand to phones/senone sequences. */\n    d2p = al->d2p;\n    dict = d2p->dict;\n    mdef = d2p->mdef;\n    for (i = 0; i < al->word.n_ent; ++i) {\n        ps_alignment_entry_t *went = al->word.seq + i;\n        ps_alignment_entry_t *sent;\n        int wid = went->id.wid;\n        int len = dict_pronlen(dict, wid);\n        int j;\n\n        for (j = 0; j < len; ++j) {\n            if ((sent = ps_alignment_vector_grow_one(&al->sseq)) == NULL) {\n                E_ERROR(\"Failed to add phone entry!\\n\");\n                return -1;\n            }\n            sent->id.pid.cipid = dict_pron(dict, wid, j);\n            sent->id.pid.tmatid = bin_mdef_pid2tmatid(mdef, sent->id.pid.cipid);\n            sent->id.pid.ssid = bin_mdef_pid2ssid(mdef, sent->id.pid.cipid);\n            assert(sent->id.pid.ssid != BAD_SSID);\n            sent->start = went->start;\n            sent->duration = went->duration;\n            sent->score = 0;\n            sent->parent = i;\n        }\n    }\n\n    /* For each senone sequence, expand to senones.  (we could do this\n     * nested above but this makes it more clear and easier to\n     * refactor) */\n    for (i = 0; i < al->sseq.n_ent; ++i) {\n        ps_alignment_entry_t *pent = al->sseq.seq + i;\n        ps_alignment_entry_t *sent;\n        int j;\n\n        for (j = 0; j < bin_mdef_n_emit_state(mdef); ++j) {\n            if ((sent = ps_alignment_vector_grow_one(&al->state)) == NULL) {\n                E_ERROR(\"Failed to add state entry!\\n\");\n                return -1;\n            }\n            sent->id.senid = bin_mdef_sseq2sen(mdef, pent->id.pid.ssid, j);\n            assert(sent->id.senid != BAD_SENID);\n            sent->start = pent->start;\n            sent->duration = pent->duration;\n            sent->score = 0;\n            sent->parent = i;\n            if (j == 0)\n                pent->child = (uint16)(sent - al->state.seq);\n        }\n    }\n\n    return 0;\n}\n\nint\nps_alignment_propagate(ps_alignment_t *al)\n{\n    ps_alignment_entry_t *last_ent = NULL;\n    int i;\n\n    /* Propagate duration up from states to phones. */\n    for (i = 0; i < al->state.n_ent; ++i) {\n        ps_alignment_entry_t *sent = al->state.seq + i;\n        ps_alignment_entry_t *pent = al->sseq.seq + sent->parent;\n        if (pent != last_ent) {\n            pent->start = sent->start;\n            pent->duration = 0;\n            pent->score = 0;\n        }\n        pent->duration += sent->duration;\n        pent->score += sent->score;\n        last_ent = pent;\n    }\n\n    /* Propagate duration up from phones to words. */\n    last_ent = NULL;\n    for (i = 0; i < al->sseq.n_ent; ++i) {\n        ps_alignment_entry_t *pent = al->sseq.seq + i;\n        ps_alignment_entry_t *went = al->word.seq + pent->parent;\n        if (went != last_ent) {\n            went->start = pent->start;\n            went->duration = 0;\n            went->score = 0;\n        }\n        went->duration += pent->duration;\n        went->score += pent->score;\n        last_ent = went;\n    }\n\n    return 0;\n}\n\nint\nps_alignment_n_words(ps_alignment_t *al)\n{\n    return (int)al->word.n_ent;\n}\n\nint\nps_alignment_n_phones(ps_alignment_t *al)\n{\n    return (int)al->sseq.n_ent;\n}\n\nint\nps_alignment_n_states(ps_alignment_t *al)\n{\n    return (int)al->state.n_ent;\n}\n\nps_alignment_iter_t *\nps_alignment_words(ps_alignment_t *al)\n{\n    ps_alignment_iter_t *itor;\n\n    if (al->word.n_ent == 0)\n        return NULL;\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->al = al;\n    itor->vec = &al->word;\n    itor->pos = 0;\n    return itor;\n}\n\nps_alignment_iter_t *\nps_alignment_phones(ps_alignment_t *al)\n{\n    ps_alignment_iter_t *itor;\n\n    if (al->sseq.n_ent == 0)\n        return NULL;\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->al = al;\n    itor->vec = &al->sseq;\n    itor->pos = 0;\n    return itor;\n}\n\nps_alignment_iter_t *\nps_alignment_states(ps_alignment_t *al)\n{\n    ps_alignment_iter_t *itor;\n\n    if (al->state.n_ent == 0)\n        return NULL;\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->al = al;\n    itor->vec = &al->state;\n    itor->pos = 0;\n    return itor;\n}\n\nps_alignment_entry_t *\nps_alignment_iter_get(ps_alignment_iter_t *itor)\n{\n    return itor->vec->seq + itor->pos;\n}\n\nint\nps_alignment_iter_free(ps_alignment_iter_t *itor)\n{\n    ckd_free(itor);\n    return 0;\n}\n\nps_alignment_iter_t *\nps_alignment_iter_goto(ps_alignment_iter_t *itor, int pos)\n{\n    if (itor == NULL)\n        return NULL;\n    if (pos >= itor->vec->n_ent) {\n        ps_alignment_iter_free(itor);\n        return NULL;\n    }\n    itor->pos = pos;\n    return itor;\n}\n\nps_alignment_iter_t *\nps_alignment_iter_next(ps_alignment_iter_t *itor)\n{\n    if (itor == NULL)\n        return NULL;\n    if (++itor->pos >= itor->vec->n_ent) {\n        ps_alignment_iter_free(itor);\n        return NULL;\n    }\n    return itor;\n}\n\nps_alignment_iter_t *\nps_alignment_iter_prev(ps_alignment_iter_t *itor)\n{\n    if (itor == NULL)\n        return NULL;\n    if (--itor->pos < 0) {\n        ps_alignment_iter_free(itor);\n        return NULL;\n    }\n    return itor;\n}\n\nps_alignment_iter_t *\nps_alignment_iter_up(ps_alignment_iter_t *itor)\n{\n    ps_alignment_iter_t *itor2;\n    if (itor == NULL)\n        return NULL;\n    if (itor->vec == &itor->al->word)\n        return NULL;\n    if (itor->vec->seq[itor->pos].parent == PS_ALIGNMENT_NONE)\n        return NULL;\n    itor2 = ckd_calloc(1, sizeof(*itor2));\n    itor2->al = itor->al;\n    itor2->pos = itor->vec->seq[itor->pos].parent;\n    if (itor->vec == &itor->al->sseq)\n        itor2->vec = &itor->al->word;\n    else\n        itor2->vec = &itor->al->sseq;\n    return itor2;\n}\n\nps_alignment_iter_t *\nps_alignment_iter_down(ps_alignment_iter_t *itor)\n{\n    ps_alignment_iter_t *itor2;\n    if (itor == NULL)\n        return NULL;\n    if (itor->vec == &itor->al->state)\n        return NULL;\n    if (itor->vec->seq[itor->pos].child == PS_ALIGNMENT_NONE)\n        return NULL;\n    itor2 = ckd_calloc(1, sizeof(*itor2));\n    itor2->al = itor->al;\n    itor2->pos = itor->vec->seq[itor->pos].child;\n    if (itor->vec == &itor->al->word)\n        itor2->vec = &itor->al->sseq;\n    else\n        itor2->vec = &itor->al->state;\n    return itor2;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2010 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file state_align_search.c State (and phone and word) alignment search.\n */\n\n#include \"state_align_search.h\"\n\nstatic int\nstate_align_search_start(ps_search_t *search)\n{\n    state_align_search_t *sas = (state_align_search_t *)search;\n\n    /* Activate the initial state. */\n    hmm_enter(sas->hmms, 0, 0, 0);\n\n    return 0;\n}\n\nstatic void\nrenormalize_hmms(state_align_search_t *sas, int frame_idx, int32 norm)\n{\n    int i;\n    for (i = 0; i < sas->n_phones; ++i)\n        hmm_normalize(sas->hmms + i, norm);\n}\n\nstatic int32\nevaluate_hmms(state_align_search_t *sas, int16 const *senscr, int frame_idx)\n{\n    int32 bs = WORST_SCORE;\n    int i;\n\n    hmm_context_set_senscore(sas->hmmctx, senscr);\n\n    for (i = 0; i < sas->n_phones; ++i) {\n        hmm_t *hmm = sas->hmms + i;\n        int32 score;\n\n        if (hmm_frame(hmm) < frame_idx)\n            continue;\n        score = hmm_vit_eval(hmm);\n        if (score BETTER_THAN bs) {\n            bs = score;\n        }\n    }\n    return bs;\n}\n\nstatic void\nprune_hmms(state_align_search_t *sas, int frame_idx)\n{\n    int nf = frame_idx + 1;\n    int i;\n\n    /* Check all phones to see if they remain active in the next frame. */\n    for (i = 0; i < sas->n_phones; ++i) {\n        hmm_t *hmm = sas->hmms + i;\n        if (hmm_frame(hmm) < frame_idx)\n            continue;\n        hmm_frame(hmm) = nf;\n    }\n}\n\nstatic void\nphone_transition(state_align_search_t *sas, int frame_idx)\n{\n    int nf = frame_idx + 1;\n    int i;\n\n    for (i = 0; i < sas->n_phones - 1; ++i) {\n        hmm_t *hmm, *nhmm;\n        int32 newphone_score;\n\n        hmm = sas->hmms + i;\n        if (hmm_frame(hmm) != nf)\n            continue;\n\n        newphone_score = hmm_out_score(hmm);\n        /* Transition into next phone using the usual Viterbi rule. */\n        nhmm = hmm + 1;\n        if (hmm_frame(nhmm) < frame_idx\n            || newphone_score BETTER_THAN hmm_in_score(nhmm)) {\n            hmm_enter(nhmm, newphone_score, hmm_out_history(hmm), nf);\n        }\n    }\n}\n\n#define TOKEN_STEP 20\nstatic void\nextend_tokenstack(state_align_search_t *sas, int frame_idx)\n{\n    if (frame_idx >= sas->n_fr_alloc) {\n        sas->n_fr_alloc = frame_idx + TOKEN_STEP + 1;\n        sas->tokens = ckd_realloc(sas->tokens,\n                                  sas->n_emit_state * sas->n_fr_alloc\n                                  * sizeof(*sas->tokens));\n    }\n    memset(sas->tokens + frame_idx * sas->n_emit_state, 0xff,\n           sas->n_emit_state * sizeof(*sas->tokens));\n}\n\nstatic void\nrecord_transitions(state_align_search_t *sas, int frame_idx)\n{\n    state_align_hist_t *tokens;\n    int i;\n\n    /* Push another frame of tokens on the stack. */\n    extend_tokenstack(sas, frame_idx);\n    tokens = sas->tokens + frame_idx * sas->n_emit_state;\n\n    /* Scan all active HMMs */\n    for (i = 0; i < sas->n_phones; ++i) {\n        hmm_t *hmm = sas->hmms + i;\n        int j;\n\n        if (hmm_frame(hmm) < frame_idx)\n            continue;\n        for (j = 0; j < sas->hmmctx->n_emit_state; ++j) {\n            int state_idx = i * sas->hmmctx->n_emit_state + j;\n            /* Record their backpointers on the token stack. */\n            tokens[state_idx].id = hmm_history(hmm, j);\n            tokens[state_idx].score = hmm_score(hmm, j);\n            /* Update backpointer fields with state index. */\n            hmm_history(hmm, j) = state_idx;\n        }\n    }\n}\n\nstatic int\nstate_align_search_step(ps_search_t *search, int frame_idx)\n{\n    state_align_search_t *sas = (state_align_search_t *)search;\n    acmod_t *acmod = ps_search_acmod(search);\n    int16 const *senscr;\n    int i;\n\n    /* Calculate senone scores. */\n    for (i = 0; i < sas->n_phones; ++i)\n        acmod_activate_hmm(acmod, sas->hmms + i);\n    senscr = acmod_score(acmod, &frame_idx);\n\n    /* Renormalize here if needed. */\n    /* FIXME: Make sure to (unit-)test this!!! */\n    if ((sas->best_score - 0x300000) WORSE_THAN WORST_SCORE) {\n        E_INFO(\"Renormalizing Scores at frame %d, best score %d\\n\",\n               frame_idx, sas->best_score);\n        renormalize_hmms(sas, frame_idx, sas->best_score);\n    }\n    \n    /* Viterbi step. */\n    sas->best_score = evaluate_hmms(sas, senscr, frame_idx);\n    prune_hmms(sas, frame_idx);\n\n    /* Transition out of non-emitting states. */\n    phone_transition(sas, frame_idx);\n\n    /* Generate new tokens from best path results. */\n    record_transitions(sas, frame_idx);\n\n    /* Update frame counter */\n    sas->frame = frame_idx;\n\n    return 0;\n}\n\nstatic int\nstate_align_search_finish(ps_search_t *search)\n{\n    state_align_search_t *sas = (state_align_search_t *)search;\n    hmm_t *final_phone = sas->hmms + sas->n_phones - 1;\n    ps_alignment_iter_t *itor;\n    ps_alignment_entry_t *ent;\n\n    int last_frame, cur_frame;\n    state_align_hist_t last, cur;\n\n    /* Best state exiting the last cur_frame. */\n    last.id = cur.id = hmm_out_history(final_phone);\n    last.score = hmm_out_score(final_phone);\n    if (last.id == 0xffff) {\n        E_ERROR(\"Failed to reach final state in alignment\\n\");\n        return -1;\n    }\n    itor = ps_alignment_states(sas->al);\n    last_frame = sas->frame + 1;\n    for (cur_frame = sas->frame - 1; cur_frame >= 0; --cur_frame) {\n\tcur = sas->tokens[cur_frame * sas->n_emit_state + cur.id];\n        /* State boundary, update alignment entry for next state. */\n        if (cur.id != last.id) {\n            itor = ps_alignment_iter_goto(itor, last.id);\n            assert(itor != NULL);\n            ent = ps_alignment_iter_get(itor);\n            ent->start = cur_frame + 1;\n            ent->duration = last_frame - ent->start;\n            ent->score =  last.score - cur.score;\n            E_DEBUG(\"state %d start %d end %d\\n\", last.id,\n                    ent->start, last_frame);\n    \t    last = cur;\n            last_frame = cur_frame + 1;\n        }\n    }\n    /* Update alignment entry for initial state. */\n    itor = ps_alignment_iter_goto(itor, 0);\n    assert(itor != NULL);\n    ent = ps_alignment_iter_get(itor);\n    ent->start = 0;\n    ent->duration = last_frame;\n    E_DEBUG(\"state %d start %d end %d\\n\", 0,\n            ent->start, last_frame);\n    ps_alignment_iter_free(itor);\n    ps_alignment_propagate(sas->al);\n\n    return 0;\n}\n\nstatic int\nstate_align_search_reinit(ps_search_t *search, dict_t *dict, dict2pid_t *d2p)\n{\n    /* This does nothing. */\n    return 0;\n}\n\nstatic void\nstate_align_search_free(ps_search_t *search)\n{\n    state_align_search_t *sas = (state_align_search_t *)search;\n    ps_search_base_free(search);\n    ckd_free(sas->hmms);\n    ckd_free(sas->tokens);\n    hmm_context_free(sas->hmmctx);\n    ckd_free(sas);\n}\n\nstatic ps_searchfuncs_t state_align_search_funcs = {\n    /* start: */  state_align_search_start,\n    /* step: */   state_align_search_step,\n    /* finish: */ state_align_search_finish,\n    /* reinit: */ state_align_search_reinit,\n    /* free: */   state_align_search_free,\n    /* lattice: */  NULL,\n    /* hyp: */      NULL,\n    /* prob: */     NULL,\n    /* seg_iter: */ NULL,\n};\n\nps_search_t *\nstate_align_search_init(const char *name,\n                        cmd_ln_t *config,\n                        acmod_t *acmod,\n                        ps_alignment_t *al)\n{\n    state_align_search_t *sas;\n    ps_alignment_iter_t *itor;\n    hmm_t *hmm;\n\n    sas = ckd_calloc(1, sizeof(*sas));\n    ps_search_init(ps_search_base(sas), &state_align_search_funcs,\n\t\t   PS_SEARCH_TYPE_STATE_ALIGN, name,\n                   config, acmod, al->d2p->dict, al->d2p);\n    sas->hmmctx = hmm_context_init(bin_mdef_n_emit_state(acmod->mdef),\n                                   acmod->tmat->tp, NULL, acmod->mdef->sseq);\n    if (sas->hmmctx == NULL) {\n        ckd_free(sas);\n        return NULL;\n    }\n    sas->al = al;\n\n    /* Generate HMM vector from phone level of alignment. */\n    sas->n_phones = ps_alignment_n_phones(al);\n    sas->n_emit_state = ps_alignment_n_states(al);\n    sas->hmms = ckd_calloc(sas->n_phones, sizeof(*sas->hmms));\n    for (hmm = sas->hmms, itor = ps_alignment_phones(al); itor;\n         ++hmm, itor = ps_alignment_iter_next(itor)) {\n        ps_alignment_entry_t *ent = ps_alignment_iter_get(itor);\n        hmm_init(sas->hmmctx, hmm, FALSE,\n                 ent->id.pid.ssid, ent->id.pid.tmatid);\n    }\n    return ps_search_base(sas);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced\n * Research Projects Agency and the National Science Foundation of the\n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n\n/**\n * @file acmod.c Acoustic model structures for PocketSphinx.\n * @author David Huggins-Daines <dhuggins@cs.cmu.edu>\n */\n\n/* System headers. */\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/prim_type.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/cmd_ln.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/byteorder.h>\n#include <sphinxbase/feat.h>\n#include <sphinxbase/bio.h>\n\n/* Local headers. */\n#include \"cmdln_macro.h\"\n#include \"acmod.h\"\n#include \"s2_semi_mgau.h\"\n#include \"ptm_mgau.h\"\n#include \"ms_mgau.h\"\n\nstatic int32 acmod_process_mfcbuf(acmod_t *acmod);\n\nstatic int\nacmod_init_am(acmod_t *acmod)\n{\n    char const *mdeffn, *tmatfn, *mllrfn, *hmmdir;\n\n    /* Read model definition. */\n    if ((mdeffn = cmd_ln_str_r(acmod->config, \"_mdef\")) == NULL) {\n        if ((hmmdir = cmd_ln_str_r(acmod->config, \"-hmm\")) == NULL)\n            E_ERROR(\"Acoustic model definition is not specified either \"\n                    \"with -mdef option or with -hmm\\n\");\n        else\n            E_ERROR(\"Folder '%s' does not contain acoustic model \"\n                    \"definition 'mdef'\\n\", hmmdir);\n\n        return -1;\n    }\n\n    if ((acmod->mdef = bin_mdef_read(acmod->config, mdeffn)) == NULL) {\n        E_ERROR(\"Failed to read acoustic model definition from %s\\n\", mdeffn);\n        return -1;\n    }\n\n    /* Read transition matrices. */\n    if ((tmatfn = cmd_ln_str_r(acmod->config, \"_tmat\")) == NULL) {\n        E_ERROR(\"No tmat file specified\\n\");\n        return -1;\n    }\n    acmod->tmat = tmat_init(tmatfn, acmod->lmath,\n                            cmd_ln_float32_r(acmod->config, \"-tmatfloor\"),\n                            TRUE);\n\n    /* Read the acoustic models. */\n    if ((cmd_ln_str_r(acmod->config, \"_mean\") == NULL)\n        || (cmd_ln_str_r(acmod->config, \"_var\") == NULL)\n        || (cmd_ln_str_r(acmod->config, \"_tmat\") == NULL)) {\n        E_ERROR(\"No mean/var/tmat files specified\\n\");\n        return -1;\n    }\n\n    if (cmd_ln_str_r(acmod->config, \"_senmgau\")) {\n        E_INFO(\"Using general multi-stream GMM computation\\n\");\n        acmod->mgau = ms_mgau_init(acmod, acmod->lmath, acmod->mdef);\n        if (acmod->mgau == NULL)\n            return -1;\n    }\n    else {\n        E_INFO(\"Attempting to use PTM computation module\\n\");\n        if ((acmod->mgau = ptm_mgau_init(acmod, acmod->mdef)) == NULL) {\n            E_INFO(\"Attempting to use semi-continuous computation module\\n\");\n            if ((acmod->mgau = s2_semi_mgau_init(acmod)) == NULL) {\n                E_INFO(\"Falling back to general multi-stream GMM computation\\n\");\n                acmod->mgau = ms_mgau_init(acmod, acmod->lmath, acmod->mdef);\n                if (acmod->mgau == NULL) {\n                    E_ERROR(\"Failed to read acoustic model\\n\");\n                    return -1;\n                }\n            }\n        }\n    }\n\n    /* If there is an MLLR transform, apply it. */\n    if ((mllrfn = cmd_ln_str_r(acmod->config, \"-mllr\"))) {\n        ps_mllr_t *mllr = ps_mllr_read(mllrfn);\n        if (mllr == NULL)\n            return -1;\n        acmod_update_mllr(acmod, mllr);\n    }\n\n    return 0;\n}\n\nstatic int\nacmod_init_feat(acmod_t *acmod)\n{\n    acmod->fcb =\n        feat_init(cmd_ln_str_r(acmod->config, \"-feat\"),\n                  cmn_type_from_str(cmd_ln_str_r(acmod->config,\"-cmn\")),\n                  cmd_ln_boolean_r(acmod->config, \"-varnorm\"),\n                  agc_type_from_str(cmd_ln_str_r(acmod->config, \"-agc\")),\n                  1, cmd_ln_int32_r(acmod->config, \"-ceplen\"));\n    if (acmod->fcb == NULL)\n        return -1;\n\n    if (cmd_ln_str_r(acmod->config, \"_lda\")) {\n        E_INFO(\"Reading linear feature transformation from %s\\n\",\n               cmd_ln_str_r(acmod->config, \"_lda\"));\n        if (feat_read_lda(acmod->fcb,\n                          cmd_ln_str_r(acmod->config, \"_lda\"),\n                          cmd_ln_int32_r(acmod->config, \"-ldadim\")) < 0)\n            return -1;\n    }\n\n    if (cmd_ln_str_r(acmod->config, \"-svspec\")) {\n        int32 **subvecs;\n        E_INFO(\"Using subvector specification %s\\n\",\n               cmd_ln_str_r(acmod->config, \"-svspec\"));\n        if ((subvecs = parse_subvecs(cmd_ln_str_r(acmod->config, \"-svspec\"))) == NULL)\n            return -1;\n        if ((feat_set_subvecs(acmod->fcb, subvecs)) < 0)\n            return -1;\n    }\n\n    if (cmd_ln_exists_r(acmod->config, \"-agcthresh\")\n        && 0 != strcmp(cmd_ln_str_r(acmod->config, \"-agc\"), \"none\")) {\n        agc_set_threshold(acmod->fcb->agc_struct,\n                          cmd_ln_float32_r(acmod->config, \"-agcthresh\"));\n    }\n\n    if (acmod->fcb->cmn_struct\n        && cmd_ln_exists_r(acmod->config, \"-cmninit\")) {\n        char *c, *cc, *vallist;\n        int32 nvals;\n\n        vallist = ckd_salloc(cmd_ln_str_r(acmod->config, \"-cmninit\"));\n        c = vallist;\n        nvals = 0;\n        while (nvals < acmod->fcb->cmn_struct->veclen\n               && (cc = strchr(c, ',')) != NULL) {\n            *cc = '\\0';\n            acmod->fcb->cmn_struct->cmn_mean[nvals] = FLOAT2MFCC(atof_c(c));\n            c = cc + 1;\n            ++nvals;\n        }\n        if (nvals < acmod->fcb->cmn_struct->veclen && *c != '\\0') {\n            acmod->fcb->cmn_struct->cmn_mean[nvals] = FLOAT2MFCC(atof_c(c));\n        }\n        ckd_free(vallist);\n    }\n    return 0;\n}\n\nint\nacmod_fe_mismatch(acmod_t *acmod, fe_t *fe)\n{\n    /* Output vector dimension needs to be the same. */\n    if (cmd_ln_int32_r(acmod->config, \"-ceplen\") != fe_get_output_size(fe)) {\n        E_ERROR(\"Configured feature length %d doesn't match feature \"\n                \"extraction output size %d\\n\",\n                cmd_ln_int32_r(acmod->config, \"-ceplen\"),\n                fe_get_output_size(fe));\n        return TRUE;\n    }\n    /* Feature parameters need to be the same. */\n    /* ... */\n    return FALSE;\n}\n\nint\nacmod_feat_mismatch(acmod_t *acmod, feat_t *fcb)\n{\n    /* Feature type needs to be the same. */\n    if (0 != strcmp(cmd_ln_str_r(acmod->config, \"-feat\"), feat_name(fcb)))\n        return TRUE;\n    /* Input vector dimension needs to be the same. */\n    if (cmd_ln_int32_r(acmod->config, \"-ceplen\") != feat_cepsize(fcb))\n        return TRUE;\n    /* FIXME: Need to check LDA and stuff too. */\n    return FALSE;\n}\n\nacmod_t *\nacmod_init(cmd_ln_t *config, logmath_t *lmath, fe_t *fe, feat_t *fcb)\n{\n    acmod_t *acmod;\n\n    acmod = ckd_calloc(1, sizeof(*acmod));\n    acmod->config = cmd_ln_retain(config);\n    acmod->lmath = lmath;\n    acmod->state = ACMOD_IDLE;\n\n    /* Initialize feature computation. */\n    if (fe) {\n        if (acmod_fe_mismatch(acmod, fe))\n            goto error_out;\n        fe_retain(fe);\n        acmod->fe = fe;\n    }\n    else {\n        /* Initialize a new front end. */\n        acmod->fe = fe_init_auto_r(config);\n        if (acmod->fe == NULL)\n            goto error_out;\n        if (acmod_fe_mismatch(acmod, acmod->fe))\n            goto error_out;\n    }\n    if (fcb) {\n        if (acmod_feat_mismatch(acmod, fcb))\n            goto error_out;\n        feat_retain(fcb);\n        acmod->fcb = fcb;\n    }\n    else {\n        /* Initialize a new fcb. */\n        if (acmod_init_feat(acmod) < 0)\n            goto error_out;\n    }\n\n    /* Load acoustic model parameters. */\n    if (acmod_init_am(acmod) < 0)\n        goto error_out;\n\n\n    /* The MFCC buffer needs to be at least as large as the dynamic\n     * feature window.  */\n    acmod->n_mfc_alloc = acmod->fcb->window_size * 2 + 1;\n    acmod->mfc_buf = (mfcc_t **)\n        ckd_calloc_2d(acmod->n_mfc_alloc, acmod->fcb->cepsize,\n                      sizeof(**acmod->mfc_buf));\n\n    /* Feature buffer has to be at least as large as MFCC buffer. */\n    acmod->n_feat_alloc = acmod->n_mfc_alloc + cmd_ln_int32_r(config, \"-pl_window\");\n    acmod->feat_buf = feat_array_alloc(acmod->fcb, acmod->n_feat_alloc);\n    acmod->framepos = ckd_calloc(acmod->n_feat_alloc, sizeof(*acmod->framepos));\n\n    acmod->utt_start_frame = 0;\n\n    /* Senone computation stuff. */\n    acmod->senone_scores = ckd_calloc(bin_mdef_n_sen(acmod->mdef),\n                                                     sizeof(*acmod->senone_scores));\n    acmod->senone_active_vec = bitvec_alloc(bin_mdef_n_sen(acmod->mdef));\n    acmod->senone_active = ckd_calloc(bin_mdef_n_sen(acmod->mdef),\n                                                     sizeof(*acmod->senone_active));\n    acmod->log_zero = logmath_get_zero(acmod->lmath);\n    acmod->compallsen = cmd_ln_boolean_r(config, \"-compallsen\");\n    return acmod;\n\nerror_out:\n    acmod_free(acmod);\n    return NULL;\n}\n\nvoid\nacmod_free(acmod_t *acmod)\n{\n    if (acmod == NULL)\n        return;\n\n    feat_free(acmod->fcb);\n    fe_free(acmod->fe);\n    cmd_ln_free_r(acmod->config);\n\n    if (acmod->mfc_buf)\n        ckd_free_2d((void **)acmod->mfc_buf);\n    if (acmod->feat_buf)\n        feat_array_free(acmod->feat_buf);\n\n    if (acmod->mfcfh)\n        fclose(acmod->mfcfh);\n    if (acmod->rawfh)\n        fclose(acmod->rawfh);\n    if (acmod->senfh)\n        fclose(acmod->senfh);\n\n    ckd_free(acmod->framepos);\n    ckd_free(acmod->senone_scores);\n    ckd_free(acmod->senone_active_vec);\n    ckd_free(acmod->senone_active);\n    ckd_free(acmod->rawdata);\n\n    if (acmod->mdef)\n        bin_mdef_free(acmod->mdef);\n    if (acmod->tmat)\n        tmat_free(acmod->tmat);\n    if (acmod->mgau)\n        ps_mgau_free(acmod->mgau);\n    if (acmod->mllr)\n        ps_mllr_free(acmod->mllr);\n\n    ckd_free(acmod);\n}\n\nps_mllr_t *\nacmod_update_mllr(acmod_t *acmod, ps_mllr_t *mllr)\n{\n    if (acmod->mllr)\n        ps_mllr_free(acmod->mllr);\n    acmod->mllr = mllr;\n    ps_mgau_transform(acmod->mgau, mllr);\n\n    return mllr;\n}\n\nint\nacmod_write_senfh_header(acmod_t *acmod, FILE *logfh)\n{\n    char nsenstr[64], logbasestr[64];\n\n    sprintf(nsenstr, \"%d\", bin_mdef_n_sen(acmod->mdef));\n    sprintf(logbasestr, \"%f\", logmath_get_base(acmod->lmath));\n    return bio_writehdr(logfh,\n                        \"version\", \"0.1\",\n                        \"mdef_file\", cmd_ln_str_r(acmod->config, \"_mdef\"),\n                        \"n_sen\", nsenstr,\n                        \"logbase\", logbasestr, NULL);\n}\n\nint\nacmod_set_senfh(acmod_t *acmod, FILE *logfh)\n{\n    if (acmod->senfh)\n        fclose(acmod->senfh);\n    acmod->senfh = logfh;\n    if (logfh == NULL)\n        return 0;\n    return acmod_write_senfh_header(acmod, logfh);\n}\n\nint\nacmod_set_mfcfh(acmod_t *acmod, FILE *logfh)\n{\n    int rv = 0;\n\n    if (acmod->mfcfh)\n        fclose(acmod->mfcfh);\n    acmod->mfcfh = logfh;\n    fwrite(&rv, 4, 1, acmod->mfcfh);\n    return rv;\n}\n\nint\nacmod_set_rawfh(acmod_t *acmod, FILE *logfh)\n{\n    if (acmod->rawfh)\n        fclose(acmod->rawfh);\n    acmod->rawfh = logfh;\n    return 0;\n}\n\nvoid\nacmod_grow_feat_buf(acmod_t *acmod, int nfr)\n{\n    if (nfr > MAX_N_FRAMES)\n        E_FATAL(\"Decoder can not process more than %d frames at once, \"\n                \"requested %d\\n\", MAX_N_FRAMES, nfr);\n\n    acmod->feat_buf = feat_array_realloc(acmod->fcb, acmod->feat_buf,\n                                         acmod->n_feat_alloc, nfr);\n    acmod->framepos = ckd_realloc(acmod->framepos,\n                                  nfr * sizeof(*acmod->framepos));\n    acmod->n_feat_alloc = nfr;\n}\n\nint\nacmod_set_grow(acmod_t *acmod, int grow_feat)\n{\n    int tmp = acmod->grow_feat;\n    acmod->grow_feat = grow_feat;\n\n    /* Expand feat_buf to a reasonable size to start with. */\n    if (grow_feat && acmod->n_feat_alloc < 128)\n        acmod_grow_feat_buf(acmod, 128);\n\n    return tmp;\n}\n\nint\nacmod_start_utt(acmod_t *acmod)\n{\n    fe_start_utt(acmod->fe);\n    acmod->state = ACMOD_STARTED;\n    acmod->n_mfc_frame = 0;\n    acmod->n_feat_frame = 0;\n    acmod->mfc_outidx = 0;\n    acmod->feat_outidx = 0;\n    acmod->output_frame = 0;\n    acmod->senscr_frame = -1;\n    acmod->n_senone_active = 0;\n    acmod->mgau->frame_idx = 0;\n    acmod->rawdata_pos = 0;\n\n    return 0;\n}\n\nint\nacmod_end_utt(acmod_t *acmod)\n{\n    int32 nfr = 0;\n\n    acmod->state = ACMOD_ENDED;\n    if (acmod->n_mfc_frame < acmod->n_mfc_alloc) {\n        int inptr;\n        /* Where to start writing them (circular buffer) */\n        inptr = (acmod->mfc_outidx + acmod->n_mfc_frame) % acmod->n_mfc_alloc;\n        /* nfr is always either zero or one. */\n        fe_end_utt(acmod->fe, acmod->mfc_buf[inptr], &nfr);\n        acmod->n_mfc_frame += nfr;\n        \n        /* Process whatever's left, and any leadout or update stats if needed. */\n        if (nfr)\n            nfr = acmod_process_mfcbuf(acmod);\n        else\n            feat_update_stats(acmod->fcb);\n    }\n    if (acmod->mfcfh) {\n        long outlen;\n        int32 rv;\n        outlen = (ftell(acmod->mfcfh) - 4) / 4;\n        /* Try to seek and write */\n        if ((rv = fseek(acmod->mfcfh, 0, SEEK_SET)) == 0) {\n            fwrite(&outlen, 4, 1, acmod->mfcfh);\n        }\n        fclose(acmod->mfcfh);\n        acmod->mfcfh = NULL;\n    }\n    if (acmod->rawfh) {\n        fclose(acmod->rawfh);\n        acmod->rawfh = NULL;\n    }\n\n    if (acmod->senfh) {\n        fclose(acmod->senfh);\n        acmod->senfh = NULL;\n    }\n\n    return nfr;\n}\n\nstatic int\nacmod_log_mfc(acmod_t *acmod,\n              mfcc_t **cep, int n_frames)\n{\n    int n = n_frames * feat_cepsize(acmod->fcb);\n    /* Write features. */\n    if (fwrite(cep[0], sizeof(mfcc_t), n, acmod->mfcfh) != n) {\n        E_ERROR_SYSTEM(\"Failed to write %d values to file\", n);\n    }\n    return 0;\n}\n\nstatic int\nacmod_process_full_cep(acmod_t *acmod,\n                       mfcc_t ***inout_cep,\n                       int *inout_n_frames)\n{\n    int32 nfr;\n\n    /* Write to file. */\n    if (acmod->mfcfh)\n        acmod_log_mfc(acmod, *inout_cep, *inout_n_frames);\n\n    /* Resize feat_buf to fit. */\n    if (acmod->n_feat_alloc < *inout_n_frames) {\n\n        if (*inout_n_frames > MAX_N_FRAMES)\n            E_FATAL(\"Batch processing can not process more than %d frames \"\n                    \"at once, requested %d\\n\", MAX_N_FRAMES, *inout_n_frames);\n\n        feat_array_free(acmod->feat_buf);\n        acmod->feat_buf = feat_array_alloc(acmod->fcb, *inout_n_frames);\n        acmod->n_feat_alloc = *inout_n_frames;\n        acmod->n_feat_frame = 0;\n        acmod->feat_outidx = 0;\n    }\n    /* Make dynamic features. */\n    nfr = feat_s2mfc2feat_live(acmod->fcb, *inout_cep, inout_n_frames,\n                               TRUE, TRUE, acmod->feat_buf);\n    acmod->n_feat_frame = nfr;\n    assert(acmod->n_feat_frame <= acmod->n_feat_alloc);\n    *inout_cep += *inout_n_frames;\n    *inout_n_frames = 0;\n\n    return nfr;\n}\n\nstatic int\nacmod_process_full_raw(acmod_t *acmod,\n                       int16 const **inout_raw,\n                       size_t *inout_n_samps)\n{\n    int32 nfr, ntail;\n    mfcc_t **cepptr;\n\n    /* Write to logging file if any. */\n    if (*inout_n_samps + acmod->rawdata_pos < acmod->rawdata_size) {\n\tmemcpy(acmod->rawdata + acmod->rawdata_pos, *inout_raw, *inout_n_samps * sizeof(int16));\n\tacmod->rawdata_pos += *inout_n_samps;\n    }\n    if (acmod->rawfh)\n        fwrite(*inout_raw, sizeof(int16), *inout_n_samps, acmod->rawfh);\n    /* Resize mfc_buf to fit. */\n    if (fe_process_frames(acmod->fe, NULL, inout_n_samps, NULL, &nfr, NULL) < 0)\n        return -1;\n    if (acmod->n_mfc_alloc < nfr + 1) {\n        ckd_free_2d(acmod->mfc_buf);\n        acmod->mfc_buf = ckd_calloc_2d(nfr + 1, fe_get_output_size(acmod->fe),\n                                       sizeof(**acmod->mfc_buf));\n        acmod->n_mfc_alloc = nfr + 1;\n    }\n    acmod->n_mfc_frame = 0;\n    acmod->mfc_outidx = 0;\n    fe_start_utt(acmod->fe);\n    if (fe_process_frames(acmod->fe, inout_raw, inout_n_samps,\n                          acmod->mfc_buf, &nfr, NULL) < 0)\n        return -1;\n    fe_end_utt(acmod->fe, acmod->mfc_buf[nfr], &ntail);\n    nfr += ntail;\n\n    cepptr = acmod->mfc_buf;\n    nfr = acmod_process_full_cep(acmod, &cepptr, &nfr);\n    acmod->n_mfc_frame = 0;\n    return nfr;\n}\n\n/**\n * Process MFCCs that are in the internal buffer into features.\n */\nstatic int32\nacmod_process_mfcbuf(acmod_t *acmod)\n{\n    mfcc_t **mfcptr;\n    int32 ncep;\n\n    ncep = acmod->n_mfc_frame;\n    /* Also do this in two parts because of the circular mfc_buf. */\n    if (acmod->mfc_outidx + ncep > acmod->n_mfc_alloc) {\n        int32 ncep1 = acmod->n_mfc_alloc - acmod->mfc_outidx;\n        int saved_state = acmod->state;\n\n        /* Make sure we don't end the utterance here. */\n        if (acmod->state == ACMOD_ENDED)\n            acmod->state = ACMOD_PROCESSING;\n        mfcptr = acmod->mfc_buf + acmod->mfc_outidx;\n        ncep1 = acmod_process_cep(acmod, &mfcptr, &ncep1, FALSE);\n        /* It's possible that not all available frames were filled. */\n        ncep -= ncep1;\n        acmod->n_mfc_frame -= ncep1;\n        acmod->mfc_outidx += ncep1;\n        acmod->mfc_outidx %= acmod->n_mfc_alloc;\n        /* Restore original state (could this really be the end) */\n        acmod->state = saved_state;\n    }\n    mfcptr = acmod->mfc_buf + acmod->mfc_outidx;\n    ncep = acmod_process_cep(acmod, &mfcptr, &ncep, FALSE);\n    acmod->n_mfc_frame -= ncep;\n    acmod->mfc_outidx += ncep;\n    acmod->mfc_outidx %= acmod->n_mfc_alloc;\n    return ncep;\n}\n\nint\nacmod_process_raw(acmod_t *acmod,\n                  int16 const **inout_raw,\n                  size_t *inout_n_samps,\n                  int full_utt)\n{\n    int32 ncep;\n    int32 out_frameidx;\n    int16 const *prev_audio_inptr;\n    \n    /* If this is a full utterance, process it all at once. */\n    if (full_utt)\n        return acmod_process_full_raw(acmod, inout_raw, inout_n_samps);\n\n    /* Append MFCCs to the end of any that are previously in there\n     * (in practice, there will probably be none) */\n    if (inout_n_samps && *inout_n_samps) {\n        int inptr;\n        int32 processed_samples;\n\n        prev_audio_inptr = *inout_raw;\n        /* Total number of frames available. */\n        ncep = acmod->n_mfc_alloc - acmod->n_mfc_frame;\n        /* Where to start writing them (circular buffer) */\n        inptr = (acmod->mfc_outidx + acmod->n_mfc_frame) % acmod->n_mfc_alloc;\n\n        /* Write them in two (or more) parts if there is wraparound. */\n        while (inptr + ncep > acmod->n_mfc_alloc) {\n            int32 ncep1 = acmod->n_mfc_alloc - inptr;\n            if (fe_process_frames(acmod->fe, inout_raw, inout_n_samps,\n                                  acmod->mfc_buf + inptr, &ncep1, &out_frameidx) < 0)\n                return -1;\n\t    \n\t    if (out_frameidx > 0)\n\t\tacmod->utt_start_frame = out_frameidx;\n\n    \t    processed_samples = *inout_raw - prev_audio_inptr;\n\t    if (processed_samples + acmod->rawdata_pos < acmod->rawdata_size) {\n\t\tmemcpy(acmod->rawdata + acmod->rawdata_pos, prev_audio_inptr, processed_samples * sizeof(int16));\n\t\tacmod->rawdata_pos += processed_samples;\n\t    }\n            /* Write to logging file if any. */\n            if (acmod->rawfh) {\n                fwrite(prev_audio_inptr, sizeof(int16),\n                       processed_samples,\n                       acmod->rawfh);\n            }\n            prev_audio_inptr = *inout_raw;\n            \n            /* ncep1 now contains the number of frames actually\n             * processed.  This is a good thing, but it means we\n             * actually still might have some room left at the end of\n             * the buffer, hence the while loop.  Unfortunately it\n             * also means that in the case where we are really\n             * actually done, we need to get out totally, hence the\n             * goto. */\n            acmod->n_mfc_frame += ncep1;\n            ncep -= ncep1;\n            inptr += ncep1;\n            inptr %= acmod->n_mfc_alloc;\n            if (ncep1 == 0)\n        \tgoto alldone;\n        }\n\n        assert(inptr + ncep <= acmod->n_mfc_alloc);        \n        if (fe_process_frames(acmod->fe, inout_raw, inout_n_samps,\n                              acmod->mfc_buf + inptr, &ncep, &out_frameidx) < 0)\n            return -1;\n\n\tif (out_frameidx > 0)\n\t    acmod->utt_start_frame = out_frameidx;\n\n\t\n\tprocessed_samples = *inout_raw - prev_audio_inptr;\n\tif (processed_samples + acmod->rawdata_pos < acmod->rawdata_size) {\n\t    memcpy(acmod->rawdata + acmod->rawdata_pos, prev_audio_inptr, processed_samples * sizeof(int16));\n\t    acmod->rawdata_pos += processed_samples;\n\t}\n        if (acmod->rawfh) {\n            fwrite(prev_audio_inptr, sizeof(int16),\n                   processed_samples, acmod->rawfh);\n        }\n        prev_audio_inptr = *inout_raw;\n        acmod->n_mfc_frame += ncep;\n    alldone:\n        ;\n    }\n\n    /* Hand things off to acmod_process_cep. */\n    return acmod_process_mfcbuf(acmod);\n}\n\nint\nacmod_process_cep(acmod_t *acmod,\n                  mfcc_t ***inout_cep,\n                  int *inout_n_frames,\n                  int full_utt)\n{\n    int32 nfeat, ncep, inptr;\n    int orig_n_frames;\n\n    /* If this is a full utterance, process it all at once. */\n    if (full_utt)\n        return acmod_process_full_cep(acmod, inout_cep, inout_n_frames);\n\n    /* Write to file. */\n    if (acmod->mfcfh)\n        acmod_log_mfc(acmod, *inout_cep, *inout_n_frames);\n\n    /* Maximum number of frames we're going to generate. */\n    orig_n_frames = ncep = nfeat = *inout_n_frames;\n\n    /* FIXME: This behaviour isn't guaranteed... */\n    if (acmod->state == ACMOD_ENDED)\n        nfeat += feat_window_size(acmod->fcb);\n    else if (acmod->state == ACMOD_STARTED)\n        nfeat -= feat_window_size(acmod->fcb);\n\n    /* Clamp number of features to fit available space. */\n    if (nfeat > acmod->n_feat_alloc - acmod->n_feat_frame) {\n        /* Grow it as needed - we have to grow it at the end of an\n         * utterance because we can't return a short read there. */\n        if (acmod->grow_feat || acmod->state == ACMOD_ENDED)\n            acmod_grow_feat_buf(acmod, acmod->n_feat_alloc + nfeat);\n        else\n            ncep -= (nfeat - (acmod->n_feat_alloc - acmod->n_feat_frame));\n    }\n\n    /* Where to start writing in the feature buffer. */\n    if (acmod->grow_feat) {\n        /* Grow to avoid wraparound if grow_feat == TRUE. */\n        inptr = acmod->feat_outidx + acmod->n_feat_frame;\n        while (inptr + nfeat >= acmod->n_feat_alloc)\n            acmod_grow_feat_buf(acmod, acmod->n_feat_alloc * 2);\n    }\n    else {\n        inptr = (acmod->feat_outidx + acmod->n_feat_frame) % acmod->n_feat_alloc;\n    }\n\n\n    /* FIXME: we can't split the last frame drop properly to be on the bounary,\n     *        so just return\n     */\n    if (inptr + nfeat > acmod->n_feat_alloc && acmod->state == ACMOD_ENDED) {\n        *inout_n_frames -= ncep;\n        *inout_cep += ncep;\n        return 0;\n    }\n\n    /* Write them in two parts if there is wraparound. */\n    if (inptr + nfeat > acmod->n_feat_alloc) {\n        int32 ncep1 = acmod->n_feat_alloc - inptr;\n\n        /* Make sure we don't end the utterance here. */\n        nfeat = feat_s2mfc2feat_live(acmod->fcb, *inout_cep,\n                                     &ncep1,\n                                     (acmod->state == ACMOD_STARTED),\n                                     FALSE,\n                                     acmod->feat_buf + inptr);\n        if (nfeat < 0)\n            return -1;\n        /* Move the output feature pointer forward. */\n        acmod->n_feat_frame += nfeat;\n        assert(acmod->n_feat_frame <= acmod->n_feat_alloc);\n        inptr += nfeat;\n        inptr %= acmod->n_feat_alloc;\n        /* Move the input feature pointers forward. */\n        *inout_n_frames -= ncep1;\n        *inout_cep += ncep1;\n        ncep -= ncep1;\n    }\n\n    nfeat = feat_s2mfc2feat_live(acmod->fcb, *inout_cep,\n                                 &ncep,\n                                 (acmod->state == ACMOD_STARTED),\n                                 (acmod->state == ACMOD_ENDED),\n                                 acmod->feat_buf + inptr);\n    if (nfeat < 0)\n        return -1;\n    acmod->n_feat_frame += nfeat;\n    assert(acmod->n_feat_frame <= acmod->n_feat_alloc);\n    /* Move the input feature pointers forward. */\n    *inout_n_frames -= ncep;\n    *inout_cep += ncep;\n    if (acmod->state == ACMOD_STARTED)\n        acmod->state = ACMOD_PROCESSING;\n    \n    return orig_n_frames - *inout_n_frames;\n}\n\nint\nacmod_process_feat(acmod_t *acmod,\n                   mfcc_t **feat)\n{\n    int i, inptr;\n\n    if (acmod->n_feat_frame == acmod->n_feat_alloc) {\n        if (acmod->grow_feat)\n            acmod_grow_feat_buf(acmod, acmod->n_feat_alloc * 2);\n        else\n            return 0;\n    }\n\n    if (acmod->grow_feat) {\n        /* Grow to avoid wraparound if grow_feat == TRUE. */\n        inptr = acmod->feat_outidx + acmod->n_feat_frame;\n        while (inptr + 1 >= acmod->n_feat_alloc)\n            acmod_grow_feat_buf(acmod, acmod->n_feat_alloc * 2);\n    }\n    else {\n        inptr = (acmod->feat_outidx + acmod->n_feat_frame) % acmod->n_feat_alloc;\n    }\n    for (i = 0; i < feat_dimension1(acmod->fcb); ++i)\n        memcpy(acmod->feat_buf[inptr][i],\n               feat[i], feat_dimension2(acmod->fcb, i) * sizeof(**feat));\n    ++acmod->n_feat_frame;\n    assert(acmod->n_feat_frame <= acmod->n_feat_alloc);\n\n    return 1;\n}\n\nstatic int\nacmod_read_senfh_header(acmod_t *acmod)\n{\n    char **name, **val;\n    int32 swap;\n    int i;\n\n    if (bio_readhdr(acmod->insenfh, &name, &val, &swap) < 0)\n        goto error_out;\n    for (i = 0; name[i] != NULL; ++i) {\n        if (!strcmp(name[i], \"n_sen\")) {\n            if (atoi(val[i]) != bin_mdef_n_sen(acmod->mdef)) {\n                E_ERROR(\"Number of senones in senone file (%d) does not \"\n                        \"match mdef (%d)\\n\", atoi(val[i]),\n                        bin_mdef_n_sen(acmod->mdef));\n                goto error_out;\n            }\n        }\n\n        if (!strcmp(name[i], \"logbase\")) {\n            if (fabs(atof_c(val[i]) - logmath_get_base(acmod->lmath)) > 0.001) {\n                E_ERROR(\"Logbase in senone file (%f) does not match acmod \"\n                        \"(%f)\\n\", atof_c(val[i]),\n                        logmath_get_base(acmod->lmath));\n                goto error_out;\n            }\n        }\n    }\n    acmod->insen_swap = swap;\n    bio_hdrarg_free(name, val);\n    return 0;\nerror_out:\n    bio_hdrarg_free(name, val);\n    return -1;\n}\n\nint\nacmod_set_insenfh(acmod_t *acmod, FILE *senfh)\n{\n    acmod->insenfh = senfh;\n    if (senfh == NULL) {\n        acmod->n_feat_frame = 0;\n        acmod->compallsen = cmd_ln_boolean_r(acmod->config, \"-compallsen\");\n        return 0;\n    }\n    acmod->compallsen = TRUE;\n    return acmod_read_senfh_header(acmod);\n}\n\nint\nacmod_rewind(acmod_t *acmod)\n{\n    /* If the feature buffer is circular, this is not possible. */\n    if (acmod->output_frame > acmod->n_feat_alloc) {\n        E_ERROR(\"Circular feature buffer cannot be rewound (output frame %d, \"\n                \"alloc %d)\\n\", acmod->output_frame, acmod->n_feat_alloc);\n        return -1;\n    }\n\n    /* Frames consumed + frames available */\n    acmod->n_feat_frame = acmod->output_frame + acmod->n_feat_frame;\n\n    /* Reset output pointers. */\n    acmod->feat_outidx = 0;\n    acmod->output_frame = 0;\n    acmod->senscr_frame = -1;\n    acmod->mgau->frame_idx = 0;\n\n    return 0;\n}\n\nint\nacmod_advance(acmod_t *acmod)\n{\n    /* Advance the output pointers. */\n    if (++acmod->feat_outidx == acmod->n_feat_alloc)\n        acmod->feat_outidx = 0;\n    --acmod->n_feat_frame;\n    ++acmod->mgau->frame_idx;\n\n    return ++acmod->output_frame;\n}\n\nint\nacmod_write_scores(acmod_t *acmod, int n_active, uint8 const *active,\n                   int16 const *senscr, FILE *senfh)\n{\n    int16 n_active2;\n\n    /* Uncompressed frame format:\n     *\n     * (2 bytes) n_active: Number of active senones\n     * If all senones active:\n     * (n_active * 2 bytes) scores of active senones\n     *\n     * Otherwise:\n     * (2 bytes) n_active: Number of active senones\n     * (n_active bytes) deltas to active senones\n     * (n_active * 2 bytes) scores of active senones\n     */\n    n_active2 = n_active;\n    if (fwrite(&n_active2, 2, 1, senfh) != 1)\n        goto error_out;\n    if (n_active == bin_mdef_n_sen(acmod->mdef)) {\n        if (fwrite(senscr, 2, n_active, senfh) != n_active)\n            goto error_out;\n    }\n    else {\n        int i, n;\n        if (fwrite(active, 1, n_active, senfh) != n_active)\n            goto error_out;\n        for (i = n = 0; i < n_active; ++i) {\n            n += active[i];\n            if (fwrite(senscr + n, 2, 1, senfh) != 1)\n                goto error_out;\n        }\n    }\n    return 0;\nerror_out:\n    E_ERROR_SYSTEM(\"Failed to write frame to senone file\");\n    return -1;\n}\n\n/**\n * Internal version, used for reading previous frames in acmod_score()\n */\nstatic int\nacmod_read_scores_internal(acmod_t *acmod)\n{\n    FILE *senfh = acmod->insenfh;\n    int16 n_active;\n    size_t rv;\n\n    if (acmod->n_feat_frame == acmod->n_feat_alloc) {\n        if (acmod->grow_feat)\n            acmod_grow_feat_buf(acmod, acmod->n_feat_alloc * 2);\n        else\n            return 0;\n    }\n\n    if (senfh == NULL)\n        return -1;\n    \n    if ((rv = fread(&n_active, 2, 1, senfh)) != 1)\n        goto error_out;\n\n    acmod->n_senone_active = n_active;\n    if (acmod->n_senone_active == bin_mdef_n_sen(acmod->mdef)) {\n        if ((rv = fread(acmod->senone_scores, 2,\n                        acmod->n_senone_active, senfh)) != acmod->n_senone_active)\n            goto error_out;\n    }\n    else {\n        int i, n;\n        \n        if ((rv = fread(acmod->senone_active, 1,\n                        acmod->n_senone_active, senfh)) != acmod->n_senone_active)\n            goto error_out;\n\n        for (i = 0, n = 0; i < acmod->n_senone_active; ++i) {\n            int j, sen = n + acmod->senone_active[i];\n            for (j = n + 1; j < sen; ++j)\n                acmod->senone_scores[j] = SENSCR_DUMMY;\n            \n            if ((rv = fread(acmod->senone_scores + sen, 2, 1, senfh)) != 1)\n                goto error_out;\n            \n            n = sen;\n        }\n\n        n++;\n        while (n < bin_mdef_n_sen(acmod->mdef))\n            acmod->senone_scores[n++] = SENSCR_DUMMY;\n    }\n    return 1;\n\nerror_out:\n    if (ferror(senfh)) {\n        E_ERROR_SYSTEM(\"Failed to read frame from senone file\");\n        return -1;\n    }\n    return 0;\n}\n\nint\nacmod_read_scores(acmod_t *acmod)\n{\n    int inptr, rv;\n\n    if (acmod->grow_feat) {\n        /* Grow to avoid wraparound if grow_feat == TRUE. */\n        inptr = acmod->feat_outidx + acmod->n_feat_frame;\n        /* Has to be +1, otherwise, next time acmod_advance() is\n         * called, this will wrap around. */\n        while (inptr + 1 >= acmod->n_feat_alloc)\n            acmod_grow_feat_buf(acmod, acmod->n_feat_alloc * 2);\n    }\n    else {\n        inptr = (acmod->feat_outidx + acmod->n_feat_frame) %\n                acmod->n_feat_alloc;\n    }\n\n    if ((rv = acmod_read_scores_internal(acmod)) != 1)\n        return rv;\n\n    /* Set acmod->senscr_frame appropriately so that these scores\n       get reused below in acmod_score(). */\n    acmod->senscr_frame = acmod->output_frame + acmod->n_feat_frame;\n\n    E_DEBUG(\"Frame %d has %d active states\\n\",\n            acmod->senscr_frame, acmod->n_senone_active);\n\n    /* Increment the \"feature frame counter\" and record the file\n     * position for the relevant frame in the (possibly circular)\n     * buffer. */\n    ++acmod->n_feat_frame;\n    acmod->framepos[inptr] = ftell(acmod->insenfh);\n\n    return 1;\n}\n\nstatic int\ncalc_frame_idx(acmod_t *acmod, int *inout_frame_idx)\n{\n    int frame_idx;\n\n    /* Calculate the absolute frame index to be scored. */\n    if (inout_frame_idx == NULL)\n        frame_idx = acmod->output_frame;\n    else if (*inout_frame_idx < 0)\n        frame_idx = acmod->output_frame + 1 + *inout_frame_idx;\n    else\n        frame_idx = *inout_frame_idx;\n\n    return frame_idx;\n}\n\nstatic int\ncalc_feat_idx(acmod_t *acmod, int frame_idx)\n{\n    int n_backfr, feat_idx;\n\n    n_backfr = acmod->n_feat_alloc - acmod->n_feat_frame;\n    if (frame_idx < 0 || acmod->output_frame - frame_idx > n_backfr) {\n        E_ERROR(\"Frame %d outside queue of %d frames, %d alloc (%d > %d), \"\n                \"cannot score\\n\", frame_idx, acmod->n_feat_frame,\n                acmod->n_feat_alloc, acmod->output_frame - frame_idx,\n                n_backfr);\n        return -1;\n    }\n\n    /* Get the index in feat_buf/framepos of the frame to be scored. */\n    feat_idx = (acmod->feat_outidx + frame_idx - acmod->output_frame) %\n               acmod->n_feat_alloc;\n    if (feat_idx < 0)\n        feat_idx += acmod->n_feat_alloc;\n\n    return feat_idx;\n}\n\nmfcc_t **\nacmod_get_frame(acmod_t *acmod, int *inout_frame_idx)\n{\n    int frame_idx, feat_idx;\n\n    /* Calculate the absolute frame index requested. */\n    frame_idx = calc_frame_idx(acmod, inout_frame_idx);\n\n    /* Calculate position of requested frame in circular buffer. */\n    if ((feat_idx = calc_feat_idx(acmod, frame_idx)) < 0)\n        return NULL;\n\n    if (inout_frame_idx)\n        *inout_frame_idx = frame_idx;\n\n    return acmod->feat_buf[feat_idx];\n}\n\nint16 const *\nacmod_score(acmod_t *acmod, int *inout_frame_idx)\n{\n    int frame_idx, feat_idx;\n\n    /* Calculate the absolute frame index to be scored. */\n    frame_idx = calc_frame_idx(acmod, inout_frame_idx);\n\n    /* If all senones are being computed, or we are using a senone file,\n       then we can reuse existing scores. */\n    if ((acmod->compallsen || acmod->insenfh)\n        && frame_idx == acmod->senscr_frame) {\n        if (inout_frame_idx)\n            *inout_frame_idx = frame_idx;\n        return acmod->senone_scores;\n    }\n\n    /* Calculate position of requested frame in circular buffer. */\n    if ((feat_idx = calc_feat_idx(acmod, frame_idx)) < 0)\n        return NULL;\n\n    /*\n     * If there is an input senone file locate the appropriate frame and read\n     * it.\n     */\n    if (acmod->insenfh) {\n        fseek(acmod->insenfh, acmod->framepos[feat_idx], SEEK_SET);\n        if (acmod_read_scores_internal(acmod) < 0)\n            return NULL;\n    }\n    else {\n        /* Build active senone list. */\n        acmod_flags2list(acmod);\n\n        /* Generate scores for the next available frame */\n        ps_mgau_frame_eval(acmod->mgau,\n                           acmod->senone_scores,\n                           acmod->senone_active,\n                           acmod->n_senone_active,\n                           acmod->feat_buf[feat_idx],\n                           frame_idx,\n                           acmod->compallsen);\n    }\n\n    if (inout_frame_idx)\n        *inout_frame_idx = frame_idx;\n    acmod->senscr_frame = frame_idx;\n\n    /* Dump scores to the senone dump file if one exists. */\n    if (acmod->senfh) {\n        if (acmod_write_scores(acmod, acmod->n_senone_active,\n                               acmod->senone_active,\n                               acmod->senone_scores,\n                               acmod->senfh) < 0)\n            return NULL;\n        E_DEBUG(\"Frame %d has %d active states\\n\", frame_idx,\n                acmod->n_senone_active);\n    }\n\n    return acmod->senone_scores;\n}\n\nint\nacmod_best_score(acmod_t *acmod, int *out_best_senid)\n{\n    int i, best;\n\n    best = SENSCR_DUMMY;\n    if (acmod->compallsen) {\n        for (i = 0; i < bin_mdef_n_sen(acmod->mdef); ++i) {\n            if (acmod->senone_scores[i] < best) {\n                best = acmod->senone_scores[i];\n                *out_best_senid = i;\n            }\n        }\n    }\n    else {\n        int16 *senscr;\n        senscr = acmod->senone_scores;\n        for (i = 0; i < acmod->n_senone_active; ++i) {\n            senscr += acmod->senone_active[i];\n            if (*senscr < best) {\n                best = *senscr;\n                *out_best_senid = i;\n            }\n        }\n    }\n    return best;\n}\n\n\nvoid\nacmod_clear_active(acmod_t *acmod)\n{\n    if (acmod->compallsen)\n        return;\n    bitvec_clear_all(acmod->senone_active_vec, bin_mdef_n_sen(acmod->mdef));\n    acmod->n_senone_active = 0;\n}\n\n#define MPX_BITVEC_SET(a,h,i)                                   \\\n    if (hmm_mpx_ssid(h,i) != BAD_SSID)                          \\\n        bitvec_set((a)->senone_active_vec, hmm_mpx_senid(h,i))\n#define NONMPX_BITVEC_SET(a,h,i)                                        \\\n    bitvec_set((a)->senone_active_vec,                                  \\\n               hmm_nonmpx_senid(h,i))\n\nvoid\nacmod_activate_hmm(acmod_t *acmod, hmm_t *hmm)\n{\n    int i;\n\n    if (acmod->compallsen)\n        return;\n    if (hmm_is_mpx(hmm)) {\n        switch (hmm_n_emit_state(hmm)) {\n        case 5:\n            MPX_BITVEC_SET(acmod, hmm, 4);\n            MPX_BITVEC_SET(acmod, hmm, 3);\n        case 3:\n            MPX_BITVEC_SET(acmod, hmm, 2);\n            MPX_BITVEC_SET(acmod, hmm, 1);\n            MPX_BITVEC_SET(acmod, hmm, 0);\n            break;\n        default:\n            for (i = 0; i < hmm_n_emit_state(hmm); ++i) {\n                MPX_BITVEC_SET(acmod, hmm, i);\n            }\n        }\n    }\n    else {\n        switch (hmm_n_emit_state(hmm)) {\n        case 5:\n            NONMPX_BITVEC_SET(acmod, hmm, 4);\n            NONMPX_BITVEC_SET(acmod, hmm, 3);\n        case 3:\n            NONMPX_BITVEC_SET(acmod, hmm, 2);\n            NONMPX_BITVEC_SET(acmod, hmm, 1);\n            NONMPX_BITVEC_SET(acmod, hmm, 0);\n            break;\n        default:\n            for (i = 0; i < hmm_n_emit_state(hmm); ++i) {\n                NONMPX_BITVEC_SET(acmod, hmm, i);\n            }\n        }\n    }\n}\n\nint32\nacmod_flags2list(acmod_t *acmod)\n{\n    int32 w, l, n, b, total_dists, total_words, extra_bits;\n    bitvec_t *flagptr;\n\n    total_dists = bin_mdef_n_sen(acmod->mdef);\n    if (acmod->compallsen) {\n        acmod->n_senone_active = total_dists;\n        return total_dists;\n    }\n    total_words = total_dists / BITVEC_BITS;\n    extra_bits = total_dists % BITVEC_BITS;\n    w = n = l = 0;\n    for (flagptr = acmod->senone_active_vec; w < total_words; ++w, ++flagptr) {\n        if (*flagptr == 0)\n            continue;\n        for (b = 0; b < BITVEC_BITS; ++b) {\n            if (*flagptr & (1UL << b)) {\n                int32 sen = w * BITVEC_BITS + b;\n                int32 delta = sen - l;\n                /* Handle excessive deltas \"lossily\" by adding a few\n                   extra senones to bridge the gap. */\n                while (delta > 255) {\n                    acmod->senone_active[n++] = 255;\n                    delta -= 255;\n                }\n                acmod->senone_active[n++] = delta;\n                l = sen;\n            }\n        }\n    }\n\n    for (b = 0; b < extra_bits; ++b) {\n        if (*flagptr & (1UL << b)) {\n            int32 sen = w * BITVEC_BITS + b;\n            int32 delta = sen - l;\n            /* Handle excessive deltas \"lossily\" by adding a few\n               extra senones to bridge the gap. */\n            while (delta > 255) {\n                acmod->senone_active[n++] = 255;\n                delta -= 255;\n            }\n            acmod->senone_active[n++] = delta;\n            l = sen;\n        }\n    }\n\n    acmod->n_senone_active = n;\n    E_DEBUG(\"acmod_flags2list: %d active in frame %d\\n\",\n            acmod->n_senone_active, acmod->output_frame);\n    return n;\n}\n\nint32\nacmod_stream_offset(acmod_t *acmod)\n{\n    return acmod->utt_start_frame;\n}\n\nvoid\nacmod_start_stream(acmod_t *acmod)\n{\n    fe_start_stream(acmod->fe);\n    acmod->utt_start_frame = 0;\n}\n\nvoid\nacmod_set_rawdata_size(acmod_t *acmod, int32 size)\n{\t\n    assert(size >= 0);\n    acmod->rawdata_size = size;\n    if (acmod->rawdata_size > 0) {\n\tckd_free(acmod->rawdata);\n\tacmod->rawdata = ckd_calloc(size, sizeof(int16));\n    }\n}\n\nvoid\nacmod_get_rawdata(acmod_t *acmod, int16 **buffer, int32 *size)\n{\n    if (buffer) {\n\t*buffer = acmod->rawdata;\n    }\n    if (size) {\n\t*size = acmod->rawdata_pos;\n    }\n}\n\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2005 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*********************************************************************\n *\n * File: bin_mdef.c\n * \n * Description: \n *\tBinary format model definition files, with support for\n *\theterogeneous topologies and variable-size N-phones\n *\n * Author: \n * \tDavid Huggins-Daines <dhuggins@cs.cmu.edu>\n *********************************************************************/\n\n/* System headers. */\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/prim_type.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/byteorder.h>\n#include <sphinxbase/case.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"mdef.h\"\n#include \"bin_mdef.h\"\n\nbin_mdef_t *\nbin_mdef_read_text(cmd_ln_t *config, const char *filename)\n{\n    bin_mdef_t *bmdef;\n    mdef_t *mdef;\n    int i, nodes, ci_idx, lc_idx, rc_idx;\n    int nchars;\n\n    if ((mdef = mdef_init((char *) filename, TRUE)) == NULL)\n        return NULL;\n\n    /* Enforce some limits.  */\n    if (mdef->n_sen > BAD_SENID) {\n        E_ERROR(\"Number of senones exceeds limit: %d > %d\\n\",\n                mdef->n_sen, BAD_SENID);\n        mdef_free(mdef);\n        return NULL;\n    }\n    if (mdef->n_sseq > BAD_SSID) {\n        E_ERROR(\"Number of senone sequences exceeds limit: %d > %d\\n\",\n                mdef->n_sseq, BAD_SSID);\n        mdef_free(mdef);\n        return NULL;\n    }\n    /* We use uint8 for ciphones */\n    if (mdef->n_ciphone > 255) {\n        E_ERROR(\"Number of phones exceeds limit: %d > %d\\n\",\n                mdef->n_ciphone, 255);\n        mdef_free(mdef);\n        return NULL;\n    }\n\n    bmdef = ckd_calloc(1, sizeof(*bmdef));\n    bmdef->refcnt = 1;\n\n    /* Easy stuff.  The mdef.c code has done the heavy lifting for us. */\n    bmdef->n_ciphone = mdef->n_ciphone;\n    bmdef->n_phone = mdef->n_phone;\n    bmdef->n_emit_state = mdef->n_emit_state;\n    bmdef->n_ci_sen = mdef->n_ci_sen;\n    bmdef->n_sen = mdef->n_sen;\n    bmdef->n_tmat = mdef->n_tmat;\n    bmdef->n_sseq = mdef->n_sseq;\n    bmdef->sseq = mdef->sseq;\n    bmdef->cd2cisen = mdef->cd2cisen;\n    bmdef->sen2cimap = mdef->sen2cimap;\n    bmdef->n_ctx = 3;           /* Triphones only. */\n    bmdef->sil = mdef->sil;\n    mdef->sseq = NULL;          /* We are taking over this one. */\n    mdef->cd2cisen = NULL;      /* And this one. */\n    mdef->sen2cimap = NULL;     /* And this one. */\n\n    /* Get the phone names.  If they are not sorted\n     * ASCII-betically then we are in a world of hurt and\n     * therefore will simply refuse to continue. */\n    bmdef->ciname = ckd_calloc(bmdef->n_ciphone, sizeof(*bmdef->ciname));\n    nchars = 0;\n    for (i = 0; i < bmdef->n_ciphone; ++i)\n        nchars += strlen(mdef->ciphone[i].name) + 1;\n    bmdef->ciname[0] = ckd_calloc(nchars, 1);\n    strcpy(bmdef->ciname[0], mdef->ciphone[0].name);\n    for (i = 1; i < bmdef->n_ciphone; ++i) {\n        bmdef->ciname[i] =\n            bmdef->ciname[i - 1] + strlen(bmdef->ciname[i - 1]) + 1;\n        strcpy(bmdef->ciname[i], mdef->ciphone[i].name);\n        if (i > 0 && strcmp(bmdef->ciname[i - 1], bmdef->ciname[i]) > 0) {\n            /* FIXME: there should be a solution to this, actually. */\n            E_ERROR(\"Phone names are not in sorted order, sorry.\");\n            bin_mdef_free(bmdef);\n            return NULL;\n        }\n    }\n\n    /* Copy over phone information. */\n    bmdef->phone = ckd_calloc(bmdef->n_phone, sizeof(*bmdef->phone));\n    for (i = 0; i < mdef->n_phone; ++i) {\n        bmdef->phone[i].ssid = mdef->phone[i].ssid;\n        bmdef->phone[i].tmat = mdef->phone[i].tmat;\n        if (i < bmdef->n_ciphone) {\n            bmdef->phone[i].info.ci.filler = mdef->ciphone[i].filler;\n        }\n        else {\n            bmdef->phone[i].info.cd.wpos = mdef->phone[i].wpos;\n            bmdef->phone[i].info.cd.ctx[0] = mdef->phone[i].ci;\n            bmdef->phone[i].info.cd.ctx[1] = mdef->phone[i].lc;\n            bmdef->phone[i].info.cd.ctx[2] = mdef->phone[i].rc;\n        }\n    }\n\n    /* Walk the wpos_ci_lclist once to find the total number of\n     * nodes and the starting locations for each level. */\n    nodes = lc_idx = ci_idx = rc_idx = 0;\n    for (i = 0; i < N_WORD_POSN; ++i) {\n        int j;\n        for (j = 0; j < mdef->n_ciphone; ++j) {\n            ph_lc_t *lc;\n\n            for (lc = mdef->wpos_ci_lclist[i][j]; lc; lc = lc->next) {\n                ph_rc_t *rc;\n                for (rc = lc->rclist; rc; rc = rc->next) {\n                    ++nodes;    /* RC node */\n                }\n                ++nodes;        /* LC node */\n                ++rc_idx;       /* Start of RC nodes (after LC nodes) */\n            }\n            ++nodes;            /* CI node */\n            ++lc_idx;           /* Start of LC nodes (after CI nodes) */\n            ++rc_idx;           /* Start of RC nodes (after CI and LC nodes) */\n        }\n        ++nodes;                /* wpos node */\n        ++ci_idx;               /* Start of CI nodes (after wpos nodes) */\n        ++lc_idx;               /* Start of LC nodes (after CI nodes) */\n        ++rc_idx;               /* STart of RC nodes (after wpos, CI, and LC nodes) */\n    }\n    E_INFO(\"Allocating %d * %d bytes (%d KiB) for CD tree\\n\",\n           nodes, sizeof(*bmdef->cd_tree), \n           nodes * sizeof(*bmdef->cd_tree) / 1024);\n    bmdef->n_cd_tree = nodes;\n    bmdef->cd_tree = ckd_calloc(nodes, sizeof(*bmdef->cd_tree));\n    for (i = 0; i < N_WORD_POSN; ++i) {\n        int j;\n\n        bmdef->cd_tree[i].ctx = i;\n        bmdef->cd_tree[i].n_down = mdef->n_ciphone;\n        bmdef->cd_tree[i].c.down = ci_idx;\n#if 0\n        E_INFO(\"%d => %c (%d@%d)\\n\",\n               i, (WPOS_NAME)[i],\n               bmdef->cd_tree[i].n_down, bmdef->cd_tree[i].c.down);\n#endif\n\n        /* Now we can build the rest of the tree. */\n        for (j = 0; j < mdef->n_ciphone; ++j) {\n            ph_lc_t *lc;\n\n            bmdef->cd_tree[ci_idx].ctx = j;\n            bmdef->cd_tree[ci_idx].c.down = lc_idx;\n            for (lc = mdef->wpos_ci_lclist[i][j]; lc; lc = lc->next) {\n                ph_rc_t *rc;\n\n                bmdef->cd_tree[lc_idx].ctx = lc->lc;\n                bmdef->cd_tree[lc_idx].c.down = rc_idx;\n                for (rc = lc->rclist; rc; rc = rc->next) {\n                    bmdef->cd_tree[rc_idx].ctx = rc->rc;\n                    bmdef->cd_tree[rc_idx].n_down = 0;\n                    bmdef->cd_tree[rc_idx].c.pid = rc->pid;\n#if 0\n                    E_INFO(\"%d => %s %s %s %c (%d@%d)\\n\",\n                           rc_idx,\n                           bmdef->ciname[j],\n                           bmdef->ciname[lc->lc],\n                           bmdef->ciname[rc->rc],\n                           (WPOS_NAME)[i],\n                           bmdef->cd_tree[rc_idx].n_down,\n                           bmdef->cd_tree[rc_idx].c.down);\n#endif\n\n                    ++bmdef->cd_tree[lc_idx].n_down;\n                    ++rc_idx;\n                }\n                /* If there are no triphones here,\n                 * this is considered a leafnode, so\n                 * set the pid to -1. */\n                if (bmdef->cd_tree[lc_idx].n_down == 0)\n                    bmdef->cd_tree[lc_idx].c.pid = -1;\n#if 0\n                E_INFO(\"%d => %s %s %c (%d@%d)\\n\",\n                       lc_idx,\n                       bmdef->ciname[j],\n                       bmdef->ciname[lc->lc],\n                       (WPOS_NAME)[i],\n                       bmdef->cd_tree[lc_idx].n_down,\n                       bmdef->cd_tree[lc_idx].c.down);\n#endif\n\n                ++bmdef->cd_tree[ci_idx].n_down;\n                ++lc_idx;\n            }\n\n            /* As above, so below. */\n            if (bmdef->cd_tree[ci_idx].n_down == 0)\n                bmdef->cd_tree[ci_idx].c.pid = -1;\n#if 0\n            E_INFO(\"%d => %d=%s (%d@%d)\\n\",\n                   ci_idx, j, bmdef->ciname[j],\n                   bmdef->cd_tree[ci_idx].n_down,\n                   bmdef->cd_tree[ci_idx].c.down);\n#endif\n\n            ++ci_idx;\n        }\n    }\n\n    mdef_free(mdef);\n\n    bmdef->alloc_mode = BIN_MDEF_FROM_TEXT;\n    return bmdef;\n}\n\nbin_mdef_t *\nbin_mdef_retain(bin_mdef_t *m)\n{\n    ++m->refcnt;\n    return m;\n}\n\nint\nbin_mdef_free(bin_mdef_t * m)\n{\n    if (m == NULL)\n        return 0;\n    if (--m->refcnt > 0)\n        return m->refcnt;\n\n    switch (m->alloc_mode) {\n    case BIN_MDEF_FROM_TEXT:\n        ckd_free(m->ciname[0]);\n        ckd_free(m->sseq[0]);\n        ckd_free(m->phone);\n        ckd_free(m->cd_tree);\n        break;\n    case BIN_MDEF_IN_MEMORY:\n        ckd_free(m->ciname[0]);\n        break;\n    case BIN_MDEF_ON_DISK:\n        break;\n    }\n    if (m->filemap)\n        mmio_file_unmap(m->filemap);\n    ckd_free(m->cd2cisen);\n    ckd_free(m->sen2cimap);\n    ckd_free(m->ciname);\n    ckd_free(m->sseq);\n    ckd_free(m);\n    return 0;\n}\n\nstatic const char format_desc[] =\n    \"BEGIN FILE FORMAT DESCRIPTION\\n\"\n    \"int32 n_ciphone;    /**< Number of base (CI) phones */\\n\"\n    \"int32 n_phone;\t     /**< Number of base (CI) phones + (CD) triphones */\\n\"\n    \"int32 n_emit_state; /**< Number of emitting states per phone (0 if heterogeneous) */\\n\"\n    \"int32 n_ci_sen;     /**< Number of CI senones; these are the first */\\n\"\n    \"int32 n_sen;\t     /**< Number of senones (CI+CD) */\\n\"\n    \"int32 n_tmat;\t     /**< Number of transition matrices */\\n\"\n    \"int32 n_sseq;       /**< Number of unique senone sequences */\\n\"\n    \"int32 n_ctx;\t     /**< Number of phones of context */\\n\"\n    \"int32 n_cd_tree;    /**< Number of nodes in CD tree structure */\\n\"\n    \"int32 sil;\t     /**< CI phone ID for silence */\\n\"\n    \"char ciphones[][];  /**< CI phone strings (null-terminated) */\\n\"\n    \"char padding[];     /**< Padding to a 4-bytes boundary */\\n\"\n    \"struct { int16 ctx; int16 n_down; int32 pid/down } cd_tree[];\\n\"\n    \"struct { int32 ssid; int32 tmat; int8 attr[4] } phones[];\\n\"\n    \"int16 sseq[];       /**< Unique senone sequences */\\n\"\n    \"int8 sseq_len[];    /**< Number of states in each sseq (none if homogeneous) */\\n\"\n    \"END FILE FORMAT DESCRIPTION\\n\";\n\nbin_mdef_t *\nbin_mdef_read(cmd_ln_t *config, const char *filename)\n{\n    bin_mdef_t *m;\n    FILE *fh;\n    size_t tree_start;\n    int32 val, i, do_mmap, swap;\n    long pos, end;\n    int32 *sseq_size;\n\n    /* Try to read it as text first. */\n    if ((m = bin_mdef_read_text(config, filename)) != NULL)\n        return m;\n\n    E_INFO(\"Reading binary model definition: %s\\n\", filename);\n    if ((fh = fopen(filename, \"rb\")) == NULL)\n        return NULL;\n\n    if (fread(&val, 4, 1, fh) != 1) {\n        fclose(fh);\n        E_ERROR_SYSTEM(\"Failed to read byte-order marker from %s\\n\",\n                       filename);\n        return NULL;\n    }\n    swap = 0;\n    if (val == BIN_MDEF_OTHER_ENDIAN) {\n        swap = 1;\n        E_INFO(\"Must byte-swap %s\\n\", filename);\n    }\n    if (fread(&val, 4, 1, fh) != 1) {\n        fclose(fh);\n        E_ERROR_SYSTEM(\"Failed to read version from %s\\n\", filename);\n        return NULL;\n    }\n    if (swap)\n        SWAP_INT32(&val);\n    if (val > BIN_MDEF_FORMAT_VERSION) {\n        E_ERROR(\"File format version %d for %s is newer than library\\n\",\n                val, filename);\n        fclose(fh);\n        return NULL;\n    }\n    if (fread(&val, 4, 1, fh) != 1) {\n        fclose(fh);\n        E_ERROR_SYSTEM(\"Failed to read header length from %s\\n\", filename);\n        return NULL;\n    }\n    if (swap)\n        SWAP_INT32(&val);\n    /* Skip format descriptor. */\n    fseek(fh, val, SEEK_CUR);\n\n    /* Finally allocate it. */\n    m = ckd_calloc(1, sizeof(*m));\n    m->refcnt = 1;\n\n    /* Check these, to make gcc/glibc shut up. */\n#define FREAD_SWAP32_CHK(dest)                                          \\\n    if (fread((dest), 4, 1, fh) != 1) {                                 \\\n        fclose(fh);                                                     \\\n        ckd_free(m);                                                    \\\n        E_ERROR_SYSTEM(\"Failed to read %s from %s\\n\", #dest, filename); \\\n        return NULL;                                                    \\\n    }                                                                   \\\n    if (swap) SWAP_INT32(dest);\n    \n    FREAD_SWAP32_CHK(&m->n_ciphone);\n    FREAD_SWAP32_CHK(&m->n_phone);\n    FREAD_SWAP32_CHK(&m->n_emit_state);\n    FREAD_SWAP32_CHK(&m->n_ci_sen);\n    FREAD_SWAP32_CHK(&m->n_sen);\n    FREAD_SWAP32_CHK(&m->n_tmat);\n    FREAD_SWAP32_CHK(&m->n_sseq);\n    FREAD_SWAP32_CHK(&m->n_ctx);\n    FREAD_SWAP32_CHK(&m->n_cd_tree);\n    FREAD_SWAP32_CHK(&m->sil);\n\n    /* CI names are first in the file. */\n    m->ciname = ckd_calloc(m->n_ciphone, sizeof(*m->ciname));\n\n    /* Decide whether to read in the whole file or mmap it. */\n    do_mmap = config ? cmd_ln_boolean_r(config, \"-mmap\") : TRUE;\n    if (swap) {\n        E_WARN(\"-mmap specified, but mdef is other-endian.  Will not memory-map.\\n\");\n        do_mmap = FALSE;\n    } \n    /* Actually try to mmap it. */\n    if (do_mmap) {\n        m->filemap = mmio_file_read(filename);\n        if (m->filemap == NULL)\n            do_mmap = FALSE;\n    }\n    pos = ftell(fh);\n    if (do_mmap) {\n        /* Get the base pointer from the memory map. */\n        m->ciname[0] = (char *)mmio_file_ptr(m->filemap) + pos;\n        /* Success! */\n        m->alloc_mode = BIN_MDEF_ON_DISK;\n    }\n    else {\n        /* Read everything into memory. */\n        m->alloc_mode = BIN_MDEF_IN_MEMORY;\n        fseek(fh, 0, SEEK_END);\n        end = ftell(fh);\n        fseek(fh, pos, SEEK_SET);\n        m->ciname[0] = ckd_malloc(end - pos);\n        if (fread(m->ciname[0], 1, end - pos, fh) != end - pos)\n            E_FATAL(\"Failed to read %d bytes of data from %s\\n\", end - pos, filename);\n    }\n\n    for (i = 1; i < m->n_ciphone; ++i)\n        m->ciname[i] = m->ciname[i - 1] + strlen(m->ciname[i - 1]) + 1;\n\n    /* Skip past the padding. */\n    tree_start =\n        m->ciname[i - 1] + strlen(m->ciname[i - 1]) + 1 - m->ciname[0];\n    tree_start = (tree_start + 3) & ~3;\n    m->cd_tree = (cd_tree_t *) (m->ciname[0] + tree_start);\n    if (swap) {\n        for (i = 0; i < m->n_cd_tree; ++i) {\n            SWAP_INT16(&m->cd_tree[i].ctx);\n            SWAP_INT16(&m->cd_tree[i].n_down);\n            SWAP_INT32(&m->cd_tree[i].c.down);\n        }\n    }\n    m->phone = (mdef_entry_t *) (m->cd_tree + m->n_cd_tree);\n    if (swap) {\n        for (i = 0; i < m->n_phone; ++i) {\n            SWAP_INT32(&m->phone[i].ssid);\n            SWAP_INT32(&m->phone[i].tmat);\n        }\n    }\n    sseq_size = (int32 *) (m->phone + m->n_phone);\n    if (swap)\n        SWAP_INT32(sseq_size);\n    m->sseq = ckd_calloc(m->n_sseq, sizeof(*m->sseq));\n    m->sseq[0] = (uint16 *) (sseq_size + 1);\n    if (swap) {\n        for (i = 0; i < *sseq_size; ++i)\n            SWAP_INT16(m->sseq[0] + i);\n    }\n    if (m->n_emit_state) {\n        for (i = 1; i < m->n_sseq; ++i)\n            m->sseq[i] = m->sseq[0] + i * m->n_emit_state;\n    }\n    else {\n        m->sseq_len = (uint8 *) (m->sseq[0] + *sseq_size);\n        for (i = 1; i < m->n_sseq; ++i)\n            m->sseq[i] = m->sseq[i - 1] + m->sseq_len[i - 1];\n    }\n\n    /* Now build the CD-to-CI mappings using the senone sequences.\n     * This is the only really accurate way to do it, though it is\n     * still inaccurate in the case of heterogeneous topologies or\n     * cross-state tying. */\n    m->cd2cisen = (int16 *) ckd_malloc(m->n_sen * sizeof(*m->cd2cisen));\n    m->sen2cimap = (int16 *) ckd_malloc(m->n_sen * sizeof(*m->sen2cimap));\n\n    /* Default mappings (identity, none) */\n    for (i = 0; i < m->n_ci_sen; ++i)\n        m->cd2cisen[i] = i;\n    for (; i < m->n_sen; ++i)\n        m->cd2cisen[i] = -1;\n    for (i = 0; i < m->n_sen; ++i)\n        m->sen2cimap[i] = -1;\n    for (i = 0; i < m->n_phone; ++i) {\n        int32 j, ssid = m->phone[i].ssid;\n\n        for (j = 0; j < bin_mdef_n_emit_state_phone(m, i); ++j) {\n            int s = bin_mdef_sseq2sen(m, ssid, j);\n            int ci = bin_mdef_pid2ci(m, i);\n            /* Take the first one and warn if we have cross-state tying. */\n            if (m->sen2cimap[s] == -1)\n                m->sen2cimap[s] = ci;\n            if (m->sen2cimap[s] != ci)\n                E_WARN\n                    (\"Senone %d is shared between multiple base phones\\n\",\n                     s);\n\n            if (j > bin_mdef_n_emit_state_phone(m, ci))\n                E_WARN(\"CD phone %d has fewer states than CI phone %d\\n\",\n                       i, ci);\n            else\n                m->cd2cisen[s] =\n                    bin_mdef_sseq2sen(m, m->phone[ci].ssid, j);\n        }\n    }\n\n    /* Set the silence phone. */\n    m->sil = bin_mdef_ciphone_id(m, S3_SILENCE_CIPHONE);\n\n    E_INFO\n        (\"%d CI-phone, %d CD-phone, %d emitstate/phone, %d CI-sen, %d Sen, %d Sen-Seq\\n\",\n         m->n_ciphone, m->n_phone - m->n_ciphone, m->n_emit_state,\n         m->n_ci_sen, m->n_sen, m->n_sseq);\n    fclose(fh);\n    return m;\n}\n\nint\nbin_mdef_write(bin_mdef_t * m, const char *filename)\n{\n    FILE *fh;\n    int32 val, i;\n\n    if ((fh = fopen(filename, \"wb\")) == NULL)\n        return -1;\n\n    /* Byteorder marker. */\n    val = BIN_MDEF_NATIVE_ENDIAN;\n    fwrite(&val, 1, 4, fh);\n    /* Version. */\n    val = BIN_MDEF_FORMAT_VERSION;\n    fwrite(&val, 1, sizeof(val), fh);\n\n    /* Round the format descriptor size up to a 4-byte boundary. */\n    val = ((sizeof(format_desc) + 3) & ~3);\n    fwrite(&val, 1, sizeof(val), fh);\n    fwrite(format_desc, 1, sizeof(format_desc), fh);\n    /* Pad it with zeros. */\n    i = 0;\n    fwrite(&i, 1, val - sizeof(format_desc), fh);\n\n    /* Binary header things. */\n    fwrite(&m->n_ciphone, 4, 1, fh);\n    fwrite(&m->n_phone, 4, 1, fh);\n    fwrite(&m->n_emit_state, 4, 1, fh);\n    fwrite(&m->n_ci_sen, 4, 1, fh);\n    fwrite(&m->n_sen, 4, 1, fh);\n    fwrite(&m->n_tmat, 4, 1, fh);\n    fwrite(&m->n_sseq, 4, 1, fh);\n    fwrite(&m->n_ctx, 4, 1, fh);\n    fwrite(&m->n_cd_tree, 4, 1, fh);\n    /* Write this as a 32-bit value to preserve alignment for the\n     * non-mmap case (we want things aligned both from the\n     * beginning of the file and the beginning of the phone\n     * strings). */\n    val = m->sil;\n    fwrite(&val, 4, 1, fh);\n\n    /* Phone strings. */\n    for (i = 0; i < m->n_ciphone; ++i)\n        fwrite(m->ciname[i], 1, strlen(m->ciname[i]) + 1, fh);\n    /* Pad with zeros. */\n    val = (ftell(fh) + 3) & ~3;\n    i = 0;\n    fwrite(&i, 1, val - ftell(fh), fh);\n\n    /* Write CD-tree */\n    fwrite(m->cd_tree, sizeof(*m->cd_tree), m->n_cd_tree, fh);\n    /* Write phones */\n    fwrite(m->phone, sizeof(*m->phone), m->n_phone, fh);\n    if (m->n_emit_state) {\n        /* Write size of sseq */\n        val = m->n_sseq * m->n_emit_state;\n        fwrite(&val, 4, 1, fh);\n\n        /* Write sseq */\n        fwrite(m->sseq[0], sizeof(**m->sseq),\n               m->n_sseq * m->n_emit_state, fh);\n    }\n    else {\n        int32 n;\n\n        /* Calcluate size of sseq */\n        n = 0;\n        for (i = 0; i < m->n_sseq; ++i)\n            n += m->sseq_len[i];\n\n        /* Write size of sseq */\n        fwrite(&n, 4, 1, fh);\n\n        /* Write sseq */\n        fwrite(m->sseq[0], sizeof(**m->sseq), n, fh);\n\n        /* Write sseq_len */\n        fwrite(m->sseq_len, 1, m->n_sseq, fh);\n    }\n    fclose(fh);\n\n    return 0;\n}\n\nint\nbin_mdef_write_text(bin_mdef_t * m, const char *filename)\n{\n    FILE *fh;\n    int p, i, n_total_state;\n\n    if (strcmp(filename, \"-\") == 0)\n        fh = stdout;\n    else {\n        if ((fh = fopen(filename, \"w\")) == NULL)\n            return -1;\n    }\n\n    fprintf(fh, \"0.3\\n\");\n    fprintf(fh, \"%d n_base\\n\", m->n_ciphone);\n    fprintf(fh, \"%d n_tri\\n\", m->n_phone - m->n_ciphone);\n    if (m->n_emit_state)\n        n_total_state = m->n_phone * (m->n_emit_state + 1);\n    else {\n        n_total_state = 0;\n        for (i = 0; i < m->n_phone; ++i)\n            n_total_state += m->sseq_len[m->phone[i].ssid] + 1;\n    }\n    fprintf(fh, \"%d n_state_map\\n\", n_total_state);\n    fprintf(fh, \"%d n_tied_state\\n\", m->n_sen);\n    fprintf(fh, \"%d n_tied_ci_state\\n\", m->n_ci_sen);\n    fprintf(fh, \"%d n_tied_tmat\\n\", m->n_tmat);\n    fprintf(fh, \"#\\n# Columns definitions\\n\");\n    fprintf(fh, \"#%4s %3s %3s %1s %6s %4s %s\\n\",\n            \"base\", \"lft\", \"rt\", \"p\", \"attrib\", \"tmat\",\n            \"     ... state id's ...\");\n\n    for (p = 0; p < m->n_ciphone; p++) {\n        int n_state;\n\n        fprintf(fh, \"%5s %3s %3s %1s\", m->ciname[p], \"-\", \"-\", \"-\");\n\n        if (bin_mdef_is_fillerphone(m, p))\n            fprintf(fh, \" %6s\", \"filler\");\n        else\n            fprintf(fh, \" %6s\", \"n/a\");\n        fprintf(fh, \" %4d\", m->phone[p].tmat);\n\n        if (m->n_emit_state)\n            n_state = m->n_emit_state;\n        else\n            n_state = m->sseq_len[m->phone[p].ssid];\n        for (i = 0; i < n_state; i++) {\n            fprintf(fh, \" %6u\", m->sseq[m->phone[p].ssid][i]);\n        }\n        fprintf(fh, \" N\\n\");\n    }\n\n\n    for (; p < m->n_phone; p++) {\n        int n_state;\n\n        fprintf(fh, \"%5s %3s %3s %c\",\n                m->ciname[m->phone[p].info.cd.ctx[0]],\n                m->ciname[m->phone[p].info.cd.ctx[1]],\n                m->ciname[m->phone[p].info.cd.ctx[2]],\n                (WPOS_NAME)[m->phone[p].info.cd.wpos]);\n\n        if (bin_mdef_is_fillerphone(m, p))\n            fprintf(fh, \" %6s\", \"filler\");\n        else\n            fprintf(fh, \" %6s\", \"n/a\");\n        fprintf(fh, \" %4d\", m->phone[p].tmat);\n\n\n        if (m->n_emit_state)\n            n_state = m->n_emit_state;\n        else\n            n_state = m->sseq_len[m->phone[p].ssid];\n        for (i = 0; i < n_state; i++) {\n            fprintf(fh, \" %6u\", m->sseq[m->phone[p].ssid][i]);\n        }\n        fprintf(fh, \" N\\n\");\n    }\n\n    if (strcmp(filename, \"-\") != 0)\n        fclose(fh);\n    return 0;\n}\n\nint\nbin_mdef_ciphone_id(bin_mdef_t * m, const char *ciphone)\n{\n    int low, mid, high;\n\n    /* Exact binary search on m->ciphone */\n    low = 0;\n    high = m->n_ciphone;\n    while (low < high) {\n        int c;\n\n        mid = (low + high) / 2;\n        c = strcmp(ciphone, m->ciname[mid]);\n        if (c == 0)\n            return mid;\n        else if (c > 0)\n            low = mid + 1;\n        else if (c < 0)\n            high = mid;\n    }\n    return -1;\n}\n\nint\nbin_mdef_ciphone_id_nocase(bin_mdef_t * m, const char *ciphone)\n{\n    int low, mid, high;\n\n    /* Exact binary search on m->ciphone */\n    low = 0;\n    high = m->n_ciphone;\n    while (low < high) {\n        int c;\n\n        mid = (low + high) / 2;\n        c = strcmp_nocase(ciphone, m->ciname[mid]);\n        if (c == 0)\n            return mid;\n        else if (c > 0)\n            low = mid + 1;\n        else if (c < 0)\n            high = mid;\n    }\n    return -1;\n}\n\nconst char *\nbin_mdef_ciphone_str(bin_mdef_t * m, int32 ci)\n{\n    assert(m != NULL);\n    assert(ci < m->n_ciphone);\n    return m->ciname[ci];\n}\n\nint\nbin_mdef_phone_id(bin_mdef_t * m, int32 ci, int32 lc, int32 rc, int32 wpos)\n{\n    cd_tree_t *cd_tree;\n    int level, max;\n    int16 ctx[4];\n\n    assert(m);\n\n    /* In the future, we might back off when context is not available,\n     * but for now we'll just return the CI phone. */\n    if (lc < 0 || rc < 0)\n        return ci;\n\n    assert((ci >= 0) && (ci < m->n_ciphone));\n    assert((lc >= 0) && (lc < m->n_ciphone));\n    assert((rc >= 0) && (rc < m->n_ciphone));\n    assert((wpos >= 0) && (wpos < N_WORD_POSN));\n\n    /* Create a context list, mapping fillers to silence. */\n    ctx[0] = wpos;\n    ctx[1] = ci;\n    ctx[2] = (m->sil >= 0\n              && m->phone[lc].info.ci.filler) ? m->sil : lc;\n    ctx[3] = (m->sil >= 0\n              && m->phone[rc].info.ci.filler) ? m->sil : rc;\n\n    /* Walk down the cd_tree. */\n    cd_tree = m->cd_tree;\n    level = 0;                  /* What level we are on. */\n    max = N_WORD_POSN;          /* Number of nodes on this level. */\n    while (level < 4) {\n        int i;\n\n#if 0\n        E_INFO(\"Looking for context %d=%s in %d at %d\\n\",\n               ctx[level], m->ciname[ctx[level]],\n               max, cd_tree - m->cd_tree);\n#endif\n        for (i = 0; i < max; ++i) {\n#if 0\n            E_INFO(\"Look at context %d=%s at %d\\n\",\n                   cd_tree[i].ctx,\n                   m->ciname[cd_tree[i].ctx], cd_tree + i - m->cd_tree);\n#endif\n            if (cd_tree[i].ctx == ctx[level])\n                break;\n        }\n        if (i == max)\n            return -1;\n#if 0\n        E_INFO(\"Found context %d=%s at %d, n_down=%d, down=%d\\n\",\n               ctx[level], m->ciname[ctx[level]],\n               cd_tree + i - m->cd_tree,\n               cd_tree[i].n_down, cd_tree[i].c.down);\n#endif\n        /* Leaf node, stop here. */\n        if (cd_tree[i].n_down == 0)\n            return cd_tree[i].c.pid;\n\n        /* Go down one level. */\n        max = cd_tree[i].n_down;\n        cd_tree = m->cd_tree + cd_tree[i].c.down;\n        ++level;\n    }\n    /* We probably shouldn't get here. */\n    return -1;\n}\n\nint\nbin_mdef_phone_id_nearest(bin_mdef_t * m, int32 b, int32 l, int32 r, int32 pos)\n{\n    int p, tmppos;\n\n\n\n    /* In the future, we might back off when context is not available,\n     * but for now we'll just return the CI phone. */\n    if (l < 0 || r < 0)\n        return b;\n\n    p = bin_mdef_phone_id(m, b, l, r, pos);\n    if (p >= 0)\n        return p;\n\n    /* Exact triphone not found; backoff to other word positions */\n    for (tmppos = 0; tmppos < N_WORD_POSN; tmppos++) {\n        if (tmppos != pos) {\n            p = bin_mdef_phone_id(m, b, l, r, tmppos);\n            if (p >= 0)\n                return p;\n        }\n    }\n\n    /* Nothing yet; backoff to silence phone if non-silence filler context */\n    /* In addition, backoff to silence phone on left/right if in beginning/end position */\n    if (m->sil >= 0) {\n        int newl = l, newr = r;\n        if (m->phone[(int)l].info.ci.filler\n            || pos == WORD_POSN_BEGIN || pos == WORD_POSN_SINGLE)\n            newl = m->sil;\n        if (m->phone[(int)r].info.ci.filler\n            || pos == WORD_POSN_END || pos == WORD_POSN_SINGLE)\n            newr = m->sil;\n        if ((newl != l) || (newr != r)) {\n            p = bin_mdef_phone_id(m, b, newl, newr, pos);\n            if (p >= 0)\n                return p;\n\n            for (tmppos = 0; tmppos < N_WORD_POSN; tmppos++) {\n                if (tmppos != pos) {\n                    p = bin_mdef_phone_id(m, b, newl, newr, tmppos);\n                    if (p >= 0)\n                        return p;\n                }\n            }\n        }\n    }\n\n    /* Nothing yet; backoff to base phone */\n    return b;\n}\n\nint\nbin_mdef_phone_str(bin_mdef_t * m, int pid, char *buf)\n{\n    char *wpos_name;\n\n    assert(m);\n    assert((pid >= 0) && (pid < m->n_phone));\n    wpos_name = WPOS_NAME;\n\n    buf[0] = '\\0';\n    if (pid < m->n_ciphone)\n        sprintf(buf, \"%s\", bin_mdef_ciphone_str(m, pid));\n    else {\n        sprintf(buf, \"%s %s %s %c\",\n                bin_mdef_ciphone_str(m, m->phone[pid].info.cd.ctx[0]),\n                bin_mdef_ciphone_str(m, m->phone[pid].info.cd.ctx[1]),\n                bin_mdef_ciphone_str(m, m->phone[pid].info.cd.ctx[2]),\n                wpos_name[m->phone[pid].info.cd.wpos]);\n    }\n    return 0;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n * blkarray_list.c -- block array-based list structure.\n * \n * HISTORY\n * \n * 18-Feb-2004\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tStarted.\n */\n\n/* System headers. */\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/prim_type.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n\n/* Local headers. */\n#include \"blkarray_list.h\"\n\n\n#define BLKARRAY_DEFAULT_MAXBLKS\t16380\n#define BLKARRAY_DEFAULT_BLKSIZE\t16380\n\n\nblkarray_list_t *\n_blkarray_list_init(int32 maxblks, int32 blksize)\n{\n    blkarray_list_t *bl;\n\n    if ((maxblks <= 0) || (blksize <= 0)) {\n        E_ERROR(\"Cannot allocate %dx%d blkarray\\n\", maxblks, blksize);\n        return NULL;\n    }\n\n    bl = (blkarray_list_t *) ckd_calloc(1, sizeof(blkarray_list_t));\n    bl->ptr = (void ***) ckd_calloc(maxblks, sizeof(void **));\n    bl->maxblks = maxblks;\n    bl->blksize = blksize;\n    bl->n_valid = 0;\n    bl->cur_row = -1;           /* No row is allocated (dummy) */\n    bl->cur_row_free = blksize; /* The dummy row is full */\n\n    return bl;\n}\n\n\nblkarray_list_t *\nblkarray_list_init(void)\n{\n    return _blkarray_list_init(BLKARRAY_DEFAULT_MAXBLKS,\n                               BLKARRAY_DEFAULT_BLKSIZE);\n}\n\nvoid\nblkarray_list_free(blkarray_list_t *bl)\n{\n    blkarray_list_reset(bl);\n    ckd_free(bl->ptr);\n    ckd_free(bl);\n}\n\n\nint32\nblkarray_list_append(blkarray_list_t * bl, void *data)\n{\n    int32 id;\n\n    assert(bl);\n\n    if (bl->cur_row_free >= bl->blksize) {\n        /* Previous row is filled; need to allocate a new row */\n        bl->cur_row++;\n\n        if (bl->cur_row >= bl->maxblks) {\n            E_ERROR(\"Block array (%dx%d) exhausted\\n\",\n                    bl->maxblks, bl->blksize);\n            bl->cur_row--;\n            return -1;\n        }\n\n        /* Allocate the new row */\n        assert(bl->ptr[bl->cur_row] == NULL);\n        bl->ptr[bl->cur_row] = (void **) ckd_malloc(bl->blksize *\n                                                    sizeof(void *));\n\n        bl->cur_row_free = 0;\n    }\n\n    bl->ptr[bl->cur_row][bl->cur_row_free] = data;\n    (bl->cur_row_free)++;\n\n    id = (bl->n_valid)++;\n    assert(id >= 0);\n\n    return id;\n}\n\n\nvoid\nblkarray_list_reset(blkarray_list_t * bl)\n{\n    int32 i, j;\n\n    /* Free all the allocated elements as well as the blocks */\n    for (i = 0; i < bl->cur_row; i++) {\n        for (j = 0; j < bl->blksize; j++)\n            ckd_free(bl->ptr[i][j]);\n\n        ckd_free(bl->ptr[i]);\n        bl->ptr[i] = NULL;\n    }\n    if (i == bl->cur_row) {     /* NEED THIS! (in case cur_row < 0) */\n        for (j = 0; j < bl->cur_row_free; j++)\n            ckd_free(bl->ptr[i][j]);\n\n        ckd_free(bl->ptr[i]);\n        bl->ptr[i] = NULL;\n    }\n\n    bl->n_valid = 0;\n    bl->cur_row = -1;\n    bl->cur_row_free = bl->blksize;\n}\n\nvoid *\nblkarray_list_get(blkarray_list_t *list, int32 n)\n{\n    int32 r, c;\n\n    if (n >= blkarray_list_n_valid(list))\n        return NULL;\n\n    r = n / blkarray_list_blksize(list);\n    c = n - (r * blkarray_list_blksize(list));\n\n    return blkarray_list_ptr(list, r, c);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* System headers. */\n#include <string.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/pio.h>\n#include <sphinxbase/strfuncs.h>\n\n/* Local headers. */\n#include \"dict.h\"\n\n\n#define DELIM\t\" \\t\\n\"         /* Set of field separator characters */\n#define DEFAULT_NUM_PHONE\t(MAX_S3CIPID+1)\n\n#if WIN32\n#define snprintf sprintf_s\n#endif \n\nextern const char *const cmu6_lts_phone_table[];\n\nstatic s3cipid_t\ndict_ciphone_id(dict_t * d, const char *str)\n{\n    if (d->nocase)\n        return bin_mdef_ciphone_id_nocase(d->mdef, str);\n    else\n        return bin_mdef_ciphone_id(d->mdef, str);\n}\n\n\nconst char *\ndict_ciphone_str(dict_t * d, s3wid_t wid, int32 pos)\n{\n    assert(d != NULL);\n    assert((wid >= 0) && (wid < d->n_word));\n    assert((pos >= 0) && (pos < d->word[wid].pronlen));\n\n    return bin_mdef_ciphone_str(d->mdef, d->word[wid].ciphone[pos]);\n}\n\n\ns3wid_t\ndict_add_word(dict_t * d, char const *word, s3cipid_t const * p, int32 np)\n{\n    int32 len;\n    dictword_t *wordp;\n    s3wid_t newwid;\n    char *wword;\n\n    if (d->n_word >= d->max_words) {\n        E_INFO(\"Reallocating to %d KiB for word entries\\n\",\n               (d->max_words + S3DICT_INC_SZ) * sizeof(dictword_t) / 1024);\n        d->word =\n            (dictword_t *) ckd_realloc(d->word,\n                                       (d->max_words +\n                                        S3DICT_INC_SZ) * sizeof(dictword_t));\n        d->max_words = d->max_words + S3DICT_INC_SZ;\n    }\n\n    wordp = d->word + d->n_word;\n    wordp->word = (char *) ckd_salloc(word);    /* Freed in dict_free */\n\n    /* Determine base/alt wids */\n    wword = ckd_salloc(word);\n    if ((len = dict_word2basestr(wword)) > 0) {\n        int32 w;\n\n        /* Truncated to a baseword string; find its ID */\n        if (hash_table_lookup_int32(d->ht, wword, &w) < 0) {\n            E_ERROR(\"Missing base word for: %s\\n\", word);\n            ckd_free(wword);\n            ckd_free(wordp->word);\n            wordp->word = NULL;\n            return BAD_S3WID;\n        }\n\n        /* Link into alt list */\n        wordp->basewid = w;\n        wordp->alt = d->word[w].alt;\n        d->word[w].alt = d->n_word;\n    } else {\n        wordp->alt = BAD_S3WID;\n        wordp->basewid = d->n_word;\n    }\n    ckd_free(wword);\n\n    /* Associate word string with d->n_word in hash table */\n    if (hash_table_enter_int32(d->ht, wordp->word, d->n_word) != d->n_word) {\n        ckd_free(wordp->word);\n        wordp->word = NULL;\n        return BAD_S3WID;\n    }\n\n    /* Fill in word entry, and set defaults */\n    if (p && (np > 0)) {\n        wordp->ciphone = (s3cipid_t *) ckd_malloc(np * sizeof(s3cipid_t));      /* Freed in dict_free */\n        memcpy(wordp->ciphone, p, np * sizeof(s3cipid_t));\n        wordp->pronlen = np;\n    }\n    else {\n        wordp->ciphone = NULL;\n        wordp->pronlen = 0;\n    }\n\n    newwid = d->n_word++;\n\n    return newwid;\n}\n\n\nstatic int32\ndict_read(FILE * fp, dict_t * d)\n{\n    lineiter_t *li;\n    char **wptr;\n    s3cipid_t *p;\n    int32 lineno, nwd;\n    s3wid_t w;\n    int32 i, maxwd;\n    size_t stralloc, phnalloc;\n\n    maxwd = 512;\n    p = (s3cipid_t *) ckd_calloc(maxwd + 4, sizeof(*p));\n    wptr = (char **) ckd_calloc(maxwd, sizeof(char *)); /* Freed below */\n\n    lineno = 0;\n    stralloc = phnalloc = 0;\n    for (li = lineiter_start(fp); li; li = lineiter_next(li)) {\n        lineno++;\n        if (0 == strncmp(li->buf, \"##\", 2)\n            || 0 == strncmp(li->buf, \";;\", 2))\n            continue;\n\n        if ((nwd = str2words(li->buf, wptr, maxwd)) < 0) {\n            /* Increase size of p, wptr. */\n            nwd = str2words(li->buf, NULL, 0);\n            assert(nwd > maxwd); /* why else would it fail? */\n            maxwd = nwd;\n            p = (s3cipid_t *) ckd_realloc(p, (maxwd + 4) * sizeof(*p));\n            wptr = (char **) ckd_realloc(wptr, maxwd * sizeof(*wptr));\n        }\n\n        if (nwd == 0)           /* Empty line */\n            continue;\n        /* wptr[0] is the word-string and wptr[1..nwd-1] the pronunciation sequence */\n        if (nwd == 1) {\n            E_ERROR(\"Line %d: No pronunciation for word '%s'; ignored\\n\",\n                    lineno, wptr[0]);\n            continue;\n        }\n\n\n        /* Convert pronunciation string to CI-phone-ids */\n        for (i = 1; i < nwd; i++) {\n            p[i - 1] = dict_ciphone_id(d, wptr[i]);\n            if (NOT_S3CIPID(p[i - 1])) {\n                E_ERROR(\"Line %d: Phone '%s' is mising in the acoustic model; word '%s' ignored\\n\",\n                        lineno, wptr[i], wptr[0]);\n                break;\n            }\n        }\n\n        if (i == nwd) {         /* All CI-phones successfully converted to IDs */\n            w = dict_add_word(d, wptr[0], p, nwd - 1);\n            if (NOT_S3WID(w))\n                E_ERROR\n                    (\"Line %d: Failed to add the word '%s' (duplicate?); ignored\\n\",\n                     lineno, wptr[0]);\n            else {\n                stralloc += strlen(d->word[w].word);\n                phnalloc += d->word[w].pronlen * sizeof(s3cipid_t);\n            }\n        }\n    }\n    E_INFO(\"Dictionary size %d, allocated %d KiB for strings, %d KiB for phones\\n\",\n           dict_size(d), (int)stralloc / 1024, (int)phnalloc / 1024);\n    ckd_free(p);\n    ckd_free(wptr);\n\n    return 0;\n}\n\nint\ndict_write(dict_t *dict, char const *filename, char const *format)\n{\n    FILE *fh;\n    int i;\n\n    if ((fh = fopen(filename, \"w\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open '%s'\", filename);\n        return -1;\n    }\n    for (i = 0; i < dict->n_word; ++i) {\n        char *phones;\n        int j, phlen;\n        if (!dict_real_word(dict, i))\n            continue;\n        for (phlen = j = 0; j < dict_pronlen(dict, i); ++j)\n            phlen += strlen(dict_ciphone_str(dict, i, j)) + 1;\n        phones = ckd_calloc(1, phlen);\n        for (j = 0; j < dict_pronlen(dict, i); ++j) {\n            strcat(phones, dict_ciphone_str(dict, i, j));\n            if (j != dict_pronlen(dict, i) - 1)\n                strcat(phones, \" \");\n        }\n        fprintf(fh, \"%-30s %s\\n\", dict_wordstr(dict, i), phones);\n        ckd_free(phones);\n    }\n    fclose(fh);\n    return 0;\n}\n\n\ndict_t *\ndict_init(cmd_ln_t *config, bin_mdef_t * mdef)\n{\n    FILE *fp, *fp2;\n    int32 n;\n    lineiter_t *li;\n    dict_t *d;\n    s3cipid_t sil;\n    char const *dictfile = NULL, *fillerfile = NULL;\n\n    if (config) {\n        dictfile = cmd_ln_str_r(config, \"-dict\");\n        fillerfile = cmd_ln_str_r(config, \"_fdict\");\n    }\n\n    /*\n     * First obtain #words in dictionary (for hash table allocation).\n     * Reason: The PC NT system doesn't like to grow memory gradually.  Better to allocate\n     * all the required memory in one go.\n     */\n    fp = NULL;\n    n = 0;\n    if (dictfile) {\n        if ((fp = fopen(dictfile, \"r\")) == NULL) {\n            E_ERROR_SYSTEM(\"Failed to open dictionary file '%s' for reading\", dictfile);\n            return NULL;\n        }\n        for (li = lineiter_start(fp); li; li = lineiter_next(li)) {\n            if (0 != strncmp(li->buf, \"##\", 2)\n                && 0 != strncmp(li->buf, \";;\", 2))\n                n++;\n        }\n\tfseek(fp, 0L, SEEK_SET);\n    }\n\n    fp2 = NULL;\n    if (fillerfile) {\n        if ((fp2 = fopen(fillerfile, \"r\")) == NULL) {\n            E_ERROR_SYSTEM(\"Failed to open filler dictionary file '%s' for reading\", fillerfile);\n            fclose(fp);\n            return NULL;\n\t}\n        for (li = lineiter_start(fp2); li; li = lineiter_next(li)) {\n\t    if (0 != strncmp(li->buf, \"##\", 2)\n    \t        && 0 != strncmp(li->buf, \";;\", 2))\n                n++;\n        }\n        fseek(fp2, 0L, SEEK_SET);\n    }\n\n    /*\n     * Allocate dict entries.  HACK!!  Allow some extra entries for words not in file.\n     * Also check for type size restrictions.\n     */\n    d = (dict_t *) ckd_calloc(1, sizeof(dict_t));       /* freed in dict_free() */\n    d->refcnt = 1;\n    d->max_words =\n        (n + S3DICT_INC_SZ < MAX_S3WID) ? n + S3DICT_INC_SZ : MAX_S3WID;\n    if (n >= MAX_S3WID) {\n        E_ERROR(\"Number of words in dictionaries (%d) exceeds limit (%d)\\n\", n,\n                MAX_S3WID);\n        fclose(fp);\n        fclose(fp2);\n        ckd_free(d);\n        return NULL;\n    }\n\n    E_INFO(\"Allocating %d * %d bytes (%d KiB) for word entries\\n\",\n           d->max_words, sizeof(dictword_t),\n           d->max_words * sizeof(dictword_t) / 1024);\n    d->word = (dictword_t *) ckd_calloc(d->max_words, sizeof(dictword_t));      /* freed in dict_free() */\n    d->n_word = 0;\n    if (mdef)\n        d->mdef = bin_mdef_retain(mdef);\n\n    /* Create new hash table for word strings; case-insensitive word strings */\n    if (config && cmd_ln_exists_r(config, \"-dictcase\"))\n        d->nocase = cmd_ln_boolean_r(config, \"-dictcase\");\n    d->ht = hash_table_new(d->max_words, d->nocase);\n\n    /* Digest main dictionary file */\n    if (fp) {\n        E_INFO(\"Reading main dictionary: %s\\n\", dictfile);\n        dict_read(fp, d);\n        fclose(fp);\n        E_INFO(\"%d words read\\n\", d->n_word);\n    }\n\n    if (dict_wordid(d, S3_START_WORD) != BAD_S3WID) {\n\tE_ERROR(\"Remove sentence start word '<s>' from the dictionary\\n\");\n\tdict_free(d);\n\treturn NULL;\n    }\n    if (dict_wordid(d, S3_FINISH_WORD) != BAD_S3WID) {\n\tE_ERROR(\"Remove sentence start word '</s>' from the dictionary\\n\");\n\tdict_free(d);\n\treturn NULL;\n    }\n    if (dict_wordid(d, S3_SILENCE_WORD) != BAD_S3WID) {\n\tE_ERROR(\"Remove silence word '<sil>' from the dictionary\\n\");\n\tdict_free(d);\n\treturn NULL;\n    }\n\n    /* Now the filler dictionary file, if it exists */\n    d->filler_start = d->n_word;\n    if (fillerfile) {\n        E_INFO(\"Reading filler dictionary: %s\\n\", fillerfile);\n        dict_read(fp2, d);\n        fclose(fp2);\n        E_INFO(\"%d words read\\n\", d->n_word - d->filler_start);\n    }\n    if (mdef)\n        sil = bin_mdef_silphone(mdef);\n    else\n        sil = 0;\n    if (dict_wordid(d, S3_START_WORD) == BAD_S3WID) {\n        dict_add_word(d, S3_START_WORD, &sil, 1);\n    }\n    if (dict_wordid(d, S3_FINISH_WORD) == BAD_S3WID) {\n        dict_add_word(d, S3_FINISH_WORD, &sil, 1);\n    }\n    if (dict_wordid(d, S3_SILENCE_WORD) == BAD_S3WID) {\n        dict_add_word(d, S3_SILENCE_WORD, &sil, 1);\n    }\n\n    d->filler_end = d->n_word - 1;\n\n    /* Initialize distinguished word-ids */\n    d->startwid = dict_wordid(d, S3_START_WORD);\n    d->finishwid = dict_wordid(d, S3_FINISH_WORD);\n    d->silwid = dict_wordid(d, S3_SILENCE_WORD);\n\n    if ((d->filler_start > d->filler_end)\n        || (!dict_filler_word(d, d->silwid))) {\n        E_ERROR(\"Word '%s' must occur (only) in filler dictionary\\n\",\n                S3_SILENCE_WORD);\n        dict_free(d);\n        return NULL;\n    }\n\n    /* No check that alternative pronunciations for filler words are in filler range!! */\n\n    return d;\n}\n\n\ns3wid_t\ndict_wordid(dict_t *d, const char *word)\n{\n    int32 w;\n\n    assert(d);\n    assert(word);\n\n    if (hash_table_lookup_int32(d->ht, word, &w) < 0)\n        return (BAD_S3WID);\n    return w;\n}\n\n\nint\ndict_filler_word(dict_t *d, s3wid_t w)\n{\n    assert(d);\n    assert((w >= 0) && (w < d->n_word));\n\n    w = dict_basewid(d, w);\n    if ((w == d->startwid) || (w == d->finishwid))\n        return 0;\n    if ((w >= d->filler_start) && (w <= d->filler_end))\n        return 1;\n    return 0;\n}\n\nint\ndict_real_word(dict_t *d, s3wid_t w)\n{\n    assert(d);\n    assert((w >= 0) && (w < d->n_word));\n\n    w = dict_basewid(d, w);\n    if ((w == d->startwid) || (w == d->finishwid))\n        return 0;\n    if ((w >= d->filler_start) && (w <= d->filler_end))\n        return 0;\n    return 1;\n}\n\n\nint32\ndict_word2basestr(char *word)\n{\n    int32 i, len;\n\n    len = strlen(word);\n    if (word[len - 1] == ')') {\n        for (i = len - 2; (i > 0) && (word[i] != '('); --i);\n\n        if (i > 0) {\n            /* The word is of the form <baseword>(...); strip from left-paren */\n            word[i] = '\\0';\n            return i;\n        }\n    }\n\n    return -1;\n}\n\ndict_t *\ndict_retain(dict_t *d)\n{\n    ++d->refcnt;\n    return d;\n}\n\nint\ndict_free(dict_t * d)\n{\n    int i;\n    dictword_t *word;\n\n    if (d == NULL)\n        return 0;\n    if (--d->refcnt > 0)\n        return d->refcnt;\n\n    /* First Step, free all memory allocated for each word */\n    for (i = 0; i < d->n_word; i++) {\n        word = (dictword_t *) & (d->word[i]);\n        if (word->word)\n            ckd_free((void *) word->word);\n        if (word->ciphone)\n            ckd_free((void *) word->ciphone);\n    }\n\n    if (d->word)\n        ckd_free((void *) d->word);\n    if (d->ht)\n        hash_table_free(d->ht);\n    if (d->mdef)\n        bin_mdef_free(d->mdef);\n    ckd_free((void *) d);\n\n    return 0;\n}\n\nvoid\ndict_report(dict_t * d)\n{\n    E_INFO_NOFN(\"Initialization of dict_t, report:\\n\");\n    E_INFO_NOFN(\"Max word: %d\\n\", d->max_words);\n    E_INFO_NOFN(\"No of word: %d\\n\", d->n_word);\n    E_INFO_NOFN(\"\\n\");\n}\n","/* -*- c-basic-offset:4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <string.h>\n\n#include \"dict2pid.h\"\n#include \"hmm.h\"\n\n\n/**\n * @file dict2pid.c - dictionary word to senone sequence mappings\n */\n\nvoid\ncompress_table(s3ssid_t * uncomp_tab, s3ssid_t * com_tab,\n               s3cipid_t * ci_map, int32 n_ci)\n{\n    int32 found;\n    int32 r;\n    int32 tmp_r;\n\n    for (r = 0; r < n_ci; r++) {\n        com_tab[r] = BAD_S3SSID;\n        ci_map[r] = BAD_S3CIPID;\n    }\n    /** Compress this map */\n    for (r = 0; r < n_ci; r++) {\n\n        found = 0;\n        for (tmp_r = 0; tmp_r < r && com_tab[tmp_r] != BAD_S3SSID; tmp_r++) {   /* If it appears before, just filled in cimap; */\n            if (uncomp_tab[r] == com_tab[tmp_r]) {\n                found = 1;\n                ci_map[r] = tmp_r;\n                break;\n            }\n        }\n\n        if (found == 0) {\n            com_tab[tmp_r] = uncomp_tab[r];\n            ci_map[r] = tmp_r;\n        }\n    }\n}\n\n\nstatic void\ncompress_right_context_tree(dict2pid_t * d2p,\n                            s3ssid_t ***rdiph_rc)\n{\n    int32 n_ci;\n    int32 b, l, r;\n    s3ssid_t *rmap;\n    s3ssid_t *tmpssid;\n    s3cipid_t *tmpcimap;\n    bin_mdef_t *mdef = d2p->mdef;\n    size_t alloc;\n\n    n_ci = mdef->n_ciphone;\n\n    tmpssid = ckd_calloc(n_ci, sizeof(s3ssid_t));\n    tmpcimap = ckd_calloc(n_ci, sizeof(s3cipid_t));\n\n    d2p->rssid =\n        (xwdssid_t **) ckd_calloc(mdef->n_ciphone, sizeof(xwdssid_t *));\n    alloc = mdef->n_ciphone * sizeof(xwdssid_t *);\n\n    for (b = 0; b < n_ci; b++) {\n        d2p->rssid[b] =\n            (xwdssid_t *) ckd_calloc(mdef->n_ciphone, sizeof(xwdssid_t));\n        alloc += mdef->n_ciphone * sizeof(xwdssid_t);\n\n        for (l = 0; l < n_ci; l++) {\n            rmap = rdiph_rc[b][l];\n            compress_table(rmap, tmpssid, tmpcimap, mdef->n_ciphone);\n\n            for (r = 0; r < mdef->n_ciphone && tmpssid[r] != BAD_S3SSID;\n                 r++);\n\n            if (tmpssid[0] != BAD_S3SSID) {\n                d2p->rssid[b][l].ssid = ckd_calloc(r, sizeof(s3ssid_t));\n                memcpy(d2p->rssid[b][l].ssid, tmpssid,\n                       r * sizeof(s3ssid_t));\n                d2p->rssid[b][l].cimap =\n                    ckd_calloc(mdef->n_ciphone, sizeof(s3cipid_t));\n                memcpy(d2p->rssid[b][l].cimap, tmpcimap,\n                       (mdef->n_ciphone) * sizeof(s3cipid_t));\n                d2p->rssid[b][l].n_ssid = r;\n            }\n            else {\n                d2p->rssid[b][l].ssid = NULL;\n                d2p->rssid[b][l].cimap = NULL;\n                d2p->rssid[b][l].n_ssid = 0;\n            }\n        }\n    }\n\n    E_INFO(\"Allocated %d bytes (%d KiB) for word-final triphones\\n\",\n           (int)alloc, (int)alloc / 1024);\n    ckd_free(tmpssid);\n    ckd_free(tmpcimap);\n}\n\nstatic void\ncompress_left_right_context_tree(dict2pid_t * d2p)\n{\n    int32 n_ci;\n    int32 b, l, r;\n    s3ssid_t *rmap;\n    s3ssid_t *tmpssid;\n    s3cipid_t *tmpcimap;\n    bin_mdef_t *mdef = d2p->mdef;\n    size_t alloc;\n\n    n_ci = mdef->n_ciphone;\n\n    tmpssid = ckd_calloc(n_ci, sizeof(s3ssid_t));\n    tmpcimap = ckd_calloc(n_ci, sizeof(s3cipid_t));\n\n    assert(d2p->lrdiph_rc);\n\n    d2p->lrssid =\n        (xwdssid_t **) ckd_calloc(mdef->n_ciphone, sizeof(xwdssid_t *));\n    alloc = mdef->n_ciphone * sizeof(xwdssid_t *);\n\n    for (b = 0; b < n_ci; b++) {\n\n        d2p->lrssid[b] =\n            (xwdssid_t *) ckd_calloc(mdef->n_ciphone, sizeof(xwdssid_t));\n        alloc += mdef->n_ciphone * sizeof(xwdssid_t);\n\n        for (l = 0; l < n_ci; l++) {\n            rmap = d2p->lrdiph_rc[b][l];\n\n            compress_table(rmap, tmpssid, tmpcimap, mdef->n_ciphone);\n\n            for (r = 0; r < mdef->n_ciphone && tmpssid[r] != BAD_S3SSID;\n                 r++);\n\n            if (tmpssid[0] != BAD_S3SSID) {\n                d2p->lrssid[b][l].ssid = ckd_calloc(r, sizeof(s3ssid_t));\n                memcpy(d2p->lrssid[b][l].ssid, tmpssid,\n                       r * sizeof(s3ssid_t));\n                d2p->lrssid[b][l].cimap =\n                    ckd_calloc(mdef->n_ciphone, sizeof(s3cipid_t));\n                memcpy(d2p->lrssid[b][l].cimap, tmpcimap,\n                       (mdef->n_ciphone) * sizeof(s3cipid_t));\n                d2p->lrssid[b][l].n_ssid = r;\n            }\n            else {\n                d2p->lrssid[b][l].ssid = NULL;\n                d2p->lrssid[b][l].cimap = NULL;\n                d2p->lrssid[b][l].n_ssid = 0;\n            }\n        }\n    }\n\n    /* Try to compress lrdiph_rc into lrdiph_rc_compressed */\n    ckd_free(tmpssid);\n    ckd_free(tmpcimap);\n\n    E_INFO(\"Allocated %d bytes (%d KiB) for single-phone word triphones\\n\",\n           (int)alloc, (int)alloc / 1024);\n}\n\n/**\n   ARCHAN, A duplicate of get_rc_npid in ctxt_table.h.  I doubt whether it is correct\n   because the compressed map has not been checked. \n*/\nint32\nget_rc_nssid(dict2pid_t * d2p, s3wid_t w)\n{\n    int32 pronlen;\n    s3cipid_t b, lc;\n    dict_t *dict = d2p->dict;\n\n    pronlen = dict->word[w].pronlen;\n    b = dict->word[w].ciphone[pronlen - 1];\n\n    if (pronlen == 1) {\n        /* Is this true ?\n           No known left context.  But all cimaps (for any l) are identical; pick one \n        */\n        /*E_INFO(\"Single phone word\\n\"); */\n        return (d2p->lrssid[b][0].n_ssid);\n    }\n    else {\n        /*    E_INFO(\"Multiple phone word\\n\"); */\n        lc = dict->word[w].ciphone[pronlen - 2];\n        return (d2p->rssid[b][lc].n_ssid);\n    }\n\n}\n\ns3cipid_t *\ndict2pid_get_rcmap(dict2pid_t * d2p, s3wid_t w)\n{\n    int32 pronlen;\n    s3cipid_t b, lc;\n    dict_t *dict = d2p->dict;\n\n    pronlen = dict->word[w].pronlen;\n    b = dict->word[w].ciphone[pronlen - 1];\n\n    if (pronlen == 1) {\n        /* Is this true ?\n           No known left context.  But all cimaps (for any l) are identical; pick one \n        */\n        /*E_INFO(\"Single phone word\\n\"); */\n        return (d2p->lrssid[b][0].cimap);\n    }\n    else {\n        /*    E_INFO(\"Multiple phone word\\n\"); */\n        lc = dict->word[w].ciphone[pronlen - 2];\n        return (d2p->rssid[b][lc].cimap);\n    }\n}\n\nstatic void\nfree_compress_map(xwdssid_t ** tree, int32 n_ci)\n{\n    int32 b, l;\n    for (b = 0; b < n_ci; b++) {\n        for (l = 0; l < n_ci; l++) {\n            ckd_free(tree[b][l].ssid);\n            ckd_free(tree[b][l].cimap);\n        }\n        ckd_free(tree[b]);\n    }\n    ckd_free(tree);\n}\n\nstatic void\npopulate_lrdiph(dict2pid_t *d2p, s3ssid_t ***rdiph_rc, s3cipid_t b)\n{\n    bin_mdef_t *mdef = d2p->mdef;\n    s3cipid_t l, r;\n\n    for (l = 0; l < bin_mdef_n_ciphone(mdef); l++) {\n        for (r = 0; r < bin_mdef_n_ciphone(mdef); r++) {\n            s3pid_t p;\n            p = bin_mdef_phone_id_nearest(mdef, (s3cipid_t) b,\n                                          (s3cipid_t) l,\n                                          (s3cipid_t) r,\n                                          WORD_POSN_SINGLE);\n            d2p->lrdiph_rc[b][l][r]\n                = bin_mdef_pid2ssid(mdef, p);\n            if (r == bin_mdef_silphone(mdef))\n                d2p->ldiph_lc[b][r][l]\n                    = bin_mdef_pid2ssid(mdef, p);\n            if (rdiph_rc && l == bin_mdef_silphone(mdef))\n                rdiph_rc[b][l][r]\n                    = bin_mdef_pid2ssid(mdef, p);\n            assert(IS_S3SSID(bin_mdef_pid2ssid(mdef, p)));\n            E_DEBUG(\"%s(%s,%s) => %d / %d\\n\",\n                    bin_mdef_ciphone_str(mdef, b),\n                    bin_mdef_ciphone_str(mdef, l),\n                    bin_mdef_ciphone_str(mdef, r),\n                    p, bin_mdef_pid2ssid(mdef, p));\n        }\n    }\n}\n\nint\ndict2pid_add_word(dict2pid_t *d2p,\n                  int32 wid)\n{\n    bin_mdef_t *mdef = d2p->mdef;\n    dict_t *d = d2p->dict;\n\n    if (dict_pronlen(d, wid) > 1) {\n        s3cipid_t l;\n        /* Make sure we have left and right context diphones for this\n         * word. */\n        if (d2p->ldiph_lc[dict_first_phone(d, wid)][dict_second_phone(d, wid)][0]\n            == BAD_S3SSID) {\n            E_DEBUG(\"Filling in left-context diphones for %s(?,%s)\\n\",\n                   bin_mdef_ciphone_str(mdef, dict_first_phone(d, wid)),\n                   bin_mdef_ciphone_str(mdef, dict_second_phone(d, wid)));\n            for (l = 0; l < bin_mdef_n_ciphone(mdef); l++) {\n                int p\n                    = bin_mdef_phone_id_nearest(mdef,\n                                                dict_first_phone(d, wid), l,\n                                                dict_second_phone(d, wid),\n                                                WORD_POSN_BEGIN);\n                d2p->ldiph_lc[dict_first_phone(d, wid)][dict_second_phone(d, wid)][l]\n                    = bin_mdef_pid2ssid(mdef, p);\n            }\n        }\n        if (d2p->rssid[dict_last_phone(d, wid)][dict_second_last_phone(d, wid)].n_ssid\n            == 0) {\n            s3ssid_t *rmap;\n            s3ssid_t *tmpssid;\n            s3cipid_t *tmpcimap;\n            s3cipid_t r;\n\n            E_DEBUG(\"Filling in right-context diphones for %s(%s,?)\\n\",\n                   bin_mdef_ciphone_str(mdef, dict_last_phone(d, wid)),\n                   bin_mdef_ciphone_str(mdef, dict_second_last_phone(d, wid)));\n            rmap = ckd_calloc(bin_mdef_n_ciphone(mdef), sizeof(*rmap));\n            for (r = 0; r < bin_mdef_n_ciphone(mdef); r++) {\n                int p\n                    = bin_mdef_phone_id_nearest(mdef,\n                                                dict_last_phone(d, wid),\n                                                dict_second_last_phone(d, wid), r,\n                                                WORD_POSN_END);\n                rmap[r] = bin_mdef_pid2ssid(mdef, p);\n            }\n            tmpssid = ckd_calloc(bin_mdef_n_ciphone(mdef), sizeof(*tmpssid));\n            tmpcimap = ckd_calloc(bin_mdef_n_ciphone(mdef), sizeof(*tmpcimap));\n            compress_table(rmap, tmpssid, tmpcimap, bin_mdef_n_ciphone(mdef));\n            for (r = 0; r < mdef->n_ciphone && tmpssid[r] != BAD_S3SSID; r++)\n                ;\n            d2p->rssid[dict_last_phone(d, wid)][dict_second_last_phone(d, wid)].ssid = tmpssid;\n            d2p->rssid[dict_last_phone(d, wid)][dict_second_last_phone(d, wid)].cimap = tmpcimap;\n            d2p->rssid[dict_last_phone(d, wid)][dict_second_last_phone(d, wid)].n_ssid = r;\n            ckd_free(rmap);\n        }\n    }\n    else {\n        /* Make sure we have a left-right context triphone entry for\n         * this word. */\n        E_INFO(\"Filling in context triphones for %s(?,?)\\n\",\n               bin_mdef_ciphone_str(mdef, dict_first_phone(d, wid)));\n        if (d2p->lrdiph_rc[dict_first_phone(d, wid)][0][0] == BAD_S3SSID) {\n            populate_lrdiph(d2p, NULL, dict_first_phone(d, wid));\n        }\n    }\n\n    return 0;\n}\n\ns3ssid_t\ndict2pid_internal(dict2pid_t *d2p,\n                  int32 wid,\n                  int pos)\n{\n    int b, l, r, p;\n    dict_t *dict = d2p->dict;\n    bin_mdef_t *mdef = d2p->mdef;\n\n    if (pos == 0 || pos == dict_pronlen(dict, wid))\n        return BAD_S3SSID;\n\n    b = dict_pron(dict, wid, pos);\n    l = dict_pron(dict, wid, pos - 1);\n    r = dict_pron(dict, wid, pos + 1);\n    p = bin_mdef_phone_id_nearest(mdef, (s3cipid_t) b,\n                                  (s3cipid_t) l, (s3cipid_t) r,\n                                  WORD_POSN_INTERNAL);\n    return bin_mdef_pid2ssid(mdef, p);\n}\n\ndict2pid_t *\ndict2pid_build(bin_mdef_t * mdef, dict_t * dict)\n{\n    dict2pid_t *dict2pid;\n    s3ssid_t ***rdiph_rc;\n    bitvec_t *ldiph, *rdiph, *single;\n    int32 pronlen;\n    int32 b, l, r, w, p;\n\n    E_INFO(\"Building PID tables for dictionary\\n\");\n    assert(mdef);\n    assert(dict);\n\n    dict2pid = (dict2pid_t *) ckd_calloc(1, sizeof(dict2pid_t));\n    dict2pid->refcount = 1;\n    dict2pid->mdef = bin_mdef_retain(mdef);\n    dict2pid->dict = dict_retain(dict);\n    E_INFO(\"Allocating %d^3 * %d bytes (%d KiB) for word-initial triphones\\n\",\n           mdef->n_ciphone, sizeof(s3ssid_t),\n           mdef->n_ciphone * mdef->n_ciphone * mdef->n_ciphone * sizeof(s3ssid_t) / 1024);\n    dict2pid->ldiph_lc =\n        (s3ssid_t ***) ckd_calloc_3d(mdef->n_ciphone, mdef->n_ciphone,\n                                     mdef->n_ciphone, sizeof(s3ssid_t));\n    /* Only used internally to generate rssid */\n    rdiph_rc =\n        (s3ssid_t ***) ckd_calloc_3d(mdef->n_ciphone, mdef->n_ciphone,\n                                     mdef->n_ciphone, sizeof(s3ssid_t));\n\n    dict2pid->lrdiph_rc = (s3ssid_t ***) ckd_calloc_3d(mdef->n_ciphone,\n                                                       mdef->n_ciphone,\n                                                       mdef->n_ciphone,\n                                                       sizeof\n                                                       (s3ssid_t));\n    /* Actually could use memset for this, if BAD_S3SSID is guaranteed\n     * to be 65535... */\n    for (b = 0; b < mdef->n_ciphone; ++b) {\n        for (r = 0; r < mdef->n_ciphone; ++r) {\n            for (l = 0; l < mdef->n_ciphone; ++l) {\n                dict2pid->ldiph_lc[b][r][l] = BAD_S3SSID;\n                dict2pid->lrdiph_rc[b][l][r] = BAD_S3SSID;\n                rdiph_rc[b][l][r] = BAD_S3SSID;\n            }\n        }\n    }\n\n    /* Track which diphones / ciphones have been seen. */\n    ldiph = bitvec_alloc(mdef->n_ciphone * mdef->n_ciphone);\n    rdiph = bitvec_alloc(mdef->n_ciphone * mdef->n_ciphone);\n    single = bitvec_alloc(mdef->n_ciphone);\n\n    for (w = 0; w < dict_size(dict2pid->dict); w++) {\n        pronlen = dict_pronlen(dict, w);\n\n        if (pronlen >= 2) {\n            b = dict_first_phone(dict, w);\n            r = dict_second_phone(dict, w);\n            /* Populate ldiph_lc */\n            if (bitvec_is_clear(ldiph, b * mdef->n_ciphone + r)) {\n                /* Mark this diphone as done */\n                bitvec_set(ldiph, b * mdef->n_ciphone + r);\n\n                /* Record all possible ssids for b(?,r) */\n                for (l = 0; l < bin_mdef_n_ciphone(mdef); l++) {\n                    p = bin_mdef_phone_id_nearest(mdef, (s3cipid_t) b,\n                                              (s3cipid_t) l, (s3cipid_t) r,\n                                              WORD_POSN_BEGIN);\n                    dict2pid->ldiph_lc[b][r][l] = bin_mdef_pid2ssid(mdef, p);\n                }\n            }\n\n\n            /* Populate rdiph_rc */\n            l = dict_second_last_phone(dict, w);\n            b = dict_last_phone(dict, w);\n            if (bitvec_is_clear(rdiph, b * mdef->n_ciphone + l)) {\n                /* Mark this diphone as done */\n                bitvec_set(rdiph, b * mdef->n_ciphone + l);\n\n                for (r = 0; r < bin_mdef_n_ciphone(mdef); r++) {\n                    p = bin_mdef_phone_id_nearest(mdef, (s3cipid_t) b,\n                                              (s3cipid_t) l, (s3cipid_t) r,\n                                              WORD_POSN_END);\n                    rdiph_rc[b][l][r] = bin_mdef_pid2ssid(mdef, p);\n                }\n            }\n        }\n        else if (pronlen == 1) {\n            b = dict_pron(dict, w, 0);\n            E_DEBUG(\"Building tables for single phone word %s phone %d = %s\\n\",\n                       dict_wordstr(dict, w), b, bin_mdef_ciphone_str(mdef, b));\n            /* Populate lrdiph_rc (and also ldiph_lc, rdiph_rc if needed) */\n            if (bitvec_is_clear(single, b)) {\n                populate_lrdiph(dict2pid, rdiph_rc, b);\n                bitvec_set(single, b);\n            }\n        }\n    }\n\n    bitvec_free(ldiph);\n    bitvec_free(rdiph);\n    bitvec_free(single);\n\n    /* Try to compress rdiph_rc into rdiph_rc_compressed */\n    compress_right_context_tree(dict2pid, rdiph_rc);\n    compress_left_right_context_tree(dict2pid);\n\n    ckd_free_3d(rdiph_rc);\n\n    dict2pid_report(dict2pid);\n    return dict2pid;\n}\n\ndict2pid_t *\ndict2pid_retain(dict2pid_t *d2p)\n{\n    ++d2p->refcount;\n    return d2p;\n}\n\nint\ndict2pid_free(dict2pid_t * d2p)\n{\n    if (d2p == NULL)\n        return 0;\n    if (--d2p->refcount > 0)\n        return d2p->refcount;\n\n    if (d2p->ldiph_lc)\n        ckd_free_3d((void ***) d2p->ldiph_lc);\n\n    if (d2p->lrdiph_rc)\n        ckd_free_3d((void ***) d2p->lrdiph_rc);\n\n    if (d2p->rssid)\n        free_compress_map(d2p->rssid, bin_mdef_n_ciphone(d2p->mdef));\n\n    if (d2p->lrssid)\n        free_compress_map(d2p->lrssid, bin_mdef_n_ciphone(d2p->mdef));\n\n    bin_mdef_free(d2p->mdef);\n    dict_free(d2p->dict);\n    ckd_free(d2p);\n    return 0;\n}\n\nvoid\ndict2pid_report(dict2pid_t * d2p)\n{\n}\n\nvoid\ndict2pid_dump(FILE * fp, dict2pid_t * d2p)\n{\n    int32 w, p, pronlen;\n    int32 i, j, b, l, r;\n    bin_mdef_t *mdef = d2p->mdef;\n    dict_t *dict = d2p->dict;\n\n    fprintf(fp, \"# INTERNAL (wd comssid ssid ssid ... ssid comssid)\\n\");\n    for (w = 0; w < dict_size(dict); w++) {\n        fprintf(fp, \"%30s \", dict_wordstr(dict, w));\n\n        pronlen = dict_pronlen(dict, w);\n        for (p = 0; p < pronlen; p++)\n            fprintf(fp, \" %5d\", dict2pid_internal(d2p, w, p));\n        fprintf(fp, \"\\n\");\n    }\n    fprintf(fp, \"#\\n\");\n\n    fprintf(fp, \"# LDIPH_LC (b r l ssid)\\n\");\n    for (b = 0; b < bin_mdef_n_ciphone(mdef); b++) {\n        for (r = 0; r < bin_mdef_n_ciphone(mdef); r++) {\n            for (l = 0; l < bin_mdef_n_ciphone(mdef); l++) {\n                if (IS_S3SSID(d2p->ldiph_lc[b][r][l]))\n                    fprintf(fp, \"%6s %6s %6s %5d\\n\", bin_mdef_ciphone_str(mdef, (s3cipid_t) b), bin_mdef_ciphone_str(mdef, (s3cipid_t) r), bin_mdef_ciphone_str(mdef, (s3cipid_t) l), d2p->ldiph_lc[b][r][l]);      /* RAH, ldiph_lc is returning an int32, %d expects an int16 */\n            }\n        }\n    }\n    fprintf(fp, \"#\\n\");\n\n    fprintf(fp, \"# SSEQ %d (senid senid ...)\\n\", mdef->n_sseq);\n    for (i = 0; i < mdef->n_sseq; i++) {\n        fprintf(fp, \"%5d \", i);\n        for (j = 0; j < bin_mdef_n_emit_state(mdef); j++)\n            fprintf(fp, \" %5d\", mdef->sseq[i][j]);\n        fprintf(fp, \"\\n\");\n    }\n    fprintf(fp, \"#\\n\");\n    fprintf(fp, \"# END\\n\");\n\n    fflush(fp);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n * fsg_history.c -- FSG Viterbi decode history\n * \n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * \n * 25-Feb-2004\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tStarted..\n */\n\n/* System headers. */\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/prim_type.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n\n/* Local headers. */\n#include \"fsg_search_internal.h\"\n#include \"fsg_history.h\"\n\n\n#define __FSG_DBG__\t0\n\n\nfsg_history_t *\nfsg_history_init(fsg_model_t * fsg, dict_t *dict)\n{\n    fsg_history_t *h;\n\n    h = (fsg_history_t *) ckd_calloc(1, sizeof(fsg_history_t));\n    h->fsg = fsg;\n    h->entries = blkarray_list_init();\n\n    if (fsg && dict) {\n        h->n_ciphone = bin_mdef_n_ciphone(dict->mdef);\n        h->frame_entries =\n            (glist_t **) ckd_calloc_2d(fsg_model_n_state(fsg),\n                                       bin_mdef_n_ciphone(dict->mdef),\n                                       sizeof(**h->frame_entries));\n    }\n    else {\n        h->frame_entries = NULL;\n    }\n\n    return h;\n}\n\nvoid\nfsg_history_free(fsg_history_t *h)\n{\n    int32 s, lc, ns, np;\n    gnode_t *gn;\n\n    if (h->fsg) {\n        ns = fsg_model_n_state(h->fsg);\n        np = h->n_ciphone;\n\n        for (s = 0; s < ns; s++) {\n            for (lc = 0; lc < np; lc++) {\n                for (gn = h->frame_entries[s][lc]; gn; gn = gnode_next(gn)) {\n                    ckd_free(gnode_ptr(gn));\n                }\n                glist_free(h->frame_entries[s][lc]);\n            }\n        }\n    }\n    ckd_free_2d(h->frame_entries);\n    blkarray_list_free(h->entries);\n    ckd_free(h);\n}\n\n\nvoid\nfsg_history_set_fsg(fsg_history_t *h, fsg_model_t *fsg, dict_t *dict)\n{\n    if (blkarray_list_n_valid(h->entries) != 0) {\n        E_WARN(\"Switching FSG while history not empty; history cleared\\n\");\n        blkarray_list_reset(h->entries);\n    }\n\n    if (h->frame_entries)\n        ckd_free_2d((void **) h->frame_entries);\n    h->frame_entries = NULL;\n    h->fsg = fsg;\n\n    if (fsg && dict) {\n        h->n_ciphone = bin_mdef_n_ciphone(dict->mdef);\n        h->frame_entries =\n            (glist_t **) ckd_calloc_2d(fsg_model_n_state(fsg),\n                                       bin_mdef_n_ciphone(dict->mdef),\n                                       sizeof(glist_t));\n    }\n}\n\n\nvoid\nfsg_history_entry_add(fsg_history_t * h,\n                      fsg_link_t * link,\n                      int32 frame, int32 score, int32 pred,\n                      int32 lc, fsg_pnode_ctxt_t rc)\n{\n    fsg_hist_entry_t *entry, *new_entry;\n    int32 s;\n    gnode_t *gn, *prev_gn;\n\n    /* Skip the optimization for the initial dummy entries; always enter them */\n    if (frame < 0) {\n        new_entry =\n            (fsg_hist_entry_t *) ckd_calloc(1, sizeof(fsg_hist_entry_t));\n        new_entry->fsglink = link;\n        new_entry->frame = frame;\n        new_entry->score = score;\n        new_entry->pred = pred;\n        new_entry->lc = lc;\n        new_entry->rc = rc;\n\n        blkarray_list_append(h->entries, (void *) new_entry);\n        return;\n    }\n\n    s = fsg_link_to_state(link);\n\n    /* Locate where this entry should be inserted in frame_entries[s][lc] */\n    prev_gn = NULL;\n    for (gn = h->frame_entries[s][lc]; gn; gn = gnode_next(gn)) {\n        entry = (fsg_hist_entry_t *) gnode_ptr(gn);\n\n        if (score BETTER_THAN entry->score)\n            break;              /* Found where to insert new entry */\n\n        /* Existing entry score not worse than new score */\n        if (FSG_PNODE_CTXT_SUB(&rc, &(entry->rc)) == 0)\n            return;             /* rc set reduced to 0; new entry can be ignored */\n\n        prev_gn = gn;\n    }\n\n    /* Create new entry after prev_gn (if prev_gn is NULL, at head) */\n    new_entry =\n        (fsg_hist_entry_t *) ckd_calloc(1, sizeof(fsg_hist_entry_t));\n    new_entry->fsglink = link;\n    new_entry->frame = frame;\n    new_entry->score = score;\n    new_entry->pred = pred;\n    new_entry->lc = lc;\n    new_entry->rc = rc;         /* Note: rc set must be non-empty at this point */\n\n    if (!prev_gn) {\n        h->frame_entries[s][lc] = glist_add_ptr(h->frame_entries[s][lc],\n                                                (void *) new_entry);\n        prev_gn = h->frame_entries[s][lc];\n    }\n    else\n        prev_gn = glist_insert_ptr(prev_gn, (void *) new_entry);\n\n    /*\n     * Update the rc set of all the remaining entries in the list.  At this\n     * point, gn is the entry, if any, immediately following new entry.\n     */\n    while (gn) {\n        entry = (fsg_hist_entry_t *) gnode_ptr(gn);\n\n        if (FSG_PNODE_CTXT_SUB(&(entry->rc), &rc) == 0) {\n            /* rc set of entry reduced to 0; can prune this entry */\n            ckd_free((void *) entry);\n            gn = gnode_free(gn, prev_gn);\n        }\n        else {\n            prev_gn = gn;\n            gn = gnode_next(gn);\n        }\n    }\n}\n\n\n/*\n * Transfer the surviving history entries for this frame into the permanent\n * history table.\n */\nvoid\nfsg_history_end_frame(fsg_history_t * h)\n{\n    int32 s, lc, ns, np;\n    gnode_t *gn;\n    fsg_hist_entry_t *entry;\n\n    ns = fsg_model_n_state(h->fsg);\n    np = h->n_ciphone;\n\n    for (s = 0; s < ns; s++) {\n        for (lc = 0; lc < np; lc++) {\n            for (gn = h->frame_entries[s][lc]; gn; gn = gnode_next(gn)) {\n                entry = (fsg_hist_entry_t *) gnode_ptr(gn);\n                blkarray_list_append(h->entries, (void *) entry);\n            }\n\n            glist_free(h->frame_entries[s][lc]);\n            h->frame_entries[s][lc] = NULL;\n        }\n    }\n}\n\n\nfsg_hist_entry_t *\nfsg_history_entry_get(fsg_history_t * h, int32 id)\n{\n    return ((fsg_hist_entry_t *) blkarray_list_get(h->entries, id));\n}\n\n\nvoid\nfsg_history_reset(fsg_history_t * h)\n{\n    blkarray_list_reset(h->entries);\n}\n\n\nint32\nfsg_history_n_entries(fsg_history_t * h)\n{\n    return (blkarray_list_n_valid(h->entries));\n}\n\nvoid\nfsg_history_utt_start(fsg_history_t * h)\n{\n    int32 s, lc, ns, np;\n\n    assert(blkarray_list_n_valid(h->entries) == 0);\n    assert(h->frame_entries);\n\n    ns = fsg_model_n_state(h->fsg);\n    np = h->n_ciphone;\n\n    for (s = 0; s < ns; s++) {\n        for (lc = 0; lc < np; lc++) {\n            assert(h->frame_entries[s][lc] == NULL);\n        }\n    }\n}\n\nvoid\nfsg_history_utt_end(fsg_history_t * h)\n{\n}\n\nvoid\nfsg_history_print(fsg_history_t *h, dict_t *dict) \n{\n    int bpidx, bp;\n    \n    for (bpidx = 0; bpidx < blkarray_list_n_valid(h->entries); bpidx++) {\n        bp = bpidx;\n        printf(\"History entry: \");\n        while (bp > 0) {\n            fsg_hist_entry_t *hist_entry = fsg_history_entry_get(h, bp);\n\t    fsg_link_t *fl = fsg_hist_entry_fsglink(hist_entry);\n    \t    char const *baseword;\n    \t    int32 wid;\n    \t    bp = fsg_hist_entry_pred(hist_entry);\n    \t    wid = fsg_link_wid(fl);\n\n    \t    if (fl == NULL)\n        \t    continue;\n\n    \t    baseword = fsg_model_word_str(h->fsg, wid);\n\n    \t    printf(\"%s(%d->%d:%d) \", baseword, \n    \t\t\t\t     fsg_link_from_state(hist_entry->fsglink), \n    \t\t\t\t     fsg_link_to_state(hist_entry->fsglink), \n    \t\t\t\t     hist_entry->frame);\n\t}\n\tprintf(\"\\n\");\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2010 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/**\n * @file fsg_lextree.c\n * @brief The collection of all the lextrees for the entire FSM.\n * @author M K Ravishankar <rkm@cs.cmu.edu>\n * @author Bhiksha Raj <bhiksha@cs.cmu.edu>\n */\n\n/* System headers. */\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"fsg_lextree.h\"\n\n#define __FSG_DBG__\t\t0\n\n/* A linklist structure that is actually used to build local lextrees at grammar nodes */\ntypedef struct fsg_glist_linklist_t {\n    int32    ci, rc;\n    glist_t  glist;\n    struct   fsg_glist_linklist_t *next;\n} fsg_glist_linklist_t;\n\n/**\n * Build the phone lextree for all transitions out of state from_state.\n * Return the root node of this tree.\n * Also, return a linear linked list of all allocated fsg_pnode_t nodes in\n * *alloc_head (for memory management purposes).\n */\nstatic fsg_pnode_t *fsg_psubtree_init(fsg_lextree_t *tree,\n                                      fsg_model_t *fsg,\n                                      int32 from_state,\n                                      fsg_pnode_t **alloc_head);\n\n/**\n * Free the given lextree.  alloc_head: head of linear list of allocated\n * nodes updated by fsg_psubtree_init().\n */\nstatic void fsg_psubtree_free(fsg_pnode_t *alloc_head);\n\n/**\n * Dump the list of nodes in the given lextree to the given file.  alloc_head:\n * head of linear list of allocated nodes updated by fsg_psubtree_init().\n */\nstatic void fsg_psubtree_dump(fsg_lextree_t *tree, fsg_pnode_t *root, FILE *fp);\n\n/**\n * Compute the left and right context CIphone sets for each state.\n */\nstatic void\nfsg_lextree_lc_rc(fsg_lextree_t *lextree)\n{\n    int32 s, i, j;\n    int32 n_ci;\n    fsg_model_t *fsg;\n    int32 silcipid;\n    int32 len;\n\n    silcipid = bin_mdef_silphone(lextree->mdef);\n    assert(silcipid >= 0);\n    n_ci = bin_mdef_n_ciphone(lextree->mdef);\n\n    fsg = lextree->fsg;\n    /*\n     * lextree->lc[s] = set of left context CIphones for state s.  Similarly, rc[s]\n     * for right context CIphones.\n     */\n    lextree->lc = ckd_calloc_2d(fsg->n_state, n_ci + 1, sizeof(**lextree->lc));\n    lextree->rc = ckd_calloc_2d(fsg->n_state, n_ci + 1, sizeof(**lextree->rc));\n    E_INFO(\"Allocated %d bytes (%d KiB) for left and right context phones\\n\",\n           fsg->n_state * (n_ci + 1) * 2,\n           fsg->n_state * (n_ci + 1) * 2 / 1024);\n\n\n    for (s = 0; s < fsg->n_state; s++) {\n        fsg_arciter_t *itor;\n        for (itor = fsg_model_arcs(fsg, s); itor; itor = fsg_arciter_next(itor)) {\n            fsg_link_t *l = fsg_arciter_get(itor);\n            int32 dictwid; /**< Dictionary (not FSG) word ID!! */\n\n            if (fsg_link_wid(l) >= 0) {\n                dictwid = dict_wordid(lextree->dict,\n                                      fsg_model_word_str(lextree->fsg, l->wid));\n\n                /*\n                 * Add the first CIphone of l->wid to the rclist of state s, and\n                 * the last CIphone to lclist of state d.\n                 * (Filler phones are a pain to deal with.  There is no direct\n                 * marking of a filler phone; but only filler words are supposed to\n                 * use such phones, so we use that fact.  HACK!!  FRAGILE!!)\n                 *\n                 * UPD: tests carsh here if .fsg model used with wrong hmm and\n                 *      dictionary\n                 */\n                if (fsg_model_is_filler(fsg, fsg_link_wid(l))) {\n                    /* Filler phone; use silence phone as context */\n                    lextree->rc[fsg_link_from_state(l)][silcipid] = 1;\n                    lextree->lc[fsg_link_to_state(l)][silcipid] = 1;\n                }\n                else {\n                    len = dict_pronlen(lextree->dict, dictwid);\n                    lextree->rc[fsg_link_from_state(l)][dict_pron(lextree->dict, dictwid, 0)] = 1;\n                    lextree->lc[fsg_link_to_state(l)][dict_pron(lextree->dict, dictwid, len - 1)] = 1;\n                }\n            }\n        }\n    }\n\n    for (s = 0; s < fsg->n_state; s++) {\n        /*\n         * Add SIL phone to the lclist and rclist of each state.  Strictly\n         * speaking, only needed at start and final states, respectively, but\n         * all states considered since the user may change the start and final\n         * states.  In any case, most applications would have a silence self\n         * loop at each state, hence these would be needed anyway.\n         */\n        lextree->lc[s][silcipid] = 1;\n        lextree->rc[s][silcipid] = 1;\n    }\n\n    /*\n     * Propagate lc and rc lists past null transitions.  (Since FSG contains\n     * null transitions closure, no need to worry about a chain of successive\n     * null transitions.  Right??)\n     *\n     * This can't be joined with the previous loop because we first calculate \n     * contexts and only then we can propagate them.\n     */\n    for (s = 0; s < fsg->n_state; s++) {\n        fsg_arciter_t *itor;\n        for (itor = fsg_model_arcs(fsg, s); itor; itor = fsg_arciter_next(itor)) {\n            fsg_link_t *l = fsg_arciter_get(itor);\n            if (fsg_link_wid(l) < 0) {\n                /*\n                 * lclist(d) |= lclist(s), because all the words ending up at s, can\n                 * now also end at d, becoming the left context for words leaving d.\n                 */\n                for (i = 0; i < n_ci; i++)\n                    lextree->lc[fsg_link_to_state(l)][i] |= lextree->lc[fsg_link_from_state(l)][i];\n                /*\n                 * Similarly, rclist(s) |= rclist(d), because all the words leaving d\n                 * can equivalently leave s, becoming the right context for words\n                 * ending up at s.\n                 */\n                for (i = 0; i < n_ci; i++)\n                    lextree->rc[fsg_link_from_state(l)][i] |= lextree->rc[fsg_link_to_state(l)][i];\n            }\n        }\n    }\n\n    /* Convert the bit-vector representation into a list */\n    for (s = 0; s < fsg->n_state; s++) {\n        j = 0;\n        for (i = 0; i < n_ci; i++) {\n            if (lextree->lc[s][i]) {\n                lextree->lc[s][j] = i;\n                j++;\n            }\n        }\n        lextree->lc[s][j] = -1;     /* Terminate the list */\n\n        j = 0;\n        for (i = 0; i < n_ci; i++) {\n            if (lextree->rc[s][i]) {\n                lextree->rc[s][j] = i;\n                j++;\n            }\n        }\n        lextree->rc[s][j] = -1;     /* Terminate the list */\n    }\n}\n\n/*\n * For now, allocate the entire lextree statically.\n */\nfsg_lextree_t *\nfsg_lextree_init(fsg_model_t * fsg, dict_t *dict, dict2pid_t *d2p,\n                 bin_mdef_t *mdef, hmm_context_t *ctx,\n                 int32 wip, int32 pip)\n{\n    int32 s, n_leaves;\n    fsg_lextree_t *lextree;\n    fsg_pnode_t *pn;\n\n    lextree = ckd_calloc(1, sizeof(fsg_lextree_t));\n    lextree->fsg = fsg;\n    lextree->root = ckd_calloc(fsg_model_n_state(fsg),\n                               sizeof(fsg_pnode_t *));\n    lextree->alloc_head = ckd_calloc(fsg_model_n_state(fsg),\n                                     sizeof(fsg_pnode_t *));\n    lextree->ctx = ctx;\n    lextree->dict = dict;\n    lextree->d2p = d2p;\n    lextree->mdef = mdef;\n    lextree->wip = wip;\n    lextree->pip = pip;\n\n    /* Compute lc and rc for fsg. */\n    fsg_lextree_lc_rc(lextree);\n\n    /* Create lextree for each state, i.e. an HMM network that\n     * represents words for all arcs exiting that state.  Note that\n     * for a dense grammar such as an N-gram model, this will\n     * rapidly exhaust all available memory. */\n    lextree->n_pnode = 0;\n    n_leaves = 0;\n    for (s = 0; s < fsg_model_n_state(fsg); s++) {\n        lextree->root[s] =\n            fsg_psubtree_init(lextree, fsg, s, &(lextree->alloc_head[s]));\n\n        for (pn = lextree->alloc_head[s]; pn; pn = pn->alloc_next) {\n            lextree->n_pnode++;\n            if (pn->leaf)\n                ++n_leaves;\n        }\n    }\n    E_INFO(\"%d HMM nodes in lextree (%d leaves)\\n\",\n           lextree->n_pnode, n_leaves);\n    E_INFO(\"Allocated %d bytes (%d KiB) for all lextree nodes\\n\",\n           lextree->n_pnode * sizeof(fsg_pnode_t),\n           lextree->n_pnode * sizeof(fsg_pnode_t) / 1024);\n    E_INFO(\"Allocated %d bytes (%d KiB) for lextree leafnodes\\n\",\n           n_leaves * sizeof(fsg_pnode_t),\n           n_leaves * sizeof(fsg_pnode_t) / 1024);\n\n#if __FSG_DBG__\n    fsg_lextree_dump(lextree, stdout);\n#endif\n\n    return lextree;\n}\n\n\nvoid\nfsg_lextree_dump(fsg_lextree_t * lextree, FILE * fp)\n{\n    int32 s;\n\n    for (s = 0; s < fsg_model_n_state(lextree->fsg); s++) {\n        fprintf(fp, \"State %5d root %p\\n\", s, lextree->root[s]);\n        fsg_psubtree_dump(lextree, lextree->root[s], fp);\n    }\n    fflush(fp);\n}\n\n\nvoid\nfsg_lextree_free(fsg_lextree_t * lextree)\n{\n    int32 s;\n\n    if (lextree == NULL)\n        return;\n\n    if (lextree->fsg)\n        for (s = 0; s < fsg_model_n_state(lextree->fsg); s++)\n            fsg_psubtree_free(lextree->alloc_head[s]);\n\n    ckd_free_2d(lextree->lc);\n    ckd_free_2d(lextree->rc);\n    ckd_free(lextree->root);\n    ckd_free(lextree->alloc_head);\n    ckd_free(lextree);\n}\n\n/******************************\n * psubtree stuff starts here *\n ******************************/\n\nvoid fsg_glist_linklist_free(fsg_glist_linklist_t *glist)\n{\n    if (glist) {\n        fsg_glist_linklist_t *nxtglist;\n        if (glist->glist)\n            glist_free(glist->glist);\n        nxtglist = glist->next;\n        while (nxtglist) {\n            ckd_free(glist);\n            glist = nxtglist;\n            if (glist->glist)\n                glist_free(glist->glist);\n            nxtglist = glist->next;\n        }\n        ckd_free(glist);\n    }\n    return;\n}\n\nvoid\nfsg_pnode_add_all_ctxt(fsg_pnode_ctxt_t * ctxt)\n{\n    int32 i;\n\n    for (i = 0; i < FSG_PNODE_CTXT_BVSZ; i++)\n        ctxt->bv[i] = 0xffffffff;\n}\n\nuint32 fsg_pnode_ctxt_sub_generic(fsg_pnode_ctxt_t *src, fsg_pnode_ctxt_t *sub)\n{\n    int32 i;\n    uint32 res = 0;\n    \n    for (i = 0; i < FSG_PNODE_CTXT_BVSZ; i++)\n        res |= (src->bv[i] = ~(sub->bv[i]) & src->bv[i]);\n    return res;\n}\n\n\n/*\n * fsg_pnode_ctxt_sub(fsg_pnode_ctxt_t * src, fsg_pnode_ctxt_t * sub)\n * This has been moved into a macro in fsg_psubtree.h \n * because it is called so frequently!\n */\n\n\n/*\n * Add the word emitted by the given transition (fsglink) to the given lextree\n * (rooted at root), and return the new lextree root.  (There may actually be\n * several root nodes, maintained in a linked list via fsg_pnode_t.sibling.\n * \"root\" is the head of this list.)\n * lclist, rclist: sets of left and right context phones for this link.\n * alloc_head: head of a linear list of all allocated pnodes for the parent\n * FSG state, kept elsewhere and updated by this routine.\n */\nstatic fsg_pnode_t *\npsubtree_add_trans(fsg_lextree_t *lextree, \n                   fsg_pnode_t * root,\n                   fsg_glist_linklist_t **curglist,\n                   fsg_link_t * fsglink,\n                   int16 *lclist, int16 *rclist,\n                   fsg_pnode_t ** alloc_head)\n{\n    int32 silcipid;             /* Silence CI phone ID */\n    int32 pronlen;              /* Pronunciation length */\n    int32 wid;                  /* FSG (not dictionary!!) word ID */\n    int32 dictwid;              /* Dictionary (not FSG!!) word ID */\n    int32 ssid;                 /* Senone Sequence ID */\n    int32 tmatid;\n    gnode_t *gn;\n    fsg_pnode_t *pnode, *pred, *head;\n    int32 n_ci, p, lc, rc;\n    glist_t lc_pnodelist;       /* Temp pnodes list for different left contexts */\n    glist_t rc_pnodelist;       /* Temp pnodes list for different right contexts */\n    int32 i, j;\n    int n_lc_alloc = 0, n_int_alloc = 0, n_rc_alloc = 0;\n\n    silcipid = bin_mdef_silphone(lextree->mdef);\n    n_ci = bin_mdef_n_ciphone(lextree->mdef);\n\n    wid = fsg_link_wid(fsglink);\n    assert(wid >= 0);           /* Cannot be a null transition */\n    dictwid = dict_wordid(lextree->dict,\n                          fsg_model_word_str(lextree->fsg, wid));\n    pronlen = dict_pronlen(lextree->dict, dictwid);\n    assert(pronlen >= 1);\n\n    assert(lclist[0] >= 0);     /* At least one phonetic context provided */\n    assert(rclist[0] >= 0);\n\n    head = *alloc_head;\n    pred = NULL;\n\n    if (pronlen == 1) {         /* Single-phone word */\n        int ci = dict_first_phone(lextree->dict, dictwid);\n        /* Only non-filler words are mpx */\n        if (!dict_filler_word(lextree->dict, dictwid)) {\n            /*\n             * Left diphone ID for single-phone words already assumes SIL is right\n             * context; only left contexts need to be handled.\n             */\n            lc_pnodelist = NULL;\n\n            for (i = 0; lclist[i] >= 0; i++) {\n                lc = lclist[i];\n                ssid = dict2pid_lrdiph_rc(lextree->d2p, ci, lc, silcipid);\n                tmatid = bin_mdef_pid2tmatid(lextree->mdef, dict_first_phone(lextree->dict, dictwid));\n                /* Check if this ssid already allocated for some other context */\n                for (gn = lc_pnodelist; gn; gn = gnode_next(gn)) {\n                    pnode = (fsg_pnode_t *) gnode_ptr(gn);\n\n                    if (hmm_nonmpx_ssid(&pnode->hmm) == ssid) {\n                        /* already allocated; share it for this context phone */\n                        fsg_pnode_add_ctxt(pnode, lc);\n                        break;\n                    }\n                }\n\n                if (!gn) {      /* ssid not already allocated */\n                    pnode =\n                        (fsg_pnode_t *) ckd_calloc(1, sizeof(fsg_pnode_t));\n                    pnode->ctx = lextree->ctx;\n                    pnode->next.fsglink = fsglink;\n                    pnode->logs2prob =\n                        (fsg_link_logs2prob(fsglink) >> SENSCR_SHIFT)\n                        + lextree->wip + lextree->pip;\n                    pnode->ci_ext = dict_first_phone(lextree->dict, dictwid);\n                    pnode->ppos = 0;\n                    pnode->leaf = TRUE;\n                    pnode->sibling = root;      /* All root nodes linked together */\n                    fsg_pnode_add_ctxt(pnode, lc);      /* Initially zeroed by calloc above */\n                    pnode->alloc_next = head;\n                    head = pnode;\n                    root = pnode;\n                    ++n_lc_alloc;\n\n                    hmm_init(lextree->ctx, &pnode->hmm, FALSE, ssid, tmatid);\n\n                    lc_pnodelist =\n                        glist_add_ptr(lc_pnodelist, (void *) pnode);\n                }\n            }\n\n            glist_free(lc_pnodelist);\n        }\n        else {                  /* Filler word; no context modelled */\n            ssid = bin_mdef_pid2ssid(lextree->mdef, ci); /* probably the same... */\n            tmatid = bin_mdef_pid2tmatid(lextree->mdef, ci);\n\n            pnode = (fsg_pnode_t *) ckd_calloc(1, sizeof(fsg_pnode_t));\n            pnode->ctx = lextree->ctx;\n            pnode->next.fsglink = fsglink;\n            pnode->logs2prob = (fsg_link_logs2prob(fsglink) >> SENSCR_SHIFT)\n                + lextree->wip + lextree->pip;\n            pnode->ci_ext = silcipid;   /* Presents SIL as context to neighbors */\n            pnode->ppos = 0;\n            pnode->leaf = TRUE;\n            pnode->sibling = root;\n            fsg_pnode_add_all_ctxt(&(pnode->ctxt));\n            pnode->alloc_next = head;\n            head = pnode;\n            root = pnode;\n            ++n_int_alloc;\n\n            hmm_init(lextree->ctx, &pnode->hmm, FALSE, ssid, tmatid);\n        }\n    }\n    else {                      /* Multi-phone word */\n        fsg_pnode_t **ssid_pnode_map;       /* Temp array of ssid->pnode mapping */\n        ssid_pnode_map =\n            (fsg_pnode_t **) ckd_calloc(n_ci, sizeof(fsg_pnode_t *));\n        lc_pnodelist = NULL;\n        rc_pnodelist = NULL;\n\n        for (p = 0; p < pronlen; p++) {\n            int ci = dict_pron(lextree->dict, dictwid, p);\n            if (p == 0) {       /* Root phone, handle required left contexts */\n                /* Find if we already have an lc_pnodelist for the first phone of this word */\n\t\tfsg_glist_linklist_t *glist;\n\n                rc = dict_pron(lextree->dict, dictwid, 1);\n\t\tfor (glist = *curglist;\n                     glist && glist->glist;\n                     glist = glist->next) {\n\t\t    if (glist->ci == ci && glist->rc == rc)\n\t\t\tbreak;\n\t\t}\n\t\tif (glist && glist->glist) {\n\t\t    assert(glist->ci == ci && glist->rc == rc);\n\t\t    /* We've found a valid glist. Hook to it and move to next phoneme */\n                    E_DEBUG(\"Found match for (%d,%d)\\n\", ci, rc);\n\t\t    lc_pnodelist = glist->glist;\n                    /* Set the predecessor node for the future tree first */\n\t\t    pred = (fsg_pnode_t *) gnode_ptr(lc_pnodelist);\n\t\t    continue;\n\t\t}\n\t\telse {\n\t\t    /* Two cases that can bring us here\n\t\t     * a. glist == NULL, i.e. end of current list. Create new entry.\n\t\t     * b. glist->glist == NULL, i.e. first entry into list.\n\t\t     */\n\t\t    if (glist == NULL) { /* Case a; reduce it to case b by allocing glist */\n\t\t        glist = (fsg_glist_linklist_t*) ckd_calloc(1, sizeof(fsg_glist_linklist_t));\n\t\t\tglist->next = *curglist;\n                        *curglist = glist;\n\t\t    }\n\t\t    glist->ci = ci;\n                    glist->rc = rc;\n\t\t    lc_pnodelist = glist->glist = NULL; /* Gets created below */\n\t\t}\n\n                for (i = 0; lclist[i] >= 0; i++) {\n                    lc = lclist[i];\n                    ssid = dict2pid_ldiph_lc(lextree->d2p, ci, rc, lc);\n                    tmatid = bin_mdef_pid2tmatid(lextree->mdef, dict_first_phone(lextree->dict, dictwid));\n                    /* Compression is not done by d2p, so we do it\n                     * here.  This might be slow, but it might not\n                     * be... we'll see. */\n                    pnode = ssid_pnode_map[0];\n                    for (j = 0; j < n_ci && ssid_pnode_map[j] != NULL; ++j) {\n                        pnode = ssid_pnode_map[j];\n                        if (hmm_nonmpx_ssid(&pnode->hmm) == ssid)\n                            break;\n                    }\n                    assert(j < n_ci);\n                    if (!pnode) {       /* Allocate pnode for this new ssid */\n                        pnode =\n                            (fsg_pnode_t *) ckd_calloc(1,\n                                                       sizeof\n                                                       (fsg_pnode_t));\n                        pnode->ctx = lextree->ctx;\n\t                /* This bit is tricky! For now we'll put the prob in the final link only */\n                        /* pnode->logs2prob = (fsg_link_logs2prob(fsglink) >> SENSCR_SHIFT)\n                           + lextree->wip + lextree->pip; */\n                        pnode->logs2prob = lextree->wip + lextree->pip;\n                        pnode->ci_ext = dict_first_phone(lextree->dict, dictwid);\n                        pnode->ppos = 0;\n                        pnode->leaf = FALSE;\n                        pnode->sibling = root;  /* All root nodes linked together */\n                        pnode->alloc_next = head;\n                        head = pnode;\n                        root = pnode;\n                        ++n_lc_alloc;\n\n                        hmm_init(lextree->ctx, &pnode->hmm, FALSE, ssid, tmatid);\n\n                        lc_pnodelist =\n                            glist_add_ptr(lc_pnodelist, (void *) pnode);\n                        ssid_pnode_map[j] = pnode;\n                    }\n                    fsg_pnode_add_ctxt(pnode, lc);\n                }\n\t\t/* Put the lc_pnodelist back into glist */\n\t\tglist->glist = lc_pnodelist;\n\n                /* The predecessor node for the future tree is the root */\n\t\tpred = root;\n            }\n            else if (p != pronlen - 1) {        /* Word internal phone */\n                fsg_pnode_t    *pnodeyoungest;\n\n                ssid = dict2pid_internal(lextree->d2p, dictwid, p);\n                tmatid = bin_mdef_pid2tmatid(lextree->mdef, dict_pron (lextree->dict, dictwid, p));\n\t        /* First check if we already have this ssid in our tree */\n\t\tpnode = pred->next.succ;\n\t\tpnodeyoungest = pnode; /* The youngest sibling */\n\t\twhile (pnode && (hmm_nonmpx_ssid(&pnode->hmm) != ssid || pnode->leaf)) {\n\t\t    pnode = pnode->sibling;\n\t\t}\n\t\tif (pnode && (hmm_nonmpx_ssid(&pnode->hmm) == ssid && !pnode->leaf)) {\n\t\t    /* Found the ssid; go to next phoneme */\n                    E_DEBUG(\"Found match for %d\\n\", ci);\n\t\t    pred = pnode;\n\t\t    continue;\n\t\t}\n\n\t\t/* pnode not found, allocate it */\n                pnode = (fsg_pnode_t *) ckd_calloc(1, sizeof(fsg_pnode_t));\n                pnode->ctx = lextree->ctx;\n                pnode->logs2prob = lextree->pip;\n                pnode->ci_ext = dict_pron(lextree->dict, dictwid, p);\n                pnode->ppos = p;\n                pnode->leaf = FALSE;\n                pnode->sibling = pnodeyoungest; /* May be NULL */\n                if (p == 1) {   /* Predecessor = set of root nodes for left ctxts */\n                    for (gn = lc_pnodelist; gn; gn = gnode_next(gn)) {\n                        pred = (fsg_pnode_t *) gnode_ptr(gn);\n                        pred->next.succ = pnode;\n                    }\n                }\n                else {          /* Predecessor = word internal node */\n                    pred->next.succ = pnode;\n                }\n                pnode->alloc_next = head;\n                head = pnode;\n                ++n_int_alloc;\n\n                hmm_init(lextree->ctx, &pnode->hmm, FALSE, ssid, tmatid);\n\n                pred = pnode;\n            }\n            else {              /* Leaf phone, handle required right contexts */\n\t        /* Note, leaf phones are not part of the tree */\n                xwdssid_t *rssid;\n                memset((void *) ssid_pnode_map, 0,\n                       n_ci * sizeof(fsg_pnode_t *));\n                lc = dict_pron(lextree->dict, dictwid, p-1);\n                rssid = dict2pid_rssid(lextree->d2p, ci, lc);\n                tmatid = bin_mdef_pid2tmatid(lextree->mdef, dict_pron (lextree->dict, dictwid, p));\n\n                for (i = 0; rclist[i] >= 0; i++) {\n                    rc = rclist[i];\n\n                    j = rssid->cimap[rc];\n                    ssid = rssid->ssid[j];\n                    pnode = ssid_pnode_map[j];\n\n                    if (!pnode) {       /* Allocate pnode for this new ssid */\n                        pnode =\n                            (fsg_pnode_t *) ckd_calloc(1,\n                                                       sizeof\n                                                       (fsg_pnode_t));\n                        pnode->ctx = lextree->ctx;\n\t\t\t/* We are plugging the word prob here. Ugly */\n                        /* pnode->logs2prob = lextree->pip; */\n                        pnode->logs2prob = (fsg_link_logs2prob(fsglink) >> SENSCR_SHIFT)\n                            + lextree->pip;\n                        pnode->ci_ext = dict_pron(lextree->dict, dictwid, p);\n                        pnode->ppos = p;\n                        pnode->leaf = TRUE;\n                        pnode->sibling = rc_pnodelist ?\n                            (fsg_pnode_t *) gnode_ptr(rc_pnodelist) : NULL;\n                        pnode->next.fsglink = fsglink;\n                        pnode->alloc_next = head;\n                        head = pnode;\n                        ++n_rc_alloc;\n\n                        hmm_init(lextree->ctx, &pnode->hmm, FALSE, ssid, tmatid);\n\n                        rc_pnodelist =\n                            glist_add_ptr(rc_pnodelist, (void *) pnode);\n                        ssid_pnode_map[j] = pnode;\n                    }\n                    else {\n                        assert(hmm_nonmpx_ssid(&pnode->hmm) == ssid);\n                    }\n                    fsg_pnode_add_ctxt(pnode, rc);\n                }\n\n                if (p == 1) {   /* Predecessor = set of root nodes for left ctxts */\n                    for (gn = lc_pnodelist; gn; gn = gnode_next(gn)) {\n                        pred = (fsg_pnode_t *) gnode_ptr(gn);\n                        if (!pred->next.succ)\n                            pred->next.succ = (fsg_pnode_t *) gnode_ptr(rc_pnodelist);\n                        else {\n                            /* Link to the end of the sibling chain */\n                            fsg_pnode_t *succ = pred->next.succ;\n                            while (succ->sibling) succ = succ->sibling;\n                            succ->sibling = (fsg_pnode_t*) gnode_ptr(rc_pnodelist);\n                            /* Since all entries of lc_pnodelist point\n                               to the same array, sufficient to update it once */\n                            break; \n                        }\n                    }\n                }\n                else {          /* Predecessor = word internal node */\n                    if (!pred->next.succ)\n                        pred->next.succ = (fsg_pnode_t *) gnode_ptr(rc_pnodelist);\n                    else {\n                        /* Link to the end of the sibling chain */\n                        fsg_pnode_t *succ = pred->next.succ;\n                        while (succ->sibling) succ = succ->sibling;\n                        succ->sibling = (fsg_pnode_t *) gnode_ptr(rc_pnodelist);\n                    }\n                }\n            }\n        }\n\n        ckd_free((void *) ssid_pnode_map);\n        /* glist_free(lc_pnodelist);  Nope; this gets freed outside */\n        glist_free(rc_pnodelist);\n    }\n\n    E_DEBUG(\"Allocated %d HMMs (%d lc, %d rc, %d internal)\\n\",\n            n_lc_alloc + n_rc_alloc + n_int_alloc,\n            n_lc_alloc, n_rc_alloc, n_int_alloc);\n    *alloc_head = head;\n\n    return root;\n}\n\n\nstatic fsg_pnode_t *\nfsg_psubtree_init(fsg_lextree_t *lextree,\n                  fsg_model_t * fsg, int32 from_state,\n                  fsg_pnode_t ** alloc_head)\n{\n    fsg_arciter_t *itor;\n    fsg_link_t *fsglink;\n    fsg_pnode_t *root;\n    int32 n_ci, n_arc;\n    fsg_glist_linklist_t *glist = NULL;\n\n    root = NULL;\n    assert(*alloc_head == NULL);\n\n    n_ci = bin_mdef_n_ciphone(lextree->mdef);\n    if (n_ci > (FSG_PNODE_CTXT_BVSZ * 32)) {\n        E_FATAL\n            (\"#phones > %d; increase FSG_PNODE_CTXT_BVSZ and recompile\\n\",\n             FSG_PNODE_CTXT_BVSZ * 32);\n    }\n\n    n_arc = 0;\n    for (itor = fsg_model_arcs(fsg, from_state); itor; \n         itor = fsg_arciter_next(itor)) {\n        int32 dst;\n        fsglink = fsg_arciter_get(itor);\n        dst = fsglink->to_state;\n\n        if (fsg_link_wid(fsglink) < 0)\n            continue;\n\n        E_DEBUG(\"Building lextree for arc from %d to %d: %s\\n\",\n                from_state, dst, fsg_model_word_str(fsg, fsg_link_wid(fsglink)));\n        root = psubtree_add_trans(lextree, root, &glist, fsglink,\n                                  lextree->lc[from_state],\n                                  lextree->rc[dst],\n                                  alloc_head);\n        ++n_arc;\n    }\n    E_DEBUG(\"State %d has %d outgoing arcs\\n\", from_state, n_arc);\n\n    fsg_glist_linklist_free(glist);\n\n    return root;\n}\n\n\nstatic void\nfsg_psubtree_free(fsg_pnode_t * head)\n{\n    fsg_pnode_t *next;\n\n    while (head) {\n        next = head->alloc_next;\n        hmm_deinit(&head->hmm);\n        ckd_free(head);\n        head = next;\n    }\n}\n\nvoid fsg_psubtree_dump_node(fsg_lextree_t *tree, fsg_pnode_t *node, FILE *fp)\n{    \n    int32 i;\n    fsg_link_t *tl;\n\n    /* Indentation */\n    for (i = 0; i <= node->ppos; i++)\n        fprintf(fp, \"  \");\n\n    fprintf(fp, \"%p.@\", node);    /* Pointer used as node\n                    \t\t   * ID */\n    fprintf(fp, \" %5d.SS\", hmm_nonmpx_ssid(&node->hmm));\n    fprintf(fp, \" %10d.LP\", node->logs2prob);\n    fprintf(fp, \" %p.SIB\", node->sibling);\n    fprintf(fp, \" %s.%d\", bin_mdef_ciphone_str(tree->mdef, node->ci_ext), node->ppos);\n    if ((node->ppos == 0) || node->leaf) {\n        fprintf(fp, \" [\");\n        for (i = 0; i < FSG_PNODE_CTXT_BVSZ; i++)\n            fprintf(fp, \"%08x\", node->ctxt.bv[i]);\n        fprintf(fp, \"]\");\n    }\n    if (node->leaf) {\n        tl = node->next.fsglink;\n        fprintf(fp, \" {%s[%d->%d](%d)}\",\n                fsg_model_word_str(tree->fsg, tl->wid),\n                tl->from_state, tl->to_state, tl->logs2prob);\n    } else {\n        fprintf(fp, \" %p.NXT\", node->next.succ);\n    }\n    fprintf(fp, \"\\n\");\n\n    return;\n}\n\nvoid \nfsg_psubtree_dump(fsg_lextree_t *tree, fsg_pnode_t *root, FILE * fp)\n{\n    fsg_pnode_t *succ;\n\n    if (root == NULL) return;\n    if (root->ppos == 0) {\n        while(root->sibling && root->sibling->next.succ == root->next.succ) {\n            fsg_psubtree_dump_node(tree, root, fp);\n            root = root->sibling;\n        }\n        fflush(fp);\n    }\n    \n    fsg_psubtree_dump_node(tree, root, fp);\n\n    if (root->leaf) {\n        if (root->ppos == 0 && root->sibling) { /* For single-phone words */\n            fsg_psubtree_dump(tree, root->sibling,fp);\n        }\n        return;\n    }\n\n    succ = root->next.succ;\n    while(succ) {\n        fsg_psubtree_dump(tree, succ,fp);\n        succ = succ->sibling;\n    }\n\n    if (root->ppos == 0) {\n        fsg_psubtree_dump(tree, root->sibling,fp);\n        fflush(fp);\n    }\n\n    return;\n}\n\nvoid\nfsg_psubtree_pnode_deactivate(fsg_pnode_t * pnode)\n{\n    hmm_clear(&pnode->hmm);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n * fsg_search.c -- Search structures for FSM decoding.\n * \n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 2004 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n *\n * 18-Feb-2004\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tStarted.\n */\n\n/* System headers. */\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/cmd_ln.h>\n\n/* Local headers. */\n#include \"pocketsphinx_internal.h\"\n#include \"ps_lattice_internal.h\"\n#include \"fsg_search_internal.h\"\n#include \"fsg_history.h\"\n#include \"fsg_lextree.h\"\n\n/* Turn this on for detailed debugging dump */\n#define __FSG_DBG__\t\t0\n#define __FSG_DBG_CHAN__\t0\n\nstatic ps_seg_t *fsg_search_seg_iter(ps_search_t *search);\nstatic ps_lattice_t *fsg_search_lattice(ps_search_t *search);\nstatic int fsg_search_prob(ps_search_t *search);\n\nstatic ps_searchfuncs_t fsg_funcs = {\n    /* start: */  fsg_search_start,\n    /* step: */   fsg_search_step,\n    /* finish: */ fsg_search_finish,\n    /* reinit: */ fsg_search_reinit,\n    /* free: */   fsg_search_free,\n    /* lattice: */  fsg_search_lattice,\n    /* hyp: */      fsg_search_hyp,\n    /* prob: */     fsg_search_prob,\n    /* seg_iter: */ fsg_search_seg_iter,\n};\n\nstatic int\nfsg_search_add_silences(fsg_search_t *fsgs, fsg_model_t *fsg)\n{\n    dict_t *dict;\n    int32 wid;\n    int n_sil;\n\n    dict = ps_search_dict(fsgs);\n    /*\n     * NOTE: Unlike N-Gram search, we do not use explicit start and\n     * end symbols.  This is because the start and end nodes are\n     * defined in the grammar.  We do add silence/filler self-loops to\n     * all states in order to allow for silence between words and at\n     * the beginning and end of utterances.\n     *\n     * This has some implications for word graph generation, namely,\n     * that there can (and usually will) be multiple start and end\n     * states in the word graph.  We therefore do add explicit start\n     * and end nodes to the graph.\n     */\n    /* Add silence self-loops to all states. */\n    fsg_model_add_silence(fsg, \"<sil>\", -1,\n                          cmd_ln_float32_r(ps_search_config(fsgs), \"-silprob\"));\n    n_sil = 0;\n    /* Add self-loops for all other fillers. */\n    for (wid = dict_filler_start(dict); wid < dict_filler_end(dict); ++wid) {\n        char const *word = dict_wordstr(dict, wid);\n        if (wid == dict_startwid(dict) || wid == dict_finishwid(dict))\n            continue;\n        fsg_model_add_silence(fsg, word, -1,\n                              cmd_ln_float32_r(ps_search_config(fsgs), \"-fillprob\"));\n        ++n_sil;\n    }\n\n    return n_sil;\n}\n\n/* Scans the dictionary and check if all words are present. */\nstatic int\nfsg_search_check_dict(fsg_search_t *fsgs, fsg_model_t *fsg)\n{\n    dict_t *dict;\n    int i;\n\n    dict = ps_search_dict(fsgs);\n    for (i = 0; i < fsg_model_n_word(fsg); ++i) {\n        char const *word;\n        int32 wid;\n\n        word = fsg_model_word_str(fsg, i);\n        wid = dict_wordid(dict, word);\n        if (wid == BAD_S3WID) {\n    \t    E_ERROR(\"The word '%s' is missing in the dictionary\\n\", word);\n    \t    return FALSE;\n    \t}\n    }\n\n    return TRUE;\n}\n\nstatic int\nfsg_search_add_altpron(fsg_search_t *fsgs, fsg_model_t *fsg)\n{\n    dict_t *dict;\n    int n_alt, n_word;\n    int i;\n\n    dict = ps_search_dict(fsgs);\n    /* Scan FSG's vocabulary for words that have alternate pronunciations. */\n    n_alt = 0;\n    n_word = fsg_model_n_word(fsg);\n    for (i = 0; i < n_word; ++i) {\n        char const *word;\n        int32 wid;\n\n        word = fsg_model_word_str(fsg, i);\n        wid = dict_wordid(dict, word);\n        if (wid != BAD_S3WID) {\n            while ((wid = dict_nextalt(dict, wid)) != BAD_S3WID) {\n\t        n_alt += fsg_model_add_alt(fsg, word, dict_wordstr(dict, wid));\n    \t    }\n    \t}\n    }\n\n    E_INFO(\"Added %d alternate word transitions\\n\", n_alt);\n    return n_alt;\n}\n\nps_search_t *\nfsg_search_init(const char *name,\n\t\tfsg_model_t *fsg,\n                cmd_ln_t *config,\n                acmod_t *acmod,\n                dict_t *dict,\n                dict2pid_t *d2p)\n{\n    fsg_search_t *fsgs = ckd_calloc(1, sizeof(*fsgs));\n    ps_search_init(ps_search_base(fsgs), &fsg_funcs, PS_SEARCH_TYPE_FSG, name, config, acmod, dict, d2p);\n\n    fsgs->fsg = fsg_model_retain(fsg);\n    /* Initialize HMM context. */\n    fsgs->hmmctx = hmm_context_init(bin_mdef_n_emit_state(acmod->mdef),\n                                    acmod->tmat->tp, NULL, acmod->mdef->sseq);\n    if (fsgs->hmmctx == NULL) {\n        ps_search_free(ps_search_base(fsgs));\n        return NULL;\n    }\n\n    /* Intialize the search history object */\n    fsgs->history = fsg_history_init(NULL, dict);\n    fsgs->frame = -1;\n\n    /* Get search pruning parameters */\n    fsgs->beam_factor = 1.0f;\n    fsgs->beam = fsgs->beam_orig\n        = (int32) logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-beam\"))\n        >> SENSCR_SHIFT;\n    fsgs->pbeam = fsgs->pbeam_orig\n        = (int32) logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-pbeam\"))\n        >> SENSCR_SHIFT;\n    fsgs->wbeam = fsgs->wbeam_orig\n        = (int32) logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-wbeam\"))\n        >> SENSCR_SHIFT;\n\n    /* LM related weights/penalties */\n    fsgs->lw = cmd_ln_float32_r(config, \"-lw\");\n    fsgs->pip = (int32) (logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-pip\"))\n                           * fsgs->lw)\n        >> SENSCR_SHIFT;\n    fsgs->wip = (int32) (logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-wip\"))\n                           * fsgs->lw)\n        >> SENSCR_SHIFT;\n\n    /* Acoustic score scale for posterior probabilities. */\n    fsgs->ascale = 1.0 / cmd_ln_float32_r(config, \"-ascale\");\n\n    E_INFO(\"FSG(beam: %d, pbeam: %d, wbeam: %d; wip: %d, pip: %d)\\n\",\n           fsgs->beam_orig, fsgs->pbeam_orig, fsgs->wbeam_orig,\n           fsgs->wip, fsgs->pip);\n\n    if (!fsg_search_check_dict(fsgs, fsg)) {\n        fsg_search_free(ps_search_base(fsgs));\n        return NULL;\n    }\n\n    if (cmd_ln_boolean_r(config, \"-fsgusefiller\") &&\n        !fsg_model_has_sil(fsg))\n        fsg_search_add_silences(fsgs, fsg);\n\n    if (cmd_ln_boolean_r(config, \"-fsgusealtpron\") &&\n        !fsg_model_has_alt(fsg))\n        fsg_search_add_altpron(fsgs, fsg);\n\n    if (fsg_search_reinit(ps_search_base(fsgs),\n                          ps_search_dict(fsgs),\n                          ps_search_dict2pid(fsgs)) < 0)\n    {\n        ps_search_free(ps_search_base(fsgs));\n        return NULL;\n    \n    }\n    ptmr_init(&fsgs->perf);\n        \n    return ps_search_base(fsgs);\n}\n\nvoid\nfsg_search_free(ps_search_t *search)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n\n    double n_speech = (double)fsgs->n_tot_frame\n            / cmd_ln_int32_r(ps_search_config(fsgs), \"-frate\");\n\n    E_INFO(\"TOTAL fsg %.2f CPU %.3f xRT\\n\",\n           fsgs->perf.t_tot_cpu,\n           fsgs->perf.t_tot_cpu / n_speech);\n    E_INFO(\"TOTAL fsg %.2f wall %.3f xRT\\n\",\n           fsgs->perf.t_tot_elapsed,\n           fsgs->perf.t_tot_elapsed / n_speech);\n\n    ps_search_base_free(search);\n    fsg_lextree_free(fsgs->lextree);\n    if (fsgs->history) {\n        fsg_history_reset(fsgs->history);\n        fsg_history_set_fsg(fsgs->history, NULL, NULL);\n        fsg_history_free(fsgs->history);\n    }\n    hmm_context_free(fsgs->hmmctx);\n    fsg_model_free(fsgs->fsg);\n    ckd_free(fsgs);\n}\n\nint\nfsg_search_reinit(ps_search_t *search, dict_t *dict, dict2pid_t *d2p)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n\n    /* Free the old lextree */\n    if (fsgs->lextree)\n        fsg_lextree_free(fsgs->lextree);\n\n    /* Free old dict2pid, dict */\n    ps_search_base_reinit(search, dict, d2p);\n    \n    /* Update the number of words (not used by this module though). */\n    search->n_words = dict_size(dict);\n\n    /* Allocate new lextree for the given FSG */\n    fsgs->lextree = fsg_lextree_init(fsgs->fsg, dict, d2p,\n                                     ps_search_acmod(fsgs)->mdef,\n                                     fsgs->hmmctx, fsgs->wip, fsgs->pip);\n\n    /* Inform the history module of the new fsg */\n    fsg_history_set_fsg(fsgs->history, fsgs->fsg, dict);\n\n    return 0;\n}\n\n\nstatic void\nfsg_search_sen_active(fsg_search_t *fsgs)\n{\n    gnode_t *gn;\n    fsg_pnode_t *pnode;\n    hmm_t *hmm;\n\n    acmod_clear_active(ps_search_acmod(fsgs));\n\n    for (gn = fsgs->pnode_active; gn; gn = gnode_next(gn)) {\n        pnode = (fsg_pnode_t *) gnode_ptr(gn);\n        hmm = fsg_pnode_hmmptr(pnode);\n        assert(hmm_frame(hmm) == fsgs->frame);\n        acmod_activate_hmm(ps_search_acmod(fsgs), hmm);\n    }\n}\n\n\n/*\n * Evaluate all the active HMMs.\n * (Executed once per frame.)\n */\nstatic void\nfsg_search_hmm_eval(fsg_search_t *fsgs)\n{\n    gnode_t *gn;\n    fsg_pnode_t *pnode;\n    hmm_t *hmm;\n    int32 bestscore;\n    int32 n, maxhmmpf;\n\n    bestscore = WORST_SCORE;\n\n    if (!fsgs->pnode_active) {\n        E_ERROR(\"Frame %d: No active HMM!!\\n\", fsgs->frame);\n        return;\n    }\n\n    for (n = 0, gn = fsgs->pnode_active; gn; gn = gnode_next(gn), n++) {\n        int32 score;\n\n        pnode = (fsg_pnode_t *) gnode_ptr(gn);\n        hmm = fsg_pnode_hmmptr(pnode);\n        assert(hmm_frame(hmm) == fsgs->frame);\n\n#if __FSG_DBG__\n        E_INFO(\"pnode(%08x) active @frm %5d\\n\", (int32) pnode,\n               fsgs->frame);\n        hmm_dump(hmm, stdout);\n#endif\n        score = hmm_vit_eval(hmm);\n#if __FSG_DBG_CHAN__\n        E_INFO(\"pnode(%08x) after eval @frm %5d\\n\",\n               (int32) pnode, fsgs->frame);\n        hmm_dump(hmm, stdout);\n#endif\n\n        if (score BETTER_THAN bestscore)\n            bestscore = score;\n    }\n\n#if __FSG_DBG__\n    E_INFO(\"[%5d] %6d HMM; bestscr: %11d\\n\", fsgs->frame, n, bestscore);\n#endif\n    fsgs->n_hmm_eval += n;\n\n    /* Adjust beams if #active HMMs larger than absolute threshold */\n    maxhmmpf = cmd_ln_int32_r(ps_search_config(fsgs), \"-maxhmmpf\");\n    if (maxhmmpf != -1 && n > maxhmmpf) {\n        /*\n         * Too many HMMs active; reduce the beam factor applied to the default\n         * beams, but not if the factor is already at a floor (0.1).\n         */\n        if (fsgs->beam_factor > 0.1) {        /* Hack!!  Hardwired constant 0.1 */\n            fsgs->beam_factor *= 0.9f;        /* Hack!!  Hardwired constant 0.9 */\n            fsgs->beam =\n                (int32) (fsgs->beam_orig * fsgs->beam_factor);\n            fsgs->pbeam =\n                (int32) (fsgs->pbeam_orig * fsgs->beam_factor);\n            fsgs->wbeam =\n                (int32) (fsgs->wbeam_orig * fsgs->beam_factor);\n        }\n    }\n    else {\n        fsgs->beam_factor = 1.0f;\n        fsgs->beam = fsgs->beam_orig;\n        fsgs->pbeam = fsgs->pbeam_orig;\n        fsgs->wbeam = fsgs->wbeam_orig;\n    }\n\n    if (n > fsg_lextree_n_pnode(fsgs->lextree))\n        E_FATAL(\"PANIC! Frame %d: #HMM evaluated(%d) > #PNodes(%d)\\n\",\n                fsgs->frame, n, fsg_lextree_n_pnode(fsgs->lextree));\n\n    fsgs->bestscore = bestscore;\n}\n\n\nstatic void\nfsg_search_pnode_trans(fsg_search_t *fsgs, fsg_pnode_t * pnode)\n{\n    fsg_pnode_t *child;\n    hmm_t *hmm;\n    int32 newscore, thresh, nf;\n\n    assert(pnode);\n    assert(!fsg_pnode_leaf(pnode));\n\n    nf = fsgs->frame + 1;\n    thresh = fsgs->bestscore + fsgs->beam;\n\n    hmm = fsg_pnode_hmmptr(pnode);\n\n    for (child = fsg_pnode_succ(pnode);\n         child; child = fsg_pnode_sibling(child)) {\n        newscore = hmm_out_score(hmm) + child->logs2prob;\n\n        if ((newscore BETTER_THAN thresh)\n            && (newscore BETTER_THAN hmm_in_score(&child->hmm))) {\n            /* Incoming score > pruning threshold and > target's existing score */\n            if (hmm_frame(&child->hmm) < nf) {\n                /* Child node not yet activated; do so */\n                fsgs->pnode_active_next =\n                    glist_add_ptr(fsgs->pnode_active_next,\n                                  (void *) child);\n            }\n\n            hmm_enter(&child->hmm, newscore, hmm_out_history(hmm), nf);\n        }\n    }\n}\n\n\nstatic void\nfsg_search_pnode_exit(fsg_search_t *fsgs, fsg_pnode_t * pnode)\n{\n    hmm_t *hmm;\n    fsg_link_t *fl;\n    int32 wid;\n    fsg_pnode_ctxt_t ctxt;\n\n    assert(pnode);\n    assert(fsg_pnode_leaf(pnode));\n\n    hmm = fsg_pnode_hmmptr(pnode);\n    fl = fsg_pnode_fsglink(pnode);\n    assert(fl);\n\n    wid = fsg_link_wid(fl);\n    assert(wid >= 0);\n\n#if __FSG_DBG__\n    E_INFO(\"[%5d] Exit(%08x) %10d(score) %5d(pred)\\n\",\n           fsgs->frame, (int32) pnode,\n           hmm_out_score(hmm), hmm_out_history(hmm));\n#endif\n\n    /*\n     * Check if this is filler or single phone word; these do not model right\n     * context (i.e., the exit score applies to all right contexts).\n     */\n    if (fsg_model_is_filler(fsgs->fsg, wid)\n        /* FIXME: This might be slow due to repeated calls to dict_to_id(). */\n        || (dict_is_single_phone(ps_search_dict(fsgs),\n                                   dict_wordid(ps_search_dict(fsgs),\n                                               fsg_model_word_str(fsgs->fsg, wid))))) {\n        /* Create a dummy context structure that applies to all right contexts */\n        fsg_pnode_add_all_ctxt(&ctxt);\n\n        /* Create history table entry for this word exit */\n        fsg_history_entry_add(fsgs->history,\n                              fl,\n                              fsgs->frame,\n                              hmm_out_score(hmm),\n                              hmm_out_history(hmm),\n                              pnode->ci_ext, ctxt);\n\n    }\n    else {\n        /* Create history table entry for this word exit */\n        fsg_history_entry_add(fsgs->history,\n                              fl,\n                              fsgs->frame,\n                              hmm_out_score(hmm),\n                              hmm_out_history(hmm),\n                              pnode->ci_ext, pnode->ctxt);\n    }\n}\n\n\n/*\n * (Beam) prune the just evaluated HMMs, determine which ones remain\n * active, which ones transition to successors, which ones exit and\n * terminate in their respective destination FSM states.\n * (Executed once per frame.)\n */\nstatic void\nfsg_search_hmm_prune_prop(fsg_search_t *fsgs)\n{\n    gnode_t *gn;\n    fsg_pnode_t *pnode;\n    hmm_t *hmm;\n    int32 thresh, word_thresh, phone_thresh;\n\n    assert(fsgs->pnode_active_next == NULL);\n\n    thresh = fsgs->bestscore + fsgs->beam;\n    phone_thresh = fsgs->bestscore + fsgs->pbeam;\n    word_thresh = fsgs->bestscore + fsgs->wbeam;\n\n    for (gn = fsgs->pnode_active; gn; gn = gnode_next(gn)) {\n        pnode = (fsg_pnode_t *) gnode_ptr(gn);\n        hmm = fsg_pnode_hmmptr(pnode);\n\n        if (hmm_bestscore(hmm) >= thresh) {\n            /* Keep this HMM active in the next frame */\n            if (hmm_frame(hmm) == fsgs->frame) {\n                hmm_frame(hmm) = fsgs->frame + 1;\n                fsgs->pnode_active_next =\n                    glist_add_ptr(fsgs->pnode_active_next,\n                                  (void *) pnode);\n            }\n            else {\n                assert(hmm_frame(hmm) == fsgs->frame + 1);\n            }\n\n            if (!fsg_pnode_leaf(pnode)) {\n                if (hmm_out_score(hmm) >= phone_thresh) {\n                    /* Transition out of this phone into its children */\n                    fsg_search_pnode_trans(fsgs, pnode);\n                }\n            }\n            else {\n                if (hmm_out_score(hmm) >= word_thresh) {\n                    /* Transition out of leaf node into destination FSG state */\n                    fsg_search_pnode_exit(fsgs, pnode);\n                }\n            }\n        }\n    }\n}\n\n\n/*\n * Propagate newly created history entries through null transitions.\n */\nstatic void\nfsg_search_null_prop(fsg_search_t *fsgs)\n{\n    int32 bpidx, n_entries, thresh, newscore;\n    fsg_hist_entry_t *hist_entry;\n    fsg_link_t *l;\n    int32 s;\n    fsg_model_t *fsg;\n\n    fsg = fsgs->fsg;\n    thresh = fsgs->bestscore + fsgs->wbeam; /* Which beam really?? */\n\n    n_entries = fsg_history_n_entries(fsgs->history);\n\n    for (bpidx = fsgs->bpidx_start; bpidx < n_entries; bpidx++) {\n        fsg_arciter_t *itor;\n        hist_entry = fsg_history_entry_get(fsgs->history, bpidx);\n\n        l = fsg_hist_entry_fsglink(hist_entry);\n\n        /* Destination FSG state for history entry */\n        s = l ? fsg_link_to_state(l) : fsg_model_start_state(fsg);\n\n        /*\n         * Check null transitions from d to all other states.  (Only need to\n         * propagate one step, since FSG contains transitive closure of null\n         * transitions.)\n         */\n        /* Add all links from from_state to dst */\n        for (itor = fsg_model_arcs(fsg, s); itor;\n             itor = fsg_arciter_next(itor)) {\n            fsg_link_t *l = fsg_arciter_get(itor);\n\n            /* FIXME: Need to deal with tag transitions somehow. */\n            if (fsg_link_wid(l) != -1)\n                continue;\n            newscore =\n                fsg_hist_entry_score(hist_entry) +\n                (fsg_link_logs2prob(l) >> SENSCR_SHIFT);\n\n            if (newscore >= thresh) {\n                fsg_history_entry_add(fsgs->history, l,\n                                      fsg_hist_entry_frame(hist_entry),\n                                      newscore,\n                                      bpidx,\n                                      fsg_hist_entry_lc(hist_entry),\n                                      fsg_hist_entry_rc(hist_entry));\n            }\n        }\n    }\n}\n\n\n/*\n * Perform cross-word transitions; propagate each history entry created in this\n * frame to lextree roots attached to the target FSG state for that entry.\n */\nstatic void\nfsg_search_word_trans(fsg_search_t *fsgs)\n{\n    int32 bpidx, n_entries;\n    fsg_hist_entry_t *hist_entry;\n    fsg_link_t *l;\n    int32 score, newscore, thresh, nf, d;\n    fsg_pnode_t *root;\n    int32 lc, rc;\n\n    n_entries = fsg_history_n_entries(fsgs->history);\n\n    thresh = fsgs->bestscore + fsgs->beam;\n    nf = fsgs->frame + 1;\n\n    for (bpidx = fsgs->bpidx_start; bpidx < n_entries; bpidx++) {\n        hist_entry = fsg_history_entry_get(fsgs->history, bpidx);\n        assert(hist_entry);\n        score = fsg_hist_entry_score(hist_entry);\n        assert(fsgs->frame == fsg_hist_entry_frame(hist_entry));\n\n        l = fsg_hist_entry_fsglink(hist_entry);\n\n        /* Destination state for hist_entry */\n        d = l ? fsg_link_to_state(l) : fsg_model_start_state(fsgs->\n                                                                fsg);\n\n        lc = fsg_hist_entry_lc(hist_entry);\n\n        /* Transition to all root nodes attached to state d */\n        for (root = fsg_lextree_root(fsgs->lextree, d);\n             root; root = root->sibling) {\n            rc = root->ci_ext;\n\n            if ((root->ctxt.bv[lc >> 5] & (1 << (lc & 0x001f))) &&\n                (hist_entry->rc.bv[rc >> 5] & (1 << (rc & 0x001f)))) {\n                /*\n                 * Last CIphone of history entry is in left-context list supported by\n                 * target root node, and\n                 * first CIphone of target root node is in right context list supported\n                 * by history entry;\n                 * So the transition can go ahead (if new score is good enough).\n                 */\n                newscore = score + root->logs2prob;\n\n                if ((newscore BETTER_THAN thresh)\n                    && (newscore BETTER_THAN hmm_in_score(&root->hmm))) {\n                    if (hmm_frame(&root->hmm) < nf) {\n                        /* Newly activated node; add to active list */\n                        fsgs->pnode_active_next =\n                            glist_add_ptr(fsgs->pnode_active_next,\n                                          (void *) root);\n#if __FSG_DBG__\n                        E_INFO\n                            (\"[%5d] WordTrans bpidx[%d] -> pnode[%08x] (activated)\\n\",\n                             fsgs->frame, bpidx, (int32) root);\n#endif\n                    }\n                    else {\n#if __FSG_DBG__\n                        E_INFO\n                            (\"[%5d] WordTrans bpidx[%d] -> pnode[%08x]\\n\",\n                             fsgs->frame, bpidx, (int32) root);\n#endif\n                    }\n\n                    hmm_enter(&root->hmm, newscore, bpidx, nf);\n                }\n            }\n        }\n    }\n}\n\n\nint\nfsg_search_step(ps_search_t *search, int frame_idx)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n    int16 const *senscr;\n    acmod_t *acmod = search->acmod;\n    gnode_t *gn;\n    fsg_pnode_t *pnode;\n    hmm_t *hmm;\n\n    /* Activate our HMMs for the current frame if need be. */\n    if (!acmod->compallsen)\n        fsg_search_sen_active(fsgs);\n    /* Compute GMM scores for the current frame. */\n    senscr = acmod_score(acmod, &frame_idx);\n    fsgs->n_sen_eval += acmod->n_senone_active;\n    hmm_context_set_senscore(fsgs->hmmctx, senscr);\n\n    /* Mark backpointer table for current frame. */\n    fsgs->bpidx_start = fsg_history_n_entries(fsgs->history);\n\n    /* Evaluate all active pnodes (HMMs) */\n    fsg_search_hmm_eval(fsgs);\n\n    /*\n     * Prune and propagate the HMMs evaluated; create history entries for\n     * word exits.  The words exits are tentative, and may be pruned; make\n     * the survivors permanent via fsg_history_end_frame().\n     */\n    fsg_search_hmm_prune_prop(fsgs);\n    fsg_history_end_frame(fsgs->history);\n\n    /*\n     * Propagate new history entries through any null transitions, creating\n     * new history entries, and then make the survivors permanent.\n     */\n    fsg_search_null_prop(fsgs);\n    fsg_history_end_frame(fsgs->history);\n\n    /*\n     * Perform cross-word transitions; propagate each history entry across its\n     * terminating state to the root nodes of the lextree attached to the state.\n     */\n    fsg_search_word_trans(fsgs);\n\n    /*\n     * We've now come full circle, HMM and FSG states have been updated for\n     * the next frame.\n     * Update the active lists, deactivate any currently active HMMs that\n     * did not survive into the next frame\n     */\n    for (gn = fsgs->pnode_active; gn; gn = gnode_next(gn)) {\n        pnode = (fsg_pnode_t *) gnode_ptr(gn);\n        hmm = fsg_pnode_hmmptr(pnode);\n\n        if (hmm_frame(hmm) == fsgs->frame) {\n            /* This HMM NOT activated for the next frame; reset it */\n            fsg_psubtree_pnode_deactivate(pnode);\n        }\n        else {\n            assert(hmm_frame(hmm) == (fsgs->frame + 1));\n        }\n    }\n\n    /* Free the currently active list */\n    glist_free(fsgs->pnode_active);\n\n    /* Make the next-frame active list the current one */\n    fsgs->pnode_active = fsgs->pnode_active_next;\n    fsgs->pnode_active_next = NULL;\n\n    /* End of this frame; ready for the next */\n    ++fsgs->frame;\n\n    return 1;\n}\n\n\n/*\n * Set all HMMs to inactive, clear active lists, initialize FSM start\n * state to be the only active node.\n * (Executed at the start of each utterance.)\n */\nint\nfsg_search_start(ps_search_t *search)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n    int32 silcipid;\n    fsg_pnode_ctxt_t ctxt;\n\n    /* Reset dynamic adjustment factor for beams */\n    fsgs->beam_factor = 1.0f;\n    fsgs->beam = fsgs->beam_orig;\n    fsgs->pbeam = fsgs->pbeam_orig;\n    fsgs->wbeam = fsgs->wbeam_orig;\n\n    silcipid = bin_mdef_ciphone_id(ps_search_acmod(fsgs)->mdef, \"SIL\");\n\n    /* Initialize EVERYTHING to be inactive */\n    assert(fsgs->pnode_active == NULL);\n    assert(fsgs->pnode_active_next == NULL);\n\n    fsg_history_reset(fsgs->history);\n    fsg_history_utt_start(fsgs->history);\n    fsgs->final = FALSE;\n\n    /* Dummy context structure that allows all right contexts to use this entry */\n    fsg_pnode_add_all_ctxt(&ctxt);\n\n    /* Create dummy history entry leading to start state */\n    fsgs->frame = -1;\n    fsgs->bestscore = 0;\n    fsg_history_entry_add(fsgs->history,\n                          NULL, -1, 0, -1, silcipid, ctxt);\n    fsgs->bpidx_start = 0;\n\n    /* Propagate dummy history entry through NULL transitions from start state */\n    fsg_search_null_prop(fsgs);\n\n    /* Perform word transitions from this dummy history entry */\n    fsg_search_word_trans(fsgs);\n\n    /* Make the next-frame active list the current one */\n    fsgs->pnode_active = fsgs->pnode_active_next;\n    fsgs->pnode_active_next = NULL;\n\n    ++fsgs->frame;\n\n    fsgs->n_hmm_eval = 0;\n    fsgs->n_sen_eval = 0;\n\n    ptmr_reset(&fsgs->perf);\n    ptmr_start(&fsgs->perf);\n\n    return 0;\n}\n\n/*\n * Cleanup at the end of each utterance.\n */\nint\nfsg_search_finish(ps_search_t *search)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n    gnode_t *gn;\n    fsg_pnode_t *pnode;\n    int32 n_hist, cf;\n\n    /* Deactivate all nodes in the current and next-frame active lists */\n    for (gn = fsgs->pnode_active; gn; gn = gnode_next(gn)) {\n        pnode = (fsg_pnode_t *) gnode_ptr(gn);\n        fsg_psubtree_pnode_deactivate(pnode);\n    }\n    for (gn = fsgs->pnode_active_next; gn; gn = gnode_next(gn)) {\n        pnode = (fsg_pnode_t *) gnode_ptr(gn);\n        fsg_psubtree_pnode_deactivate(pnode);\n    }\n\n    glist_free(fsgs->pnode_active);\n    fsgs->pnode_active = NULL;\n    glist_free(fsgs->pnode_active_next);\n    fsgs->pnode_active_next = NULL;\n\n    fsgs->final = TRUE;\n\n    n_hist = fsg_history_n_entries(fsgs->history);\n    fsgs->n_tot_frame += fsgs->frame;\n    E_INFO\n        (\"%d frames, %d HMMs (%d/fr), %d senones (%d/fr), %d history entries (%d/fr)\\n\\n\",\n         fsgs->frame, fsgs->n_hmm_eval,\n         (fsgs->frame > 0) ? fsgs->n_hmm_eval / fsgs->frame : 0,\n         fsgs->n_sen_eval,\n         (fsgs->frame > 0) ? fsgs->n_sen_eval / fsgs->frame : 0,\n         n_hist, (fsgs->frame > 0) ? n_hist / fsgs->frame : 0);\n\n    /* Print out some statistics. */\n    ptmr_stop(&fsgs->perf);\n    /* This is the number of frames processed. */\n    cf = ps_search_acmod(fsgs)->output_frame;\n    if (cf > 0) {\n        double n_speech = (double) (cf + 1)\n            / cmd_ln_int32_r(ps_search_config(fsgs), \"-frate\");\n        E_INFO(\"fsg %.2f CPU %.3f xRT\\n\",\n               fsgs->perf.t_cpu, fsgs->perf.t_cpu / n_speech);\n        E_INFO(\"fsg %.2f wall %.3f xRT\\n\",\n               fsgs->perf.t_elapsed, fsgs->perf.t_elapsed / n_speech);\n    }\n\n\n    return 0;\n}\n\nstatic int\nfsg_search_find_exit(fsg_search_t *fsgs, int frame_idx, int final, int32 *out_score)\n{\n    fsg_hist_entry_t *hist_entry = NULL;\n    fsg_model_t *fsg;\n    int bpidx, frm, last_frm, besthist;\n    int32 bestscore;\n\n    if (frame_idx == -1)\n        frame_idx = fsgs->frame - 1;\n    last_frm = frm = frame_idx;\n\n    /* Scan backwards to find a word exit in frame_idx. */\n    bpidx = fsg_history_n_entries(fsgs->history) - 1;\n    while (bpidx > 0) {\n        hist_entry = fsg_history_entry_get(fsgs->history, bpidx);\n        if (fsg_hist_entry_frame(hist_entry) <= frame_idx) {\n            frm = last_frm = fsg_hist_entry_frame(hist_entry);\n            break;\n        }\n        bpidx--;\n    }\n\n    /* No hypothesis (yet). */\n    if (bpidx <= 0)\n        return bpidx;\n\n    /* Now find best word exit in this frame. */\n    bestscore = INT_MIN;\n    besthist = -1;\n    fsg = fsgs->fsg;\n    while (frm == last_frm) {\n        fsg_link_t *fl;\n        int32 score;\n\n        fl = fsg_hist_entry_fsglink(hist_entry);\n        score = fsg_hist_entry_score(hist_entry);\n        \n        if (fl == NULL)\n\t    break;\n\n\t/* Prefer final hypothesis */\n\tif (score == bestscore && fsg_link_to_state(fl) == fsg_model_final_state(fsg)) {\n    \t    besthist = bpidx;\n\t} else if (score BETTER_THAN bestscore) {\n            /* Only enforce the final state constraint if this is a final hypothesis. */\n            if ((!final)\n                || fsg_link_to_state(fl) == fsg_model_final_state(fsg)) {\n                bestscore = score;\n                besthist = bpidx;\n            }\n        }\n        \n        --bpidx;\n        if (bpidx < 0)\n            break;\n        hist_entry = fsg_history_entry_get(fsgs->history, bpidx);\n        frm = fsg_hist_entry_frame(hist_entry);\n    }\n\n    /* Final state not reached. */\n    if (besthist == -1) {\n        E_ERROR(\"Final result does not match the grammar in frame %d\\n\", frame_idx);\n        return -1;\n    }\n\n    /* This here's the one we want. */\n    if (out_score)\n        *out_score = bestscore;\n\n    return besthist;\n}\n\n/* FIXME: Mostly duplicated with ngram_search_bestpath(). */\nstatic ps_latlink_t *\nfsg_search_bestpath(ps_search_t *search, int32 *out_score, int backward)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n\n    if (search->last_link == NULL) {\n        search->last_link = ps_lattice_bestpath(search->dag, NULL,\n                                                1.0, fsgs->ascale);\n        if (search->last_link == NULL)\n            return NULL;\n        /* Also calculate betas so we can fill in the posterior\n         * probability field in the segmentation. */\n        if (search->post == 0)\n            search->post = ps_lattice_posterior(search->dag, NULL, fsgs->ascale);\n    }\n    if (out_score)\n        *out_score = search->last_link->path_scr + search->dag->final_node_ascr;\n    return search->last_link;\n}\n\nchar const *\nfsg_search_hyp(ps_search_t *search, int32 *out_score)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n    dict_t *dict = ps_search_dict(search);\n    char *c;\n    size_t len;\n    int bp, bpidx;\n\n    /* Get last backpointer table index. */\n    bpidx = fsg_search_find_exit(fsgs, fsgs->frame, fsgs->final, out_score);\n    /* No hypothesis (yet). */\n    if (bpidx <= 0) {\n        return NULL;\n    }\n\n    /* If bestpath is enabled and the utterance is complete, then run it. */\n    if (fsgs->bestpath && fsgs->final) {\n        ps_lattice_t *dag;\n        ps_latlink_t *link;\n\n        if ((dag = fsg_search_lattice(search)) == NULL) {\n    \t    E_WARN(\"Failed to obtain the lattice while bestpath enabled\\n\");\n            return NULL;\n        }\n        if ((link = fsg_search_bestpath(search, out_score, FALSE)) == NULL) {\n    \t    E_WARN(\"Failed to find the bestpath in a lattice\\n\");\n            return NULL;\n        }\n        return ps_lattice_hyp(dag, link);\n    }\n\n    bp = bpidx;\n    len = 0;\n    while (bp > 0) {\n        fsg_hist_entry_t *hist_entry = fsg_history_entry_get(fsgs->history, bp);\n        fsg_link_t *fl = fsg_hist_entry_fsglink(hist_entry);\n        char const *baseword;\n        int32 wid;\n\n        bp = fsg_hist_entry_pred(hist_entry);\n        wid = fsg_link_wid(fl);\n        if (wid < 0 || fsg_model_is_filler(fsgs->fsg, wid))\n            continue;\n        baseword = dict_basestr(dict,\n                                dict_wordid(dict,\n                                            fsg_model_word_str(fsgs->fsg, wid)));\n        len += strlen(baseword) + 1;\n    }\n    \n    ckd_free(search->hyp_str);\n    if (len == 0) {\n\tsearch->hyp_str = NULL;\n\treturn search->hyp_str;\n    }\n    search->hyp_str = ckd_calloc(1, len);\n\n    bp = bpidx;\n    c = search->hyp_str + len - 1;\n    while (bp > 0) {\n        fsg_hist_entry_t *hist_entry = fsg_history_entry_get(fsgs->history, bp);\n        fsg_link_t *fl = fsg_hist_entry_fsglink(hist_entry);\n        char const *baseword;\n        int32 wid;\n\n        bp = fsg_hist_entry_pred(hist_entry);\n        wid = fsg_link_wid(fl);\n        if (wid < 0 || fsg_model_is_filler(fsgs->fsg, wid))\n            continue;\n        baseword = dict_basestr(dict,\n                                dict_wordid(dict,\n                                            fsg_model_word_str(fsgs->fsg, wid)));\n        len = strlen(baseword);\n        c -= len;\n        memcpy(c, baseword, len);\n        if (c > search->hyp_str) {\n            --c;\n            *c = ' ';\n        }\n    }\n\n    return search->hyp_str;\n}\n\nstatic void\nfsg_seg_bp2itor(ps_seg_t *seg, fsg_hist_entry_t *hist_entry)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)seg->search;\n    fsg_hist_entry_t *ph = NULL;\n    int32 bp;\n\n    if ((bp = fsg_hist_entry_pred(hist_entry)) >= 0)\n        ph = fsg_history_entry_get(fsgs->history, bp);\n    seg->word = fsg_model_word_str(fsgs->fsg, hist_entry->fsglink->wid);\n    seg->ef = fsg_hist_entry_frame(hist_entry);\n    seg->sf = ph ? fsg_hist_entry_frame(ph) + 1 : 0;\n    /* This is kind of silly but it happens for null transitions. */\n    if (seg->sf > seg->ef) seg->sf = seg->ef;\n    seg->prob = 0; /* Bogus value... */\n    /* \"Language model\" score = transition probability. */\n    seg->lback = 1;\n    seg->lscr = fsg_link_logs2prob(hist_entry->fsglink) >> SENSCR_SHIFT;\n    if (ph) {\n        /* FIXME: Not sure exactly how cross-word triphones are handled. */\n        seg->ascr = hist_entry->score - ph->score - seg->lscr;\n    }\n    else\n        seg->ascr = hist_entry->score - seg->lscr;\n}\n\n\nstatic void\nfsg_seg_free(ps_seg_t *seg)\n{\n    fsg_seg_t *itor = (fsg_seg_t *)seg;\n    ckd_free(itor->hist);\n    ckd_free(itor);\n}\n\nstatic ps_seg_t *\nfsg_seg_next(ps_seg_t *seg)\n{\n    fsg_seg_t *itor = (fsg_seg_t *)seg;\n\n    if (++itor->cur == itor->n_hist) {\n        fsg_seg_free(seg);\n        return NULL;\n    }\n\n    fsg_seg_bp2itor(seg, itor->hist[itor->cur]);\n    return seg;\n}\n\nstatic ps_segfuncs_t fsg_segfuncs = {\n    /* seg_next */ fsg_seg_next,\n    /* seg_free */ fsg_seg_free\n};\n\nstatic ps_seg_t *\nfsg_search_seg_iter(ps_search_t *search)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n    fsg_seg_t *itor;\n    int32 out_score;\n    int bp, bpidx, cur;\n\n    bpidx = fsg_search_find_exit(fsgs, fsgs->frame, fsgs->final, &out_score);\n    /* No hypothesis (yet). */\n    if (bpidx <= 0)\n        return NULL;\n\n    /* If bestpath is enabled and the utterance is complete, then run it. */\n    if (fsgs->bestpath && fsgs->final) {\n        ps_lattice_t *dag;\n        ps_latlink_t *link;\n\n        if ((dag = fsg_search_lattice(search)) == NULL)\n            return NULL;\n        if ((link = fsg_search_bestpath(search, &out_score, TRUE)) == NULL)\n            return NULL;\n        return ps_lattice_seg_iter(dag, link, 1.0);\n    }\n\n    /* Calling this an \"iterator\" is a bit of a misnomer since we have\n     * to get the entire backtrace in order to produce it.  On the\n     * other hand, all we actually need is the bptbl IDs, and we can\n     * allocate a fixed-size array of them. */\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->base.vt = &fsg_segfuncs;\n    itor->base.search = search;\n    itor->base.lwf = 1.0;\n    itor->n_hist = 0;\n    bp = bpidx;\n    while (bp > 0) {\n        fsg_hist_entry_t *hist_entry = fsg_history_entry_get(fsgs->history, bp);\n        bp = fsg_hist_entry_pred(hist_entry);\n        ++itor->n_hist;\n    }\n    if (itor->n_hist == 0) {\n        ckd_free(itor);\n        return NULL;\n    }\n    itor->hist = ckd_calloc(itor->n_hist, sizeof(*itor->hist));\n    cur = itor->n_hist - 1;\n    bp = bpidx;\n    while (bp > 0) {\n        fsg_hist_entry_t *hist_entry = fsg_history_entry_get(fsgs->history, bp);\n        itor->hist[cur] = hist_entry;\n        bp = fsg_hist_entry_pred(hist_entry);\n        --cur;\n    }\n\n    /* Fill in relevant fields for first element. */\n    fsg_seg_bp2itor((ps_seg_t *)itor, itor->hist[0]);\n    \n    return (ps_seg_t *)itor;\n}\n\nstatic int\nfsg_search_prob(ps_search_t *search)\n{\n    fsg_search_t *fsgs = (fsg_search_t *)search;\n\n    /* If bestpath is enabled and the utterance is complete, then run it. */\n    if (fsgs->bestpath && fsgs->final) {\n        ps_lattice_t *dag;\n        ps_latlink_t *link;\n\n        if ((dag = fsg_search_lattice(search)) == NULL)\n            return 0;\n        if ((link = fsg_search_bestpath(search, NULL, TRUE)) == NULL)\n            return 0;\n        return search->post;\n    }\n    else {\n        /* FIXME: Give some kind of good estimate here, eventually. */\n        return 0;\n    }\n}\n\nstatic ps_latnode_t *\nfind_node(ps_lattice_t *dag, fsg_model_t *fsg, int sf, int32 wid, int32 node_id)\n{\n    ps_latnode_t *node;\n\n    for (node = dag->nodes; node; node = node->next)\n        if ((node->sf == sf) && (node->wid == wid) && (node->node_id == node_id))\n            break;\n    return node;\n}\n\nstatic ps_latnode_t *\nnew_node(ps_lattice_t *dag, fsg_model_t *fsg, int sf, int ef, int32 wid, int32 node_id, int32 ascr)\n{\n    ps_latnode_t *node;\n\n    node = find_node(dag, fsg, sf, wid, node_id);\n\n    if (node) {\n        /* Update end frames. */\n        if (node->lef == -1 || node->lef < ef)\n            node->lef = ef;\n        if (node->fef == -1 || node->fef > ef)\n            node->fef = ef;\n        /* Update best link score. */\n        if (ascr BETTER_THAN node->info.best_exit)\n            node->info.best_exit = ascr;\n    }\n    else {\n        /* New node; link to head of list */\n        node = listelem_malloc(dag->latnode_alloc);\n        node->wid = wid;\n        node->sf = sf;\n        node->fef = node->lef = ef;\n        node->reachable = FALSE;\n        node->entries = NULL;\n        node->exits = NULL;\n        node->info.best_exit = ascr;\n        node->node_id = node_id;\n\n        node->next = dag->nodes;\n        dag->nodes = node;\n        ++dag->n_nodes;\n    }\n\n    return node;\n}\n\nstatic ps_latnode_t *\nfind_start_node(fsg_search_t *fsgs, ps_lattice_t *dag)\n{\n    ps_latnode_t *node;\n    glist_t start = NULL;\n    int nstart = 0;\n\n    /* Look for all nodes starting in frame zero with some exits. */\n    for (node = dag->nodes; node; node = node->next) {\n        if (node->sf == 0 && node->exits) {\n            E_INFO(\"Start node %s.%d:%d:%d\\n\",\n                   fsg_model_word_str(fsgs->fsg, node->wid),\n                   node->sf, node->fef, node->lef);\n            start = glist_add_ptr(start, node);\n            ++nstart;\n        }\n    }\n\n    /* If there was more than one start node candidate, then we need\n     * to create an artificial start node with epsilon transitions to\n     * all of them. */\n    if (nstart == 1) {\n        node = gnode_ptr(start);\n    }\n    else {\n        gnode_t *st;\n        int wid;\n\n        wid = fsg_model_word_add(fsgs->fsg, \"<s>\");\n        if (fsgs->fsg->silwords)\n            bitvec_set(fsgs->fsg->silwords, wid);\n        node = new_node(dag, fsgs->fsg, 0, 0, wid, -1, 0);\n        for (st = start; st; st = gnode_next(st))\n            ps_lattice_link(dag, node, gnode_ptr(st), 0, 0);\n    }\n    glist_free(start);\n    return node;\n}\n\nstatic ps_latnode_t *\nfind_end_node(fsg_search_t *fsgs, ps_lattice_t *dag)\n{\n    ps_latnode_t *node;\n    glist_t end = NULL;\n    int nend = 0;\n\n    /* Look for all nodes ending in last frame with some entries. */\n    for (node = dag->nodes; node; node = node->next) {\n        if (node->lef == dag->n_frames - 1 && node->entries) {\n            E_INFO(\"End node %s.%d:%d:%d (%d)\\n\",\n                   fsg_model_word_str(fsgs->fsg, node->wid),\n                   node->sf, node->fef, node->lef, node->info.best_exit);\n            end = glist_add_ptr(end, node);\n            ++nend;\n        }\n    }\n\n    if (nend == 1) {\n        node = gnode_ptr(end);\n    }\n    else if (nend == 0) {\n        ps_latnode_t *last = NULL;\n        int ef = 0;\n\n        /* If there were no end node candidates, then just use the\n         * node with the last exit frame. */\n        for (node = dag->nodes; node; node = node->next) {\n            if (node->lef > ef && node->entries) {\n                last = node;\n                ef = node->lef;\n            }\n        }\n        node = last;\n        if (node)\n            E_INFO(\"End node %s.%d:%d:%d (%d)\\n\",\n                   fsg_model_word_str(fsgs->fsg, node->wid),\n                   node->sf, node->fef, node->lef, node->info.best_exit);\n    }    \n    else {\n        /* If there was more than one end node candidate, then we need\n         * to create an artificial end node with epsilon transitions\n         * out of all of them. */\n        gnode_t *st;\n        int wid;\n        wid = fsg_model_word_add(fsgs->fsg, \"</s>\");\n        if (fsgs->fsg->silwords)\n            bitvec_set(fsgs->fsg->silwords, wid);\n        node = new_node(dag, fsgs->fsg, fsgs->frame, fsgs->frame, wid, -1, 0);\n        /* Use the \"best\" (in reality it will be the only) exit link\n         * score from this final node as the link score. */\n        for (st = end; st; st = gnode_next(st)) {\n            ps_latnode_t *src = gnode_ptr(st);\n            ps_lattice_link(dag, src, node, src->info.best_exit, fsgs->frame);\n        }\n    }\n    glist_free(end);\n    return node;\n}\n\nstatic void\nmark_reachable(ps_lattice_t *dag, ps_latnode_t *end)\n{\n    glist_t q;\n\n    /* It doesn't matter which order we do this in. */\n    end->reachable = TRUE;\n    q = glist_add_ptr(NULL, end);\n    while (q) {\n        ps_latnode_t *node = gnode_ptr(q);\n        latlink_list_t *x;\n\n        /* Pop the front of the list. */\n        q = gnode_free(q, NULL);\n        /* Expand all its predecessors that haven't been seen yet. */\n        for (x = node->entries; x; x = x->next) {\n            ps_latnode_t *next = x->link->from;\n            if (!next->reachable) {\n                next->reachable = TRUE;\n                q = glist_add_ptr(q, next);\n            }\n        }\n    }\n}\n\n/**\n * Generate a lattice from FSG search results.\n *\n * One might think that this is simply a matter of adding acoustic\n * scores to the FSG's edges.  However, one would be wrong.  The\n * crucial difference here is that the word lattice is acyclic, and it\n * also contains timing information.\n */\nstatic ps_lattice_t *\nfsg_search_lattice(ps_search_t *search)\n{\n    fsg_search_t *fsgs;\n    fsg_model_t *fsg;\n    ps_latnode_t *node;\n    ps_lattice_t *dag;\n    int32 i, n;\n\n    fsgs = (fsg_search_t *)search;\n\n    /* Check to see if a lattice has previously been created over the\n     * same number of frames, and reuse it if so. */\n    if (search->dag && search->dag->n_frames == fsgs->frame)\n        return search->dag;\n\n    /* Nope, create a new one. */\n    ps_lattice_free(search->dag);\n    search->dag = NULL;\n    dag = ps_lattice_init_search(search, fsgs->frame);\n    fsg = fsgs->fsg;\n\n    /*\n     * Each history table entry represents a link in the word graph.\n     * The set of nodes is determined by the number of unique\n     * (word,start-frame) pairs in the history table.  So we will\n     * first find all those nodes.\n     */\n    n = fsg_history_n_entries(fsgs->history);\n    for (i = 0; i < n; ++i) {\n        fsg_hist_entry_t *fh = fsg_history_entry_get(fsgs->history, i);\n        int32 ascr;\n        int sf;\n\n        /* Skip null transitions. */\n        if (fh->fsglink == NULL || fh->fsglink->wid == -1)\n            continue;\n\n        /* Find the start node of this link. */\n        if (fh->pred) {\n            fsg_hist_entry_t *pfh = fsg_history_entry_get(fsgs->history, fh->pred);\n            /* FIXME: We include the transition score in the lattice\n             * link score.  This is because of the practical\n             * difficulty of obtaining it separately in bestpath or\n             * forward-backward search, and because it is essentially\n             * a unigram probability, so there is no need to treat it\n             * separately from the acoustic score.  However, it's not\n             * clear that this will actually yield correct results.*/\n            ascr = fh->score - pfh->score;\n            sf = pfh->frame + 1;\n        }\n        else {\n            ascr = fh->score;\n            sf = 0;\n        }\n\n        /*\n         * Note that although scores are tied to links rather than\n         * nodes, it's possible that there are no links out of the\n         * destination node, and thus we need to preserve its score in\n         * case it turns out to be utterance-final.\n         */\n        new_node(dag, fsg, sf, fh->frame, fh->fsglink->wid, fsg_link_to_state(fh->fsglink), ascr);\n    }\n\n    /*\n     * Now, we will create links only to nodes that actually exist.\n     */\n    n = fsg_history_n_entries(fsgs->history);\n    for (i = 0; i < n; ++i) {\n        fsg_hist_entry_t *fh = fsg_history_entry_get(fsgs->history, i);\n        fsg_arciter_t *itor;\n        ps_latnode_t *src, *dest;\n        int32 ascr;\n        int sf;\n\n        /* Skip null transitions. */\n        if (fh->fsglink == NULL || fh->fsglink->wid == -1)\n            continue;\n\n        /* Find the start node of this link and calculate its link score. */\n        if (fh->pred) {\n            fsg_hist_entry_t *pfh = fsg_history_entry_get(fsgs->history, fh->pred);\n            sf = pfh->frame + 1;\n            ascr = fh->score - pfh->score;\n        }\n        else {\n            ascr = fh->score;\n            sf = 0;\n        }\n        src = find_node(dag, fsg, sf, fh->fsglink->wid, fsg_link_to_state(fh->fsglink));\n        sf = fh->frame + 1;\n\n        for (itor = fsg_model_arcs(fsg, fsg_link_to_state(fh->fsglink));\n             itor; itor = fsg_arciter_next(itor)) {\n            fsg_link_t *link = fsg_arciter_get(itor);\n            \n            /* FIXME: Need to figure out what to do about tag transitions. */\n            if (link->wid >= 0) {\n                /*\n                 * For each non-epsilon link following this one, look for a\n                 * matching node in the lattice and link to it.\n                 */\n                if ((dest = find_node(dag, fsg, sf, link->wid, fsg_link_to_state(link))) != NULL)\n            \t    ps_lattice_link(dag, src, dest, ascr, fh->frame);\n            }\n            else {\n                /*\n                 * Transitive closure on nulls has already been done, so we\n                 * just need to look one link forward from them.\n                 */\n                fsg_arciter_t *itor2;\n                \n                /* Add all non-null links out of j. */\n                for (itor2 = fsg_model_arcs(fsg, fsg_link_to_state(link));\n                     itor2; itor2 = fsg_arciter_next(itor2)) {\n                    fsg_link_t *link = fsg_arciter_get(itor2);\n\n                    if (link->wid == -1)\n                        continue;\n                    \n                    if ((dest = find_node(dag, fsg, sf, link->wid, fsg_link_to_state(link))) != NULL) {\n                        ps_lattice_link(dag, src, dest, ascr, fh->frame);\n                    }\n                }\n            }\n        }\n    }\n\n\n    /* Figure out which nodes are the start and end nodes. */\n    if ((dag->start = find_start_node(fsgs, dag)) == NULL) {\n\tE_WARN(\"Failed to find the start node\\n\");\n        goto error_out;\n    }\n    if ((dag->end = find_end_node(fsgs, dag)) == NULL) {\n\tE_WARN(\"Failed to find the end node\\n\");\n        goto error_out;\n    }\n\n\n    E_INFO(\"lattice start node %s.%d end node %s.%d\\n\",\n           fsg_model_word_str(fsg, dag->start->wid), dag->start->sf,\n           fsg_model_word_str(fsg, dag->end->wid), dag->end->sf);\n    /* FIXME: Need to calculate final_node_ascr here. */\n\n    /*\n     * Convert word IDs from FSG to dictionary.\n     */\n    for (node = dag->nodes; node; node = node->next) {\n        node->wid = dict_wordid(dag->search->dict,\n                                fsg_model_word_str(fsg, node->wid));\n        node->basewid = dict_basewid(dag->search->dict, node->wid);\n    }\n\n    /*\n     * Now we are done, because the links in the graph are uniquely\n     * defined by the history table.  However we should remove any\n     * nodes which are not reachable from the end node of the FSG.\n     * Everything is reachable from the start node by definition.\n     */\n    mark_reachable(dag, dag->end);\n\n    ps_lattice_delete_unreachable(dag);\n    {\n        int32 silpen, fillpen;\n\n        silpen = (int32)(logmath_log(fsg->lmath,\n                                     cmd_ln_float32_r(ps_search_config(fsgs), \"-silprob\"))\n                         * fsg->lw)\n            >> SENSCR_SHIFT;\n        fillpen = (int32)(logmath_log(fsg->lmath,\n                                      cmd_ln_float32_r(ps_search_config(fsgs), \"-fillprob\"))\n                          * fsg->lw)\n            >> SENSCR_SHIFT;\n\t\n\tps_lattice_penalize_fillers(dag, silpen, fillpen);\n    }\n    search->dag = dag;\n\n    return dag;\n\n\nerror_out:\n    ps_lattice_free(dag);\n    return NULL;\n\n}\n\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file hmm.h Implementation of HMM base structure.\n */\n\n/* System headers. */\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"hmm.h\"\n\nhmm_context_t *\nhmm_context_init(int32 n_emit_state,\n\t\t uint8 ** const *tp,\n\t\t int16 const *senscore,\n\t\t uint16 * const *sseq)\n{\n    hmm_context_t *ctx;\n\n    assert(n_emit_state > 0);\n    if (n_emit_state > HMM_MAX_NSTATE) {\n        E_ERROR(\"Number of emitting states must be <= %d\\n\", HMM_MAX_NSTATE);\n        return NULL;\n    }\n\n    ctx = ckd_calloc(1, sizeof(*ctx));\n    ctx->n_emit_state = n_emit_state;\n    ctx->tp = tp;\n    ctx->senscore = senscore;\n    ctx->sseq = sseq;\n    ctx->st_sen_scr = ckd_calloc(n_emit_state, sizeof(*ctx->st_sen_scr));\n\n    return ctx;\n}\n\nvoid\nhmm_context_free(hmm_context_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n    ckd_free(ctx->st_sen_scr);\n    ckd_free(ctx);\n}\n\nvoid\nhmm_init(hmm_context_t *ctx, hmm_t *hmm, int mpx, int ssid, int tmatid)\n{\n    hmm->ctx = ctx;\n    hmm->mpx = mpx;\n    hmm->n_emit_state = ctx->n_emit_state;\n    if (mpx) {\n        int i;\n        hmm->ssid = BAD_SSID;\n        hmm->senid[0] = ssid;\n        for (i = 1; i < hmm_n_emit_state(hmm); ++i) {\n            hmm->senid[i] = BAD_SSID;\n        }\n    }\n    else {\n        hmm->ssid = ssid;\n        memcpy(hmm->senid, ctx->sseq[ssid], hmm->n_emit_state * sizeof(*hmm->senid));\n    }\n    hmm->tmatid = tmatid;\n    hmm_clear(hmm);\n}\n\nvoid\nhmm_deinit(hmm_t *hmm)\n{\n}\n\nvoid\nhmm_dump(hmm_t * hmm,\n         FILE * fp)\n{\n    int32 i;\n\n    if (hmm_is_mpx(hmm)) {\n        fprintf(fp, \"MPX   \");\n        for (i = 0; i < hmm_n_emit_state(hmm); i++)\n            fprintf(fp, \" %11d\", hmm_senid(hmm, i));\n        fprintf(fp, \" ( \");\n        for (i = 0; i < hmm_n_emit_state(hmm); i++)\n            fprintf(fp, \"%d \", hmm_ssid(hmm, i));\n        fprintf(fp, \")\\n\");\n    }\n    else {\n        fprintf(fp, \"SSID  \");\n        for (i = 0; i < hmm_n_emit_state(hmm); i++)\n            fprintf(fp, \" %11d\", hmm_senid(hmm, i));\n        fprintf(fp, \" (%d)\\n\", hmm_ssid(hmm, 0));\n    }\n\n    if (hmm->ctx->senscore) {\n        fprintf(fp, \"SENSCR\");\n        for (i = 0; i < hmm_n_emit_state(hmm); i++)\n            fprintf(fp, \" %11d\", hmm_senscr(hmm, i));\n        fprintf(fp, \"\\n\");\n    }\n\n    fprintf(fp, \"SCORES %11d\", hmm_in_score(hmm));\n    for (i = 1; i < hmm_n_emit_state(hmm); i++)\n        fprintf(fp, \" %11d\", hmm_score(hmm, i));\n    fprintf(fp, \" %11d\", hmm_out_score(hmm));\n    fprintf(fp, \"\\n\");\n\n    fprintf(fp, \"HISTID %11d\", hmm_in_history(hmm));\n    for (i = 1; i < hmm_n_emit_state(hmm); i++)\n        fprintf(fp, \" %11d\", hmm_history(hmm, i));\n    fprintf(fp, \" %11d\", hmm_out_history(hmm));\n    fprintf(fp, \"\\n\");\n\n    if (hmm_in_score(hmm) > 0)\n        fprintf(fp,\n                \"ALERT!! The input score %d is large than 0. Probably wrap around.\\n\",\n                hmm_in_score(hmm));\n    if (hmm_out_score(hmm) > 0)\n        fprintf(fp,\n                \"ALERT!! The output score %d is large than 0. Probably wrap around\\n.\",\n                hmm_out_score(hmm));\n\n    fflush(fp);\n}\n\n\nvoid\nhmm_clear_scores(hmm_t * h)\n{\n    int32 i;\n\n    hmm_in_score(h) = WORST_SCORE;\n    for (i = 1; i < hmm_n_emit_state(h); i++)\n        hmm_score(h, i) = WORST_SCORE;\n    hmm_out_score(h) = WORST_SCORE;\n\n    h->bestscore = WORST_SCORE;\n}\n\nvoid\nhmm_clear(hmm_t * h)\n{\n    int32 i;\n\n    hmm_in_score(h) = WORST_SCORE;\n    hmm_in_history(h) = -1;\n    for (i = 1; i < hmm_n_emit_state(h); i++) {\n        hmm_score(h, i) = WORST_SCORE;\n        hmm_history(h, i) = -1;\n    }\n    hmm_out_score(h) = WORST_SCORE;\n    hmm_out_history(h) = -1;\n\n    h->bestscore = WORST_SCORE;\n    h->frame = -1;\n}\n\nvoid\nhmm_enter(hmm_t *h, int32 score, int32 histid, int frame)\n{\n    hmm_in_score(h) = score;\n    hmm_in_history(h) = histid;\n    hmm_frame(h) = frame;\n}\n\nvoid\nhmm_normalize(hmm_t *h, int32 bestscr)\n{\n    int32 i;\n\n    for (i = 0; i < hmm_n_emit_state(h); i++) {\n        if (hmm_score(h, i) BETTER_THAN WORST_SCORE)\n            hmm_score(h, i) -= bestscr;\n    }\n    if (hmm_out_score(h) BETTER_THAN WORST_SCORE)\n        hmm_out_score(h) -= bestscr;\n}\n\n#define hmm_tprob_5st(i, j) (-tp[(i)*6+(j)])\n#define nonmpx_senscr(i) (-senscore[sseq[i]])\n\nstatic int32\nhmm_vit_eval_5st_lr(hmm_t * hmm)\n{\n    int16 const *senscore = hmm->ctx->senscore;\n    uint8 const *tp = hmm->ctx->tp[hmm->tmatid][0];\n    uint16 const *sseq = hmm->senid;\n    int32 s5, s4, s3, s2, s1, s0, t2, t1, t0, bestScore;\n\n    /* It was the best of scores, it was the worst of scores. */\n    bestScore = WORST_SCORE;\n\n    /* Cache problem here! */\n    s4 = hmm_score(hmm, 4) + nonmpx_senscr(4);\n    s3 = hmm_score(hmm, 3) + nonmpx_senscr(3);\n    /* Transitions into non-emitting state 5 */\n    if (s3 BETTER_THAN WORST_SCORE) {\n        t1 = s4 + hmm_tprob_5st(4, 5);\n        t2 = s3 + hmm_tprob_5st(3, 5);\n        if (t1 BETTER_THAN t2) {\n            s5 = t1;\n            hmm_out_history(hmm)  = hmm_history(hmm, 4);\n        } else {\n            s5 = t2;\n            hmm_out_history(hmm)  = hmm_history(hmm, 3);\n        }\n        if (s5 WORSE_THAN WORST_SCORE) s5 = WORST_SCORE;\n        hmm_out_score(hmm) = s5;\n        bestScore = s5;\n    }\n\n    s2 = hmm_score(hmm, 2) + nonmpx_senscr(2);\n    /* All transitions into state 4 */\n    if (s2 BETTER_THAN WORST_SCORE) {\n        t0 = s4 + hmm_tprob_5st(4, 4);\n        t1 = s3 + hmm_tprob_5st(3, 4);\n        t2 = s2 + hmm_tprob_5st(2, 4);\n        if (t0 BETTER_THAN t1) {\n            if (t2 BETTER_THAN t0) {\n                s4 = t2;\n                hmm_history(hmm, 4)  = hmm_history(hmm, 2);\n            } else\n                s4 = t0;\n        } else {\n            if (t2 BETTER_THAN t1) {\n                s4 = t2;\n                hmm_history(hmm, 4)  = hmm_history(hmm, 2);\n            } else {\n                s4 = t1;\n                hmm_history(hmm, 4)  = hmm_history(hmm, 3);\n            }\n        }\n        if (s4 WORSE_THAN WORST_SCORE) s4 = WORST_SCORE;\n        if (s4 BETTER_THAN bestScore) bestScore = s4;\n        hmm_score(hmm, 4) = s4;\n    }\n\n    s1 = hmm_score(hmm, 1) + nonmpx_senscr(1);\n    /* All transitions into state 3 */\n    if (s1 BETTER_THAN WORST_SCORE) {\n        t0 = s3 + hmm_tprob_5st(3, 3);\n        t1 = s2 + hmm_tprob_5st(2, 3);\n        t2 = s1 + hmm_tprob_5st(1, 3);\n        if (t0 BETTER_THAN t1) {\n            if (t2 BETTER_THAN t0) {\n                s3 = t2;\n                hmm_history(hmm, 3)  = hmm_history(hmm, 1);\n            } else\n                s3 = t0;\n        } else {\n            if (t2 BETTER_THAN t1) {\n                s3 = t2;\n                hmm_history(hmm, 3)  = hmm_history(hmm, 1);\n            } else {\n                s3 = t1;\n                hmm_history(hmm, 3)  = hmm_history(hmm, 2);\n            }\n        }\n        if (s3 WORSE_THAN WORST_SCORE) s3 = WORST_SCORE;\n        if (s3 BETTER_THAN bestScore) bestScore = s3;\n        hmm_score(hmm, 3) = s3;\n    }\n\n    s0 = hmm_in_score(hmm) + nonmpx_senscr(0);\n    /* All transitions into state 2 (state 0 is always active) */\n    t0 = s2 + hmm_tprob_5st(2, 2);\n    t1 = s1 + hmm_tprob_5st(1, 2);\n    t2 = s0 + hmm_tprob_5st(0, 2);\n    if (t0 BETTER_THAN t1) {\n        if (t2 BETTER_THAN t0) {\n            s2 = t2;\n            hmm_history(hmm, 2)  = hmm_in_history(hmm);\n        } else\n            s2 = t0;\n    } else {\n        if (t2 BETTER_THAN t1) {\n            s2 = t2;\n            hmm_history(hmm, 2)  = hmm_in_history(hmm);\n        } else {\n            s2 = t1;\n            hmm_history(hmm, 2)  = hmm_history(hmm, 1);\n        }\n    }\n    if (s2 WORSE_THAN WORST_SCORE) s2 = WORST_SCORE;\n    if (s2 BETTER_THAN bestScore) bestScore = s2;\n    hmm_score(hmm, 2) = s2;\n\n\n    /* All transitions into state 1 */\n    t0 = s1 + hmm_tprob_5st(1, 1);\n    t1 = s0 + hmm_tprob_5st(0, 1);\n    if (t0 BETTER_THAN t1) {\n        s1 = t0;\n    } else {\n        s1 = t1;\n        hmm_history(hmm, 1)  = hmm_in_history(hmm);\n    }\n    if (s1 WORSE_THAN WORST_SCORE) s1 = WORST_SCORE;\n    if (s1 BETTER_THAN bestScore) bestScore = s1;\n    hmm_score(hmm, 1) = s1;\n\n    /* All transitions into state 0 */\n    s0 = s0 + hmm_tprob_5st(0, 0);\n    if (s0 WORSE_THAN WORST_SCORE) s0 = WORST_SCORE;\n    if (s0 BETTER_THAN bestScore) bestScore = s0;\n    hmm_in_score(hmm) = s0;\n\n    hmm_bestscore(hmm) = bestScore;\n    return bestScore;\n}\n\n#define mpx_senid(st) sseq[ssid[st]][st]\n#define mpx_senscr(st) (-senscore[mpx_senid(st)])\n\nstatic int32\nhmm_vit_eval_5st_lr_mpx(hmm_t * hmm)\n{\n    uint8 const *tp = hmm->ctx->tp[hmm->tmatid][0];\n    int16 const *senscore = hmm->ctx->senscore;\n    uint16 * const *sseq = hmm->ctx->sseq;\n    uint16 *ssid = hmm->senid;\n    int32 bestScore;\n    int32 s5, s4, s3, s2, s1, s0, t2, t1, t0;\n\n    /* Don't propagate WORST_SCORE */\n    if (ssid[4] == BAD_SSID)\n        s4 = t1 = WORST_SCORE;\n    else {\n        s4 = hmm_score(hmm, 4) + mpx_senscr(4);\n        t1 = s4 + hmm_tprob_5st(4, 5);\n    }\n    if (ssid[3] == BAD_SSID)\n        s3 = t2 = WORST_SCORE;\n    else {\n        s3 = hmm_score(hmm, 3) + mpx_senscr(3);\n        t2 = s3 + hmm_tprob_5st(3, 5);\n    }\n    if (t1 BETTER_THAN t2) {\n        s5 = t1;\n        hmm_out_history(hmm) = hmm_history(hmm, 4);\n    }\n    else {\n        s5 = t2;\n        hmm_out_history(hmm) = hmm_history(hmm, 3);\n    }\n    if (s5 WORSE_THAN WORST_SCORE) s5 = WORST_SCORE;\n    hmm_out_score(hmm) = s5;\n    bestScore = s5;\n\n    /* Don't propagate WORST_SCORE */\n    if (ssid[2] == BAD_SSID)\n        s2 = t2 = WORST_SCORE;\n    else {\n        s2 = hmm_score(hmm, 2) + mpx_senscr(2);\n        t2 = s2 + hmm_tprob_5st(2, 4);\n    }\n\n    t0 = t1 = WORST_SCORE;\n    if (s4 != WORST_SCORE)\n        t0 = s4 + hmm_tprob_5st(4, 4);\n    if (s3 != WORST_SCORE)\n        t1 = s3 + hmm_tprob_5st(3, 4);\n    if (t0 BETTER_THAN t1) {\n        if (t2 BETTER_THAN t0) {\n            s4 = t2;\n            hmm_history(hmm, 4) = hmm_history(hmm, 2);\n            ssid[4] = ssid[2];\n        }\n        else\n            s4 = t0;\n    }\n    else {\n        if (t2 BETTER_THAN t1) {\n            s4 = t2;\n            hmm_history(hmm, 4) = hmm_history(hmm, 2);\n            ssid[4] = ssid[2];\n        }\n        else {\n            s4 = t1;\n            hmm_history(hmm, 4) = hmm_history(hmm, 3);\n            ssid[4] = ssid[3];\n        }\n    }\n    if (s4 WORSE_THAN WORST_SCORE) s4 = WORST_SCORE;\n    if (s4 BETTER_THAN bestScore)\n        bestScore = s4;\n    hmm_score(hmm, 4) = s4;\n\n    /* Don't propagate WORST_SCORE */\n    if (ssid[1] == BAD_SSID)\n        s1 = t2 = WORST_SCORE;\n    else {\n        s1 = hmm_score(hmm, 1) + mpx_senscr(1);\n        t2 = s1 + hmm_tprob_5st(1, 3);\n    }\n    t0 = t1 = WORST_SCORE;\n    if (s3 != WORST_SCORE)\n        t0 = s3 + hmm_tprob_5st(3, 3);\n    if (s2 != WORST_SCORE)\n        t1 = s2 + hmm_tprob_5st(2, 3);\n    if (t0 BETTER_THAN t1) {\n        if (t2 BETTER_THAN t0) {\n            s3 = t2;\n            hmm_history(hmm, 3) = hmm_history(hmm, 1);\n            ssid[3] = ssid[1];\n        }\n        else\n            s3 = t0;\n    }\n    else {\n        if (t2 BETTER_THAN t1) {\n            s3 = t2;\n            hmm_history(hmm, 3) = hmm_history(hmm, 1);\n            ssid[3] = ssid[1];\n        }\n        else {\n            s3 = t1;\n            hmm_history(hmm, 3) = hmm_history(hmm, 2);\n            ssid[3] = ssid[2];\n        }\n    }\n    if (s3 WORSE_THAN WORST_SCORE) s3 = WORST_SCORE;\n    if (s3 BETTER_THAN bestScore) bestScore = s3;\n    hmm_score(hmm, 3) = s3;\n\n    /* State 0 is always active */\n    s0 = hmm_in_score(hmm) + mpx_senscr(0);\n\n    /* Don't propagate WORST_SCORE */\n    t0 = t1 = WORST_SCORE;\n    if (s2 != WORST_SCORE)\n        t0 = s2 + hmm_tprob_5st(2, 2);\n    if (s1 != WORST_SCORE)\n        t1 = s1 + hmm_tprob_5st(1, 2);\n    t2 = s0 + hmm_tprob_5st(0, 2);\n    if (t0 BETTER_THAN t1) {\n        if (t2 BETTER_THAN t0) {\n            s2 = t2;\n            hmm_history(hmm, 2) = hmm_in_history(hmm);\n            ssid[2] = ssid[0];\n        }\n        else\n            s2 = t0;\n    }\n    else {\n        if (t2 BETTER_THAN t1) {\n            s2 = t2;\n            hmm_history(hmm, 2) = hmm_in_history(hmm);\n            ssid[2] = ssid[0];\n        }\n        else {\n            s2 = t1;\n            hmm_history(hmm, 2) = hmm_history(hmm, 1);\n            ssid[2] = ssid[1];\n        }\n    }\n    if (s2 WORSE_THAN WORST_SCORE) s2 = WORST_SCORE;\n    if (s2 BETTER_THAN bestScore) bestScore = s2;\n    hmm_score(hmm, 2) = s2;\n\n    /* Don't propagate WORST_SCORE */\n    t0 = WORST_SCORE;\n    if (s1 != WORST_SCORE)\n        t0 = s1 + hmm_tprob_5st(1, 1);\n    t1 = s0 + hmm_tprob_5st(0, 1);\n    if (t0 BETTER_THAN t1) {\n        s1 = t0;\n    }\n    else {\n        s1 = t1;\n        hmm_history(hmm, 1) = hmm_in_history(hmm);\n        ssid[1] = ssid[0];\n    }\n    if (s1 WORSE_THAN WORST_SCORE) s1 = WORST_SCORE;\n    if (s1 BETTER_THAN bestScore) bestScore = s1;\n    hmm_score(hmm, 1) = s1;\n\n    s0 += hmm_tprob_5st(0, 0);\n    if (s0 WORSE_THAN WORST_SCORE) s0 = WORST_SCORE;\n    if (s0 BETTER_THAN bestScore) bestScore = s0;\n    hmm_in_score(hmm) = s0;\n\n    hmm_bestscore(hmm) = bestScore;\n    return bestScore;\n}\n\n#define hmm_tprob_3st(i, j) (-tp[(i)*4+(j)])\n\nstatic int32\nhmm_vit_eval_3st_lr(hmm_t * hmm)\n{\n    int16 const *senscore = hmm->ctx->senscore;\n    uint8 const *tp = hmm->ctx->tp[hmm->tmatid][0];\n    uint16 const *sseq = hmm->senid;\n    int32 s3, s2, s1, s0, t2, t1, t0, bestScore;\n\n    s2 = hmm_score(hmm, 2) + nonmpx_senscr(2);\n    s1 = hmm_score(hmm, 1) + nonmpx_senscr(1);\n    s0 = hmm_in_score(hmm) + nonmpx_senscr(0);\n\n    /* It was the best of scores, it was the worst of scores. */\n    bestScore = WORST_SCORE;\n    t2 = INT_MIN; /* Not used unless skipstate is true */\n\n    /* Transitions into non-emitting state 3 */\n    if (s1 BETTER_THAN WORST_SCORE) {\n        t1 = s2 + hmm_tprob_3st(2, 3);\n        if (hmm_tprob_3st(1,3) BETTER_THAN TMAT_WORST_SCORE)\n            t2 = s1 + hmm_tprob_3st(1, 3);\n        if (t1 BETTER_THAN t2) {\n            s3 = t1;\n            hmm_out_history(hmm)  = hmm_history(hmm, 2);\n        } else {\n            s3 = t2;\n            hmm_out_history(hmm)  = hmm_history(hmm, 1);\n        }\n        if (s3 WORSE_THAN WORST_SCORE) s3 = WORST_SCORE;\n        hmm_out_score(hmm) = s3;\n        bestScore = s3;\n    }\n\n    /* All transitions into state 2 (state 0 is always active) */\n    t0 = s2 + hmm_tprob_3st(2, 2);\n    t1 = s1 + hmm_tprob_3st(1, 2);\n    if (hmm_tprob_3st(0, 2) BETTER_THAN TMAT_WORST_SCORE)\n        t2 = s0 + hmm_tprob_3st(0, 2);\n    if (t0 BETTER_THAN t1) {\n        if (t2 BETTER_THAN t0) {\n            s2 = t2;\n            hmm_history(hmm, 2)  = hmm_in_history(hmm);\n        } else\n            s2 = t0;\n    } else {\n        if (t2 BETTER_THAN t1) {\n            s2 = t2;\n            hmm_history(hmm, 2)  = hmm_in_history(hmm);\n        } else {\n            s2 = t1;\n            hmm_history(hmm, 2)  = hmm_history(hmm, 1);\n        }\n    }\n    if (s2 WORSE_THAN WORST_SCORE) s2 = WORST_SCORE;\n    if (s2 BETTER_THAN bestScore) bestScore = s2;\n    hmm_score(hmm, 2) = s2;\n\n    /* All transitions into state 1 */\n    t0 = s1 + hmm_tprob_3st(1, 1);\n    t1 = s0 + hmm_tprob_3st(0, 1);\n    if (t0 BETTER_THAN t1) {\n        s1 = t0;\n    } else {\n        s1 = t1;\n        hmm_history(hmm, 1)  = hmm_in_history(hmm);\n    }\n    if (s1 WORSE_THAN WORST_SCORE) s1 = WORST_SCORE;\n    if (s1 BETTER_THAN bestScore) bestScore = s1;\n    hmm_score(hmm, 1) = s1;\n\n    /* All transitions into state 0 */\n    s0 = s0 + hmm_tprob_3st(0, 0);\n    if (s0 WORSE_THAN WORST_SCORE) s0 = WORST_SCORE;\n    if (s0 BETTER_THAN bestScore) bestScore = s0;\n    hmm_in_score(hmm) = s0;\n\n    hmm_bestscore(hmm) = bestScore;\n    return bestScore;\n}\n\nstatic int32\nhmm_vit_eval_3st_lr_mpx(hmm_t * hmm)\n{\n    uint8 const *tp = hmm->ctx->tp[hmm->tmatid][0];\n    int16 const *senscore = hmm->ctx->senscore;\n    uint16 * const *sseq = hmm->ctx->sseq;\n    uint16 *ssid = hmm->senid;\n    int32 bestScore;\n    int32 s3, s2, s1, s0, t2, t1, t0;\n\n    /* Don't propagate WORST_SCORE */\n    t2 = INT_MIN; /* Not used unless skipstate is true */\n    if (ssid[2] == BAD_SSID)\n        s2 = t1 = WORST_SCORE;\n    else {\n        s2 = hmm_score(hmm, 2) + mpx_senscr(2);\n        t1 = s2 + hmm_tprob_3st(2, 3);\n    }\n    if (ssid[1] == BAD_SSID)\n        s1 = t2 = WORST_SCORE;\n    else {\n        s1 = hmm_score(hmm, 1) + mpx_senscr(1);\n        if (hmm_tprob_3st(1,3) BETTER_THAN TMAT_WORST_SCORE)\n            t2 = s1 + hmm_tprob_3st(1, 3);\n    }\n    if (t1 BETTER_THAN t2) {\n        s3 = t1;\n        hmm_out_history(hmm) = hmm_history(hmm, 2);\n    }\n    else {\n        s3 = t2;\n        hmm_out_history(hmm) = hmm_history(hmm, 1);\n    }\n    if (s3 WORSE_THAN WORST_SCORE) s3 = WORST_SCORE;\n    hmm_out_score(hmm) = s3;\n    bestScore = s3;\n\n    /* State 0 is always active */\n    s0 = hmm_in_score(hmm) + mpx_senscr(0);\n\n    /* Don't propagate WORST_SCORE */\n    t0 = t1 = WORST_SCORE;\n    if (s2 != WORST_SCORE)\n        t0 = s2 + hmm_tprob_3st(2, 2);\n    if (s1 != WORST_SCORE)\n        t1 = s1 + hmm_tprob_3st(1, 2);\n    if (hmm_tprob_3st(0,2) BETTER_THAN TMAT_WORST_SCORE)\n        t2 = s0 + hmm_tprob_3st(0, 2);\n    if (t0 BETTER_THAN t1) {\n        if (t2 BETTER_THAN t0) {\n            s2 = t2;\n            hmm_history(hmm, 2) = hmm_in_history(hmm);\n            ssid[2] = ssid[0];\n        }\n        else\n            s2 = t0;\n    }\n    else {\n        if (t2 BETTER_THAN t1) {\n            s2 = t2;\n            hmm_history(hmm, 2) = hmm_in_history(hmm);\n            ssid[2] = ssid[0];\n        }\n        else {\n            s2 = t1;\n            hmm_history(hmm, 2) = hmm_history(hmm, 1);\n            ssid[2] = ssid[1];\n        }\n    }\n    if (s2 WORSE_THAN WORST_SCORE) s2 = WORST_SCORE;\n    if (s2 BETTER_THAN bestScore) bestScore = s2;\n    hmm_score(hmm, 2) = s2;\n\n    /* Don't propagate WORST_SCORE */\n    t0 = WORST_SCORE;\n    if (s1 != WORST_SCORE)\n        t0 = s1 + hmm_tprob_3st(1, 1);\n    t1 = s0 + hmm_tprob_3st(0, 1);\n    if (t0 BETTER_THAN t1) {\n        s1 = t0;\n    }\n    else {\n        s1 = t1;\n        hmm_history(hmm, 1) = hmm_in_history(hmm);\n        ssid[1] = ssid[0];\n    }\n    if (s1 WORSE_THAN WORST_SCORE) s1 = WORST_SCORE;\n    if (s1 BETTER_THAN bestScore) bestScore = s1;\n    hmm_score(hmm, 1) = s1;\n\n    /* State 0 is always active */\n    s0 += hmm_tprob_3st(0, 0);\n    if (s0 WORSE_THAN WORST_SCORE) s0 = WORST_SCORE;\n    if (s0 BETTER_THAN bestScore) bestScore = s0;\n    hmm_in_score(hmm) = s0;\n\n    hmm_bestscore(hmm) = bestScore;\n    return bestScore;\n}\n\nstatic int32\nhmm_vit_eval_anytopo(hmm_t * hmm)\n{\n    hmm_context_t *ctx = hmm->ctx;\n    int32 to, from, bestfrom;\n    int32 newscr, scr, bestscr;\n    int final_state;\n\n    /* Compute previous state-score + observation output prob for each emitting state */\n    ctx->st_sen_scr[0] = hmm_in_score(hmm) + hmm_senscr(hmm, 0);\n    for (from = 1; from < hmm_n_emit_state(hmm); ++from) {\n        if ((ctx->st_sen_scr[from] =\n             hmm_score(hmm, from) + hmm_senscr(hmm, from)) WORSE_THAN WORST_SCORE)\n            ctx->st_sen_scr[from] = WORST_SCORE;\n    }\n\n    /* FIXME/TODO: Use the BLAS for all this. */\n    /* Evaluate final-state first, which does not have a self-transition */\n    final_state = hmm_n_emit_state(hmm);\n    to = final_state;\n    scr = WORST_SCORE;\n    bestfrom = -1;\n    for (from = to - 1; from >= 0; --from) {\n        if ((hmm_tprob(hmm, from, to) BETTER_THAN TMAT_WORST_SCORE) &&\n            ((newscr = ctx->st_sen_scr[from]\n              + hmm_tprob(hmm, from, to)) BETTER_THAN scr)) {\n            scr = newscr;\n            bestfrom = from;\n        }\n    }\n    hmm_out_score(hmm) = scr;\n    if (bestfrom >= 0)\n        hmm_out_history(hmm) = hmm_history(hmm, bestfrom);\n    bestscr = scr;\n\n    /* Evaluate all other states, which might have self-transitions */\n    for (to = final_state - 1; to >= 0; --to) {\n        /* Score from self-transition, if any */\n        scr =\n            (hmm_tprob(hmm, to, to) BETTER_THAN TMAT_WORST_SCORE)\n            ? ctx->st_sen_scr[to] + hmm_tprob(hmm, to, to)\n            : WORST_SCORE;\n\n        /* Scores from transitions from other states */\n        bestfrom = -1;\n        for (from = to - 1; from >= 0; --from) {\n            if ((hmm_tprob(hmm, from, to) BETTER_THAN TMAT_WORST_SCORE) &&\n                ((newscr = ctx->st_sen_scr[from]\n                  + hmm_tprob(hmm, from, to)) BETTER_THAN scr)) {\n                scr = newscr;\n                bestfrom = from;\n            }\n        }\n\n        /* Update new result for state to */\n        if (to == 0) {\n            hmm_in_score(hmm) = scr;\n            if (bestfrom >= 0)\n                hmm_in_history(hmm) = hmm_history(hmm, bestfrom);\n        }\n        else {\n            hmm_score(hmm, to) = scr;\n            if (bestfrom >= 0)\n                hmm_history(hmm, to) = hmm_history(hmm, bestfrom);\n        }\n        /* Propagate ssid for multiplex HMMs */\n        if (bestfrom >= 0 && hmm_is_mpx(hmm))\n            hmm->senid[to] = hmm->senid[bestfrom];\n\n        if (bestscr WORSE_THAN scr)\n            bestscr = scr;\n    }\n\n    hmm_bestscore(hmm) = bestscr;\n    return bestscr;\n}\n\nint32\nhmm_vit_eval(hmm_t * hmm)\n{\n    if (hmm_is_mpx(hmm)) {\n        if (hmm_n_emit_state(hmm) == 5)\n            return hmm_vit_eval_5st_lr_mpx(hmm);\n        else if (hmm_n_emit_state(hmm) == 3)\n            return hmm_vit_eval_3st_lr_mpx(hmm);\n        else\n            return hmm_vit_eval_anytopo(hmm);\n    }\n    else {\n        if (hmm_n_emit_state(hmm) == 5)\n            return hmm_vit_eval_5st_lr(hmm);\n        else if (hmm_n_emit_state(hmm) == 3)\n            return hmm_vit_eval_3st_lr(hmm);\n        else\n            return hmm_vit_eval_anytopo(hmm);\n    }\n}\n\nint32\nhmm_dump_vit_eval(hmm_t * hmm, FILE * fp)\n{\n    int32 bs = 0;\n\n    if (fp) {\n        fprintf(fp, \"BEFORE:\\n\");\n        hmm_dump(hmm, fp);\n    }\n    bs = hmm_vit_eval(hmm);\n    if (fp) {\n        fprintf(fp, \"AFTER:\\n\");\n        hmm_dump(hmm, fp);\n    }\n\n    return bs;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n * mdef.c -- HMM model definition: base (CI) phones and triphones\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * \n * \n * 22-Nov-2004\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tImported from s3.2, for supporting s3 format continuous\n * \t\tacoustic models.\n * \n * 14-Oct-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tAdded mdef_sseq2sen_active().\n * \n * 06-May-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tIn mdef_phone_id(), added backing off to silence phone context from filler\n * \t\tcontext if original triphone not found.\n * \n * 30-Apr-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tAdded senone-sequence id (ssid) to phone_t and appropriate functions to\n * \t\tmaintain it.  Instead, moved state sequence info to mdef_t.\n * \n * 13-Jul-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tAdded mdef_phone_str().\n * \n * 01-Jan-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tAllowed mdef_phone_id_nearest to return base phone id if either\n * \t\tleft or right context (or both) is undefined.\n * \n * 01-Jan-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tCreated.\n */\n\n\n/*\n * Major assumptions:\n *   All phones have same #states, same topology.\n *   Every phone has exactly one non-emitting, final state--the last one.\n *   CI phones must appear first in model definition file.\n */\n\n/* System headers. */\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"mdef.h\"\n\n\n#define MODEL_DEF_VERSION\t\"0.3\"\n\nstatic void\nciphone_add(mdef_t * m, char *ci, int p)\n{\n    assert(p < m->n_ciphone);\n\n    m->ciphone[p].name = (char *) ckd_salloc(ci);       /* freed in mdef_free */\n    if (hash_table_enter(m->ciphone_ht, m->ciphone[p].name,\n                         (void *)(long)p) != (void *)(long)p)\n        E_FATAL(\"hash_table_enter(%s) failed; duplicate CIphone?\\n\",\n                m->ciphone[p].name);\n}\n\n\nstatic ph_lc_t *\nfind_ph_lc(ph_lc_t * lclist, int lc)\n{\n    ph_lc_t *lcptr;\n\n    for (lcptr = lclist; lcptr && (lcptr->lc != lc); lcptr = lcptr->next);\n    return lcptr;\n}\n\n\nstatic ph_rc_t *\nfind_ph_rc(ph_rc_t * rclist, int rc)\n{\n    ph_rc_t *rcptr;\n\n    for (rcptr = rclist; rcptr && (rcptr->rc != rc); rcptr = rcptr->next);\n    return rcptr;\n}\n\n\nstatic void\ntriphone_add(mdef_t * m,\n             int ci, int lc, int rc, word_posn_t wpos,\n             int p)\n{\n    ph_lc_t *lcptr;\n    ph_rc_t *rcptr;\n\n    assert(p < m->n_phone);\n\n    /* Fill in phone[p] information (state and tmat mappings added later) */\n    m->phone[p].ci = ci;\n    m->phone[p].lc = lc;\n    m->phone[p].rc = rc;\n    m->phone[p].wpos = wpos;\n\n    /* Create <ci,lc,rc,wpos> -> p mapping if not a CI phone */\n    if (p >= m->n_ciphone) {\n        if ((lcptr = find_ph_lc(m->wpos_ci_lclist[wpos][(int) ci], lc))\n            == NULL) {\n            lcptr = (ph_lc_t *) ckd_calloc(1, sizeof(ph_lc_t)); /* freed at mdef_free, I believe */\n            lcptr->lc = lc;\n            lcptr->next = m->wpos_ci_lclist[wpos][(int) ci];\n            m->wpos_ci_lclist[wpos][(int) ci] = lcptr;  /* This is what needs to be freed */\n        }\n        if ((rcptr = find_ph_rc(lcptr->rclist, rc)) != NULL) {\n            __BIGSTACKVARIABLE__ char buf[4096];\n\n            mdef_phone_str(m, rcptr->pid, buf);\n            E_FATAL(\"Duplicate triphone: %s\\n\", buf);\n        }\n\n        rcptr = (ph_rc_t *) ckd_calloc(1, sizeof(ph_rc_t));     /* freed in mdef_free, I believe */\n        rcptr->rc = rc;\n        rcptr->pid = p;\n        rcptr->next = lcptr->rclist;\n        lcptr->rclist = rcptr;\n    }\n}\n\n\nint\nmdef_ciphone_id(mdef_t * m, char *ci)\n{\n    int32 id;\n    if (hash_table_lookup_int32(m->ciphone_ht, ci, &id) < 0)\n        return -1;\n    return id;\n}\n\n\nconst char *\nmdef_ciphone_str(mdef_t * m, int id)\n{\n    assert(m);\n    assert((id >= 0) && (id < m->n_ciphone));\n\n    return (m->ciphone[id].name);\n}\n\n\nint\nmdef_phone_str(mdef_t * m, int pid, char *buf)\n{\n    char *wpos_name;\n\n    assert(m);\n    assert((pid >= 0) && (pid < m->n_phone));\n    wpos_name = WPOS_NAME;\n\n    buf[0] = '\\0';\n    if (pid < m->n_ciphone)\n        sprintf(buf, \"%s\", mdef_ciphone_str(m, pid));\n    else {\n        sprintf(buf, \"%s %s %s %c\",\n                mdef_ciphone_str(m, m->phone[pid].ci),\n                mdef_ciphone_str(m, m->phone[pid].lc),\n                mdef_ciphone_str(m, m->phone[pid].rc),\n                wpos_name[m->phone[pid].wpos]);\n    }\n    return 0;\n}\n\n\nint\nmdef_phone_id(mdef_t * m,\n              int ci, int lc, int rc, word_posn_t wpos)\n{\n    ph_lc_t *lcptr;\n    ph_rc_t *rcptr;\n    int newl, newr;\n\n    assert(m);\n    assert((ci >= 0) && (ci < m->n_ciphone));\n    assert((lc >= 0) && (lc < m->n_ciphone));\n    assert((rc >= 0) && (rc < m->n_ciphone));\n    assert((wpos >= 0) && (wpos < N_WORD_POSN));\n\n    if (((lcptr =\n          find_ph_lc(m->wpos_ci_lclist[wpos][(int) ci], lc)) == NULL)\n        || ((rcptr = find_ph_rc(lcptr->rclist, rc)) == NULL)) {\n        /* Not found; backoff to silence context if non-silence filler context */\n        if (m->sil < 0)\n            return -1;\n\n        newl = m->ciphone[(int) lc].filler ? m->sil : lc;\n        newr = m->ciphone[(int) rc].filler ? m->sil : rc;\n        if ((newl == lc) && (newr == rc))\n            return -1;\n\n        return (mdef_phone_id(m, ci, newl, newr, wpos));\n    }\n\n    return (rcptr->pid);\n}\n\nint\nmdef_is_ciphone(mdef_t * m, int p)\n{\n    assert(m);\n    assert((p >= 0) && (p < m->n_phone));\n\n    return ((p < m->n_ciphone) ? 1 : 0);\n}\n\nint\nmdef_is_cisenone(mdef_t * m, int s)\n{\n    assert(m);\n    if (s >= m->n_sen) {\n        return 0;\n    }\n    assert(s >= 0);\n    return ((s == m->cd2cisen[s]) ? 1 : 0);\n}\n\n\n/* Parse tmat and state->senone mappings for phone p and fill in structure */\nstatic void\nparse_tmat_senmap(mdef_t * m, char *line, long off, int p)\n{\n    int32 wlen, n, s;\n    char *lp;\n    __BIGSTACKVARIABLE__ char word[1024];\n\n    lp = line + off;\n\n    /* Read transition matrix id */\n    if ((sscanf(lp, \"%d%n\", &n, &wlen) != 1) || (n < 0))\n        E_FATAL(\"Missing or bad transition matrix id: %s\\n\", line);\n    m->phone[p].tmat = n;\n    if (m->n_tmat <= n)\n        E_FATAL(\"tmat-id(%d) > #tmat in header(%d): %s\\n\", n, m->n_tmat,\n                line);\n    lp += wlen;\n\n    /* Read senone mappings for each emitting state */\n    for (n = 0; n < m->n_emit_state; n++) {\n        if ((sscanf(lp, \"%d%n\", &s, &wlen) != 1) || (s < 0))\n            E_FATAL(\"Missing or bad state[%d]->senone mapping: %s\\n\", n,\n                    line);\n\n        if ((p < m->n_ciphone) && (m->n_ci_sen <= s))\n            E_FATAL(\"CI-senone-id(%d) > #CI-senones(%d): %s\\n\", s,\n                    m->n_ci_sen, line);\n        if (m->n_sen <= s)\n            E_FATAL(\"Senone-id(%d) > #senones(%d): %s\\n\", s, m->n_sen,\n                    line);\n\n        m->sseq[p][n] = s;\n        lp += wlen;\n    }\n\n    /* Check for the last non-emitting state N */\n    if ((sscanf(lp, \"%s%n\", word, &wlen) != 1) || (strcmp(word, \"N\") != 0))\n        E_FATAL(\"Missing non-emitting state spec: %s\\n\", line);\n    lp += wlen;\n\n    /* Check for end of line */\n    if (sscanf(lp, \"%s%n\", word, &wlen) == 1)\n        E_FATAL(\"Non-empty beyond non-emitting final state: %s\\n\", line);\n}\n\n\nstatic void\nparse_base_line(mdef_t * m, char *line, int p)\n{\n    int32 wlen, n;\n    __BIGSTACKVARIABLE__ char word[1024], *lp;\n    int ci;\n\n    lp = line;\n\n    /* Read base phone name */\n    if (sscanf(lp, \"%s%n\", word, &wlen) != 1)\n        E_FATAL(\"Missing base phone name: %s\\n\", line);\n    lp += wlen;\n\n    /* Make sure it's not a duplicate */\n    ci = mdef_ciphone_id(m, word);\n    if (ci >= 0)\n        E_FATAL(\"Duplicate base phone: %s\\n\", line);\n\n    /* Add ciphone to ciphone table with id p */\n    ciphone_add(m, word, p);\n    ci = (int) p;\n\n    /* Read and skip \"-\" for lc, rc, wpos */\n    for (n = 0; n < 3; n++) {\n        if ((sscanf(lp, \"%s%n\", word, &wlen) != 1)\n            || (strcmp(word, \"-\") != 0))\n            E_FATAL(\"Bad context info for base phone: %s\\n\", line);\n        lp += wlen;\n    }\n\n    /* Read filler attribute, if present */\n    if (sscanf(lp, \"%s%n\", word, &wlen) != 1)\n        E_FATAL(\"Missing filler atribute field: %s\\n\", line);\n    lp += wlen;\n    if (strcmp(word, \"filler\") == 0)\n        m->ciphone[(int) ci].filler = 1;\n    else if (strcmp(word, \"n/a\") == 0)\n        m->ciphone[(int) ci].filler = 0;\n    else\n        E_FATAL(\"Bad filler attribute field: %s\\n\", line);\n\n    triphone_add(m, ci, -1, -1, WORD_POSN_UNDEFINED, p);\n\n    /* Parse remainder of line: transition matrix and state->senone mappings */\n    parse_tmat_senmap(m, line, lp - line, p);\n}\n\n\nstatic void\nparse_tri_line(mdef_t * m, char *line, int p)\n{\n    int32 wlen;\n    __BIGSTACKVARIABLE__ char word[1024], *lp;\n    int ci, lc, rc;\n    word_posn_t wpos = WORD_POSN_BEGIN;\n\n    lp = line;\n\n    /* Read base phone name */\n    if (sscanf(lp, \"%s%n\", word, &wlen) != 1)\n        E_FATAL(\"Missing base phone name: %s\\n\", line);\n    lp += wlen;\n\n    ci = mdef_ciphone_id(m, word);\n    if (ci < 0)\n        E_FATAL(\"Unknown base phone: %s\\n\", line);\n\n    /* Read lc */\n    if (sscanf(lp, \"%s%n\", word, &wlen) != 1)\n        E_FATAL(\"Missing left context: %s\\n\", line);\n    lp += wlen;\n    lc = mdef_ciphone_id(m, word);\n    if (lc < 0)\n        E_FATAL(\"Unknown left context: %s\\n\", line);\n\n    /* Read rc */\n    if (sscanf(lp, \"%s%n\", word, &wlen) != 1)\n        E_FATAL(\"Missing right context: %s\\n\", line);\n    lp += wlen;\n    rc = mdef_ciphone_id(m, word);\n    if (rc < 0)\n        E_FATAL(\"Unknown right  context: %s\\n\", line);\n\n    /* Read tripone word-position within word */\n    if ((sscanf(lp, \"%s%n\", word, &wlen) != 1) || (word[1] != '\\0'))\n        E_FATAL(\"Missing or bad word-position spec: %s\\n\", line);\n    lp += wlen;\n    switch (word[0]) {\n    case 'b':\n        wpos = WORD_POSN_BEGIN;\n        break;\n    case 'e':\n        wpos = WORD_POSN_END;\n        break;\n    case 's':\n        wpos = WORD_POSN_SINGLE;\n        break;\n    case 'i':\n        wpos = WORD_POSN_INTERNAL;\n        break;\n    default:\n        E_FATAL(\"Bad word-position spec: %s\\n\", line);\n    }\n\n    /* Read filler attribute, if present.  Must match base phone attribute */\n    if (sscanf(lp, \"%s%n\", word, &wlen) != 1)\n        E_FATAL(\"Missing filler attribute field: %s\\n\", line);\n    lp += wlen;\n    if (((strcmp(word, \"filler\") == 0) && (m->ciphone[(int) ci].filler)) ||\n        ((strcmp(word, \"n/a\") == 0) && (!m->ciphone[(int) ci].filler))) {\n        /* Everything is fine */\n    }\n    else\n        E_FATAL(\"Bad filler attribute field: %s\\n\", line);\n\n    triphone_add(m, ci, lc, rc, wpos, p);\n\n    /* Parse remainder of line: transition matrix and state->senone mappings */\n    parse_tmat_senmap(m, line, lp - line, p);\n}\n\n\nstatic void\nsseq_compress(mdef_t * m)\n{\n    hash_table_t *h;\n    uint16 **sseq;\n    int32 n_sseq;\n    int32 p, j, k;\n    glist_t g;\n    gnode_t *gn;\n    hash_entry_t *he;\n\n    k = m->n_emit_state * sizeof(int16);\n\n    h = hash_table_new(m->n_phone, HASH_CASE_YES);\n    n_sseq = 0;\n\n    /* Identify unique senone-sequence IDs.  BUG: tmat-id not being considered!! */\n    for (p = 0; p < m->n_phone; p++) {\n        /* Add senone sequence to hash table */\n\tif (n_sseq\n            == (j = hash_table_enter_bkey_int32(h, (char *)m->sseq[p], k, n_sseq)))\n            n_sseq++;\n\n        m->phone[p].ssid = j;\n    }\n\n    /* Generate compacted sseq table */\n    sseq = ckd_calloc_2d(n_sseq, m->n_emit_state, sizeof(**sseq)); /* freed in mdef_free() */\n\n    g = hash_table_tolist(h, &j);\n    assert(j == n_sseq);\n\n    for (gn = g; gn; gn = gnode_next(gn)) {\n        he = (hash_entry_t *) gnode_ptr(gn);\n        j = (int32)(long)hash_entry_val(he);\n        memcpy(sseq[j], hash_entry_key(he), k);\n    }\n    glist_free(g);\n\n    /* Free the old, temporary senone sequence table, replace with compacted one */\n    ckd_free_2d(m->sseq);\n    m->sseq = sseq;\n    m->n_sseq = n_sseq;\n\n    hash_table_free(h);\n}\n\n\nstatic int32\nnoncomment_line(char *line, int32 size, FILE * fp)\n{\n    while (fgets(line, size, fp) != NULL) {\n        if (line[0] != '#')\n            return 0;\n    }\n    return -1;\n}\n\n\n/*\n * Initialize phones (ci and triphones) and state->senone mappings from .mdef file.\n */\nmdef_t *\nmdef_init(char *mdeffile, int32 breport)\n{\n    FILE *fp;\n    int32 n_ci, n_tri, n_map, n;\n    __BIGSTACKVARIABLE__ char tag[1024], buf[1024];\n    uint16 **senmap;\n    int p;\n    int32 s, ci, cd;\n    mdef_t *m;\n\n    if (!mdeffile)\n        E_FATAL(\"No mdef-file\\n\");\n\n    if (breport)\n        E_INFO(\"Reading model definition: %s\\n\", mdeffile);\n\n    m = (mdef_t *) ckd_calloc(1, sizeof(mdef_t));       /* freed in mdef_free */\n\n    if ((fp = fopen(mdeffile, \"r\")) == NULL)\n        E_FATAL_SYSTEM(\"Failed to open mdef file '%s' for reading\", mdeffile);\n\n    if (noncomment_line(buf, sizeof(buf), fp) < 0)\n        E_FATAL(\"Empty file: %s\\n\", mdeffile);\n\n    if (strncmp(buf, \"BMDF\", 4) == 0 || strncmp(buf, \"FDMB\", 4) == 0) {\n        E_INFO\n            (\"Found byte-order mark %.4s, assuming this is a binary mdef file\\n\",\n             buf);\n        fclose(fp);\n        ckd_free(m);\n        return NULL;\n    }\n    if (strncmp(buf, MODEL_DEF_VERSION, strlen(MODEL_DEF_VERSION)) != 0)\n        E_FATAL(\"Version error: Expecing %s, but read %s\\n\",\n                MODEL_DEF_VERSION, buf);\n\n    /* Read #base phones, #triphones, #senone mappings defined in header */\n    n_ci = -1;\n    n_tri = -1;\n    n_map = -1;\n    m->n_ci_sen = -1;\n    m->n_sen = -1;\n    m->n_tmat = -1;\n    do {\n        if (noncomment_line(buf, sizeof(buf), fp) < 0)\n            E_FATAL(\"Incomplete header\\n\");\n\n        if ((sscanf(buf, \"%d %s\", &n, tag) != 2) || (n < 0))\n            E_FATAL(\"Error in header: %s\\n\", buf);\n\n        if (strcmp(tag, \"n_base\") == 0)\n            n_ci = n;\n        else if (strcmp(tag, \"n_tri\") == 0)\n            n_tri = n;\n        else if (strcmp(tag, \"n_state_map\") == 0)\n            n_map = n;\n        else if (strcmp(tag, \"n_tied_ci_state\") == 0)\n            m->n_ci_sen = n;\n        else if (strcmp(tag, \"n_tied_state\") == 0)\n            m->n_sen = n;\n        else if (strcmp(tag, \"n_tied_tmat\") == 0)\n            m->n_tmat = n;\n        else\n            E_FATAL(\"Unknown header line: %s\\n\", buf);\n    } while ((n_ci < 0) || (n_tri < 0) || (n_map < 0) ||\n             (m->n_ci_sen < 0) || (m->n_sen < 0) || (m->n_tmat < 0));\n\n    if ((n_ci == 0) || (m->n_ci_sen == 0) || (m->n_tmat == 0)\n        || (m->n_ci_sen > m->n_sen))\n        E_FATAL(\"%s: Error in header\\n\", mdeffile);\n\n    /* Check typesize limits */\n    if (n_ci >= MAX_INT16)\n        E_FATAL(\"%s: #CI phones (%d) exceeds limit (%d)\\n\", mdeffile, n_ci,\n                MAX_INT16);\n    if (n_ci + n_tri >= MAX_INT32) /* Comparison is always false... */\n        E_FATAL(\"%s: #Phones (%d) exceeds limit (%d)\\n\", mdeffile,\n                n_ci + n_tri, MAX_INT32);\n    if (m->n_sen >= MAX_INT16)\n        E_FATAL(\"%s: #senones (%d) exceeds limit (%d)\\n\", mdeffile,\n                m->n_sen, MAX_INT16);\n    if (m->n_tmat >= MAX_INT32) /* Comparison is always false... */\n        E_FATAL(\"%s: #tmats (%d) exceeds limit (%d)\\n\", mdeffile,\n                m->n_tmat, MAX_INT32);\n\n    m->n_emit_state = (n_map / (n_ci + n_tri)) - 1;\n    if ((m->n_emit_state + 1) * (n_ci + n_tri) != n_map)\n        E_FATAL\n            (\"Header error: n_state_map not a multiple of n_ci*n_tri\\n\");\n\n    /* Initialize ciphone info */\n    m->n_ciphone = n_ci;\n    m->ciphone_ht = hash_table_new(n_ci, HASH_CASE_YES);  /* With case-insensitive string names *//* freed in mdef_free */\n    m->ciphone = (ciphone_t *) ckd_calloc(n_ci, sizeof(ciphone_t));     /* freed in mdef_free */\n\n    /* Initialize phones info (ciphones + triphones) */\n    m->n_phone = n_ci + n_tri;\n    m->phone = (phone_t *) ckd_calloc(m->n_phone, sizeof(phone_t));     /* freed in mdef_free */\n\n    /* Allocate space for state->senone map for each phone */\n    senmap = ckd_calloc_2d(m->n_phone, m->n_emit_state, sizeof(**senmap));      /* freed in mdef_free */\n    m->sseq = senmap;           /* TEMPORARY; until it is compressed into just the unique ones */\n\n    /* Allocate initial space for <ci,lc,rc,wpos> -> pid mapping */\n    m->wpos_ci_lclist = (ph_lc_t ***) ckd_calloc_2d(N_WORD_POSN, m->n_ciphone, sizeof(ph_lc_t *));      /* freed in mdef_free */\n\n    /*\n     * Read base phones and triphones.  They'll simply be assigned a running sequence\n     * number as their \"phone-id\".  If the phone-id < n_ci, it's a ciphone.\n     */\n\n    /* Read base phones */\n    for (p = 0; p < n_ci; p++) {\n        if (noncomment_line(buf, sizeof(buf), fp) < 0)\n            E_FATAL(\"Premature EOF reading CIphone %d\\n\", p);\n        parse_base_line(m, buf, p);\n    }\n    m->sil = mdef_ciphone_id(m, S3_SILENCE_CIPHONE);\n\n    /* Read triphones, if any */\n    for (; p < m->n_phone; p++) {\n        if (noncomment_line(buf, sizeof(buf), fp) < 0)\n            E_FATAL(\"Premature EOF reading phone %d\\n\", p);\n        parse_tri_line(m, buf, p);\n    }\n\n    if (noncomment_line(buf, sizeof(buf), fp) >= 0)\n        E_ERROR(\"Non-empty file beyond expected #phones (%d)\\n\",\n                m->n_phone);\n\n    /* Build CD senones to CI senones map */\n    if (m->n_ciphone * m->n_emit_state != m->n_ci_sen)\n        E_FATAL\n            (\"#CI-senones(%d) != #CI-phone(%d) x #emitting-states(%d)\\n\",\n             m->n_ci_sen, m->n_ciphone, m->n_emit_state);\n    m->cd2cisen = (int16 *) ckd_calloc(m->n_sen, sizeof(*m->cd2cisen)); /* freed in mdef_free */\n\n    m->sen2cimap = (int16 *) ckd_calloc(m->n_sen, sizeof(*m->sen2cimap)); /* freed in mdef_free */\n\n    for (s = 0; s < m->n_sen; s++)\n        m->sen2cimap[s] = -1;\n    for (s = 0; s < m->n_ci_sen; s++) { /* CI senones */\n        m->cd2cisen[s] = s;\n        m->sen2cimap[s] = s / m->n_emit_state;\n    }\n    for (p = n_ci; p < m->n_phone; p++) {       /* CD senones */\n        for (s = 0; s < m->n_emit_state; s++) {\n            cd = m->sseq[p][s];\n            ci = m->sseq[m->phone[p].ci][s];\n            m->cd2cisen[cd] = ci;\n            m->sen2cimap[cd] = m->phone[p].ci;\n        }\n    }\n\n    sseq_compress(m);\n    fclose(fp);\n\n    return m;\n}\n\nvoid\nmdef_report(mdef_t * m)\n{\n    E_INFO_NOFN(\"Initialization of mdef_t, report:\\n\");\n    E_INFO_NOFN\n        (\"%d CI-phone, %d CD-phone, %d emitstate/phone, %d CI-sen, %d Sen, %d Sen-Seq\\n\",\n         m->n_ciphone, m->n_phone - m->n_ciphone, m->n_emit_state,\n         m->n_ci_sen, m->n_sen, m->n_sseq);\n    E_INFO_NOFN(\"\\n\");\n\n}\n\n/* RAH 4.23.01, Need to step down the ->next list to see if there are\n   any more things to free\n */\n\n\n\n/* RAH 4.19.01, Attempt to free memory that was allocated within this module\n   I have not verified that all the memory has been freed. I've taken only a \n   reasonable effort for now.\n   RAH 4.24.01 - verified that all memory is released.\n */\nvoid\nmdef_free_recursive_lc(ph_lc_t * lc)\n{\n    if (lc == NULL)\n        return;\n\n    if (lc->rclist)\n        mdef_free_recursive_rc(lc->rclist);\n\n    if (lc->next)\n        mdef_free_recursive_lc(lc->next);\n\n    ckd_free((void *) lc);\n}\n\nvoid\nmdef_free_recursive_rc(ph_rc_t * rc)\n{\n    if (rc == NULL)\n        return;\n\n    if (rc->next)\n        mdef_free_recursive_rc(rc->next);\n\n    ckd_free((void *) rc);\n}\n\n\n/* RAH, Free memory that was allocated in mdef_init \n   Rational purify shows that no leaks exist\n */\n\nvoid\nmdef_free(mdef_t * m)\n{\n    int i, j;\n\n    if (m) {\n        if (m->sen2cimap)\n            ckd_free((void *) m->sen2cimap);\n        if (m->cd2cisen)\n            ckd_free((void *) m->cd2cisen);\n\n        /* RAH, go down the ->next list and delete all the pieces */\n        for (i = 0; i < N_WORD_POSN; i++)\n            for (j = 0; j < m->n_ciphone; j++)\n                if (m->wpos_ci_lclist[i][j]) {\n                    mdef_free_recursive_lc(m->wpos_ci_lclist[i][j]->next);\n                    mdef_free_recursive_rc(m->wpos_ci_lclist[i][j]->\n                                           rclist);\n                }\n\n        for (i = 0; i < N_WORD_POSN; i++)\n            for (j = 0; j < m->n_ciphone; j++)\n                if (m->wpos_ci_lclist[i][j])\n                    ckd_free((void *) m->wpos_ci_lclist[i][j]);\n\n\n        if (m->wpos_ci_lclist)\n            ckd_free_2d((void *) m->wpos_ci_lclist);\n        if (m->sseq)\n            ckd_free_2d((void *) m->sseq);\n        /* Free phone context */\n        if (m->phone)\n            ckd_free((void *) m->phone);\n        if (m->ciphone_ht)\n            hash_table_free(m->ciphone_ht);\n\n        for (i = 0; i < m->n_ciphone; i++) {\n            if (m->ciphone[i].name)\n                ckd_free((void *) m->ciphone[i].name);\n        }\n\n\n        if (m->ciphone)\n            ckd_free((void *) m->ciphone);\n\n        ckd_free((void *) m);\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n#include <float.h>\n\n#include <sphinxbase/bio.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n\n#include \"ms_gauden.h\"\n\n#define GAUDEN_PARAM_VERSION\t\"1.0\"\n\n#ifndef M_PI\n#define M_PI\t3.1415926535897932385e0\n#endif\n\n#define WORST_DIST\t(int32)(0x80000000)\n\nvoid\ngauden_dump(const gauden_t * g)\n{\n    int32 c;\n\n    for (c = 0; c < g->n_mgau; c++)\n        gauden_dump_ind(g, c);\n}\n\n\nvoid\ngauden_dump_ind(const gauden_t * g, int senidx)\n{\n    int32 f, d, i;\n\n    for (f = 0; f < g->n_feat; f++) {\n        E_INFO(\"Codebook %d, Feature %d (%dx%d):\\n\",\n               senidx, f, g->n_density, g->featlen[f]);\n\n        for (d = 0; d < g->n_density; d++) {\n            printf(\"m[%3d]\", d);\n            for (i = 0; i < g->featlen[f]; i++)\n                printf(\" %7.4f\", MFCC2FLOAT(g->mean[senidx][f][d][i]));\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n\n        for (d = 0; d < g->n_density; d++) {\n            printf(\"v[%3d]\", d);\n            for (i = 0; i < g->featlen[f]; i++)\n                printf(\" %d\", (int)g->var[senidx][f][d][i]);\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n\n        for (d = 0; d < g->n_density; d++)\n            printf(\"d[%3d] %d\\n\", d, (int)g->det[senidx][f][d]);\n    }\n    fflush(stderr);\n}\n\n/**\n * Reads gaussian parameters from a file\n *\n * @param: out_param   output parameter\n * @\n *\n * @returns: allocated 4-d array of gaussians\n *\n */\nstatic float ****\ngauden_param_read(const char *file_name,\n                  int32 * out_n_mgau,\n                  int32 * out_n_feat,\n                  int32 * out_n_density,\n                  int32 ** out_veclen)\n{\n    char tmp;\n    FILE *fp;\n    int32 i, j, k, l, n, blk;\n    int32 n_mgau;\n    int32 n_feat;\n    int32 n_density;\n    int32 *veclen;\n    int32 byteswap, chksum_present;\n    float32 ****out;\n    float32 *buf;\n    char **argname, **argval;\n    uint32 chksum;\n\n    E_INFO(\"Reading mixture gaussian parameter: %s\\n\", file_name);\n\n    if ((fp = fopen(file_name, \"rb\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open file '%s' for reading\", file_name);\n        return NULL;\n    }\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0) {\n        E_ERROR(\"Failed to read header from file '%s'\\n\", file_name);\n        fclose(fp);\n        return NULL;\n    }\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], GAUDEN_PARAM_VERSION) != 0)\n                E_WARN(\"Version mismatch(%s): %s, expecting %s\\n\",\n                       file_name, argval[i], GAUDEN_PARAM_VERSION);\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            chksum_present = 1; /* Ignore the associated value */\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    /* #Codebooks */\n    if (bio_fread(&n_mgau, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {\n        E_ERROR(\"Failed to read number fo codebooks from %s\\n\", file_name);\n        fclose(fp);\n        return NULL;\n    }\n    *out_n_mgau = n_mgau;\n\n    /* #Features/codebook */\n    if (bio_fread(&n_feat, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {\n        E_ERROR(\"Failed to read number of features from %s\\n\", file_name);\n        fclose(fp);\n        return NULL;\n    }\n    *out_n_feat = n_feat;\n\n    /* #Gaussian densities/feature in each codebook */\n    if (bio_fread(&n_density, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {\n        E_ERROR(\"fread(%s) (#density/codebook) failed\\n\", file_name);\n    }\n    *out_n_density = n_density;\n\n    /* #Dimensions in each feature stream */\n    veclen = ckd_calloc(n_feat, sizeof(uint32));\n    *out_veclen = veclen;\n    if (bio_fread(veclen, sizeof(int32), n_feat, fp, byteswap, &chksum) !=\n        n_feat) {\n        E_ERROR(\"fread(%s) (feature-lengths) failed\\n\", file_name);\n        fclose(fp);\n        return NULL;\n    }\n\n    /* blk = total vector length of all feature streams */\n    for (i = 0, blk = 0; i < n_feat; i++)\n        blk += veclen[i];\n\n    /* #Floats to follow; for the ENTIRE SET of CODEBOOKS */\n    if (bio_fread(&n, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {\n        E_ERROR(\"Failed to read number of parameters from %s\\n\", file_name);\n        fclose(fp);\n        return NULL;\n    }\n\n    if (n != n_mgau * n_density * blk) {\n        E_ERROR\n            (\"Number of parameters in %s(%d) doesn't match dimensions: %d x %d x %d\\n\",\n             file_name, n, n_mgau, n_density, blk);\n        fclose(fp);\n        return NULL;\n    }\n\n    /* Allocate memory for mixture gaussian densities if not already allocated */\n    out = (float32 ****) ckd_calloc_3d(n_mgau, n_feat, n_density,\n                                      sizeof(float32 *));\n    buf = (float32 *) ckd_calloc(n, sizeof(float32));\n    for (i = 0, l = 0; i < n_mgau; i++) {\n        for (j = 0; j < n_feat; j++) {\n            for (k = 0; k < n_density; k++) {\n                out[i][j][k] = &buf[l];\n                l += veclen[j];\n            }\n        }\n    }\n\n    /* Read mixture gaussian densities data */\n    if (bio_fread(buf, sizeof(float32), n, fp, byteswap, &chksum) != n) {\n        E_ERROR(\"Failed to read density data from file '%s'\\n\", file_name);\n        fclose(fp);\n        ckd_free_3d(out);\n        return NULL;\n    }\n\n    if (chksum_present)\n        bio_verify_chksum(fp, byteswap, chksum);\n\n    if (fread(&tmp, 1, 1, fp) == 1) {\n        E_ERROR(\"More data than expected in %s\\n\", file_name);\n        fclose(fp);\n        ckd_free_3d(out);\n        return NULL;\n    }\n\n    fclose(fp);\n\n    E_INFO(\"%d codebook, %d feature, size: \\n\", n_mgau, n_feat);\n    for (i = 0; i < n_feat; i++)\n        E_INFO(\" %dx%d\\n\", n_density, veclen[i]);\n\n    return out;\n}\n\nstatic void\ngauden_param_free(mfcc_t **** p)\n{\n    ckd_free(p[0][0][0]);\n    ckd_free_3d(p);\n}\n\n/*\n * Some of the gaussian density computation can be carried out in advance:\n * \tlog(determinant) calculation,\n * \t1/(2*var) in the exponent,\n * NOTE; The density computation is performed in log domain.\n */\nstatic int32\ngauden_dist_precompute(gauden_t * g, logmath_t *lmath, float32 varfloor)\n{\n    int32 i, m, f, d, flen;\n    mfcc_t *meanp;\n    mfcc_t *varp;\n    mfcc_t *detp;\n    int32 floored;\n\n    floored = 0;\n    /* Allocate space for determinants */\n    g->det = ckd_calloc_3d(g->n_mgau, g->n_feat, g->n_density, sizeof(***g->det));\n\n    for (m = 0; m < g->n_mgau; m++) {\n        for (f = 0; f < g->n_feat; f++) {\n            flen = g->featlen[f];\n\n            /* Determinants for all variance vectors in g->[m][f] */\n            for (d = 0, detp = g->det[m][f]; d < g->n_density; d++, detp++) {\n                *detp = 0;\n                for (i = 0, varp = g->var[m][f][d], meanp = g->mean[m][f][d];\n                     i < flen; i++, varp++, meanp++) {\n                    float32 *fvarp = (float32 *)varp;\n\n#ifdef FIXED_POINT\n                    float32 *fmp = (float32 *)meanp;\n                    *meanp = FLOAT2MFCC(*fmp);\n#endif\n                    if (*fvarp < varfloor) {\n                        *fvarp = varfloor;\n                        ++floored;\n                    }\n                    *detp += (mfcc_t)logmath_log(lmath,\n                                                 1.0 / sqrt(*fvarp * 2.0 * M_PI));\n                    /* Precompute this part of the exponential */\n                    *varp = (mfcc_t)logmath_ln_to_log(lmath,\n                                                      (1.0 / (*fvarp * 2.0)));\n                }\n            }\n        }\n    }\n\n    E_INFO(\"%d variance values floored\\n\", floored);\n\n    return 0;\n}\n\n\ngauden_t *\ngauden_init(char const *meanfile, char const *varfile, float32 varfloor, logmath_t *lmath)\n{\n    int32 i, m, f, d, *flen;\n    gauden_t *g;\n\n    assert(meanfile != NULL);\n    assert(varfile != NULL);\n    assert(varfloor > 0.0);\n\n    g = (gauden_t *) ckd_calloc(1, sizeof(gauden_t));\n    g->lmath = lmath;\n\n    g->mean = (mfcc_t ****)gauden_param_read(meanfile, &g->n_mgau, &g->n_feat, &g->n_density,\n                      &g->featlen);\n    if (g->mean == NULL) {\n\treturn NULL;\n    }\n    g->var = (mfcc_t ****)gauden_param_read(varfile, &m, &f, &d, &flen);\n    if (g->var == NULL) {\n\treturn NULL;\n    }\n\n    /* Verify mean and variance parameter dimensions */\n    if ((m != g->n_mgau) || (f != g->n_feat) || (d != g->n_density)) {\n        E_ERROR\n            (\"Mixture-gaussians dimensions for means and variances differ\\n\");\n        ckd_free(flen);\n        gauden_free(g);\n        return NULL;\n    }\n    for (i = 0; i < g->n_feat; i++) {\n        if (g->featlen[i] != flen[i]) {\n            E_FATAL(\"Feature lengths for means and variances differ\\n\");\n            ckd_free(flen);\n            gauden_free(g);\n            return NULL;\n        }\n    }\n\n    ckd_free(flen);\n\n    gauden_dist_precompute(g, lmath, varfloor);\n\n    return g;\n}\n\nvoid\ngauden_free(gauden_t * g)\n{\n    if (g == NULL)\n        return;\n    if (g->mean)\n        gauden_param_free(g->mean);\n    if (g->var)\n        gauden_param_free(g->var);\n    if (g->det)\n        ckd_free_3d(g->det);\n    if (g->featlen)\n        ckd_free(g->featlen);\n    ckd_free(g);\n}\n\n/* See compute_dist below */\nstatic int32\ncompute_dist_all(gauden_dist_t * out_dist, mfcc_t* obs, int32 featlen,\n                 mfcc_t ** mean, mfcc_t ** var, mfcc_t * det,\n                 int32 n_density)\n{\n    int32 i, d;\n\n    for (d = 0; d < n_density; ++d) {\n        mfcc_t *m;\n        mfcc_t *v;\n        mfcc_t dval;\n\n        m = mean[d];\n        v = var[d];\n        dval = det[d];\n\n        for (i = 0; i < featlen; i++) {\n            mfcc_t diff;\n#ifdef FIXED_POINT\n            /* Have to check for underflows here. */\n            mfcc_t pdval = dval;\n            diff = obs[i] - m[i];\n            dval -= MFCCMUL(MFCCMUL(diff, diff), v[i]);\n            if (dval > pdval) {\n                dval = WORST_SCORE;\n                break;\n            }\n#else\n            diff = obs[i] - m[i];\n            /* The compiler really likes this to be a single\n             * expression, for whatever reason. */\n            dval -= diff * diff * v[i];\n#endif\n        }\n\n        out_dist[d].dist = dval;\n        out_dist[d].id = d;\n    }\n\n    return 0;\n}\n\n\n/*\n * Compute the top-N closest gaussians from the chosen set (mgau,feat)\n * for the given input observation vector.\n */\nstatic int32\ncompute_dist(gauden_dist_t * out_dist, int32 n_top,\n             mfcc_t * obs, int32 featlen,\n             mfcc_t ** mean, mfcc_t ** var, mfcc_t * det,\n             int32 n_density)\n{\n    int32 i, j, d;\n    gauden_dist_t *worst;\n\n    /* Special case optimization when n_density <= n_top */\n    if (n_top >= n_density)\n        return (compute_dist_all\n                (out_dist, obs, featlen, mean, var, det, n_density));\n\n    for (i = 0; i < n_top; i++)\n        out_dist[i].dist = WORST_DIST;\n    worst = &(out_dist[n_top - 1]);\n\n    for (d = 0; d < n_density; d++) {\n        mfcc_t *m;\n        mfcc_t *v;\n        mfcc_t dval;\n\n        m = mean[d];\n        v = var[d];\n        dval = det[d];\n\n        for (i = 0; (i < featlen) && (dval >= worst->dist); i++) {\n            mfcc_t diff;\n#ifdef FIXED_POINT\n            /* Have to check for underflows here. */\n            mfcc_t pdval = dval;\n            diff = obs[i] - m[i];\n            dval -= MFCCMUL(MFCCMUL(diff, diff), v[i]);\n            if (dval > pdval) {\n                dval = WORST_SCORE;\n                break;\n            }\n#else\n            diff = obs[i] - m[i];\n            /* The compiler really likes this to be a single\n             * expression, for whatever reason. */\n            dval -= diff * diff * v[i];\n#endif\n        }\n\n        if ((i < featlen) || (dval < worst->dist))     /* Codeword d worse than worst */\n            continue;\n\n        /* Codeword d at least as good as worst so far; insert in the ordered list */\n        for (i = 0; (i < n_top) && (dval < out_dist[i].dist); i++);\n        assert(i < n_top);\n        for (j = n_top - 1; j > i; --j)\n            out_dist[j] = out_dist[j - 1];\n        out_dist[i].dist = dval;\n        out_dist[i].id = d;\n    }\n\n    return 0;\n}\n\n\n/*\n * Compute distances of the input observation from the top N codewords in the given\n * codebook (g->{mean,var}[mgau]).  The input observation, obs, includes vectors for\n * all features in the codebook.\n */\nint32\ngauden_dist(gauden_t * g,\n            int mgau, int32 n_top, mfcc_t** obs, gauden_dist_t ** out_dist)\n{\n    int32 f;\n\n    assert((n_top > 0) && (n_top <= g->n_density));\n\n    for (f = 0; f < g->n_feat; f++) {\n        compute_dist(out_dist[f], n_top,\n                     obs[f], g->featlen[f],\n                     g->mean[mgau][f], g->var[mgau][f], g->det[mgau][f],\n                     g->n_density);\n        E_DEBUG(\"Top CW(%d,%d) = %d %d\\n\", mgau, f, out_dist[f][0].id,\n                (int)out_dist[f][0].dist >> SENSCR_SHIFT);\n    }\n\n    return 0;\n}\n\nint32\ngauden_mllr_transform(gauden_t *g, ps_mllr_t *mllr, cmd_ln_t *config)\n{\n    int32 i, m, f, d, *flen;\n\n    /* Free data if already here */\n    if (g->mean)\n        gauden_param_free(g->mean);\n    if (g->var)\n        gauden_param_free(g->var);\n    if (g->det)\n        ckd_free_3d(g->det);\n    if (g->featlen)\n        ckd_free(g->featlen);\n    g->det = NULL;\n    g->featlen = NULL;\n\n    /* Reload means and variances (un-precomputed). */\n    g->mean = (mfcc_t ****)gauden_param_read(cmd_ln_str_r(config, \"_mean\"), &g->n_mgau, &g->n_feat, &g->n_density,\n                      &g->featlen);\n    g->var = (mfcc_t ****)gauden_param_read(cmd_ln_str_r(config, \"_var\"), &m, &f, &d, &flen);\n\n    /* Verify mean and variance parameter dimensions */\n    if ((m != g->n_mgau) || (f != g->n_feat) || (d != g->n_density))\n        E_FATAL\n            (\"Mixture-gaussians dimensions for means and variances differ\\n\");\n    for (i = 0; i < g->n_feat; i++)\n        if (g->featlen[i] != flen[i])\n            E_FATAL(\"Feature lengths for means and variances differ\\n\");\n    ckd_free(flen);\n\n    /* Transform codebook for each stream s */\n    for (i = 0; i < g->n_mgau; ++i) {\n        for (f = 0; f < g->n_feat; ++f) {\n            float64 *temp;\n            temp = (float64 *) ckd_calloc(g->featlen[f], sizeof(float64));\n            /* Transform each density d in selected codebook */\n            for (d = 0; d < g->n_density; d++) {\n                int l;\n                for (l = 0; l < g->featlen[f]; l++) {\n                    temp[l] = 0.0;\n                    for (m = 0; m < g->featlen[f]; m++) {\n                        /* FIXME: For now, only one class, hence the zeros below. */\n                        temp[l] += mllr->A[f][0][l][m] * g->mean[i][f][d][m];\n                    }\n                    temp[l] += mllr->b[f][0][l];\n                }\n\n                for (l = 0; l < g->featlen[f]; l++) {\n                    g->mean[i][f][d][l] = (float32) temp[l];\n                    g->var[i][f][d][l] *= mllr->h[f][0][l];\n                }\n            }\n            ckd_free(temp);\n        }\n    }\n\n    /* Re-precompute (if we aren't adapting variances this isn't\n     * actually necessary...) */\n    gauden_dist_precompute(g, g->lmath, cmd_ln_float32_r(config, \"-varfloor\"));\n    return 0;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * ms_mgau.c -- Essentially a wrapper that wrap up gauden and\n * senone. It supports multi-stream. \n *\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1997 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * HISTORY\n * $Log$\n * Revision 1.2  2006/02/22  16:56:01  arthchan2003\n * Merged from SPHINX3_5_2_RCI_IRII_BRANCH: Added ms_mgau.[ch] into the trunk. It is a wrapper of ms_gauden and ms_senone\n * \n * Revision 1.1.2.4  2005/09/25 18:55:19  arthchan2003\n * Added a flag to turn on and off precomputation.\n *\n * Revision 1.1.2.3  2005/08/03 18:53:44  dhdfu\n * Add memory deallocation functions.  Also move all the initialization\n * of ms_mgau_model_t into ms_mgau_init (duh!), which entails removing it\n * from decode_anytopo and friends.\n *\n * Revision 1.1.2.2  2005/08/02 21:05:38  arthchan2003\n * 1, Added dist and mgau_active as intermediate variable for computation. 2, Added ms_cont_mgau_frame_eval, which is a multi stream version of GMM computation mainly s3.0 family of tools. 3, Fixed dox-doc.\n *\n * Revision 1.1.2.1  2005/07/20 19:37:09  arthchan2003\n * Added a multi-stream cont_mgau (ms_mgau) which is a wrapper of both gauden and senone.  Add ms_mgau_init and model_set_mllr.  This allow eliminating 600 lines of code in decode_anytopo/align/allphone.\n *\n *\n *\n */\n\n/* Local headers. */\n#include \"ms_mgau.h\"\n\nstatic ps_mgaufuncs_t ms_mgau_funcs = {\n    \"ms\",\n    ms_cont_mgau_frame_eval, /* frame_eval */\n    ms_mgau_mllr_transform,  /* transform */\n    ms_mgau_free             /* free */\n};\n\nps_mgau_t *\nms_mgau_init(acmod_t *acmod, logmath_t *lmath, bin_mdef_t *mdef)\n{\n    /* Codebooks */\n    ms_mgau_model_t *msg;\n    ps_mgau_t *mg;\n    gauden_t *g;\n    senone_t *s;\n    cmd_ln_t *config;\n    int i;\n\n    config = acmod->config;\n\n    msg = (ms_mgau_model_t *) ckd_calloc(1, sizeof(ms_mgau_model_t));\n    msg->config = config;\n    msg->g = NULL;\n    msg->s = NULL;\n    \n    if ((g = msg->g = gauden_init(cmd_ln_str_r(config, \"_mean\"),\n                             cmd_ln_str_r(config, \"_var\"),\n                             cmd_ln_float32_r(config, \"-varfloor\"),\n                             lmath)) == NULL) {\n\tE_ERROR(\"Failed to read means and variances\\n\");\t\n\tgoto error_out;\n    }\n\n    /* Verify n_feat and veclen, against acmod. */\n    if (g->n_feat != feat_dimension1(acmod->fcb)) {\n        E_ERROR(\"Number of streams does not match: %d != %d\\n\",\n                g->n_feat, feat_dimension1(acmod->fcb));\n        goto error_out;\n    }\n    for (i = 0; i < g->n_feat; ++i) {\n        if (g->featlen[i] != feat_dimension2(acmod->fcb, i)) {\n            E_ERROR(\"Dimension of stream %d does not match: %d != %d\\n\", i,\n                    g->featlen[i], feat_dimension2(acmod->fcb, i));\n            goto error_out;\n        }\n    }\n\n    s = msg->s = senone_init(msg->g,\n                             cmd_ln_str_r(config, \"_mixw\"),\n                             cmd_ln_str_r(config, \"_senmgau\"),\n                             cmd_ln_float32_r(config, \"-mixwfloor\"),\n                             lmath, mdef);\n\n    s->aw = cmd_ln_int32_r(config, \"-aw\");\n\n    /* Verify senone parameters against gauden parameters */\n    if (s->n_feat != g->n_feat)\n        E_FATAL(\"#Feature mismatch: gauden= %d, senone= %d\\n\", g->n_feat,\n                s->n_feat);\n    if (s->n_cw != g->n_density)\n        E_FATAL(\"#Densities mismatch: gauden= %d, senone= %d\\n\",\n                g->n_density, s->n_cw);\n    if (s->n_gauden > g->n_mgau)\n        E_FATAL(\"Senones need more codebooks (%d) than present (%d)\\n\",\n                s->n_gauden, g->n_mgau);\n    if (s->n_gauden < g->n_mgau)\n        E_ERROR(\"Senones use fewer codebooks (%d) than present (%d)\\n\",\n                s->n_gauden, g->n_mgau);\n\n    msg->topn = cmd_ln_int32_r(config, \"-topn\");\n    E_INFO(\"The value of topn: %d\\n\", msg->topn);\n    if (msg->topn == 0 || msg->topn > msg->g->n_density) {\n        E_WARN\n            (\"-topn argument (%d) invalid or > #density codewords (%d); set to latter\\n\",\n             msg->topn, msg->g->n_density);\n        msg->topn = msg->g->n_density;\n    }\n\n    msg->dist = (gauden_dist_t ***)\n        ckd_calloc_3d(g->n_mgau, g->n_feat, msg->topn,\n                      sizeof(gauden_dist_t));\n    msg->mgau_active = ckd_calloc(g->n_mgau, sizeof(int8));\n\n    mg = (ps_mgau_t *)msg;\n    mg->vt = &ms_mgau_funcs;\n    return mg;\nerror_out:\n    ms_mgau_free(ps_mgau_base(msg));\n    return NULL;    \n}\n\nvoid\nms_mgau_free(ps_mgau_t * mg)\n{\n    ms_mgau_model_t *msg = (ms_mgau_model_t *)mg;\n    if (msg == NULL)\n        return;\n\n    if (msg->g)\n\tgauden_free(msg->g);\n    if (msg->s)\n        senone_free(msg->s);\n    if (msg->dist)\n        ckd_free_3d((void *) msg->dist);\n    if (msg->mgau_active)\n        ckd_free(msg->mgau_active);\n    \n    ckd_free(msg);\n}\n\nint\nms_mgau_mllr_transform(ps_mgau_t *s,\n\t\t       ps_mllr_t *mllr)\n{\n    ms_mgau_model_t *msg = (ms_mgau_model_t *)s;\n    return gauden_mllr_transform(msg->g, mllr, msg->config);\n}\n\nint32\nms_cont_mgau_frame_eval(ps_mgau_t * mg,\n\t\t\tint16 *senscr,\n\t\t\tuint8 *senone_active,\n\t\t\tint32 n_senone_active,\n                        mfcc_t ** feat,\n\t\t\tint32 frame,\n\t\t\tint32 compallsen)\n{\n    ms_mgau_model_t *msg = (ms_mgau_model_t *)mg;\n    int32 gid;\n    int32 topn;\n    int32 best;\n    gauden_t *g;\n    senone_t *sen;\n\n    topn = ms_mgau_topn(msg);\n    g = ms_mgau_gauden(msg);\n    sen = ms_mgau_senone(msg);\n\n    if (compallsen) {\n\tint32 s;\n\n\tfor (gid = 0; gid < g->n_mgau; gid++)\n\t    gauden_dist(g, gid, topn, feat, msg->dist[gid]);\n\n\tbest = (int32) 0x7fffffff;\n\tfor (s = 0; s < sen->n_sen; s++) {\n\t    senscr[s] = senone_eval(sen, s, msg->dist[sen->mgau[s]], topn);\n\t    if (best > senscr[s]) {\n\t\tbest = senscr[s];\n\t    }\n\t}\n\n\t/* Normalize senone scores */\n\tfor (s = 0; s < sen->n_sen; s++) {\n\t    int32 bs = senscr[s] - best;\n\t    if (bs > 32767)\n\t\tbs = 32767;\n\t    if (bs < -32768)\n\t\tbs = -32768;\n\t    senscr[s] = bs;\n\t}\n    }\n    else {\n\tint32 i, n;\n\t/* Flag all active mixture-gaussian codebooks */\n\tfor (gid = 0; gid < g->n_mgau; gid++)\n\t    msg->mgau_active[gid] = 0;\n\n\tn = 0;\n\tfor (i = 0; i < n_senone_active; i++) {\n\t    /* senone_active consists of deltas. */\n\t    int32 s = senone_active[i] + n;\n\t    msg->mgau_active[sen->mgau[s]] = 1;\n\t    n = s;\n\t}\n\n\t/* Compute topn gaussian density values (for active codebooks) */\n\tfor (gid = 0; gid < g->n_mgau; gid++) {\n\t    if (msg->mgau_active[gid])\n\t\tgauden_dist(g, gid, topn, feat, msg->dist[gid]);\n\t}\n\n\tbest = (int32) 0x7fffffff;\n\tn = 0;\n\tfor (i = 0; i < n_senone_active; i++) {\n\t    int32 s = senone_active[i] + n;\n\t    senscr[s] = senone_eval(sen, s, msg->dist[sen->mgau[s]], topn);\n\t    if (best > senscr[s]) {\n\t\tbest = senscr[s];\n\t    }\n\t    n = s;\n\t}\n\n\t/* Normalize senone scores */\n\tn = 0;\n\tfor (i = 0; i < n_senone_active; i++) {\n\t    int32 s = senone_active[i] + n;\n\t    int32 bs = senscr[s] - best;\n\t    if (bs > 32767)\n\t\tbs = 32767;\n\t    if (bs < -32768)\n\t\tbs = -32768;\n\t    senscr[s] = bs;\n\t    n = s;\n\t}\n    }\n\n    return 0;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* System headers. */\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/bio.h>\n\n/* Local headers. */\n#include \"ms_senone.h\"\n\n#define MIXW_PARAM_VERSION\t\"1.0\"\n#define SPDEF_PARAM_VERSION\t\"1.2\"\n\nstatic int32\nsenone_mgau_map_read(senone_t * s, char const *file_name)\n{\n    FILE *fp;\n    int32 byteswap, chksum_present, n_gauden_present;\n    uint32 chksum;\n    int32 i;\n    char eofchk;\n    char **argname, **argval;\n    void *ptr;\n    float32 v;\n\n    E_INFO(\"Reading senone gauden-codebook map file: %s\\n\", file_name);\n\n    if ((fp = fopen(file_name, \"rb\")) == NULL)\n        E_FATAL_SYSTEM(\"Failed to open map file '%s' for reading\", file_name);\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0)\n        E_FATAL(\"Failed to read header from file '%s'\\n\", file_name);\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    n_gauden_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], SPDEF_PARAM_VERSION) != 0) {\n                E_WARN(\"Version mismatch(%s): %s, expecting %s\\n\",\n                       file_name, argval[i], SPDEF_PARAM_VERSION);\n            }\n\n            /* HACK!! Convert version# to float32 and take appropriate action */\n            if (sscanf(argval[i], \"%f\", &v) != 1)\n                E_FATAL(\"%s: Bad version no. string: %s\\n\", file_name,\n                        argval[i]);\n\n            n_gauden_present = (v > 1.1) ? 1 : 0;\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            chksum_present = 1; /* Ignore the associated value */\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    /* Read #gauden (if version matches) */\n    if (n_gauden_present) {\n        E_INFO(\"Reading number of codebooks from %s\\n\", file_name);\n        if (bio_fread\n            (&(s->n_gauden), sizeof(int32), 1, fp, byteswap, &chksum) != 1)\n            E_FATAL(\"fread(%s) (#gauden) failed\\n\", file_name);\n    }\n\n    /* Read 1d array data */\n    if (bio_fread_1d(&ptr, sizeof(uint32), &(s->n_sen), fp,\n\t\t     byteswap, &chksum) < 0) {\n        E_FATAL(\"bio_fread_1d(%s) failed\\n\", file_name);\n    }\n    s->mgau = ptr;\n    E_INFO(\"Mapping %d senones to %d codebooks\\n\", s->n_sen, s->n_gauden);\n\n    /* Infer n_gauden if not present in this version */\n    if (!n_gauden_present) {\n        s->n_gauden = 1;\n        for (i = 0; i < s->n_sen; i++)\n            if (s->mgau[i] >= s->n_gauden)\n                s->n_gauden = s->mgau[i] + 1;\n    }\n\n    if (chksum_present)\n        bio_verify_chksum(fp, byteswap, chksum);\n\n    if (fread(&eofchk, 1, 1, fp) == 1)\n        E_FATAL(\"More data than expected in %s: %d\\n\", file_name, eofchk);\n\n    fclose(fp);\n\n    E_INFO(\"Read %d->%d senone-codebook mappings\\n\", s->n_sen,\n           s->n_gauden);\n\n    return 1;\n}\n\n\nstatic int32\nsenone_mixw_read(senone_t * s, char const *file_name, logmath_t *lmath)\n{\n    char eofchk;\n    FILE *fp;\n    int32 byteswap, chksum_present;\n    uint32 chksum;\n    float32 *pdf;\n    int32 i, f, c, p, n_err;\n    char **argname, **argval;\n\n    E_INFO(\"Reading senone mixture weights: %s\\n\", file_name);\n\n    if ((fp = fopen(file_name, \"rb\")) == NULL)\n        E_FATAL_SYSTEM(\"Failed to open mixture weights file '%s' for reading\", file_name);\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0)\n        E_FATAL(\"Failed to read header from file '%s'\\n\", file_name);\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], MIXW_PARAM_VERSION) != 0)\n                E_WARN(\"Version mismatch(%s): %s, expecting %s\\n\",\n                       file_name, argval[i], MIXW_PARAM_VERSION);\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            chksum_present = 1; /* Ignore the associated value */\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    /* Read #senones, #features, #codewords, arraysize */\n    if ((bio_fread(&(s->n_sen), sizeof(int32), 1, fp, byteswap, &chksum) !=\n         1)\n        ||\n        (bio_fread(&(s->n_feat), sizeof(int32), 1, fp, byteswap, &chksum)\n         != 1)\n        || (bio_fread(&(s->n_cw), sizeof(int32), 1, fp, byteswap, &chksum)\n            != 1)\n        || (bio_fread(&i, sizeof(int32), 1, fp, byteswap, &chksum) != 1)) {\n        E_FATAL(\"bio_fread(%s) (arraysize) failed\\n\", file_name);\n    }\n    if (i != s->n_sen * s->n_feat * s->n_cw) {\n        E_FATAL\n            (\"%s: #float32s(%d) doesn't match dimensions: %d x %d x %d\\n\",\n             file_name, i, s->n_sen, s->n_feat, s->n_cw);\n    }\n\n    /*\n     * Compute #LSB bits to be dropped to represent mixwfloor with 8 bits.\n     * All PDF values will be truncated (in the LSB positions) by these many bits.\n     */\n    if ((s->mixwfloor <= 0.0) || (s->mixwfloor >= 1.0))\n        E_FATAL(\"mixwfloor (%e) not in range (0, 1)\\n\", s->mixwfloor);\n\n    /* Use a fixed shift for compatibility with everything else. */\n    E_INFO(\"Truncating senone logs3(pdf) values by %d bits\\n\", SENSCR_SHIFT);\n\n    /*\n     * Allocate memory for senone PDF data.  Organize normally or transposed depending on\n     * s->n_gauden.\n     */\n    if (s->n_gauden > 1) {\n\tE_INFO(\"Not transposing mixture weights in memory\\n\");\n        s->pdf =\n            (senprob_t ***) ckd_calloc_3d(s->n_sen, s->n_feat, s->n_cw,\n                                          sizeof(senprob_t));\n    }\n    else {\n\tE_INFO(\"Transposing mixture weights in memory\\n\");\n        s->pdf =\n            (senprob_t ***) ckd_calloc_3d(s->n_feat, s->n_cw, s->n_sen,\n                                          sizeof(senprob_t));\n    }\n\n    /* Temporary structure to read in floats */\n    pdf = (float32 *) ckd_calloc(s->n_cw, sizeof(float32));\n\n    /* Read senone probs data, normalize, floor, convert to logs3, truncate to 8 bits */\n    n_err = 0;\n    for (i = 0; i < s->n_sen; i++) {\n        for (f = 0; f < s->n_feat; f++) {\n            if (bio_fread\n                ((void *) pdf, sizeof(float32), s->n_cw, fp, byteswap,\n                 &chksum)\n                != s->n_cw) {\n                E_FATAL(\"bio_fread(%s) (arraydata) failed\\n\", file_name);\n            }\n\n            /* Normalize and floor */\n            if (vector_sum_norm(pdf, s->n_cw) <= 0.0)\n                n_err++;\n            vector_floor(pdf, s->n_cw, s->mixwfloor);\n            vector_sum_norm(pdf, s->n_cw);\n\n            /* Convert to logs3, truncate to 8 bits, and store in s->pdf */\n            for (c = 0; c < s->n_cw; c++) {\n                p = -(logmath_log(lmath, pdf[c]));\n                p += (1 << (SENSCR_SHIFT - 1)) - 1; /* Rounding before truncation */\n\n                if (s->n_gauden > 1)\n                    s->pdf[i][f][c] =\n                        (p < (255 << SENSCR_SHIFT)) ? (p >> SENSCR_SHIFT) : 255;\n                else\n                    s->pdf[f][c][i] =\n                        (p < (255 << SENSCR_SHIFT)) ? (p >> SENSCR_SHIFT) : 255;\n            }\n        }\n    }\n    if (n_err > 0)\n        E_WARN(\"Weight normalization failed for %d mixture weights components\\n\", n_err);\n\n    ckd_free(pdf);\n\n    if (chksum_present)\n        bio_verify_chksum(fp, byteswap, chksum);\n\n    if (fread(&eofchk, 1, 1, fp) == 1)\n        E_FATAL(\"More data than expected in %s\\n\", file_name);\n\n    fclose(fp);\n\n    E_INFO\n        (\"Read mixture weights for %d senones: %d features x %d codewords\\n\",\n         s->n_sen, s->n_feat, s->n_cw);\n\n    return 1;\n}\n\n\nsenone_t *\nsenone_init(gauden_t *g, char const *mixwfile, char const *sen2mgau_map_file,\n\t    float32 mixwfloor, logmath_t *lmath, bin_mdef_t *mdef)\n{\n    senone_t *s;\n    int32 n = 0, i;\n\n    s = (senone_t *) ckd_calloc(1, sizeof(senone_t));\n    s->lmath = logmath_init(logmath_get_base(lmath), SENSCR_SHIFT, TRUE);\n    s->mixwfloor = mixwfloor;\n\n    s->n_gauden = g->n_mgau;\n    if (sen2mgau_map_file) {\n\tif (!(strcmp(sen2mgau_map_file, \".semi.\") == 0\n\t      || strcmp(sen2mgau_map_file, \".ptm.\") == 0\n\t      || strcmp(sen2mgau_map_file, \".cont.\") == 0)) {\n\t    senone_mgau_map_read(s, sen2mgau_map_file);\n\t    n = s->n_sen;\n\t}\n    }\n    else {\n\tif (s->n_gauden == 1)\n\t    sen2mgau_map_file = \".semi.\";\n\telse if (s->n_gauden == bin_mdef_n_ciphone(mdef))\n\t    sen2mgau_map_file = \".ptm.\";\n\telse\n\t    sen2mgau_map_file = \".cont.\";\n    }\n\n    senone_mixw_read(s, mixwfile, lmath);\n\n    if (strcmp(sen2mgau_map_file, \".semi.\") == 0) {\n        /* All-to-1 senones-codebook mapping */\n\tE_INFO(\"Mapping all senones to one codebook\\n\");\n        s->mgau = (uint32 *) ckd_calloc(s->n_sen, sizeof(*s->mgau));\n    }\n    else if (strcmp(sen2mgau_map_file, \".ptm.\") == 0) {\n        /* All-to-ciphone-id senones-codebook mapping */\n\tE_INFO(\"Mapping senones to context-independent phone codebooks\\n\");\n        s->mgau = (uint32 *) ckd_calloc(s->n_sen, sizeof(*s->mgau));\n        for (i = 0; i < s->n_sen; i++)\n\t    s->mgau[i] = bin_mdef_sen2cimap(mdef, i);\n    }\n    else if (strcmp(sen2mgau_map_file, \".cont.\") == 0\n             || strcmp(sen2mgau_map_file, \".s3cont.\") == 0) {\n        /* 1-to-1 senone-codebook mapping */\n\tE_INFO(\"Mapping senones to individual codebooks\\n\");\n        if (s->n_sen <= 1)\n            E_FATAL(\"#senone=%d; must be >1\\n\", s->n_sen);\n\n        s->mgau = (uint32 *) ckd_calloc(s->n_sen, sizeof(*s->mgau));\n        for (i = 0; i < s->n_sen; i++)\n            s->mgau[i] = i;\n\t/* Not sure why this is here, it probably does nothing. */\n        s->n_gauden = s->n_sen;\n    }\n    else {\n        if (s->n_sen != n)\n            E_FATAL(\"#senones inconsistent: %d in %s; %d in %s\\n\",\n                    n, sen2mgau_map_file, s->n_sen, mixwfile);\n    }\n\n    s->featscr = NULL;\n    return s;\n}\n\nvoid\nsenone_free(senone_t * s)\n{\n    if (s == NULL)\n        return;\n    if (s->pdf)\n        ckd_free_3d((void *) s->pdf);\n    if (s->mgau)\n        ckd_free(s->mgau);\n    if (s->featscr)\n        ckd_free(s->featscr);\n    logmath_free(s->lmath);\n    ckd_free(s);\n}\n\n\n/*\n * Compute senone score for one senone.\n * NOTE:  Remember that senone PDF tables contain SCALED, NEGATED logs3 values.\n * NOTE:  Remember also that PDF data may be transposed or not depending on s->n_gauden.\n */\nint32\nsenone_eval(senone_t * s, int id, gauden_dist_t ** dist, int32 n_top)\n{\n    int32 scr;                  /* total senone score */\n    int32 fden;                 /* Gaussian density */\n    int32 fscr;                 /* senone score for one feature */\n    int32 fwscr;                /* senone score for one feature, one codeword */\n    int32 f, t;\n    gauden_dist_t *fdist;\n\n    assert((id >= 0) && (id < s->n_sen));\n    assert((n_top > 0) && (n_top <= s->n_cw));\n\n    scr = 0;\n\n    for (f = 0; f < s->n_feat; f++) {\n#ifdef SPHINX_DEBUG\n        int top;\n#endif\n        fdist = dist[f];\n\n        /* Top codeword for feature f */\n#ifdef SPHINX_DEBUG\n\ttop = \n#endif\n\tfden = ((int32)fdist[0].dist + ((1<<SENSCR_SHIFT) - 1)) >> SENSCR_SHIFT;\n        fscr = (s->n_gauden > 1)\n\t    ? (fden + -s->pdf[id][f][fdist[0].id])  /* untransposed */\n\t    : (fden + -s->pdf[f][fdist[0].id][id]); /* transposed */\n        E_DEBUG(\"fden[%d][%d] l+= %d + %d = %d\\n\",\n                    id, f, -(fscr - fden), -(fden-top), -(fscr-top));\n        /* Remaining of n_top codewords for feature f */\n        for (t = 1; t < n_top; t++) {\n\t    fden = ((int32)fdist[t].dist + ((1<<SENSCR_SHIFT) - 1)) >> SENSCR_SHIFT;\n            fwscr = (s->n_gauden > 1) ?\n                (fden + -s->pdf[id][f][fdist[t].id]) :\n                (fden + -s->pdf[f][fdist[t].id][id]);\n            fscr = logmath_add(s->lmath, fscr, fwscr);\n            E_DEBUG(\"fden[%d][%d] l+= %d + %d = %d\\n\",\n                        id, f, -(fwscr - fden), -(fden-top), -(fscr-top));\n        }\n\t/* Senone scores are also scaled, negated logs3 values.  Hence\n\t * we have to negate the stuff we calculated above. */\n        scr -= fscr;\n    }\n    /* Downscale scores. */\n    scr /= s->aw;\n\n    /* Avoid overflowing int16 */\n    if (scr > 32767)\n      scr = 32767;\n    if (scr < -32768)\n      scr = -32768;\n    return scr;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced\n * Research Projects Agency and the National Science Foundation of the\n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file ngram_search.c N-Gram based multi-pass search (\"FBS\")\n */\n\n/* System headers. */\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/listelem_alloc.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"pocketsphinx_internal.h\"\n#include \"ps_lattice_internal.h\"\n#include \"ngram_search.h\"\n#include \"ngram_search_fwdtree.h\"\n#include \"ngram_search_fwdflat.h\"\n\nstatic int ngram_search_start(ps_search_t *search);\nstatic int ngram_search_step(ps_search_t *search, int frame_idx);\nstatic int ngram_search_finish(ps_search_t *search);\nstatic int ngram_search_reinit(ps_search_t *search, dict_t *dict, dict2pid_t *d2p);\nstatic char const *ngram_search_hyp(ps_search_t *search, int32 *out_score);\nstatic int32 ngram_search_prob(ps_search_t *search);\nstatic ps_seg_t *ngram_search_seg_iter(ps_search_t *search);\n\nstatic ps_searchfuncs_t ngram_funcs = {\n    /* start: */  ngram_search_start,\n    /* step: */   ngram_search_step,\n    /* finish: */ ngram_search_finish,\n    /* reinit: */ ngram_search_reinit,\n    /* free: */   ngram_search_free,\n    /* lattice: */  ngram_search_lattice,\n    /* hyp: */      ngram_search_hyp,\n    /* prob: */     ngram_search_prob,\n    /* seg_iter: */ ngram_search_seg_iter,\n};\n\nstatic ngram_model_t *default_lm;\n\nstatic void\nngram_search_update_widmap(ngram_search_t *ngs)\n{\n    char const **words;\n    int32 i, n_words;\n\n    /* It's okay to include fillers since they won't be in the LM */\n    n_words = ps_search_n_words(ngs);\n    words = (char const**)ckd_calloc(n_words, sizeof(*words));\n    /* This will include alternates, again, that's okay since they aren't in the LM */\n    for (i = 0; i < n_words; ++i)\n        words[i] = dict_wordstr(ps_search_dict(ngs), i);\n    ngram_model_set_map_words(ngs->lmset, words, n_words);\n    ckd_free(words);\n}\n\nstatic void\nngram_search_calc_beams(ngram_search_t *ngs)\n{\n    cmd_ln_t *config;\n    acmod_t *acmod;\n\n    config = ps_search_config(ngs);\n    acmod = ps_search_acmod(ngs);\n\n    /* Log beam widths. */\n    ngs->beam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-beam\"))>>SENSCR_SHIFT;\n    ngs->wbeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-wbeam\"))>>SENSCR_SHIFT;\n    ngs->pbeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-pbeam\"))>>SENSCR_SHIFT;\n    ngs->lpbeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-lpbeam\"))>>SENSCR_SHIFT;\n    ngs->lponlybeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-lponlybeam\"))>>SENSCR_SHIFT;\n    ngs->fwdflatbeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-fwdflatbeam\"))>>SENSCR_SHIFT;\n    ngs->fwdflatwbeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-fwdflatwbeam\"))>>SENSCR_SHIFT;\n\n    /* Absolute pruning parameters. */\n    ngs->maxwpf = cmd_ln_int32_r(config, \"-maxwpf\");\n    ngs->maxhmmpf = cmd_ln_int32_r(config, \"-maxhmmpf\");\n\n    /* Various penalties which may or may not be useful. */\n    ngs->wip = logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-wip\")) >>SENSCR_SHIFT;\n    ngs->nwpen = logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-nwpen\")) >>SENSCR_SHIFT;\n    ngs->pip = logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-pip\")) >>SENSCR_SHIFT;\n    ngs->silpen = ngs->pip\n        + (logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-silprob\"))>>SENSCR_SHIFT);\n    ngs->fillpen = ngs->pip\n        + (logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-fillprob\"))>>SENSCR_SHIFT);\n\n    /* Language weight ratios for fwdflat and bestpath search. */\n    ngs->fwdflat_fwdtree_lw_ratio =\n        cmd_ln_float32_r(config, \"-fwdflatlw\")\n        / cmd_ln_float32_r(config, \"-lw\");\n    ngs->bestpath_fwdtree_lw_ratio =\n        cmd_ln_float32_r(config, \"-bestpathlw\")\n        / cmd_ln_float32_r(config, \"-lw\");\n\n    /* Acoustic score scale for posterior probabilities. */\n    ngs->ascale = 1.0 / cmd_ln_float32_r(config, \"-ascale\");\n}\n\nps_search_t *\nngram_search_init(const char *name,\n                  ngram_model_t *lm,\n                  cmd_ln_t *config,\n                  acmod_t *acmod,\n                  dict_t *dict,\n                  dict2pid_t *d2p)\n{\n    ngram_search_t *ngs;\n    static char *lmname = \"default\";\n\n    /* Make the acmod's feature buffer growable if we are doing two-pass\n     * search. */\n    acmod_set_grow(acmod, cmd_ln_boolean_r(config, \"-fwdflat\") &&\n                          cmd_ln_boolean_r(config, \"-fwdtree\"));\n\n    ngs = ckd_calloc(1, sizeof(*ngs));\n    ps_search_init(&ngs->base, &ngram_funcs, PS_SEARCH_TYPE_NGRAM, name, config, acmod, dict, d2p);\n\n    ngs->hmmctx = hmm_context_init(bin_mdef_n_emit_state(acmod->mdef),\n                                   acmod->tmat->tp, NULL, acmod->mdef->sseq);\n    if (ngs->hmmctx == NULL) {\n        ps_search_free(ps_search_base(ngs));\n        return NULL;\n    }\n    ngs->chan_alloc = listelem_alloc_init(sizeof(chan_t));\n    ngs->root_chan_alloc = listelem_alloc_init(sizeof(root_chan_t));\n    ngs->latnode_alloc = listelem_alloc_init(sizeof(ps_latnode_t));\n\n    /* Calculate various beam widths and such. */\n    ngram_search_calc_beams(ngs);\n\n    /* Allocate a billion different tables for stuff. */\n    ngs->word_chan = ckd_calloc(dict_size(dict),\n                                sizeof(*ngs->word_chan));\n    ngs->word_lat_idx = ckd_calloc(dict_size(dict),\n                                   sizeof(*ngs->word_lat_idx));\n    ngs->word_active = bitvec_alloc(dict_size(dict));\n    ngs->last_ltrans = ckd_calloc(dict_size(dict),\n                                  sizeof(*ngs->last_ltrans));\n\n    /* FIXME: All these structures need to be made dynamic with\n     * garbage collection. */\n    ngs->bp_table_size = cmd_ln_int32_r(config, \"-latsize\");\n    ngs->bp_table = ckd_calloc(ngs->bp_table_size,\n                               sizeof(*ngs->bp_table));\n    /* FIXME: This thing is frickin' huge. */\n    ngs->bscore_stack_size = ngs->bp_table_size * 20;\n    ngs->bscore_stack = ckd_calloc(ngs->bscore_stack_size,\n                                   sizeof(*ngs->bscore_stack));\n    ngs->n_frame_alloc = 256;\n    ngs->bp_table_idx = ckd_calloc(ngs->n_frame_alloc + 1,\n                                   sizeof(*ngs->bp_table_idx));\n    ++ngs->bp_table_idx; /* Make bptableidx[-1] valid */\n\n    /* Allocate active word list array */\n    ngs->active_word_list = ckd_calloc_2d(2, dict_size(dict),\n                                          sizeof(**ngs->active_word_list));\n\n    ngs->lmset = ngram_model_set_init(config, &lm, &lmname, NULL, 1);\n    if (!ngs->lmset)\n        goto error_out;\n\n    if (ngram_wid(ngs->lmset, S3_FINISH_WORD) ==\n        ngram_unknown_wid(ngs->lmset))\n    {\n        E_ERROR(\"Language model/set does not contain </s>, \"\n                \"recognition will fail\\n\");\n        goto error_out;\n    }\n\n    /* Create word mappings. */\n    ngram_search_update_widmap(ngs);\n\n    /* Initialize fwdtree, fwdflat, bestpath modules if necessary. */\n    if (cmd_ln_boolean_r(config, \"-fwdtree\")) {\n        ngram_fwdtree_init(ngs);\n        ngs->fwdtree = TRUE;\n        ngs->fwdtree_perf.name = \"fwdtree\";\n        ptmr_init(&ngs->fwdtree_perf);\n    }\n    if (cmd_ln_boolean_r(config, \"-fwdflat\")) {\n        ngram_fwdflat_init(ngs);\n        ngs->fwdflat = TRUE;\n        ngs->fwdflat_perf.name = \"fwdflat\";\n        ptmr_init(&ngs->fwdflat_perf);\n    }\n    if (cmd_ln_boolean_r(config, \"-bestpath\")) {\n        ngs->bestpath = TRUE;\n        ngs->bestpath_perf.name = \"bestpath\";\n        ptmr_init(&ngs->bestpath_perf);\n    }\n\n    return (ps_search_t *)ngs;\n\nerror_out:\n    ngram_search_free((ps_search_t *)ngs);\n    return NULL;\n}\n\nstatic int\nngram_search_reinit(ps_search_t *search, dict_t *dict, dict2pid_t *d2p)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n    int old_n_words;\n    int rv = 0;\n\n    /* Update the number of words. */\n    old_n_words = search->n_words;\n    if (old_n_words != dict_size(dict)) {\n        search->n_words = dict_size(dict);\n        /* Reallocate these temporary arrays. */\n        ckd_free(ngs->word_lat_idx);\n        ckd_free(ngs->word_active);\n        ckd_free(ngs->last_ltrans);\n        ckd_free_2d(ngs->active_word_list);\n        ngs->word_lat_idx = ckd_calloc(search->n_words, sizeof(*ngs->word_lat_idx));\n        ngs->word_active = bitvec_alloc(search->n_words);\n        ngs->last_ltrans = ckd_calloc(search->n_words, sizeof(*ngs->last_ltrans));\n        ngs->active_word_list\n            = ckd_calloc_2d(2, search->n_words,\n                            sizeof(**ngs->active_word_list));\n    }\n\n    /* Free old dict2pid, dict */\n    ps_search_base_reinit(search, dict, d2p);\n\n    if (ngs->lmset == NULL)\n        return 0;\n\n    /* Update beam widths. */\n    ngram_search_calc_beams(ngs);\n\n    /* Update word mappings. */\n    ngram_search_update_widmap(ngs);\n\n    /* Now rebuild lextrees. */\n    if (ngs->fwdtree) {\n        if ((rv = ngram_fwdtree_reinit(ngs)) < 0)\n            return rv;\n    }\n    if (ngs->fwdflat) {\n        if ((rv = ngram_fwdflat_reinit(ngs)) < 0)\n            return rv;\n    }\n\n    return rv;\n}\n\nvoid\nngram_search_free(ps_search_t *search)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n    \n    if (ngs->fwdtree)\n        ngram_fwdtree_deinit(ngs);\n    if (ngs->fwdflat)\n        ngram_fwdflat_deinit(ngs);\n    if (ngs->bestpath) {\n        double n_speech = (double)ngs->n_tot_frame\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n\n        E_INFO(\"TOTAL bestpath %.2f CPU %.3f xRT\\n\",\n               ngs->bestpath_perf.t_tot_cpu,\n               ngs->bestpath_perf.t_tot_cpu / n_speech);\n        E_INFO(\"TOTAL bestpath %.2f wall %.3f xRT\\n\",\n               ngs->bestpath_perf.t_tot_elapsed,\n               ngs->bestpath_perf.t_tot_elapsed / n_speech);\n    }\n\n    ps_search_base_free(search);\n    hmm_context_free(ngs->hmmctx);\n    listelem_alloc_free(ngs->chan_alloc);\n    listelem_alloc_free(ngs->root_chan_alloc);\n    listelem_alloc_free(ngs->latnode_alloc);\n    ngram_model_free(ngs->lmset);\n\n    ckd_free(ngs->word_chan);\n    ckd_free(ngs->word_lat_idx);\n    bitvec_free(ngs->word_active);\n    ckd_free(ngs->bp_table);\n    ckd_free(ngs->bscore_stack);\n    if (ngs->bp_table_idx != NULL)\n        ckd_free(ngs->bp_table_idx - 1);\n    ckd_free_2d(ngs->active_word_list);\n    ckd_free(ngs->last_ltrans);\n    ckd_free(ngs);\n}\n\nint\nngram_search_mark_bptable(ngram_search_t *ngs, int frame_idx)\n{\n    if (frame_idx >= ngs->n_frame_alloc) {\n        ngs->n_frame_alloc *= 2;\n        ngs->bp_table_idx = ckd_realloc(ngs->bp_table_idx - 1,\n                                        (ngs->n_frame_alloc + 1)\n                                        * sizeof(*ngs->bp_table_idx));\n        if (ngs->frm_wordlist) {\n            ngs->frm_wordlist = ckd_realloc(ngs->frm_wordlist,\n                                            ngs->n_frame_alloc\n                                            * sizeof(*ngs->frm_wordlist));\n        }\n        ++ngs->bp_table_idx; /* Make bptableidx[-1] valid */\n    }\n    ngs->bp_table_idx[frame_idx] = ngs->bpidx;\n    return ngs->bpidx;\n}\n\nstatic void\nset_real_wid(ngram_search_t *ngs, int32 bp)\n{\n    bptbl_t *ent, *prev;\n\n    assert(bp != NO_BP);\n    ent = ngs->bp_table + bp;\n    if (ent->bp == NO_BP)\n        prev = NULL;\n    else\n        prev = ngs->bp_table + ent->bp;\n\n    /* Propagate lm state for fillers, rotate it for words. */\n    if (dict_filler_word(ps_search_dict(ngs), ent->wid)) {\n        if (prev != NULL) {\n            ent->real_wid = prev->real_wid;\n            ent->prev_real_wid = prev->prev_real_wid;\n        }\n        else {\n            ent->real_wid = dict_basewid(ps_search_dict(ngs),\n                                         ent->wid);\n            ent->prev_real_wid = BAD_S3WID;\n        }\n    }\n    else {\n        ent->real_wid = dict_basewid(ps_search_dict(ngs), ent->wid);\n        if (prev != NULL)\n            ent->prev_real_wid = prev->real_wid;\n        else\n            ent->prev_real_wid = BAD_S3WID;\n    }\n}\n\n#define NGRAM_HISTORY_LONG_WORD 2000 /* 20s */\n\nvoid\nngram_search_save_bp(ngram_search_t *ngs, int frame_idx,\n                     int32 w, int32 score, int32 path, int32 rc)\n{\n    int32 bp;\n\n    /* Look for an existing exit for this word in this frame.  The\n     * only reason one would exist is from a different right context\n     * triphone, but of course that happens quite frequently. */\n    bp = ngs->word_lat_idx[w];\n    if (bp != NO_BP) {\n\n        if (frame_idx - ngs->bp_table[path].frame > NGRAM_HISTORY_LONG_WORD) {\n    \t    E_WARN(\"Word '%s' survived for %d frames, potential overpruning\\n\", dict_wordstr(ps_search_dict(ngs), w),\n\t    \t    frame_idx - ngs->bp_table[path].frame);\n\t}\n\n        /* Keep only the best scoring one, we will reconstruct the\n         * others from the right context scores - usually the history\n         * is not lost. */\n        if (ngs->bp_table[bp].score WORSE_THAN score) {\n            assert(path != bp); /* Pathological. */\n            if (ngs->bp_table[bp].bp != path) {\n                int32 bplh[2], newlh[2];\n                /* But, sometimes, the history *is* lost.  If we wanted to\n                 * do exact language model scoring we'd have to preserve\n                 * these alternate histories. */\n                E_DEBUG(\"Updating path history %d => %d frame %d\\n\",\n                        ngs->bp_table[bp].bp, path, frame_idx);\n                bplh[0] = ngs->bp_table[bp].bp == -1\n                    ? -1 : ngs->bp_table[ngs->bp_table[bp].bp].prev_real_wid;\n                bplh[1] = ngs->bp_table[bp].bp == -1\n                    ? -1 : ngs->bp_table[ngs->bp_table[bp].bp].real_wid;\n                newlh[0] = path == -1\n                    ? -1 : ngs->bp_table[path].prev_real_wid;\n                newlh[1] = path == -1\n                    ? -1 : ngs->bp_table[path].real_wid;\n                /* Actually it's worth checking how often the actual\n                 * language model state changes. */\n                if (bplh[0] != newlh[0] || bplh[1] != newlh[1]) {\n                    /* It's fairly rare that the actual language model\n                     * state changes, but it does happen some\n                     * times. */\n                    E_DEBUG(\"Updating language model state %s,%s => %s,%s frame %d\\n\",\n                                dict_wordstr(ps_search_dict(ngs), bplh[0]),\n                                dict_wordstr(ps_search_dict(ngs), bplh[1]),\n                                dict_wordstr(ps_search_dict(ngs), newlh[0]),\n                                dict_wordstr(ps_search_dict(ngs), newlh[1]),\n                                frame_idx);\n                    set_real_wid(ngs, bp);\n                }\n                ngs->bp_table[bp].bp = path;\n            }\n            ngs->bp_table[bp].score = score;\n        }\n        /* But do keep track of scores for all right contexts, since\n         * we need them to determine the starting path scores for any\n         * successors of this word exit. */\n        if (ngs->bp_table[bp].s_idx != -1)\n            ngs->bscore_stack[ngs->bp_table[bp].s_idx + rc] = score;\n    }\n    else {\n        int32 i, rcsize;\n        bptbl_t *be;\n\n        /* This might happen if recognition fails. */\n        if (ngs->bpidx == NO_BP) {\n            E_ERROR(\"No entries in backpointer table!\");\n            return;\n        }\n\n        /* Expand the backpointer tables if necessary. */\n        if (ngs->bpidx >= ngs->bp_table_size) {\n            ngs->bp_table_size *= 2;\n            ngs->bp_table = ckd_realloc(ngs->bp_table,\n                                        ngs->bp_table_size\n                                        * sizeof(*ngs->bp_table));\n            E_INFO(\"Resized backpointer table to %d entries\\n\", ngs->bp_table_size);\n        }\n        if (ngs->bss_head >= ngs->bscore_stack_size\n            - bin_mdef_n_ciphone(ps_search_acmod(ngs)->mdef)) {\n            ngs->bscore_stack_size *= 2;\n            ngs->bscore_stack = ckd_realloc(ngs->bscore_stack,\n                                            ngs->bscore_stack_size\n                                            * sizeof(*ngs->bscore_stack));\n            E_INFO(\"Resized score stack to %d entries\\n\", ngs->bscore_stack_size);\n        }\n\n        ngs->word_lat_idx[w] = ngs->bpidx;\n        be = &(ngs->bp_table[ngs->bpidx]);\n        be->wid = w;\n        be->frame = frame_idx;\n        be->bp = path;\n        be->score = score;\n        be->s_idx = ngs->bss_head;\n        be->valid = TRUE;\n        assert(path != ngs->bpidx);\n\n        /* DICT2PID */\n        /* Get diphone ID for final phone and number of ssids corresponding to it. */\n        be->last_phone = dict_last_phone(ps_search_dict(ngs),w);\n        if (dict_is_single_phone(ps_search_dict(ngs), w)) {\n            be->last2_phone = -1;\n            be->s_idx = -1;\n            rcsize = 0;\n        }\n        else {\n            be->last2_phone = dict_second_last_phone(ps_search_dict(ngs),w);\n            rcsize = dict2pid_rssid(ps_search_dict2pid(ngs),\n                                    be->last_phone, be->last2_phone)->n_ssid;\n        }\n        /* Allocate some space on the bscore_stack for all of these triphones. */\n        for (i = 0; i < rcsize; ++i)\n            ngs->bscore_stack[ngs->bss_head + i] = WORST_SCORE;\n        if (rcsize)\n            ngs->bscore_stack[ngs->bss_head + rc] = score;\n        set_real_wid(ngs, ngs->bpidx);\n\n        ngs->bpidx++;\n        ngs->bss_head += rcsize;\n    }\n}\n\nint\nngram_search_find_exit(ngram_search_t *ngs, int frame_idx, int32 *out_best_score)\n{\n    /* End of backpointers for this frame. */\n    int end_bpidx;\n    int best_exit, bp;\n    int32 best_score;\n\n    /* No hypothesis means no exit node! */\n    if (ngs->n_frame == 0)\n        return NO_BP;\n\n    if (frame_idx == -1 || frame_idx >= ngs->n_frame)\n        frame_idx = ngs->n_frame - 1;\n    end_bpidx = ngs->bp_table_idx[frame_idx];\n\n    best_score = WORST_SCORE;\n    best_exit = NO_BP;\n\n    /* Scan back to find a frame with some backpointers in it. */\n    while (frame_idx >= 0 && ngs->bp_table_idx[frame_idx] == end_bpidx)\n        --frame_idx;\n    /* This is NOT an error, it just means there is no hypothesis yet. */\n    if (frame_idx < 0)\n        return NO_BP;\n\n    /* Now find the entry for </s> OR the best scoring entry. */\n    assert(end_bpidx < ngs->bp_table_size);\n    for (bp = ngs->bp_table_idx[frame_idx]; bp < end_bpidx; ++bp) {\n        if (ngs->bp_table[bp].wid == ps_search_finish_wid(ngs)\n            || ngs->bp_table[bp].score BETTER_THAN best_score) {\n            best_score = ngs->bp_table[bp].score;\n            best_exit = bp;\n        }\n        if (ngs->bp_table[bp].wid == ps_search_finish_wid(ngs))\n            break;\n    }\n\n    if (out_best_score) {\n\t*out_best_score = best_score;\n    }\n    return best_exit;\n}\n\nchar const *\nngram_search_bp_hyp(ngram_search_t *ngs, int bpidx)\n{\n    ps_search_t *base = ps_search_base(ngs);\n    char *c;\n    size_t len;\n    int bp;\n\n    if (bpidx == NO_BP)\n        return NULL;\n\n    bp = bpidx;\n    len = 0;\n    while (bp != NO_BP) {\n        bptbl_t *be = &ngs->bp_table[bp];\n        bp = be->bp;\n        if (dict_real_word(ps_search_dict(ngs), be->wid))\n            len += strlen(dict_basestr(ps_search_dict(ngs), be->wid)) + 1;\n    }\n\n    ckd_free(base->hyp_str);\n    if (len == 0) {\n\tbase->hyp_str = NULL;\n\treturn base->hyp_str;\n    }\n    base->hyp_str = ckd_calloc(1, len);\n\n    bp = bpidx;\n    c = base->hyp_str + len - 1;\n    while (bp != NO_BP) {\n        bptbl_t *be = &ngs->bp_table[bp];\n        size_t len;\n\n        bp = be->bp;\n        if (dict_real_word(ps_search_dict(ngs), be->wid)) {\n            len = strlen(dict_basestr(ps_search_dict(ngs), be->wid));\n            c -= len;\n            memcpy(c, dict_basestr(ps_search_dict(ngs), be->wid), len);\n            if (c > base->hyp_str) {\n                --c;\n                *c = ' ';\n            }\n        }\n    }\n\n    return base->hyp_str;\n}\n\nvoid\nngram_search_alloc_all_rc(ngram_search_t *ngs, int32 w)\n{\n    chan_t *hmm, *thmm;\n    xwdssid_t *rssid;\n    int32 i, tmatid, ciphone;\n\n    /* DICT2PID */\n    /* Get pointer to array of triphones for final diphone. */\n    assert(!dict_is_single_phone(ps_search_dict(ngs), w));\n    ciphone = dict_last_phone(ps_search_dict(ngs),w);\n    rssid = dict2pid_rssid(ps_search_dict2pid(ngs),\n                           ciphone,\n                           dict_second_last_phone(ps_search_dict(ngs),w));\n    tmatid = bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, ciphone);\n    hmm = ngs->word_chan[w];\n    if ((hmm == NULL) || (hmm_nonmpx_ssid(&hmm->hmm) != rssid->ssid[0])) {\n        hmm = listelem_malloc(ngs->chan_alloc);\n        hmm->next = ngs->word_chan[w];\n        ngs->word_chan[w] = hmm;\n\n        hmm->info.rc_id = 0;\n        hmm->ciphone = ciphone;\n        hmm_init(ngs->hmmctx, &hmm->hmm, FALSE, rssid->ssid[0], tmatid);\n        E_DEBUG(\"allocated rc_id 0 ssid %d ciphone %d lc %d word %s\\n\",\n                rssid->ssid[0], hmm->ciphone,\n                dict_second_last_phone(ps_search_dict(ngs),w),\n                dict_wordstr(ps_search_dict(ngs),w));\n    }\n    for (i = 1; i < rssid->n_ssid; ++i) {\n        if ((hmm->next == NULL) || (hmm_nonmpx_ssid(&hmm->next->hmm) != rssid->ssid[i])) {\n            thmm = listelem_malloc(ngs->chan_alloc);\n            thmm->next = hmm->next;\n            hmm->next = thmm;\n            hmm = thmm;\n\n            hmm->info.rc_id = i;\n            hmm->ciphone = ciphone;\n            hmm_init(ngs->hmmctx, &hmm->hmm, FALSE, rssid->ssid[i], tmatid);\n            E_DEBUG(\"allocated rc_id %d ssid %d ciphone %d lc %d word %s\\n\",\n                    i, rssid->ssid[i], hmm->ciphone,\n                    dict_second_last_phone(ps_search_dict(ngs),w),\n                    dict_wordstr(ps_search_dict(ngs),w));\n        }\n        else\n            hmm = hmm->next;\n    }\n}\n\nvoid\nngram_search_free_all_rc(ngram_search_t *ngs, int32 w)\n{\n    chan_t *hmm, *thmm;\n\n    for (hmm = ngs->word_chan[w]; hmm; hmm = thmm) {\n        thmm = hmm->next;\n        hmm_deinit(&hmm->hmm);\n        listelem_free(ngs->chan_alloc, hmm);\n    }\n    ngs->word_chan[w] = NULL;\n}\n\nint32\nngram_search_exit_score(ngram_search_t *ngs, bptbl_t *pbe, int rcphone)\n{\n    /* DICT2PID */\n    /* Get the mapping from right context phone ID to index in the\n     * right context table and the bscore_stack. */\n    if (pbe->last2_phone == -1) {\n        /* No right context for single phone predecessor words. */\n        return pbe->score;\n    }\n    else {\n        xwdssid_t *rssid;\n        /* Find the index for the last diphone of the previous word +\n         * the first phone of the current word. */\n        rssid = dict2pid_rssid(ps_search_dict2pid(ngs),\n                               pbe->last_phone, pbe->last2_phone);\n        /* This may be WORST_SCORE, which means that there was no exit\n         * with rcphone as right context. */\n        return ngs->bscore_stack[pbe->s_idx + rssid->cimap[rcphone]];\n    }\n}\n\n/*\n * Compute acoustic and LM scores for a BPTable entry (segment).\n */\nvoid\nngram_compute_seg_score(ngram_search_t *ngs, bptbl_t *be, float32 lwf,\n                        int32 *out_ascr, int32 *out_lscr)\n{\n    bptbl_t *pbe;\n    int32 start_score;\n\n    /* Start of utterance. */\n    if (be->bp == NO_BP) {\n        *out_ascr = be->score;\n        *out_lscr = 0;\n        return;\n    }\n\n    /* Otherwise, calculate lscr and ascr. */\n    pbe = ngs->bp_table + be->bp;\n    start_score = ngram_search_exit_score(ngs, pbe,\n                                 dict_first_phone(ps_search_dict(ngs),be->wid));\n    assert(start_score BETTER_THAN WORST_SCORE);\n\n    /* FIXME: These result in positive acoustic scores when filler\n       words have non-filler pronunciations.  That whole business\n       is still pretty much broken but at least it doesn't\n       segfault. */\n    if (be->wid == ps_search_silence_wid(ngs)) {\n        *out_lscr = ngs->silpen;\n    }\n    else if (dict_filler_word(ps_search_dict(ngs), be->wid)) {\n        *out_lscr = ngs->fillpen;\n    }\n    else {\n        int32 n_used;\n        *out_lscr = ngram_tg_score(ngs->lmset,\n                                   be->real_wid,\n                                   pbe->real_wid,\n                                   pbe->prev_real_wid,\n                                   &n_used)>>SENSCR_SHIFT;\n        *out_lscr = *out_lscr * lwf;\n    }\n    *out_ascr = be->score - start_score - *out_lscr;\n}\n\nstatic int\nngram_search_start(ps_search_t *search)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    ngs->done = FALSE;\n    ngram_model_flush(ngs->lmset);\n    if (ngs->fwdtree)\n        ngram_fwdtree_start(ngs);\n    else if (ngs->fwdflat)\n        ngram_fwdflat_start(ngs);\n    else\n        return -1;\n    return 0;\n}\n\nstatic int\nngram_search_step(ps_search_t *search, int frame_idx)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    if (ngs->fwdtree)\n        return ngram_fwdtree_search(ngs, frame_idx);\n    else if (ngs->fwdflat)\n        return ngram_fwdflat_search(ngs, frame_idx);\n    else\n        return -1;\n}\n\nvoid\ndump_bptable(ngram_search_t *ngs)\n{\n    int i;\n    E_INFO(\"Backpointer table (%d entries):\\n\", ngs->bpidx);\n    for (i = 0; i < ngs->bpidx; ++i) {\n        bptbl_t *bpe = ngs->bp_table + i;\n        int j, rcsize;\n\n        E_INFO_NOFN(\"%-5d %-10s start %-3d end %-3d score %-8d bp %-3d real_wid %-5d prev_real_wid %-5d\",\n                    i, dict_wordstr(ps_search_dict(ngs), bpe->wid),\n                    (bpe->bp == -1\n                     ? 0 : ngs->bp_table[bpe->bp].frame + 1),\n                    bpe->frame, bpe->score, bpe->bp,\n                    bpe->real_wid, bpe->prev_real_wid);\n\n        if (bpe->last2_phone == -1)\n            rcsize = 0;\n        else\n            rcsize = dict2pid_rssid(ps_search_dict2pid(ngs),\n                                    bpe->last_phone, bpe->last2_phone)->n_ssid;\n        if (rcsize) {\n            E_INFOCONT(\"\\tbss\");\n            for (j = 0; j < rcsize; ++j)\n                if (ngs->bscore_stack[bpe->s_idx + j] != WORST_SCORE)\n                    E_INFOCONT(\" %d\", bpe->score - ngs->bscore_stack[bpe->s_idx + j]);\n        }\n        E_INFOCONT(\"\\n\");\n    }\n}\n\nstatic int\nngram_search_finish(ps_search_t *search)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    ngs->n_tot_frame += ngs->n_frame;\n    if (ngs->fwdtree) {\n        ngram_fwdtree_finish(ngs);\n        /* dump_bptable(ngs); */\n\n        /* Now do fwdflat search in its entirety, if requested. */\n        if (ngs->fwdflat) {\n            int i;\n            /* Rewind the acoustic model. */\n            if (acmod_rewind(ps_search_acmod(ngs)) < 0)\n                return -1;\n            /* Now redo search. */\n            ngram_fwdflat_start(ngs);\n            i = 0;\n            while (ps_search_acmod(ngs)->n_feat_frame > 0) {\n                int nfr;\n                if ((nfr = ngram_fwdflat_search(ngs, i)) < 0)\n                    return nfr;\n                acmod_advance(ps_search_acmod(ngs));\n                ++i;\n            }\n            ngram_fwdflat_finish(ngs);\n            /* And now, we should have a result... */\n            /* dump_bptable(ngs); */\n        }\n    }\n    else if (ngs->fwdflat) {\n        ngram_fwdflat_finish(ngs);\n    }\n\n    /* Mark the current utterance as done. */\n    ngs->done = TRUE;\n    return 0;\n}\n\nstatic ps_latlink_t *\nngram_search_bestpath(ps_search_t *search, int32 *out_score, int backward)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    if (search->last_link == NULL) {\n        search->last_link = ps_lattice_bestpath(search->dag, ngs->lmset,\n                                                ngs->bestpath_fwdtree_lw_ratio,\n                                                ngs->ascale);\n        if (search->last_link == NULL)\n            return NULL;\n        /* Also calculate betas so we can fill in the posterior\n         * probability field in the segmentation. */\n        if (search->post == 0)\n            search->post = ps_lattice_posterior(search->dag, ngs->lmset,\n                                                ngs->ascale);\n    }\n    if (out_score)\n        *out_score = search->last_link->path_scr + search->dag->final_node_ascr;\n    return search->last_link;\n}\n\nstatic char const *\nngram_search_hyp(ps_search_t *search, int32 *out_score)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    /* Only do bestpath search if the utterance is complete. */\n    if (ngs->bestpath && ngs->done) {\n        ps_lattice_t *dag;\n        ps_latlink_t *link;\n        char const *hyp;\n        double n_speech;\n\n        ptmr_reset(&ngs->bestpath_perf);\n        ptmr_start(&ngs->bestpath_perf);\n        if ((dag = ngram_search_lattice(search)) == NULL)\n            return NULL;\n        if ((link = ngram_search_bestpath(search, out_score, FALSE)) == NULL)\n            return NULL;\n        hyp = ps_lattice_hyp(dag, link);\n        ptmr_stop(&ngs->bestpath_perf);\n        n_speech = (double)dag->n_frames\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n        E_INFO(\"bestpath %.2f CPU %.3f xRT\\n\",\n               ngs->bestpath_perf.t_cpu,\n               ngs->bestpath_perf.t_cpu / n_speech);\n        E_INFO(\"bestpath %.2f wall %.3f xRT\\n\",\n               ngs->bestpath_perf.t_elapsed,\n               ngs->bestpath_perf.t_elapsed / n_speech);\n        return hyp;\n    }\n    else {\n        int32 bpidx;\n\n        /* fwdtree and fwdflat use same backpointer table. */\n        bpidx = ngram_search_find_exit(ngs, -1, out_score);\n        if (bpidx != NO_BP)\n            return ngram_search_bp_hyp(ngs, bpidx);\n    }\n\n    return NULL;\n}\n\nstatic void\nngram_search_bp2itor(ps_seg_t *seg, int bp)\n{\n    ngram_search_t *ngs = (ngram_search_t *)seg->search;\n    bptbl_t *be, *pbe;\n\n    be = &ngs->bp_table[bp];\n    pbe = be->bp == -1 ? NULL : &ngs->bp_table[be->bp];\n    seg->word = dict_wordstr(ps_search_dict(ngs), be->wid);\n    seg->ef = be->frame;\n    seg->sf = pbe ? pbe->frame + 1 : 0;\n    seg->prob = 0; /* Bogus value... */\n    /* Compute acoustic and LM scores for this segment. */\n    if (pbe == NULL) {\n        seg->ascr = be->score;\n        seg->lscr = 0;\n        seg->lback = 0;\n    }\n    else {\n        int32 start_score;\n\n        /* Find ending path score of previous word. */\n        start_score = ngram_search_exit_score(ngs, pbe,\n                                     dict_first_phone(ps_search_dict(ngs), be->wid));\n        assert(start_score BETTER_THAN WORST_SCORE);\n        if (be->wid == ps_search_silence_wid(ngs)) {\n            seg->lscr = ngs->silpen;\n        }\n        else if (dict_filler_word(ps_search_dict(ngs), be->wid)) {\n            seg->lscr = ngs->fillpen;\n        }\n        else {\n            seg->lscr = ngram_tg_score(ngs->lmset,\n                                       be->real_wid,\n                                       pbe->real_wid,\n                                       pbe->prev_real_wid,\n                                       &seg->lback)>>SENSCR_SHIFT;\n            seg->lscr = (int32)(seg->lscr * seg->lwf);\n        }\n        seg->ascr = be->score - start_score - seg->lscr;\n    }\n}\n\nstatic void\nngram_bp_seg_free(ps_seg_t *seg)\n{\n    bptbl_seg_t *itor = (bptbl_seg_t *)seg;\n\n    ckd_free(itor->bpidx);\n    ckd_free(itor);\n}\n\nstatic ps_seg_t *\nngram_bp_seg_next(ps_seg_t *seg)\n{\n    bptbl_seg_t *itor = (bptbl_seg_t *)seg;\n\n    if (++itor->cur == itor->n_bpidx) {\n        ngram_bp_seg_free(seg);\n        return NULL;\n    }\n\n    ngram_search_bp2itor(seg, itor->bpidx[itor->cur]);\n    return seg;\n}\n\nstatic ps_segfuncs_t ngram_bp_segfuncs = {\n    /* seg_next */ ngram_bp_seg_next,\n    /* seg_free */ ngram_bp_seg_free\n};\n\nstatic ps_seg_t *\nngram_search_bp_iter(ngram_search_t *ngs, int bpidx, float32 lwf)\n{\n    bptbl_seg_t *itor;\n    int bp, cur;\n\n    /* Calling this an \"iterator\" is a bit of a misnomer since we have\n     * to get the entire backtrace in order to produce it.  On the\n     * other hand, all we actually need is the bptbl IDs, and we can\n     * allocate a fixed-size array of them. */\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->base.vt = &ngram_bp_segfuncs;\n    itor->base.search = ps_search_base(ngs);\n    itor->base.lwf = lwf;\n    itor->n_bpidx = 0;\n    bp = bpidx;\n    while (bp != NO_BP) {\n        bptbl_t *be = &ngs->bp_table[bp];\n        bp = be->bp;\n        ++itor->n_bpidx;\n    }\n    if (itor->n_bpidx == 0) {\n        ckd_free(itor);\n        return NULL;\n    }\n    itor->bpidx = ckd_calloc(itor->n_bpidx, sizeof(*itor->bpidx));\n    cur = itor->n_bpidx - 1;\n    bp = bpidx;\n    while (bp != NO_BP) {\n        bptbl_t *be = &ngs->bp_table[bp];\n        itor->bpidx[cur] = bp;\n        bp = be->bp;\n        --cur;\n    }\n\n    /* Fill in relevant fields for first element. */\n    ngram_search_bp2itor((ps_seg_t *)itor, itor->bpidx[0]);\n\n    return (ps_seg_t *)itor;\n}\n\nstatic ps_seg_t *\nngram_search_seg_iter(ps_search_t *search)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    /* Only do bestpath search if the utterance is done. */\n    if (ngs->bestpath && ngs->done) {\n        ps_lattice_t *dag;\n        ps_latlink_t *link;\n        double n_speech;\n        ps_seg_t *itor;\n\n        ptmr_reset(&ngs->bestpath_perf);\n        ptmr_start(&ngs->bestpath_perf);\n        if ((dag = ngram_search_lattice(search)) == NULL)\n            return NULL;\n        if ((link = ngram_search_bestpath(search, NULL, TRUE)) == NULL)\n            return NULL;\n        itor = ps_lattice_seg_iter(dag, link,\n                                   ngs->bestpath_fwdtree_lw_ratio);\n        ptmr_stop(&ngs->bestpath_perf);\n        n_speech = (double)dag->n_frames\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n        E_INFO(\"bestpath %.2f CPU %.3f xRT\\n\",\n               ngs->bestpath_perf.t_cpu,\n               ngs->bestpath_perf.t_cpu / n_speech);\n        E_INFO(\"bestpath %.2f wall %.3f xRT\\n\",\n               ngs->bestpath_perf.t_elapsed,\n               ngs->bestpath_perf.t_elapsed / n_speech);\n        return itor;\n    }\n    else {\n        int32 bpidx;\n\n        /* fwdtree and fwdflat use same backpointer table. */\n        bpidx = ngram_search_find_exit(ngs, -1, NULL);\n        return ngram_search_bp_iter(ngs, bpidx,\n                                    /* but different language weights... */\n                                    (ngs->done && ngs->fwdflat)\n                                    ? ngs->fwdflat_fwdtree_lw_ratio : 1.0);\n    }\n\n    return NULL;\n}\n\nstatic int32\nngram_search_prob(ps_search_t *search)\n{\n    ngram_search_t *ngs = (ngram_search_t *)search;\n\n    /* Only do bestpath search if the utterance is done. */\n    if (ngs->bestpath && ngs->done) {\n        ps_lattice_t *dag;\n        ps_latlink_t *link;\n\n        if ((dag = ngram_search_lattice(search)) == NULL)\n            return 0;\n        if ((link = ngram_search_bestpath(search, NULL, TRUE)) == NULL)\n            return 0;\n        return search->post;\n    }\n    else {\n        /* FIXME: Give some kind of good estimate here, eventually. */\n        return 0;\n    }\n}\n\nstatic void\ncreate_dag_nodes(ngram_search_t *ngs, ps_lattice_t *dag)\n{\n    bptbl_t *bp_ptr;\n    int32 i;\n\n    for (i = 0, bp_ptr = ngs->bp_table; i < ngs->bpidx; ++i, ++bp_ptr) {\n        int32 sf, ef, wid;\n        ps_latnode_t *node;\n\n        /* Skip invalid backpointers (these result from -maxwpf pruning) */\n        if (!bp_ptr->valid)\n            continue;\n\n        sf = (bp_ptr->bp < 0) ? 0 : ngs->bp_table[bp_ptr->bp].frame + 1;\n        ef = bp_ptr->frame;\n        wid = bp_ptr->wid;\n\n        assert(ef < dag->n_frames);\n        /* Skip non-final </s> entries. */\n        if ((wid == ps_search_finish_wid(ngs)) && (ef < dag->n_frames - 1))\n            continue;\n\n        /* Skip if word not in LM */\n        if ((!dict_filler_word(ps_search_dict(ngs), wid))\n            && (!ngram_model_set_known_wid(ngs->lmset,\n                                           dict_basewid(ps_search_dict(ngs), wid))))\n            continue;\n\n        /* See if bptbl entry <wid,sf> already in lattice */\n        for (node = dag->nodes; node; node = node->next) {\n            if ((node->wid == wid) && (node->sf == sf))\n                break;\n        }\n\n        /* For the moment, store bptbl indices in node.{fef,lef} */\n        if (node)\n            node->lef = i;\n        else {\n            /* New node; link to head of list */\n            node = listelem_malloc(dag->latnode_alloc);\n            node->wid = wid;\n            node->sf = sf; /* This is a frame index. */\n            node->fef = node->lef = i; /* These are backpointer indices (argh) */\n            node->reachable = FALSE;\n            node->entries = NULL;\n            node->exits = NULL;\n\n            /* NOTE: This creates the list of nodes in reverse\n             * topological order, i.e. a node always precedes its\n             * antecedents in this list. */\n            node->next = dag->nodes;\n            dag->nodes = node;\n            ++dag->n_nodes;\n        }\n    }\n}\n\nstatic ps_latnode_t *\nfind_start_node(ngram_search_t *ngs, ps_lattice_t *dag)\n{\n    ps_latnode_t *node;\n\n    /* Find start node <s>.0 */\n    for (node = dag->nodes; node; node = node->next) {\n        if ((node->wid == ps_search_start_wid(ngs)) && (node->sf == 0))\n            break;\n    }\n    if (!node) {\n        /* This is probably impossible. */\n        E_ERROR(\"Couldn't find <s> in first frame\\n\");\n        return NULL;\n    }\n    return node;\n}\n\nstatic ps_latnode_t *\nfind_end_node(ngram_search_t *ngs, ps_lattice_t *dag, float32 lwf)\n{\n    ps_latnode_t *node;\n    int32 ef, bestbp, bp, bestscore;\n\n    /* Find final node </s>.last_frame; nothing can follow this node */\n    for (node = dag->nodes; node; node = node->next) {\n        int32 lef = ngs->bp_table[node->lef].frame;\n        if ((node->wid == ps_search_finish_wid(ngs))\n            && (lef == dag->n_frames - 1))\n            break;\n    }\n    if (node != NULL)\n        return node;\n\n    /* It is quite likely that no </s> exited in the last frame.  So,\n     * find the node corresponding to the best exit. */\n    /* Find the last frame containing a word exit. */\n    for (ef = dag->n_frames - 1;\n         ef >= 0 && ngs->bp_table_idx[ef] == ngs->bpidx;\n         --ef);\n    if (ef < 0) {\n        E_ERROR(\"Empty backpointer table: can not build DAG.\\n\");\n        return NULL;\n    }\n\n    /* Find best word exit in that frame. */\n    bestscore = WORST_SCORE;\n    bestbp = NO_BP;\n    for (bp = ngs->bp_table_idx[ef]; bp < ngs->bp_table_idx[ef + 1]; ++bp) {\n        int32 n_used, l_scr, wid, prev_wid;\n        wid = ngs->bp_table[bp].real_wid;\n        prev_wid = ngs->bp_table[bp].prev_real_wid;\n        /* Always prefer </s>, of which there will only be one per frame. */\n        if (wid == ps_search_finish_wid(ngs)) {\n            bestbp = bp;\n            break;\n        }\n        l_scr = ngram_tg_score(ngs->lmset, ps_search_finish_wid(ngs),\n                               wid, prev_wid, &n_used) >>SENSCR_SHIFT;\n        l_scr = l_scr * lwf;\n        if (ngs->bp_table[bp].score + l_scr BETTER_THAN bestscore) {\n            bestscore = ngs->bp_table[bp].score + l_scr;\n            bestbp = bp;\n        }\n    }\n    if (bestbp == NO_BP) {\n        E_ERROR(\"No word exits found in last frame (%d), assuming no recognition\\n\", ef);\n        return NULL;\n    }\n    E_INFO(\"</s> not found in last frame, using %s.%d instead\\n\",\n           dict_basestr(ps_search_dict(ngs), ngs->bp_table[bestbp].wid), ef);\n\n    /* Now find the node that corresponds to it. */\n    for (node = dag->nodes; node; node = node->next) {\n        if (node->lef == bestbp)\n            return node;\n    }\n\n    /* FIXME: This seems to happen a lot! */\n    E_ERROR(\"Failed to find DAG node corresponding to %s\\n\",\n           dict_basestr(ps_search_dict(ngs), ngs->bp_table[bestbp].wid));\n    return NULL;\n}\n\n/*\n * Build lattice from bptable.\n */\nps_lattice_t *\nngram_search_lattice(ps_search_t *search)\n{\n    int32 i, score, ascr, lscr;\n    ps_latnode_t *node, *from, *to;\n    ngram_search_t *ngs;\n    ps_lattice_t *dag;\n    int min_endfr, nlink;\n    float lwf;\n\n    ngs = (ngram_search_t *)search;\n    min_endfr = cmd_ln_int32_r(ps_search_config(search), \"-min_endfr\");\n\n    /* If the best score is WORST_SCORE or worse, there is no way to\n     * make a lattice. */\n    if (ngs->best_score == WORST_SCORE || ngs->best_score WORSE_THAN WORST_SCORE)\n        return NULL;\n\n    /* Check to see if a lattice has previously been created over the\n     * same number of frames, and reuse it if so. */\n    if (search->dag && search->dag->n_frames == ngs->n_frame)\n        return search->dag;\n\n    /* Nope, create a new one. */\n    ps_lattice_free(search->dag);\n    search->dag = NULL;\n    dag = ps_lattice_init_search(search, ngs->n_frame);\n    /* Compute these such that they agree with the fwdtree language weight. */\n    lwf = ngs->fwdflat ? ngs->fwdflat_fwdtree_lw_ratio : 1.0;\n    create_dag_nodes(ngs, dag);\n    if ((dag->start = find_start_node(ngs, dag)) == NULL)\n        goto error_out;\n    if ((dag->end = find_end_node(ngs, dag, ngs->bestpath_fwdtree_lw_ratio)) == NULL)\n        goto error_out;\n    E_INFO(\"lattice start node %s.%d end node %s.%d\\n\",\n           dict_wordstr(search->dict, dag->start->wid), dag->start->sf,\n           dict_wordstr(search->dict, dag->end->wid), dag->end->sf);\n\n    ngram_compute_seg_score(ngs, ngs->bp_table + dag->end->lef, lwf,\n                            &dag->final_node_ascr, &lscr);\n\n    /*\n     * At this point, dag->nodes is ordered such that nodes earlier in\n     * the list can follow (in time) those later in the list, but not\n     * vice versa (see above - also note that adjacency is purely\n     * determined by time which is why we can make this claim).  Now\n     * create precedence links and simultanesously mark all nodes that\n     * can reach dag->end.  (All nodes are reached from dag->start\n     * simply by definition - they were created that way).\n     *\n     * Note that this also means that any nodes before dag->end in the\n     * list can be discarded, meaning that dag->end will always be\n     * equal to dag->nodes (FIXME: except when loading from a file but\n     * we can fix that...)\n     */\n    i = 0;\n    while (dag->nodes && dag->nodes != dag->end) {\n        ps_latnode_t *next = dag->nodes->next;\n        listelem_free(dag->latnode_alloc, dag->nodes);\n        dag->nodes = next;\n        ++i;\n    }\n    E_INFO(\"Eliminated %d nodes before end node\\n\", i);\n    dag->end->reachable = TRUE;\n    nlink = 0;\n    for (to = dag->end; to; to = to->next) {\n        int fef, lef;\n\n        /* Skip if not reachable; it will never be reachable from dag->end */\n        if (!to->reachable)\n            continue;\n\n        /* Prune nodes with too few endpoints - heuristic\n           borrowed from Sphinx3 */\n        fef = ngs->bp_table[to->fef].frame;\n        lef = ngs->bp_table[to->lef].frame;\n        if (to != dag->end && lef - fef < min_endfr) {\n            to->reachable = FALSE;\n            continue;\n        }\n\n        /* Find predecessors of to : from->fef+1 <= to->sf <= from->lef+1 */\n        for (from = to->next; from; from = from->next) {\n            bptbl_t *from_bpe;\n\n            fef = ngs->bp_table[from->fef].frame;\n            lef = ngs->bp_table[from->lef].frame;\n\n            if ((to->sf <= fef) || (to->sf > lef + 1))\n                continue;\n            if (lef - fef < min_endfr) {\n                assert(!from->reachable);\n                continue;\n            }\n\n            /* Find bptable entry for \"from\" that exactly precedes \"to\" */\n            i = from->fef;\n            from_bpe = ngs->bp_table + i;\n            for (; i <= from->lef; i++, from_bpe++) {\n                if (from_bpe->wid != from->wid)\n                    continue;\n                if (from_bpe->frame >= to->sf - 1)\n                    break;\n            }\n\n            if ((i > from->lef) || (from_bpe->frame != to->sf - 1))\n                continue;\n\n            /* Find acoustic score from.sf->to.sf-1 with right context = to */\n            /* This gives us from_bpe's best acoustic score. */\n            ngram_compute_seg_score(ngs, from_bpe, lwf,\n                                    &ascr, &lscr);\n            /* Now find the exact path score for from->to, including\n             * the appropriate final triphone.  In fact this might not\n             * exist. */\n            score = ngram_search_exit_score(ngs, from_bpe,\n                                            dict_first_phone(ps_search_dict(ngs), to->wid));\n            /* Does not exist.  Can't create a link here. */\n            if (score == WORST_SCORE)\n                continue;\n            /* Adjust the arc score to match the correct triphone. */\n            else\n                score = ascr + (score - from_bpe->score);\n            if (score BETTER_THAN 0) {\n                /* Scores must be negative, or Bad Things will happen.\n                   In general, they are, except in corner cases\n                   involving filler words.  We don't want to throw any\n                   links away so we'll keep these, but with some\n                   arbitrarily improbable but recognizable score. */\n                ps_lattice_link(dag, from, to, -424242, from_bpe->frame);\n                ++nlink;\n                from->reachable = TRUE;\n            }\n            else if (score BETTER_THAN WORST_SCORE) {\n                ps_lattice_link(dag, from, to, score, from_bpe->frame);\n                ++nlink;\n                from->reachable = TRUE;\n            }\n        }\n    }\n\n    /* There must be at least one path between dag->start and dag->end */\n    if (!dag->start->reachable) {\n        E_ERROR(\"End node of lattice isolated; unreachable\\n\");\n        goto error_out;\n    }\n\n    for (node = dag->nodes; node; node = node->next) {\n        /* Change node->{fef,lef} from bptbl indices to frames. */\n        node->fef = ngs->bp_table[node->fef].frame;\n        node->lef = ngs->bp_table[node->lef].frame;\n        /* Find base wid for nodes. */\n        node->basewid = dict_basewid(search->dict, node->wid);\n    }\n\n    /* Link nodes with alternate pronunciations at the same timepoint. */\n    for (node = dag->nodes; node; node = node->next) {\n        ps_latnode_t *alt;\n        /* Scan forward to find the next alternate, then stop. */\n        for (alt = node->next; alt && alt->sf == node->sf; alt = alt->next) {\n            if (alt->basewid == node->basewid) {\n                alt->alt = node->alt;\n                node->alt = alt;\n                break;\n            }\n        }\n    }\n    E_INFO(\"Lattice has %d nodes, %d links\\n\", dag->n_nodes, nlink);\n\n    /* Minor hack: If the final node is a filler word and not </s>,\n     * then set its base word ID to </s>, so that the language model\n     * scores won't be screwed up. */\n    if (dict_filler_word(ps_search_dict(ngs), dag->end->wid))\n        dag->end->basewid = ps_search_finish_wid(ngs);\n\n    /* Free nodes unreachable from dag->end and their links */\n    ps_lattice_delete_unreachable(dag);\n\n    /* Add silprob and fillprob to corresponding links */\n    ps_lattice_penalize_fillers(dag, ngs->silpen, ngs->fillpen);\n\n    search->dag = dag;\n    return dag;\n\nerror_out:\n    ps_lattice_free(dag);\n    return NULL;\n}\n\nvoid ngram_search_set_lm(ngram_model_t *lm)\n{\n    default_lm = ngram_model_retain(lm);\n}\n\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file ngram_search_fwdtree.c Lexicon tree search.\n */\n\n/* System headers. */\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/listelem_alloc.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"ngram_search_fwdtree.h\"\n#include \"phone_loop_search.h\"\n\n/* Turn this on to dump channels for debugging */\n#define __CHAN_DUMP__\t\t0\n#if __CHAN_DUMP__\n#define chan_v_eval(chan) hmm_dump_vit_eval(&(chan)->hmm, stderr)\n#else\n#define chan_v_eval(chan) hmm_vit_eval(&(chan)->hmm)\n#endif\n\n/*\n * Allocate that part of the search channel tree structure that is independent of the\n * LM in use.\n */\nstatic void\ninit_search_tree(ngram_search_t *ngs)\n{\n    int32 w, ndiph, i, n_words, n_ci;\n    dict_t *dict = ps_search_dict(ngs);\n    bitvec_t *dimap;\n\n    E_INFO(\"Initializing search tree\\n\");\n\n    n_words = ps_search_n_words(ngs);\n    ngs->homophone_set = ckd_calloc(n_words, sizeof(*ngs->homophone_set));\n\n    /* Find #single phone words, and #unique first diphones (#root channels) in dict. */\n    ndiph = 0;\n    ngs->n_1ph_words = 0;\n    n_ci = bin_mdef_n_ciphone(ps_search_acmod(ngs)->mdef);\n    /* Allocate a bitvector with flags for each possible diphone. */\n    dimap = bitvec_alloc(n_ci * n_ci);\n    for (w = 0; w < n_words; w++) {\n        if (!dict_real_word(dict, w))\n            continue;\n        if (dict_is_single_phone(dict, w))\n            ++ngs->n_1ph_words;\n        else {\n            int ph0, ph1;\n            ph0 = dict_first_phone(dict, w);\n            ph1 = dict_second_phone(dict, w);\n            /* Increment ndiph the first time we see a diphone. */\n            if (bitvec_is_clear(dimap, ph0 * n_ci + ph1)) {\n                bitvec_set(dimap, ph0 * n_ci + ph1);\n                ++ndiph;\n            }\n        }\n    }\n    E_INFO(\"%d unique initial diphones\\n\", ndiph);\n    bitvec_free(dimap);\n\n    /* Add remaining dict words (</s>, <s>, <sil>, noise words) to single-phone words */\n    ngs->n_1ph_words += dict_num_fillers(dict) + 2;\n    ngs->n_root_chan_alloc = ndiph + 1;\n    /* Verify that these are all *actually* single-phone words,\n     * otherwise really bad things will happen to us. */\n    for (w = 0; w < n_words; ++w) {\n        if (dict_real_word(dict, w))\n            continue;\n        if (!dict_is_single_phone(dict, w)) {\n            E_WARN(\"Filler word %d = %s has more than one phone, ignoring it.\\n\",\n                   w, dict_wordstr(dict, w));\n            --ngs->n_1ph_words;\n        }\n    }\n\n    /* Allocate and initialize root channels */\n    ngs->root_chan =\n        ckd_calloc(ngs->n_root_chan_alloc, sizeof(*ngs->root_chan));\n    for (i = 0; i < ngs->n_root_chan_alloc; i++) {\n        hmm_init(ngs->hmmctx, &ngs->root_chan[i].hmm, TRUE, -1, -1);\n        ngs->root_chan[i].penult_phn_wid = -1;\n        ngs->root_chan[i].next = NULL;\n    }\n\n    /* Permanently allocate and initialize channels for single-phone\n     * words (1/word). */\n    ngs->rhmm_1ph = ckd_calloc(ngs->n_1ph_words, sizeof(*ngs->rhmm_1ph));\n    i = 0;\n    for (w = 0; w < n_words; w++) {\n        if (!dict_is_single_phone(dict, w))\n            continue;\n        /* Use SIL as right context for these. */\n        ngs->rhmm_1ph[i].ci2phone = bin_mdef_silphone(ps_search_acmod(ngs)->mdef);\n        ngs->rhmm_1ph[i].ciphone = dict_first_phone(dict, w);\n        hmm_init(ngs->hmmctx, &ngs->rhmm_1ph[i].hmm, TRUE,\n                 bin_mdef_pid2ssid(ps_search_acmod(ngs)->mdef, ngs->rhmm_1ph[i].ciphone),\n                 bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, ngs->rhmm_1ph[i].ciphone));\n        ngs->rhmm_1ph[i].next = NULL;\n\n        ngs->word_chan[w] = (chan_t *) &(ngs->rhmm_1ph[i]);\n        i++;\n    }\n\n    ngs->single_phone_wid = ckd_calloc(ngs->n_1ph_words,\n                                       sizeof(*ngs->single_phone_wid));\n}\n\n/*\n * One-time initialization of internal channels in HMM tree.\n */\nstatic void\ninit_nonroot_chan(ngram_search_t *ngs, chan_t * hmm, int32 ph, int32 ci, int32 tmatid)\n{\n    hmm->next = NULL;\n    hmm->alt = NULL;\n    hmm->info.penult_phn_wid = -1;\n    hmm->ciphone = ci;\n    hmm_init(ngs->hmmctx, &hmm->hmm, FALSE, ph, tmatid);\n}\n\n/*\n * Allocate and initialize search channel-tree structure.\n * At this point, all the root-channels have been allocated and partly initialized\n * (as per init_search_tree()), and channels for all the single-phone words have been\n * allocated and initialized.  None of the interior channels of search-trees have\n * been allocated.\n * This routine may be called on every utterance, after reinit_search_tree() clears\n * the search tree created for the previous utterance.  Meant for reconfiguring the\n * search tree to suit the currently active LM.\n */\nstatic void\ncreate_search_channels(ngram_search_t *ngs)\n{\n    chan_t *hmm;\n    root_chan_t *rhmm;\n    int32 w, i, j, p, ph, tmatid;\n    int32 n_words;\n    dict_t *dict = ps_search_dict(ngs);\n    dict2pid_t *d2p = ps_search_dict2pid(ngs);\n\n    n_words = ps_search_n_words(ngs);\n\n    E_INFO(\"Creating search channels\\n\");\n\n    for (w = 0; w < n_words; w++)\n        ngs->homophone_set[w] = -1;\n\n    ngs->n_1ph_LMwords = 0;\n    ngs->n_root_chan = 0;\n    ngs->n_nonroot_chan = 0;\n\n    for (w = 0; w < n_words; w++) {\n        int ciphone, ci2phone;\n\n        /* Ignore dictionary words not in LM */\n        if (!ngram_model_set_known_wid(ngs->lmset, dict_basewid(dict, w)))\n            continue;\n\n        /* Handle single-phone words individually; not in channel tree */\n        if (dict_is_single_phone(dict, w)) {\n            E_DEBUG(\"single_phone_wid[%d] = %s\\n\",\n                       ngs->n_1ph_LMwords, dict_wordstr(dict, w));\n            ngs->single_phone_wid[ngs->n_1ph_LMwords++] = w;\n            continue;\n        }\n\n        /* Find a root channel matching the initial diphone, or\n         * allocate one if not found. */\n        ciphone = dict_first_phone(dict, w);\n        ci2phone = dict_second_phone(dict, w);\n        for (i = 0; i < ngs->n_root_chan; ++i) {\n            if (ngs->root_chan[i].ciphone == ciphone\n                && ngs->root_chan[i].ci2phone == ci2phone)\n                break;\n        }\n        if (i == ngs->n_root_chan) {\n            rhmm = &(ngs->root_chan[ngs->n_root_chan]);\n            rhmm->hmm.tmatid = bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, ciphone);\n            /* Begin with CI phone?  Not sure this makes a difference... */\n            hmm_mpx_ssid(&rhmm->hmm, 0) =\n                bin_mdef_pid2ssid(ps_search_acmod(ngs)->mdef, ciphone);\n            rhmm->ciphone = ciphone;\n            rhmm->ci2phone = ci2phone;\n            ngs->n_root_chan++;\n        }\n        else\n            rhmm = &(ngs->root_chan[i]);\n\n        E_DEBUG(\"word %s rhmm %d\\n\", dict_wordstr(dict, w), rhmm - ngs->root_chan);\n        /* Now, rhmm = root channel for w.  Go on to remaining phones */\n        if (dict_pronlen(dict, w) == 2) {\n            /* Next phone is the last; not kept in tree; add w to penult_phn_wid set */\n            if ((j = rhmm->penult_phn_wid) < 0)\n                rhmm->penult_phn_wid = w;\n            else {\n                for (; ngs->homophone_set[j] >= 0; j = ngs->homophone_set[j]);\n                ngs->homophone_set[j] = w;\n            }\n        }\n        else {\n            /* Add remaining phones, except the last, to tree */\n            ph = dict2pid_internal(d2p, w, 1);\n            tmatid = bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, dict_pron(dict, w, 1));\n            hmm = rhmm->next;\n            if (hmm == NULL) {\n                rhmm->next = hmm = listelem_malloc(ngs->chan_alloc);\n                init_nonroot_chan(ngs, hmm, ph, dict_pron(dict, w, 1), tmatid);\n                ngs->n_nonroot_chan++;\n            }\n            else {\n                chan_t *prev_hmm = NULL;\n\n                for (; hmm && (hmm_nonmpx_ssid(&hmm->hmm) != ph); hmm = hmm->alt)\n                    prev_hmm = hmm;\n                if (!hmm) {     /* thanks, rkm! */\n                    prev_hmm->alt = hmm = listelem_malloc(ngs->chan_alloc);\n                    init_nonroot_chan(ngs, hmm, ph, dict_pron(dict, w, 1), tmatid);\n                    ngs->n_nonroot_chan++;\n                }\n            }\n            E_DEBUG(\"phone %s = %d\\n\",\n                       bin_mdef_ciphone_str(ps_search_acmod(ngs)->mdef,\n                                            dict_second_phone(dict, w)), ph);\n            for (p = 2; p < dict_pronlen(dict, w) - 1; p++) {\n                ph = dict2pid_internal(d2p, w, p);\n                tmatid = bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, dict_pron(dict, w, p));\n                if (!hmm->next) {\n                    hmm->next = listelem_malloc(ngs->chan_alloc);\n                    hmm = hmm->next;\n                    init_nonroot_chan(ngs, hmm, ph, dict_pron(dict, w, p), tmatid);\n                    ngs->n_nonroot_chan++;\n                }\n                else {\n                    chan_t *prev_hmm = NULL;\n\n                    for (hmm = hmm->next; hmm && (hmm_nonmpx_ssid(&hmm->hmm) != ph);\n                         hmm = hmm->alt)\n                        prev_hmm = hmm;\n                    if (!hmm) { /* thanks, rkm! */\n                        prev_hmm->alt = hmm = listelem_malloc(ngs->chan_alloc);\n                        init_nonroot_chan(ngs, hmm, ph, dict_pron(dict, w, p), tmatid);\n                        ngs->n_nonroot_chan++;\n                    }\n                }\n                E_DEBUG(\"phone %s = %d\\n\",\n                        bin_mdef_ciphone_str(ps_search_acmod(ngs)->mdef,\n                                            dict_pron(dict, w, p)), ph);\n            }\n\n            /* All but last phone of w in tree; add w to hmm->info.penult_phn_wid set */\n            if ((j = hmm->info.penult_phn_wid) < 0)\n                hmm->info.penult_phn_wid = w;\n            else {\n                for (; ngs->homophone_set[j] >= 0; j = ngs->homophone_set[j]);\n                ngs->homophone_set[j] = w;\n            }\n        }\n    }\n\n    ngs->n_1ph_words = ngs->n_1ph_LMwords;\n\n    /* Add filler words to the array of 1ph words. */\n    for (w = 0; w < n_words; ++w) {\n        /* Skip anything that doesn't actually have a single phone. */\n        if (!dict_is_single_phone(dict, w))\n            continue;\n        /* Also skip \"real words\" and things that are in the LM. */\n        if (dict_real_word(dict, w))\n            continue;\n        if (ngram_model_set_known_wid(ngs->lmset, dict_basewid(dict, w)))\n            continue;\n        E_DEBUG(\"single_phone_wid[%d] = %s\\n\",\n                   ngs->n_1ph_words, dict_wordstr(dict, w));\n        ngs->single_phone_wid[ngs->n_1ph_words++] = w;\n    }\n\n    if (ngs->n_nonroot_chan >= ngs->max_nonroot_chan) {\n        /* Give some room for channels for new words added dynamically at run time */\n        ngs->max_nonroot_chan = ngs->n_nonroot_chan + 128;\n        E_INFO(\"Max nonroot chan increased to %d\\n\", ngs->max_nonroot_chan);\n\n        /* Free old active channel list array if any and allocate new one */\n        if (ngs->active_chan_list)\n            ckd_free_2d(ngs->active_chan_list);\n        ngs->active_chan_list = ckd_calloc_2d(2, ngs->max_nonroot_chan,\n                                              sizeof(**ngs->active_chan_list));\n    }\n\n    E_INFO(\"Created %d root, %d non-root channels, %d single-phone words\\n\",\n           ngs->n_root_chan, ngs->n_nonroot_chan, ngs->n_1ph_words);\n\n    if (ngs->n_root_chan + ngs->n_1ph_words == 0)\n\tE_ERROR(\"No word from the language model has pronunciation in the dictionary\\n\");\n}\n\nstatic void\nreinit_search_subtree(ngram_search_t *ngs, chan_t * hmm)\n{\n    chan_t *child, *sibling;\n\n    /* First free all children under hmm */\n    for (child = hmm->next; child; child = sibling) {\n        sibling = child->alt;\n        reinit_search_subtree(ngs, child);\n    }\n\n    /* Now free hmm */\n    hmm_deinit(&hmm->hmm);\n    listelem_free(ngs->chan_alloc, hmm);\n}\n\n/*\n * Delete search tree by freeing all interior channels within search tree and\n * restoring root channel state to the init state (i.e., just after init_search_tree()).\n */\nstatic void\nreinit_search_tree(ngram_search_t *ngs)\n{\n    int32 i;\n    chan_t *hmm, *sibling;\n\n    for (i = 0; i < ngs->n_root_chan; i++) {\n        hmm = ngs->root_chan[i].next;\n\n        while (hmm) {\n            sibling = hmm->alt;\n            reinit_search_subtree(ngs, hmm);\n            hmm = sibling;\n        }\n\n        ngs->root_chan[i].penult_phn_wid = -1;\n        ngs->root_chan[i].next = NULL;\n    }\n    ngs->n_nonroot_chan = 0;\n}\n\nvoid\nngram_fwdtree_init(ngram_search_t *ngs)\n{\n    /* Allocate bestbp_rc, lastphn_cand, last_ltrans */\n    ngs->bestbp_rc = ckd_calloc(bin_mdef_n_ciphone(ps_search_acmod(ngs)->mdef),\n                                sizeof(*ngs->bestbp_rc));\n    ngs->lastphn_cand = ckd_calloc(ps_search_n_words(ngs),\n                                   sizeof(*ngs->lastphn_cand));\n    init_search_tree(ngs);\n    create_search_channels(ngs);\n}\n\nstatic void\ndeinit_search_tree(ngram_search_t *ngs)\n{\n    int i, w, n_words;\n\n    n_words = ps_search_n_words(ngs);\n    for (i = 0; i < ngs->n_root_chan_alloc; i++) {\n        hmm_deinit(&ngs->root_chan[i].hmm);\n    }\n    if (ngs->rhmm_1ph) {\n        for (i = w = 0; w < n_words; ++w) {\n            if (!dict_is_single_phone(ps_search_dict(ngs), w))\n                continue;\n            hmm_deinit(&ngs->rhmm_1ph[i].hmm);\n            ++i;\n        }\n        ckd_free(ngs->rhmm_1ph);\n        ngs->rhmm_1ph = NULL;\n    }\n    ngs->n_root_chan = 0;\n    ngs->n_root_chan_alloc = 0;\n    ckd_free(ngs->root_chan);\n    ngs->root_chan = NULL;\n    ckd_free(ngs->single_phone_wid);\n    ngs->single_phone_wid = NULL;\n    ckd_free(ngs->homophone_set);\n    ngs->homophone_set = NULL;\n}\n\nvoid\nngram_fwdtree_deinit(ngram_search_t *ngs)\n{\n    double n_speech = (double)ngs->n_tot_frame\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n\n    E_INFO(\"TOTAL fwdtree %.2f CPU %.3f xRT\\n\",\n           ngs->fwdtree_perf.t_tot_cpu,\n           ngs->fwdtree_perf.t_tot_cpu / n_speech);\n    E_INFO(\"TOTAL fwdtree %.2f wall %.3f xRT\\n\",\n           ngs->fwdtree_perf.t_tot_elapsed,\n           ngs->fwdtree_perf.t_tot_elapsed / n_speech);\n\n    /* Reset non-root channels. */\n    reinit_search_tree(ngs);\n    /* Free the search tree. */\n    deinit_search_tree(ngs);\n    /* Free other stuff. */\n    ngs->max_nonroot_chan = 0;\n    ckd_free_2d(ngs->active_chan_list);\n    ngs->active_chan_list = NULL;\n    ckd_free(ngs->cand_sf);\n    ngs->cand_sf = NULL;\n    ckd_free(ngs->bestbp_rc);\n    ngs->bestbp_rc = NULL;\n    ckd_free(ngs->lastphn_cand);\n    ngs->lastphn_cand = NULL;\n}\n\nint\nngram_fwdtree_reinit(ngram_search_t *ngs)\n{\n    /* Reset non-root channels. */\n    reinit_search_tree(ngs);\n    /* Free the search tree. */\n    deinit_search_tree(ngs);\n    /* Reallocate things that depend on the number of words. */\n    ckd_free(ngs->lastphn_cand);\n    ngs->lastphn_cand = ckd_calloc(ps_search_n_words(ngs),\n                                   sizeof(*ngs->lastphn_cand));\n    ckd_free(ngs->word_chan);\n    ngs->word_chan = ckd_calloc(ps_search_n_words(ngs),\n                                sizeof(*ngs->word_chan));\n    /* Rebuild the search tree. */\n    init_search_tree(ngs);\n    create_search_channels(ngs);\n    return 0;\n}\n\nvoid\nngram_fwdtree_start(ngram_search_t *ngs)\n{\n    ps_search_t *base = (ps_search_t *)ngs;\n    int32 i, w, n_words;\n    root_chan_t *rhmm;\n\n    n_words = ps_search_n_words(ngs);\n\n    /* Reset utterance statistics. */\n    memset(&ngs->st, 0, sizeof(ngs->st));\n    ptmr_reset(&ngs->fwdtree_perf);\n    ptmr_start(&ngs->fwdtree_perf);\n\n    /* Reset backpointer table. */\n    ngs->bpidx = 0;\n    ngs->bss_head = 0;\n\n    /* Reset word lattice. */\n    for (i = 0; i < n_words; ++i)\n        ngs->word_lat_idx[i] = NO_BP;\n\n    /* Reset active HMM and word lists. */\n    ngs->n_active_chan[0] = ngs->n_active_chan[1] = 0;\n    ngs->n_active_word[0] = ngs->n_active_word[1] = 0;\n\n    /* Reset scores. */\n    ngs->best_score = 0;\n    ngs->renormalized = 0;\n\n    /* Reset other stuff. */\n    for (i = 0; i < n_words; i++)\n        ngs->last_ltrans[i].sf = -1;\n    ngs->n_frame = 0;\n\n    /* Clear the hypothesis string. */\n    ckd_free(base->hyp_str);\n    base->hyp_str = NULL;\n\n    /* Reset the permanently allocated single-phone words, since they\n     * may have junk left over in them from FWDFLAT. */\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        hmm_clear(&rhmm->hmm);\n    }\n\n    /* Start search with <s>; word_chan[<s>] is permanently allocated */\n    rhmm = (root_chan_t *) ngs->word_chan[dict_startwid(ps_search_dict(ngs))];\n    hmm_clear(&rhmm->hmm);\n    hmm_enter(&rhmm->hmm, 0, NO_BP, 0);\n}\n\n/*\n * Mark the active senones for all senones belonging to channels that are active in the\n * current frame.\n */\nstatic void\ncompute_sen_active(ngram_search_t *ngs, int frame_idx)\n{\n    root_chan_t *rhmm;\n    chan_t *hmm, **acl;\n    int32 i, w, *awl;\n\n    acmod_clear_active(ps_search_acmod(ngs));\n\n    /* Flag active senones for root channels */\n    for (i = ngs->n_root_chan, rhmm = ngs->root_chan; i > 0; --i, rhmm++) {\n        if (hmm_frame(&rhmm->hmm) == frame_idx)\n            acmod_activate_hmm(ps_search_acmod(ngs), &rhmm->hmm);\n    }\n\n    /* Flag active senones for nonroot channels in HMM tree */\n    i = ngs->n_active_chan[frame_idx & 0x1];\n    acl = ngs->active_chan_list[frame_idx & 0x1];\n    for (hmm = *(acl++); i > 0; --i, hmm = *(acl++)) {\n        acmod_activate_hmm(ps_search_acmod(ngs), &hmm->hmm);\n    }\n\n    /* Flag active senones for individual word channels */\n    i = ngs->n_active_word[frame_idx & 0x1];\n    awl = ngs->active_word_list[frame_idx & 0x1];\n    for (w = *(awl++); i > 0; --i, w = *(awl++)) {\n        for (hmm = ngs->word_chan[w]; hmm; hmm = hmm->next) {\n            acmod_activate_hmm(ps_search_acmod(ngs), &hmm->hmm);\n        }\n    }\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n\n        if (hmm_frame(&rhmm->hmm) == frame_idx)\n            acmod_activate_hmm(ps_search_acmod(ngs), &rhmm->hmm);\n    }\n}\n\nstatic void\nrenormalize_scores(ngram_search_t *ngs, int frame_idx, int32 norm)\n{\n    root_chan_t *rhmm;\n    chan_t *hmm, **acl;\n    int32 i, w, *awl;\n\n    /* Renormalize root channels */\n    for (i = ngs->n_root_chan, rhmm = ngs->root_chan; i > 0; --i, rhmm++) {\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            hmm_normalize(&rhmm->hmm, norm);\n        }\n    }\n\n    /* Renormalize nonroot channels in HMM tree */\n    i = ngs->n_active_chan[frame_idx & 0x1];\n    acl = ngs->active_chan_list[frame_idx & 0x1];\n    for (hmm = *(acl++); i > 0; --i, hmm = *(acl++)) {\n        hmm_normalize(&hmm->hmm, norm);\n    }\n\n    /* Renormalize individual word channels */\n    i = ngs->n_active_word[frame_idx & 0x1];\n    awl = ngs->active_word_list[frame_idx & 0x1];\n    for (w = *(awl++); i > 0; --i, w = *(awl++)) {\n        for (hmm = ngs->word_chan[w]; hmm; hmm = hmm->next) {\n            hmm_normalize(&hmm->hmm, norm);\n        }\n    }\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            hmm_normalize(&rhmm->hmm, norm);\n        }\n    }\n\n    ngs->renormalized = TRUE;\n}\n\nstatic int32\neval_root_chan(ngram_search_t *ngs, int frame_idx)\n{\n    root_chan_t *rhmm;\n    int32 i, bestscore;\n\n    bestscore = WORST_SCORE;\n    for (i = ngs->n_root_chan, rhmm = ngs->root_chan; i > 0; --i, rhmm++) {\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            int32 score = chan_v_eval(rhmm);\n            if (score BETTER_THAN bestscore)\n                bestscore = score;\n            ++ngs->st.n_root_chan_eval;\n        }\n    }\n    return (bestscore);\n}\n\nstatic int32\neval_nonroot_chan(ngram_search_t *ngs, int frame_idx)\n{\n    chan_t *hmm, **acl;\n    int32 i, bestscore;\n\n    i = ngs->n_active_chan[frame_idx & 0x1];\n    acl = ngs->active_chan_list[frame_idx & 0x1];\n    bestscore = WORST_SCORE;\n    ngs->st.n_nonroot_chan_eval += i;\n\n    for (hmm = *(acl++); i > 0; --i, hmm = *(acl++)) {\n        int32 score = chan_v_eval(hmm);\n        assert(hmm_frame(&hmm->hmm) == frame_idx);\n        if (score BETTER_THAN bestscore)\n            bestscore = score;\n    }\n\n    return bestscore;\n}\n\nstatic int32\neval_word_chan(ngram_search_t *ngs, int frame_idx)\n{\n    root_chan_t *rhmm;\n    chan_t *hmm;\n    int32 i, w, bestscore, *awl, j, k;\n\n    k = 0;\n    bestscore = WORST_SCORE;\n    awl = ngs->active_word_list[frame_idx & 0x1];\n\n    i = ngs->n_active_word[frame_idx & 0x1];\n    for (w = *(awl++); i > 0; --i, w = *(awl++)) {\n        assert(bitvec_is_set(ngs->word_active, w));\n        bitvec_clear(ngs->word_active, w);\n        assert(ngs->word_chan[w] != NULL);\n\n        for (hmm = ngs->word_chan[w]; hmm; hmm = hmm->next) {\n            int32 score;\n\n            assert(hmm_frame(&hmm->hmm) == frame_idx);\n            score = chan_v_eval(hmm);\n            /*printf(\"eval word chan %d score %d\\n\", w, score); */\n\n            if (score BETTER_THAN bestscore)\n                bestscore = score;\n\n            k++;\n        }\n    }\n\n    /* Similarly for statically allocated single-phone words */\n    j = 0;\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        int32 score;\n\n        w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) < frame_idx)\n            continue;\n\n        score = chan_v_eval(rhmm);\n        /* printf(\"eval 1ph word chan %d score %d\\n\", w, score); */\n        if (score BETTER_THAN bestscore && w != ps_search_finish_wid(ngs))\n            bestscore = score;\n\n        j++;\n    }\n\n    ngs->st.n_last_chan_eval += k + j;\n    ngs->st.n_nonroot_chan_eval += k + j;\n    ngs->st.n_word_lastchan_eval +=\n        ngs->n_active_word[frame_idx & 0x1] + j;\n\n    return bestscore;\n}\n\nstatic int32\nevaluate_channels(ngram_search_t *ngs, int16 const *senone_scores, int frame_idx)\n{\n    int32 bs;\n\n    hmm_context_set_senscore(ngs->hmmctx, senone_scores);\n    ngs->best_score = eval_root_chan(ngs, frame_idx);\n    if ((bs = eval_nonroot_chan(ngs, frame_idx)) BETTER_THAN ngs->best_score)\n        ngs->best_score = bs;\n    if ((bs = eval_word_chan(ngs, frame_idx)) BETTER_THAN ngs->best_score)\n        ngs->best_score = bs;\n    ngs->last_phone_best_score = bs;\n\n    return ngs->best_score;\n}\n\n/*\n * Prune currently active root channels for next frame.  Also, perform exit\n * transitions out of them and activate successors.\n * score[] of pruned root chan set to WORST_SCORE elsewhere.\n */\nstatic void\nprune_root_chan(ngram_search_t *ngs, int frame_idx)\n{\n    root_chan_t *rhmm;\n    chan_t *hmm;\n    int32 i, nf, w;\n    int32 thresh, newphone_thresh, lastphn_thresh, newphone_score;\n    chan_t **nacl;              /* next active list */\n    lastphn_cand_t *candp;\n    phone_loop_search_t *pls;\n\n    nf = frame_idx + 1;\n    thresh = ngs->best_score + ngs->dynamic_beam;\n    newphone_thresh = ngs->best_score + ngs->pbeam;\n    lastphn_thresh = ngs->best_score + ngs->lpbeam;\n    nacl = ngs->active_chan_list[nf & 0x1];\n    pls = (phone_loop_search_t *)ps_search_lookahead(ngs);\n\n    for (i = 0, rhmm = ngs->root_chan; i < ngs->n_root_chan; i++, rhmm++) {\n        E_DEBUG(\"Root channel %d frame %d score %d thresh %d\\n\",\n                i, hmm_frame(&rhmm->hmm), hmm_bestscore(&rhmm->hmm), thresh);\n        /* First check if this channel was active in current frame */\n        if (hmm_frame(&rhmm->hmm) < frame_idx)\n            continue;\n\n        if (hmm_bestscore(&rhmm->hmm) BETTER_THAN thresh) {\n            hmm_frame(&rhmm->hmm) = nf;  /* rhmm will be active in next frame */\n            E_DEBUG(\"Preserving root channel %d score %d\\n\", i, hmm_bestscore(&rhmm->hmm));\n            /* transitions out of this root channel */\n            /* transition to all next-level channels in the HMM tree */\n            newphone_score = hmm_out_score(&rhmm->hmm) + ngs->pip;\n            if (pls != NULL || newphone_score BETTER_THAN newphone_thresh) {\n                for (hmm = rhmm->next; hmm; hmm = hmm->alt) {\n                    int32 pl_newphone_score = newphone_score\n                        + phone_loop_search_score(pls, hmm->ciphone);\n                    if (pl_newphone_score BETTER_THAN newphone_thresh) {\n                        if ((hmm_frame(&hmm->hmm) < frame_idx)\n                            || (newphone_score BETTER_THAN hmm_in_score(&hmm->hmm))) {\n                            hmm_enter(&hmm->hmm, newphone_score,\n                                      hmm_out_history(&rhmm->hmm), nf);\n                            *(nacl++) = hmm;\n                        }\n                    }\n                }\n            }\n\n            /*\n             * Transition to last phone of all words for which this is the\n             * penultimate phone (the last phones may need multiple right contexts).\n             * Remember to remove the temporary newword_penalty.\n             */\n            if (pls != NULL || newphone_score BETTER_THAN lastphn_thresh) {\n                for (w = rhmm->penult_phn_wid; w >= 0;\n                     w = ngs->homophone_set[w]) {\n                    int32 pl_newphone_score = newphone_score\n                        + phone_loop_search_score\n                        (pls, dict_last_phone(ps_search_dict(ngs),w));\n                    E_DEBUG(\"word %s newphone_score %d\\n\", dict_wordstr(ps_search_dict(ngs), w), newphone_score);\n                    if (pl_newphone_score BETTER_THAN lastphn_thresh) {\n                        candp = ngs->lastphn_cand + ngs->n_lastphn_cand;\n                        ngs->n_lastphn_cand++;\n                        candp->wid = w;\n                        candp->score =\n                            newphone_score - ngs->nwpen;\n                        candp->bp = hmm_out_history(&rhmm->hmm);\n                    }\n                }\n            }\n        }\n    }\n    ngs->n_active_chan[nf & 0x1] = (int)(nacl - ngs->active_chan_list[nf & 0x1]);\n}\n\n/*\n * Prune currently active nonroot channels in HMM tree for next frame.  Also, perform\n * exit transitions out of such channels and activate successors.\n */\nstatic void\nprune_nonroot_chan(ngram_search_t *ngs, int frame_idx)\n{\n    chan_t *hmm, *nexthmm;\n    int32 nf, w, i;\n    int32 thresh, newphone_thresh, lastphn_thresh, newphone_score;\n    chan_t **acl, **nacl;       /* active list, next active list */\n    lastphn_cand_t *candp;\n    phone_loop_search_t *pls;\n\n    nf = frame_idx + 1;\n\n    thresh = ngs->best_score + ngs->dynamic_beam;\n    newphone_thresh = ngs->best_score + ngs->pbeam;\n    lastphn_thresh = ngs->best_score + ngs->lpbeam;\n    pls = (phone_loop_search_t *)ps_search_lookahead(ngs);\n\n    acl = ngs->active_chan_list[frame_idx & 0x1];   /* currently active HMMs in tree */\n    nacl = ngs->active_chan_list[nf & 0x1] + ngs->n_active_chan[nf & 0x1];\n\n    for (i = ngs->n_active_chan[frame_idx & 0x1], hmm = *(acl++); i > 0;\n         --i, hmm = *(acl++)) {\n        assert(hmm_frame(&hmm->hmm) >= frame_idx);\n\n        if (hmm_bestscore(&hmm->hmm) BETTER_THAN thresh) {\n            /* retain this channel in next frame */\n            if (hmm_frame(&hmm->hmm) != nf) {\n                hmm_frame(&hmm->hmm) = nf;\n                *(nacl++) = hmm;\n            }\n\n            /* transition to all next-level channel in the HMM tree */\n            newphone_score = hmm_out_score(&hmm->hmm) + ngs->pip;\n            if (pls != NULL || newphone_score BETTER_THAN newphone_thresh) {\n                for (nexthmm = hmm->next; nexthmm; nexthmm = nexthmm->alt) {\n                    int32 pl_newphone_score = newphone_score\n                        + phone_loop_search_score(pls, nexthmm->ciphone);\n                    if ((pl_newphone_score BETTER_THAN newphone_thresh)\n                        && ((hmm_frame(&nexthmm->hmm) < frame_idx)\n                            || (newphone_score\n                                BETTER_THAN hmm_in_score(&nexthmm->hmm)))) {\n                        if (hmm_frame(&nexthmm->hmm) != nf) {\n                            /* Keep this HMM on the active list */\n                            *(nacl++) = nexthmm;\n                        }\n                        hmm_enter(&nexthmm->hmm, newphone_score,\n                                  hmm_out_history(&hmm->hmm), nf);\n                    }\n                }\n            }\n\n            /*\n             * Transition to last phone of all words for which this is the\n             * penultimate phone (the last phones may need multiple right contexts).\n             * Remember to remove the temporary newword_penalty.\n             */\n            if (pls != NULL || newphone_score BETTER_THAN lastphn_thresh) {\n                for (w = hmm->info.penult_phn_wid; w >= 0;\n                     w = ngs->homophone_set[w]) {\n                    int32 pl_newphone_score = newphone_score\n                        + phone_loop_search_score\n                        (pls, dict_last_phone(ps_search_dict(ngs),w));\n                    if (pl_newphone_score BETTER_THAN lastphn_thresh) {\n                        candp = ngs->lastphn_cand + ngs->n_lastphn_cand;\n                        ngs->n_lastphn_cand++;\n                        candp->wid = w;\n                        candp->score =\n                            newphone_score - ngs->nwpen;\n                        candp->bp = hmm_out_history(&hmm->hmm);\n                    }\n                }\n            }\n        }\n        else if (hmm_frame(&hmm->hmm) != nf) {\n            hmm_clear(&hmm->hmm);\n        }\n    }\n    ngs->n_active_chan[nf & 0x1] = (int)(nacl - ngs->active_chan_list[nf & 0x1]);\n}\n\n/*\n * Execute the transition into the last phone for all candidates words emerging from\n * the HMM tree.  Attach LM scores to such transitions.\n * (Executed after pruning root and non-root, but before pruning word-chan.)\n */\nstatic void\nlast_phone_transition(ngram_search_t *ngs, int frame_idx)\n{\n    int32 i, j, k, nf, bp, bpend, w;\n    lastphn_cand_t *candp;\n    int32 *nawl;\n    int32 thresh;\n    int32 bestscore, dscr;\n    chan_t *hmm;\n    bptbl_t *bpe;\n    int32 n_cand_sf = 0;\n\n    nf = frame_idx + 1;\n    nawl = ngs->active_word_list[nf & 0x1];\n    ngs->st.n_lastphn_cand_utt += ngs->n_lastphn_cand;\n\n    /* For each candidate word (entering its last phone) */\n    /* If best LM score and bp for candidate known use it, else sort cands by startfrm */\n    for (i = 0, candp = ngs->lastphn_cand; i < ngs->n_lastphn_cand; i++, candp++) {\n        int32 start_score;\n\n        /* This can happen if recognition fails. */\n        if (candp->bp == -1)\n            continue;\n        /* Backpointer entry for it. */\n        bpe = &(ngs->bp_table[candp->bp]);\n\n        /* Subtract starting score for candidate, leave it with only word score */\n        start_score = ngram_search_exit_score\n            (ngs, bpe, dict_first_phone(ps_search_dict(ngs), candp->wid));\n        assert(start_score BETTER_THAN WORST_SCORE);\n        candp->score -= start_score;\n\n        /*\n         * If this candidate not occurred in an earlier frame, prepare for finding\n         * best transition score into last phone; sort by start frame.\n         */\n        /* i.e. if we don't have an entry in last_ltrans for this\n         * <word,sf>, then create one */\n        if (ngs->last_ltrans[candp->wid].sf != bpe->frame + 1) {\n            /* Look for an entry in cand_sf matching the backpointer\n             * for this candidate. */\n            for (j = 0; j < n_cand_sf; j++) {\n                if (ngs->cand_sf[j].bp_ef == bpe->frame)\n                    break;\n            }\n            /* Oh, we found one, so chain onto it. */\n            if (j < n_cand_sf)\n                candp->next = ngs->cand_sf[j].cand;\n            else {\n                /* Nope, let's make a new one, allocating cand_sf if necessary. */\n                if (n_cand_sf >= ngs->cand_sf_alloc) {\n                    if (ngs->cand_sf_alloc == 0) {\n                        ngs->cand_sf =\n                            ckd_calloc(CAND_SF_ALLOCSIZE,\n                                       sizeof(*ngs->cand_sf));\n                        ngs->cand_sf_alloc = CAND_SF_ALLOCSIZE;\n                    }\n                    else {\n                        ngs->cand_sf_alloc += CAND_SF_ALLOCSIZE;\n                        ngs->cand_sf = ckd_realloc(ngs->cand_sf,\n                                                   ngs->cand_sf_alloc\n                                                   * sizeof(*ngs->cand_sf));\n                        E_INFO(\"cand_sf[] increased to %d entries\\n\",\n                               ngs->cand_sf_alloc);\n                    }\n                }\n\n                /* Use the newly created cand_sf. */\n                j = n_cand_sf++;\n                candp->next = -1; /* End of the chain. */\n                ngs->cand_sf[j].bp_ef = bpe->frame;\n            }\n            /* Update it to point to this candidate. */\n            ngs->cand_sf[j].cand = i;\n\n            ngs->last_ltrans[candp->wid].dscr = WORST_SCORE;\n            ngs->last_ltrans[candp->wid].sf = bpe->frame + 1;\n        }\n    }\n\n    /* Compute best LM score and bp for new cands entered in the sorted lists above */\n    for (i = 0; i < n_cand_sf; i++) {\n        /* For the i-th unique end frame... */\n        bp = ngs->bp_table_idx[ngs->cand_sf[i].bp_ef];\n        bpend = ngs->bp_table_idx[ngs->cand_sf[i].bp_ef + 1];\n        for (bpe = &(ngs->bp_table[bp]); bp < bpend; bp++, bpe++) {\n            if (!bpe->valid)\n                continue;\n            /* For each candidate at the start frame find bp->cand transition-score */\n            for (j = ngs->cand_sf[i].cand; j >= 0; j = candp->next) {\n                int32 n_used;\n                candp = &(ngs->lastphn_cand[j]);\n                dscr = \n                    ngram_search_exit_score\n                    (ngs, bpe, dict_first_phone(ps_search_dict(ngs), candp->wid));\n                if (dscr BETTER_THAN WORST_SCORE) {\n                    assert(!dict_filler_word(ps_search_dict(ngs), candp->wid));\n                    dscr += ngram_tg_score(ngs->lmset,\n                                           dict_basewid(ps_search_dict(ngs), candp->wid),\n                                           bpe->real_wid,\n                                           bpe->prev_real_wid,\n                                           &n_used)>>SENSCR_SHIFT;\n                }\n\n                if (dscr BETTER_THAN ngs->last_ltrans[candp->wid].dscr) {\n                    ngs->last_ltrans[candp->wid].dscr = dscr;\n                    ngs->last_ltrans[candp->wid].bp = bp;\n                }\n            }\n        }\n    }\n\n    /* Update best transitions for all candidates; also update best lastphone score */\n    bestscore = ngs->last_phone_best_score;\n    for (i = 0, candp = ngs->lastphn_cand; i < ngs->n_lastphn_cand; i++, candp++) {\n        candp->score += ngs->last_ltrans[candp->wid].dscr;\n        candp->bp = ngs->last_ltrans[candp->wid].bp;\n\n        if (candp->score BETTER_THAN bestscore)\n            bestscore = candp->score;\n    }\n    ngs->last_phone_best_score = bestscore;\n\n    /* At this pt, we know the best entry score (with LM component) for all candidates */\n    thresh = bestscore + ngs->lponlybeam;\n    for (i = ngs->n_lastphn_cand, candp = ngs->lastphn_cand; i > 0; --i, candp++) {\n        if (candp->score BETTER_THAN thresh) {\n            w = candp->wid;\n\n            ngram_search_alloc_all_rc(ngs, w);\n\n            k = 0;\n            for (hmm = ngs->word_chan[w]; hmm; hmm = hmm->next) {\n                if ((hmm_frame(&hmm->hmm) < frame_idx)\n                    || (candp->score BETTER_THAN hmm_in_score(&hmm->hmm))) {\n                    assert(hmm_frame(&hmm->hmm) != nf);\n                    hmm_enter(&hmm->hmm,\n                              candp->score, candp->bp, nf);\n                    k++;\n                }\n            }\n            if (k > 0) {\n                assert(bitvec_is_clear(ngs->word_active, w));\n                assert(!dict_is_single_phone(ps_search_dict(ngs), w));\n                *(nawl++) = w;\n                bitvec_set(ngs->word_active, w);\n            }\n        }\n    }\n    ngs->n_active_word[nf & 0x1] = (int)(nawl - ngs->active_word_list[nf & 0x1]);\n}\n\n/*\n * Prune currently active word channels for next frame.  Also, perform exit\n * transitions out of such channels and active successors.\n */\nstatic void\nprune_word_chan(ngram_search_t *ngs, int frame_idx)\n{\n    root_chan_t *rhmm;\n    chan_t *hmm, *thmm;\n    chan_t **phmmp;             /* previous HMM-pointer */\n    int32 nf, w, i, k;\n    int32 newword_thresh, lastphn_thresh;\n    int32 *awl, *nawl;\n\n    nf = frame_idx + 1;\n    newword_thresh = ngs->last_phone_best_score + ngs->wbeam;\n    lastphn_thresh = ngs->last_phone_best_score + ngs->lponlybeam;\n\n    awl = ngs->active_word_list[frame_idx & 0x1];\n    nawl = ngs->active_word_list[nf & 0x1] + ngs->n_active_word[nf & 0x1];\n\n    /* Dynamically allocated last channels of multi-phone words */\n    for (i = ngs->n_active_word[frame_idx & 0x1], w = *(awl++); i > 0;\n         --i, w = *(awl++)) {\n        k = 0;\n        phmmp = &(ngs->word_chan[w]);\n        for (hmm = ngs->word_chan[w]; hmm; hmm = thmm) {\n            assert(hmm_frame(&hmm->hmm) >= frame_idx);\n\n            thmm = hmm->next;\n            if (hmm_bestscore(&hmm->hmm) BETTER_THAN lastphn_thresh) {\n                /* retain this channel in next frame */\n                hmm_frame(&hmm->hmm) = nf;\n                k++;\n                phmmp = &(hmm->next);\n\n                /* Could if ((! skip_alt_frm) || (frame_idx & 0x1)) the following */\n                if (hmm_out_score(&hmm->hmm) BETTER_THAN newword_thresh) {\n                    /* can exit channel and recognize word */\n                    ngram_search_save_bp(ngs, frame_idx, w,\n                                 hmm_out_score(&hmm->hmm),\n                                 hmm_out_history(&hmm->hmm),\n                                 hmm->info.rc_id);\n                }\n            }\n            else if (hmm_frame(&hmm->hmm) == nf) {\n                phmmp = &(hmm->next);\n            }\n            else {\n                hmm_deinit(&hmm->hmm);\n                listelem_free(ngs->chan_alloc, hmm);\n                *phmmp = thmm;\n            }\n        }\n        if ((k > 0) && (bitvec_is_clear(ngs->word_active, w))) {\n            assert(!dict_is_single_phone(ps_search_dict(ngs), w));\n            *(nawl++) = w;\n            bitvec_set(ngs->word_active, w);\n        }\n    }\n    ngs->n_active_word[nf & 0x1] = (int)(nawl - ngs->active_word_list[nf & 0x1]);\n\n    /*\n     * Prune permanently allocated single-phone channels.\n     * NOTES: score[] of pruned channels set to WORST_SCORE elsewhere.\n     */\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        E_DEBUG(\"Single phone word %s frame %d score %d thresh %d outscore %d nwthresh %d\\n\",\n                dict_wordstr(ps_search_dict(ngs),w),\n                hmm_frame(&rhmm->hmm), hmm_bestscore(&rhmm->hmm),\n                lastphn_thresh, hmm_out_score(&rhmm->hmm), newword_thresh);\n        if (hmm_frame(&rhmm->hmm) < frame_idx)\n            continue;\n        if (hmm_bestscore(&rhmm->hmm) BETTER_THAN lastphn_thresh) {\n            hmm_frame(&rhmm->hmm) = nf;\n\n            /* Could if ((! skip_alt_frm) || (frame_idx & 0x1)) the following */\n            if (hmm_out_score(&rhmm->hmm) BETTER_THAN newword_thresh) {\n                E_DEBUG(\"Exiting single phone word %s with %d > %d, %d\\n\",\n                        dict_wordstr(ps_search_dict(ngs),w),\n                        hmm_out_score(&rhmm->hmm),\n                        lastphn_thresh, newword_thresh);\n                ngram_search_save_bp(ngs, frame_idx, w,\n                             hmm_out_score(&rhmm->hmm),\n                             hmm_out_history(&rhmm->hmm), 0);\n            }\n        }\n    }\n}\n\nstatic void\nprune_channels(ngram_search_t *ngs, int frame_idx)\n{\n    /* Clear last phone candidate list. */\n    ngs->n_lastphn_cand = 0;\n    /* Set the dynamic beam based on maxhmmpf here. */\n    ngs->dynamic_beam = ngs->beam;\n    if (ngs->maxhmmpf != -1\n        && ngs->st.n_root_chan_eval + ngs->st.n_nonroot_chan_eval > ngs->maxhmmpf) {\n        /* Build a histogram to approximately prune them. */\n        int32 bins[256], bw, nhmms, i;\n        root_chan_t *rhmm;\n        chan_t **acl, *hmm;\n\n        /* Bins go from zero (best score) to edge of beam. */\n        bw = -ngs->beam / 256;\n        memset(bins, 0, sizeof(bins));\n        /* For each active root channel. */\n        for (i = 0, rhmm = ngs->root_chan; i < ngs->n_root_chan; i++, rhmm++) {\n            int32 b;\n\n            /* Put it in a bin according to its bestscore. */\n            b = (ngs->best_score - hmm_bestscore(&rhmm->hmm)) / bw;\n            if (b >= 256)\n                b = 255;\n            ++bins[b];\n        }\n        /* For each active non-root channel. */\n        acl = ngs->active_chan_list[frame_idx & 0x1];       /* currently active HMMs in tree */\n        for (i = ngs->n_active_chan[frame_idx & 0x1], hmm = *(acl++);\n             i > 0; --i, hmm = *(acl++)) {\n            int32 b;\n\n            /* Put it in a bin according to its bestscore. */\n            b = (ngs->best_score - hmm_bestscore(&hmm->hmm)) / bw;\n            if (b >= 256)\n                b = 255;\n            ++bins[b];\n        }\n        /* Walk down the bins to find the new beam. */\n        for (i = nhmms = 0; i < 256; ++i) {\n            nhmms += bins[i];\n            if (nhmms > ngs->maxhmmpf)\n                break;\n        }\n        ngs->dynamic_beam = -(i * bw);\n    }\n\n    prune_root_chan(ngs, frame_idx);\n    prune_nonroot_chan(ngs, frame_idx);\n    last_phone_transition(ngs, frame_idx);\n    prune_word_chan(ngs, frame_idx);\n}\n\n/*\n * Limit the number of word exits in each frame to maxwpf.  And also limit the number of filler\n * words to 1.\n */\nstatic void\nbptable_maxwpf(ngram_search_t *ngs, int frame_idx)\n{\n    int32 bp, n;\n    int32 bestscr, worstscr;\n    bptbl_t *bpe, *bestbpe, *worstbpe;\n\n    /* Don't prune if no pruing. */\n    if (ngs->maxwpf == -1 || ngs->maxwpf == ps_search_n_words(ngs))\n        return;\n\n    /* Allow only one filler word exit (the best) per frame */\n    bestscr = (int32) 0x80000000;\n    bestbpe = NULL;\n    n = 0;\n    for (bp = ngs->bp_table_idx[frame_idx]; bp < ngs->bpidx; bp++) {\n        bpe = &(ngs->bp_table[bp]);\n        if (dict_filler_word(ps_search_dict(ngs), bpe->wid)) {\n            if (bpe->score BETTER_THAN bestscr) {\n                bestscr = bpe->score;\n                bestbpe = bpe;\n            }\n            bpe->valid = FALSE;\n            n++;                /* No. of filler words */\n        }\n    }\n    /* Restore bestbpe to valid state */\n    if (bestbpe != NULL) {\n        bestbpe->valid = TRUE;\n        --n;\n    }\n\n    /* Allow up to maxwpf best entries to survive; mark the remaining with valid = 0 */\n    n = (ngs->bpidx\n         - ngs->bp_table_idx[frame_idx]) - n;  /* No. of entries after limiting fillers */\n    for (; n > ngs->maxwpf; --n) {\n        /* Find worst BPTable entry */\n        worstscr = (int32) 0x7fffffff;\n        worstbpe = NULL;\n        for (bp = ngs->bp_table_idx[frame_idx]; (bp < ngs->bpidx); bp++) {\n            bpe = &(ngs->bp_table[bp]);\n            if (bpe->valid && (bpe->score WORSE_THAN worstscr)) {\n                worstscr = bpe->score;\n                worstbpe = bpe;\n            }\n        }\n        /* FIXME: Don't panic! */\n        if (worstbpe == NULL)\n            E_FATAL(\"PANIC: No worst BPtable entry remaining\\n\");\n        worstbpe->valid = FALSE;\n    }\n}\n\nstatic void\nword_transition(ngram_search_t *ngs, int frame_idx)\n{\n    int32 i, k, bp, w, nf;\n    int32 rc;\n    int32 thresh, newscore, pl_newscore;\n    bptbl_t *bpe;\n    root_chan_t *rhmm;\n    struct bestbp_rc_s *bestbp_rc_ptr;\n    phone_loop_search_t *pls;\n    dict_t *dict = ps_search_dict(ngs);\n    dict2pid_t *d2p = ps_search_dict2pid(ngs);\n\n    /*\n     * Transition to start of new word instances (HMM tree roots); but only if words\n     * other than </s> finished here.\n     * But, first, find the best starting score for each possible right context phone.\n     */\n    for (i = bin_mdef_n_ciphone(ps_search_acmod(ngs)->mdef) - 1; i >= 0; --i)\n        ngs->bestbp_rc[i].score = WORST_SCORE;\n    k = 0;\n    pls = (phone_loop_search_t *)ps_search_lookahead(ngs);\n    /* Ugh, this is complicated.  Scan all word exits for this frame\n     * (they have already been created by prune_word_chan()). */\n    for (bp = ngs->bp_table_idx[frame_idx]; bp < ngs->bpidx; bp++) {\n        bpe = &(ngs->bp_table[bp]);\n        ngs->word_lat_idx[bpe->wid] = NO_BP;\n\n        if (bpe->wid == ps_search_finish_wid(ngs))\n            continue;\n        k++;\n\n        /* DICT2PID */\n        /* Array of HMM scores corresponding to all the possible right\n         * context expansions of the final phone.  It's likely that a\n         * lot of these are going to be missing, actually. */\n        if (bpe->last2_phone == -1) { /* implies s_idx == -1 */\n            /* No right context expansion. */\n            for (rc = 0; rc < bin_mdef_n_ciphone(ps_search_acmod(ngs)->mdef); ++rc) {\n                if (bpe->score BETTER_THAN ngs->bestbp_rc[rc].score) {\n                    E_DEBUG(\"bestbp_rc[0] = %d lc %d\\n\",\n                            bpe->score, bpe->last_phone);\n                    ngs->bestbp_rc[rc].score = bpe->score;\n                    ngs->bestbp_rc[rc].path = bp;\n                    ngs->bestbp_rc[rc].lc = bpe->last_phone;\n                }\n            }\n        }\n        else {\n            xwdssid_t *rssid = dict2pid_rssid(d2p, bpe->last_phone, bpe->last2_phone);\n            int32 *rcss = &(ngs->bscore_stack[bpe->s_idx]);\n            for (rc = 0; rc < bin_mdef_n_ciphone(ps_search_acmod(ngs)->mdef); ++rc) {\n                if (rcss[rssid->cimap[rc]] BETTER_THAN ngs->bestbp_rc[rc].score) {\n                    E_DEBUG(\"bestbp_rc[%d] = %d lc %d\\n\",\n                            rc, rcss[rssid->cimap[rc]], bpe->last_phone);\n                    ngs->bestbp_rc[rc].score = rcss[rssid->cimap[rc]];\n                    ngs->bestbp_rc[rc].path = bp;\n                    ngs->bestbp_rc[rc].lc = bpe->last_phone;\n                }\n            }\n        }\n    }\n    if (k == 0)\n        return;\n\n    nf = frame_idx + 1;\n    thresh = ngs->best_score + ngs->dynamic_beam;\n    /*\n     * Hypothesize successors to words finished in this frame.\n     * Main dictionary, multi-phone words transition to HMM-trees roots.\n     */\n    for (i = ngs->n_root_chan, rhmm = ngs->root_chan; i > 0; --i, rhmm++) {\n        bestbp_rc_ptr = &(ngs->bestbp_rc[rhmm->ciphone]);\n\n        newscore = bestbp_rc_ptr->score + ngs->nwpen + ngs->pip;\n        pl_newscore = newscore\n            + phone_loop_search_score(pls, rhmm->ciphone);\n        if (pl_newscore BETTER_THAN thresh) {\n            if ((hmm_frame(&rhmm->hmm) < frame_idx)\n                || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n                hmm_enter(&rhmm->hmm, newscore,\n                          bestbp_rc_ptr->path, nf);\n                /* DICT2PID: Another place where mpx ssids are entered. */\n                /* Look up the ssid to use when entering this mpx triphone. */\n                hmm_mpx_ssid(&rhmm->hmm, 0) =\n                    dict2pid_ldiph_lc(d2p, rhmm->ciphone, rhmm->ci2phone, bestbp_rc_ptr->lc);\n                assert(hmm_mpx_ssid(&rhmm->hmm, 0) != BAD_SSID);\n            }\n        }\n    }\n\n    /*\n     * Single phone words; no right context for these.  Cannot use bestbp_rc as\n     * LM scores have to be included.  First find best transition to these words.\n     */\n    for (i = 0; i < ngs->n_1ph_LMwords; i++) {\n        w = ngs->single_phone_wid[i];\n        ngs->last_ltrans[w].dscr = (int32) 0x80000000;\n    }\n    for (bp = ngs->bp_table_idx[frame_idx]; bp < ngs->bpidx; bp++) {\n        bpe = &(ngs->bp_table[bp]);\n        if (!bpe->valid)\n            continue;\n\n        for (i = 0; i < ngs->n_1ph_LMwords; i++) {\n            int32 n_used;\n            w = ngs->single_phone_wid[i];\n            newscore = ngram_search_exit_score\n                (ngs, bpe, dict_first_phone(dict, w));\n            E_DEBUG(\"initial newscore for %s: %d\\n\",\n                    dict_wordstr(dict, w), newscore);\n            if (newscore != WORST_SCORE)\n                newscore += ngram_tg_score(ngs->lmset,\n                                           dict_basewid(dict, w),\n                                           bpe->real_wid,\n                                           bpe->prev_real_wid,\n                                           &n_used)>>SENSCR_SHIFT;\n\n            /* FIXME: Not sure how WORST_SCORE could be better, but it\n             * apparently happens. */\n            if (newscore BETTER_THAN ngs->last_ltrans[w].dscr) {\n                ngs->last_ltrans[w].dscr = newscore;\n                ngs->last_ltrans[w].bp = bp;\n            }\n        }\n    }\n\n    /* Now transition to in-LM single phone words */\n    for (i = 0; i < ngs->n_1ph_LMwords; i++) {\n        w = ngs->single_phone_wid[i];\n        /* Never transition into the start word (for one thing, it is\n           a non-event in the language model.) */\n        if (w == dict_startwid(ps_search_dict(ngs)))\n            continue;\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        newscore = ngs->last_ltrans[w].dscr + ngs->pip;\n\tpl_newscore = newscore + phone_loop_search_score(pls, rhmm->ciphone);\n        if (pl_newscore BETTER_THAN thresh) {\n            bpe = ngs->bp_table + ngs->last_ltrans[w].bp;\n            if ((hmm_frame(&rhmm->hmm) < frame_idx)\n                || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n                hmm_enter(&rhmm->hmm,\n                          newscore, ngs->last_ltrans[w].bp, nf);\n                /* DICT2PID: another place where mpx ssids are entered. */\n                /* Look up the ssid to use when entering this mpx triphone. */\n                hmm_mpx_ssid(&rhmm->hmm, 0) =\n                    dict2pid_ldiph_lc(d2p, rhmm->ciphone, rhmm->ci2phone,\n                                      dict_last_phone(dict, bpe->wid));\n                assert(hmm_mpx_ssid(&rhmm->hmm, 0) != BAD_SSID);\n            }\n        }\n    }\n\n    /* Remaining words: <sil>, noise words.  No mpx for these! */\n    w = ps_search_silence_wid(ngs);\n    rhmm = (root_chan_t *) ngs->word_chan[w];\n    bestbp_rc_ptr = &(ngs->bestbp_rc[ps_search_acmod(ngs)->mdef->sil]);\n    newscore = bestbp_rc_ptr->score + ngs->silpen + ngs->pip;\n    pl_newscore = newscore\n        + phone_loop_search_score(pls, rhmm->ciphone);\n    if (pl_newscore BETTER_THAN thresh) {\n        if ((hmm_frame(&rhmm->hmm) < frame_idx)\n            || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n            hmm_enter(&rhmm->hmm,\n                      newscore, bestbp_rc_ptr->path, nf);\n        }\n    }\n    for (w = dict_filler_start(dict); w <= dict_filler_end(dict); w++) {\n        if (w == ps_search_silence_wid(ngs))\n            continue;\n        /* Never transition into the start word (for one thing, it is\n           a non-event in the language model.) */\n        if (w == dict_startwid(ps_search_dict(ngs)))\n            continue;\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        /* If this was not actually a single-phone word, rhmm will be NULL. */\n        if (rhmm == NULL)\n            continue;\n        newscore = bestbp_rc_ptr->score + ngs->fillpen + ngs->pip;\n        pl_newscore = newscore\n            + phone_loop_search_score(pls, rhmm->ciphone);\n        if (pl_newscore BETTER_THAN thresh) {\n            if ((hmm_frame(&rhmm->hmm) < frame_idx)\n                || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n                hmm_enter(&rhmm->hmm,\n                          newscore, bestbp_rc_ptr->path, nf);\n            }\n        }\n    }\n}\n\nstatic void\ndeactivate_channels(ngram_search_t *ngs, int frame_idx)\n{\n    root_chan_t *rhmm;\n    int i;\n\n    /* Clear score[] of pruned root channels */\n    for (i = ngs->n_root_chan, rhmm = ngs->root_chan; i > 0; --i, rhmm++) {\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            hmm_clear(&rhmm->hmm);\n        }\n    }\n    /* Clear score[] of pruned single-phone channels */\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        int32 w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            hmm_clear(&rhmm->hmm);\n        }\n    }\n}\n\nint\nngram_fwdtree_search(ngram_search_t *ngs, int frame_idx)\n{\n    int16 const *senscr;\n\n    /* Activate our HMMs for the current frame if need be. */\n    if (!ps_search_acmod(ngs)->compallsen)\n        compute_sen_active(ngs, frame_idx);\n\n    /* Compute GMM scores for the current frame. */\n    if ((senscr = acmod_score(ps_search_acmod(ngs), &frame_idx)) == NULL)\n        return 0;\n    ngs->st.n_senone_active_utt += ps_search_acmod(ngs)->n_senone_active;\n\n    /* Mark backpointer table for current frame. */\n    ngram_search_mark_bptable(ngs, frame_idx);\n\n    /* If the best score is equal to or worse than WORST_SCORE,\n     * recognition has failed, don't bother to keep trying. */\n    if (ngs->best_score == WORST_SCORE || ngs->best_score WORSE_THAN WORST_SCORE)\n        return 0;\n    /* Renormalize if necessary */\n    if (ngs->best_score + (2 * ngs->beam) WORSE_THAN WORST_SCORE) {\n        E_INFO(\"Renormalizing Scores at frame %d, best score %d\\n\",\n               frame_idx, ngs->best_score);\n        renormalize_scores(ngs, frame_idx, ngs->best_score);\n    }\n\n    /* Evaluate HMMs */\n    evaluate_channels(ngs, senscr, frame_idx);\n    /* Prune HMMs and do phone transitions. */\n    prune_channels(ngs, frame_idx);\n    /* Do absolute pruning on word exits. */\n    bptable_maxwpf(ngs, frame_idx);\n    /* Do word transitions. */\n    word_transition(ngs, frame_idx);\n    /* Deactivate pruned HMMs. */\n    deactivate_channels(ngs, frame_idx);\n\n    ++ngs->n_frame;\n    /* Return the number of frames processed. */\n    return 1;\n}\n\nvoid\nngram_fwdtree_finish(ngram_search_t *ngs)\n{\n    int32 i, w, cf, *awl;\n    root_chan_t *rhmm;\n    chan_t *hmm, **acl;\n\n    /* This is the number of frames processed. */\n    cf = ps_search_acmod(ngs)->output_frame;\n    /* Add a mark in the backpointer table for one past the final frame. */\n    ngram_search_mark_bptable(ngs, cf);\n\n    /* Deactivate channels lined up for the next frame */\n    /* First, root channels of HMM tree */\n    for (i = ngs->n_root_chan, rhmm = ngs->root_chan; i > 0; --i, rhmm++) {\n        hmm_clear(&rhmm->hmm);\n    }\n\n    /* nonroot channels of HMM tree */\n    i = ngs->n_active_chan[cf & 0x1];\n    acl = ngs->active_chan_list[cf & 0x1];\n    for (hmm = *(acl++); i > 0; --i, hmm = *(acl++)) {\n        hmm_clear(&hmm->hmm);\n    }\n\n    /* word channels */\n    i = ngs->n_active_word[cf & 0x1];\n    awl = ngs->active_word_list[cf & 0x1];\n    for (w = *(awl++); i > 0; --i, w = *(awl++)) {\n        /* Don't accidentally free single-phone words! */\n        if (dict_is_single_phone(ps_search_dict(ngs), w))\n            continue;\n        bitvec_clear(ngs->word_active, w);\n        if (ngs->word_chan[w] == NULL)\n            continue;\n        ngram_search_free_all_rc(ngs, w);\n    }\n\n    /*\n     * The previous search code did a postprocessing of the\n     * backpointer table here, but we will postpone this until it is\n     * absolutely necessary, i.e. when generating a word graph.\n     * Likewise we don't actually have to decide what the exit word is\n     * until somebody requests a backtrace.\n     */\n\n    ptmr_stop(&ngs->fwdtree_perf);\n    /* Print out some statistics. */\n    if (cf > 0) {\n        double n_speech = (double)(cf + 1)\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n        E_INFO(\"%8d words recognized (%d/fr)\\n\",\n               ngs->bpidx, (ngs->bpidx + (cf >> 1)) / (cf + 1));\n        E_INFO(\"%8d senones evaluated (%d/fr)\\n\", ngs->st.n_senone_active_utt,\n               (ngs->st.n_senone_active_utt + (cf >> 1)) / (cf + 1));\n        E_INFO(\"%8d channels searched (%d/fr), %d 1st, %d last\\n\",\n               ngs->st.n_root_chan_eval + ngs->st.n_nonroot_chan_eval,\n               (ngs->st.n_root_chan_eval + ngs->st.n_nonroot_chan_eval) / (cf + 1),\n               ngs->st.n_root_chan_eval, ngs->st.n_last_chan_eval);\n        E_INFO(\"%8d words for which last channels evaluated (%d/fr)\\n\",\n               ngs->st.n_word_lastchan_eval,\n               ngs->st.n_word_lastchan_eval / (cf + 1));\n        E_INFO(\"%8d candidate words for entering last phone (%d/fr)\\n\",\n               ngs->st.n_lastphn_cand_utt, ngs->st.n_lastphn_cand_utt / (cf + 1));\n        E_INFO(\"fwdtree %.2f CPU %.3f xRT\\n\",\n               ngs->fwdtree_perf.t_cpu,\n               ngs->fwdtree_perf.t_cpu / n_speech);\n        E_INFO(\"fwdtree %.2f wall %.3f xRT\\n\",\n               ngs->fwdtree_perf.t_elapsed,\n               ngs->fwdtree_perf.t_elapsed / n_speech);\n    }\n    /* dump_bptable(ngs); */\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file ngram_search_fwdflat.c Flat lexicon search.\n */\n\n/* System headers. */\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/listelem_alloc.h>\n#include <sphinxbase/err.h>\n\n/* Local headers. */\n#include \"ngram_search.h\"\n#include \"ps_lattice_internal.h\"\n\n/* Turn this on to dump channels for debugging */\n#define __CHAN_DUMP__\t\t0\n#if __CHAN_DUMP__\n#define chan_v_eval(chan) hmm_dump_vit_eval(&(chan)->hmm, stderr)\n#else\n#define chan_v_eval(chan) hmm_vit_eval(&(chan)->hmm)\n#endif\n\nstatic void\nngram_fwdflat_expand_all(ngram_search_t *ngs)\n{\n    int n_words, i;\n\n    /* For all \"real words\" (not fillers or <s>/</s>) in the dictionary,\n     *\n     * 1) Add the ones which are in the LM to the fwdflat wordlist\n     * 2) And to the expansion list (since we are expanding all)\n     */\n    ngs->n_expand_words = 0;\n    n_words = ps_search_n_words(ngs);\n    bitvec_clear_all(ngs->expand_word_flag, ps_search_n_words(ngs));\n    for (i = 0; i < n_words; ++i) {\n        if (!ngram_model_set_known_wid(ngs->lmset,\n                                       dict_basewid(ps_search_dict(ngs),i)))\n            continue;\n        ngs->fwdflat_wordlist[ngs->n_expand_words] = i;\n        ngs->expand_word_list[ngs->n_expand_words] = i;\n        bitvec_set(ngs->expand_word_flag, i);\n        ngs->n_expand_words++;\n    }\n    E_INFO(\"Utterance vocabulary contains %d words\\n\", ngs->n_expand_words);\n    ngs->expand_word_list[ngs->n_expand_words] = -1;\n    ngs->fwdflat_wordlist[ngs->n_expand_words] = -1;\n}\n\nstatic void\nngram_fwdflat_allocate_1ph(ngram_search_t *ngs)\n{\n    dict_t *dict = ps_search_dict(ngs);\n    int n_words = ps_search_n_words(ngs);\n    int i, w;\n\n    /* Allocate single-phone words, since they won't have\n     * been allocated for us by fwdtree initialization. */\n    ngs->n_1ph_words = 0;\n    for (w = 0; w < n_words; w++) {\n        if (dict_is_single_phone(dict, w))\n            ++ngs->n_1ph_words;\n    }\n    ngs->single_phone_wid = ckd_calloc(ngs->n_1ph_words,\n                                       sizeof(*ngs->single_phone_wid));\n    ngs->rhmm_1ph = ckd_calloc(ngs->n_1ph_words, sizeof(*ngs->rhmm_1ph));\n    i = 0;\n    for (w = 0; w < n_words; w++) {\n        if (!dict_is_single_phone(dict, w))\n            continue;\n\n        /* DICT2PID location */\n        ngs->rhmm_1ph[i].ciphone = dict_first_phone(dict, w);\n        ngs->rhmm_1ph[i].ci2phone = bin_mdef_silphone(ps_search_acmod(ngs)->mdef);\n        hmm_init(ngs->hmmctx, &ngs->rhmm_1ph[i].hmm, TRUE,\n                 /* ssid */ bin_mdef_pid2ssid(ps_search_acmod(ngs)->mdef,\n                                              ngs->rhmm_1ph[i].ciphone),\n                 /* tmatid */ bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef,\n    \t\t\t\t\t\t  ngs->rhmm_1ph[i].ciphone));\n        ngs->rhmm_1ph[i].next = NULL;\n        ngs->word_chan[w] = (chan_t *) &(ngs->rhmm_1ph[i]);\n        ngs->single_phone_wid[i] = w;\n        i++;\n    }\n}\n\nstatic void\nngram_fwdflat_free_1ph(ngram_search_t *ngs)\n{\n    int i, w;\n    int n_words = ps_search_n_words(ngs);\n\n    for (i = w = 0; w < n_words; ++w) {\n        if (!dict_is_single_phone(ps_search_dict(ngs), w))\n            continue;\n        hmm_deinit(&ngs->rhmm_1ph[i].hmm);\n        ++i;\n    }\n    ckd_free(ngs->rhmm_1ph);\n    ngs->rhmm_1ph = NULL;\n    ckd_free(ngs->single_phone_wid);\n}\n\nvoid\nngram_fwdflat_init(ngram_search_t *ngs)\n{\n    int n_words;\n\n    n_words = ps_search_n_words(ngs);\n    ngs->fwdflat_wordlist = ckd_calloc(n_words + 1, sizeof(*ngs->fwdflat_wordlist));\n    ngs->expand_word_flag = bitvec_alloc(n_words);\n    ngs->expand_word_list = ckd_calloc(n_words + 1, sizeof(*ngs->expand_word_list));\n    ngs->frm_wordlist = ckd_calloc(ngs->n_frame_alloc, sizeof(*ngs->frm_wordlist));\n    ngs->min_ef_width = cmd_ln_int32_r(ps_search_config(ngs), \"-fwdflatefwid\");\n    ngs->max_sf_win = cmd_ln_int32_r(ps_search_config(ngs), \"-fwdflatsfwin\");\n    E_INFO(\"fwdflat: min_ef_width = %d, max_sf_win = %d\\n\",\n           ngs->min_ef_width, ngs->max_sf_win);\n\n    /* No tree-search; pre-build the expansion list, including all LM words. */\n    if (!ngs->fwdtree) {\n        /* Build full expansion list from LM words. */\n        ngram_fwdflat_expand_all(ngs);\n        /* Allocate single phone words. */\n        ngram_fwdflat_allocate_1ph(ngs);\n    }\n}\n\nvoid\nngram_fwdflat_deinit(ngram_search_t *ngs)\n{\n    double n_speech = (double)ngs->n_tot_frame\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n\n    E_INFO(\"TOTAL fwdflat %.2f CPU %.3f xRT\\n\",\n           ngs->fwdflat_perf.t_tot_cpu,\n           ngs->fwdflat_perf.t_tot_cpu / n_speech);\n    E_INFO(\"TOTAL fwdflat %.2f wall %.3f xRT\\n\",\n           ngs->fwdflat_perf.t_tot_elapsed,\n           ngs->fwdflat_perf.t_tot_elapsed / n_speech);\n\n    /* Free single-phone words if we allocated them. */\n    if (!ngs->fwdtree) {\n        ngram_fwdflat_free_1ph(ngs);\n    }\n    ckd_free(ngs->fwdflat_wordlist);\n    bitvec_free(ngs->expand_word_flag);\n    ckd_free(ngs->expand_word_list);\n    ckd_free(ngs->frm_wordlist);\n}\n\nint\nngram_fwdflat_reinit(ngram_search_t *ngs)\n{\n    /* Reallocate things that depend on the number of words. */\n    int n_words;\n\n    ckd_free(ngs->fwdflat_wordlist);\n    ckd_free(ngs->expand_word_list);\n    bitvec_free(ngs->expand_word_flag);\n    n_words = ps_search_n_words(ngs);\n    ngs->fwdflat_wordlist = ckd_calloc(n_words + 1, sizeof(*ngs->fwdflat_wordlist));\n    ngs->expand_word_flag = bitvec_alloc(n_words);\n    ngs->expand_word_list = ckd_calloc(n_words + 1, sizeof(*ngs->expand_word_list));\n    \n    /* No tree-search; take care of the expansion list and single phone words. */\n    if (!ngs->fwdtree) {\n        /* Free single-phone words. */\n        ngram_fwdflat_free_1ph(ngs);\n        /* Reallocate word_chan. */\n        ckd_free(ngs->word_chan);\n        ngs->word_chan = ckd_calloc(dict_size(ps_search_dict(ngs)),\n                                    sizeof(*ngs->word_chan));\n        /* Rebuild full expansion list from LM words. */\n        ngram_fwdflat_expand_all(ngs);\n        /* Allocate single phone words. */\n        ngram_fwdflat_allocate_1ph(ngs);\n    }\n    /* Otherwise there is nothing to do since the wordlist is\n     * generated anew every utterance. */\n    return 0;\n}\n\n/**\n * Find all active words in backpointer table and sort by frame.\n */\nstatic void\nbuild_fwdflat_wordlist(ngram_search_t *ngs)\n{\n    int32 i, f, sf, ef, wid, nwd;\n    bptbl_t *bp;\n    ps_latnode_t *node, *prevnode, *nextnode;\n\n    /* No tree-search, use statically allocated wordlist. */\n    if (!ngs->fwdtree)\n        return;\n\n    memset(ngs->frm_wordlist, 0, ngs->n_frame_alloc * sizeof(*ngs->frm_wordlist));\n\n    /* Scan the backpointer table for all active words and record\n     * their exit frames. */\n    for (i = 0, bp = ngs->bp_table; i < ngs->bpidx; i++, bp++) {\n        sf = (bp->bp < 0) ? 0 : ngs->bp_table[bp->bp].frame + 1;\n        ef = bp->frame;\n        wid = bp->wid;\n\n        /* Anything that can be transitioned to in the LM can go in\n         * the word list. */\n        if (!ngram_model_set_known_wid(ngs->lmset,\n                                       dict_basewid(ps_search_dict(ngs), wid)))\n            continue;\n\n        /* Look for it in the wordlist. */\n        for (node = ngs->frm_wordlist[sf]; node && (node->wid != wid);\n             node = node->next);\n\n        /* Update last end frame. */\n        if (node)\n            node->lef = ef;\n        else {\n            /* New node; link to head of list */\n            node = listelem_malloc(ngs->latnode_alloc);\n            node->wid = wid;\n            node->fef = node->lef = ef;\n\n            node->next = ngs->frm_wordlist[sf];\n            ngs->frm_wordlist[sf] = node;\n        }\n    }\n\n    /* Eliminate \"unlikely\" words, for which there are too few end points */\n    for (f = 0; f < ngs->n_frame; f++) {\n        prevnode = NULL;\n        for (node = ngs->frm_wordlist[f]; node; node = nextnode) {\n            nextnode = node->next;\n            /* Word has too few endpoints */\n            if ((node->lef - node->fef < ngs->min_ef_width) ||\n                /* Word is </s> and doesn't actually end in last frame */\n                ((node->wid == ps_search_finish_wid(ngs)) && (node->lef < ngs->n_frame - 1))) {\n                if (!prevnode)\n                    ngs->frm_wordlist[f] = nextnode;\n                else\n                    prevnode->next = nextnode;\n                listelem_free(ngs->latnode_alloc, node);\n            }\n            else\n                prevnode = node;\n        }\n    }\n\n    /* Form overall wordlist for 2nd pass */\n    nwd = 0;\n    bitvec_clear_all(ngs->word_active, ps_search_n_words(ngs));\n    for (f = 0; f < ngs->n_frame; f++) {\n        for (node = ngs->frm_wordlist[f]; node; node = node->next) {\n            if (!bitvec_is_set(ngs->word_active, node->wid)) {\n                bitvec_set(ngs->word_active, node->wid);\n                ngs->fwdflat_wordlist[nwd++] = node->wid;\n            }\n        }\n    }\n    ngs->fwdflat_wordlist[nwd] = -1;\n    E_INFO(\"Utterance vocabulary contains %d words\\n\", nwd);\n}\n\n/**\n * Build HMM network for one utterance of fwdflat search.\n */\nstatic void\nbuild_fwdflat_chan(ngram_search_t *ngs)\n{\n    int32 i, wid, p;\n    root_chan_t *rhmm;\n    chan_t *hmm, *prevhmm;\n    dict_t *dict;\n    dict2pid_t *d2p;\n\n    dict = ps_search_dict(ngs);\n    d2p = ps_search_dict2pid(ngs);\n\n    /* Build word HMMs for each word in the lattice. */\n    for (i = 0; ngs->fwdflat_wordlist[i] >= 0; i++) {\n        wid = ngs->fwdflat_wordlist[i];\n\n        /* Single-phone words are permanently allocated */\n        if (dict_is_single_phone(dict, wid))\n            continue;\n\n        assert(ngs->word_chan[wid] == NULL);\n\n        /* Multiplex root HMM for first phone (one root per word, flat\n         * lexicon).  diphone is irrelevant here, for the time being,\n         * at least. */\n        rhmm = listelem_malloc(ngs->root_chan_alloc);\n        rhmm->ci2phone = dict_second_phone(dict, wid);\n        rhmm->ciphone = dict_first_phone(dict, wid);\n        rhmm->next = NULL;\n        hmm_init(ngs->hmmctx, &rhmm->hmm, TRUE,\n                 bin_mdef_pid2ssid(ps_search_acmod(ngs)->mdef, rhmm->ciphone),\n                 bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, rhmm->ciphone));\n\n        /* HMMs for word-internal phones */\n        prevhmm = NULL;\n        for (p = 1; p < dict_pronlen(dict, wid) - 1; p++) {\n            hmm = listelem_malloc(ngs->chan_alloc);\n            hmm->ciphone = dict_pron(dict, wid, p);\n            hmm->info.rc_id = (p == dict_pronlen(dict, wid) - 1) ? 0 : -1;\n            hmm->next = NULL;\n            hmm_init(ngs->hmmctx, &hmm->hmm, FALSE,\n                     dict2pid_internal(d2p,wid,p), \n\t\t     bin_mdef_pid2tmatid(ps_search_acmod(ngs)->mdef, hmm->ciphone));\n\n            if (prevhmm)\n                prevhmm->next = hmm;\n            else\n                rhmm->next = hmm;\n\n            prevhmm = hmm;\n        }\n\n        /* Right-context phones */\n        ngram_search_alloc_all_rc(ngs, wid);\n\n        /* Link in just allocated right-context phones */\n        if (prevhmm)\n            prevhmm->next = ngs->word_chan[wid];\n        else\n            rhmm->next = ngs->word_chan[wid];\n        ngs->word_chan[wid] = (chan_t *) rhmm;\n    }\n\n}\n\nvoid\nngram_fwdflat_start(ngram_search_t *ngs)\n{\n    root_chan_t *rhmm;\n    int i;\n\n    ptmr_reset(&ngs->fwdflat_perf);\n    ptmr_start(&ngs->fwdflat_perf);\n    build_fwdflat_wordlist(ngs);\n    build_fwdflat_chan(ngs);\n\n    ngs->bpidx = 0;\n    ngs->bss_head = 0;\n\n    for (i = 0; i < ps_search_n_words(ngs); i++)\n        ngs->word_lat_idx[i] = NO_BP;\n\n    /* Reset the permanently allocated single-phone words, since they\n     * may have junk left over in them from previous searches. */\n    for (i = 0; i < ngs->n_1ph_words; i++) {\n        int32 w = ngs->single_phone_wid[i];\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        hmm_clear(&rhmm->hmm);\n    }\n\n    /* Start search with <s>; word_chan[<s>] is permanently allocated */\n    rhmm = (root_chan_t *) ngs->word_chan[ps_search_start_wid(ngs)];\n    hmm_enter(&rhmm->hmm, 0, NO_BP, 0);\n    ngs->active_word_list[0][0] = ps_search_start_wid(ngs);\n    ngs->n_active_word[0] = 1;\n\n    ngs->best_score = 0;\n    ngs->renormalized = FALSE;\n\n    for (i = 0; i < ps_search_n_words(ngs); i++)\n        ngs->last_ltrans[i].sf = -1;\n\n    if (!ngs->fwdtree)\n        ngs->n_frame = 0;\n\n    ngs->st.n_fwdflat_chan = 0;\n    ngs->st.n_fwdflat_words = 0;\n    ngs->st.n_fwdflat_word_transition = 0;\n    ngs->st.n_senone_active_utt = 0;\n}\n\nstatic void\ncompute_fwdflat_sen_active(ngram_search_t *ngs, int frame_idx)\n{\n    int32 i, nw, w;\n    int32 *awl;\n    root_chan_t *rhmm;\n    chan_t *hmm;\n\n    acmod_clear_active(ps_search_acmod(ngs));\n\n    nw = ngs->n_active_word[frame_idx & 0x1];\n    awl = ngs->active_word_list[frame_idx & 0x1];\n\n    for (i = 0; i < nw; i++) {\n        w = *(awl++);\n        rhmm = (root_chan_t *)ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            acmod_activate_hmm(ps_search_acmod(ngs), &rhmm->hmm);\n        }\n\n        for (hmm = rhmm->next; hmm; hmm = hmm->next) {\n            if (hmm_frame(&hmm->hmm) == frame_idx) {\n                acmod_activate_hmm(ps_search_acmod(ngs), &hmm->hmm);\n            }\n        }\n    }\n}\n\nstatic void\nfwdflat_eval_chan(ngram_search_t *ngs, int frame_idx)\n{\n    int32 i, w, nw, bestscore;\n    int32 *awl;\n    root_chan_t *rhmm;\n    chan_t *hmm;\n\n    nw = ngs->n_active_word[frame_idx & 0x1];\n    awl = ngs->active_word_list[frame_idx & 0x1];\n    bestscore = WORST_SCORE;\n\n    ngs->st.n_fwdflat_words += nw;\n\n    /* Scan all active words. */\n    for (i = 0; i < nw; i++) {\n        w = *(awl++);\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) == frame_idx) {\n            int32 score = chan_v_eval(rhmm);\n            if ((score BETTER_THAN bestscore) && (w != ps_search_finish_wid(ngs)))\n                bestscore = score;\n            ngs->st.n_fwdflat_chan++;\n        }\n\n        for (hmm = rhmm->next; hmm; hmm = hmm->next) {\n            if (hmm_frame(&hmm->hmm) == frame_idx) {\n                int32 score = chan_v_eval(hmm);\n                if (score BETTER_THAN bestscore)\n                    bestscore = score;\n                ngs->st.n_fwdflat_chan++;\n            }\n        }\n    }\n\n    ngs->best_score = bestscore;\n}\n\nstatic void\nfwdflat_prune_chan(ngram_search_t *ngs, int frame_idx)\n{\n    int32 i, nw, cf, nf, w, pip, newscore, thresh, wordthresh;\n    int32 *awl;\n    root_chan_t *rhmm;\n    chan_t *hmm, *nexthmm;\n\n    cf = frame_idx;\n    nf = cf + 1;\n    nw = ngs->n_active_word[cf & 0x1];\n    awl = ngs->active_word_list[cf & 0x1];\n    bitvec_clear_all(ngs->word_active, ps_search_n_words(ngs));\n\n    thresh = ngs->best_score + ngs->fwdflatbeam;\n    wordthresh = ngs->best_score + ngs->fwdflatwbeam;\n    pip = ngs->pip;\n    E_DEBUG(\"frame %d thresh %d wordthresh %d\\n\", frame_idx, thresh, wordthresh);\n\n    /* Scan all active words. */\n    for (i = 0; i < nw; i++) {\n        w = *(awl++);\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        /* Propagate active root channels */\n        if (hmm_frame(&rhmm->hmm) == cf\n            && hmm_bestscore(&rhmm->hmm) BETTER_THAN thresh) {\n            hmm_frame(&rhmm->hmm) = nf;\n            bitvec_set(ngs->word_active, w);\n\n            /* Transitions out of root channel */\n            newscore = hmm_out_score(&rhmm->hmm);\n            if (rhmm->next) {\n                assert(!dict_is_single_phone(ps_search_dict(ngs), w));\n\n                newscore += pip;\n                if (newscore BETTER_THAN thresh) {\n                    hmm = rhmm->next;\n                    /* Enter all right context phones */\n                    if (hmm->info.rc_id >= 0) {\n                        for (; hmm; hmm = hmm->next) {\n                            if ((hmm_frame(&hmm->hmm) < cf)\n                                || (newscore BETTER_THAN hmm_in_score(&hmm->hmm))) {\n                                hmm_enter(&hmm->hmm, newscore,\n                                          hmm_out_history(&rhmm->hmm), nf);\n                            }\n                        }\n                    }\n                    /* Just a normal word internal phone */\n                    else {\n                        if ((hmm_frame(&hmm->hmm) < cf)\n                            || (newscore BETTER_THAN hmm_in_score(&hmm->hmm))) {\n                                hmm_enter(&hmm->hmm, newscore,\n                                          hmm_out_history(&rhmm->hmm), nf);\n                        }\n                    }\n                }\n            }\n            else {\n                assert(dict_is_single_phone(ps_search_dict(ngs), w));\n\n                /* Word exit for single-phone words (where did their\n                 * whmms come from?) (either from\n                 * ngram_search_fwdtree, or from\n                 * ngram_fwdflat_allocate_1ph(), that's where) */\n                if (newscore BETTER_THAN wordthresh) {\n                    ngram_search_save_bp(ngs, cf, w, newscore,\n                                         hmm_out_history(&rhmm->hmm), 0);\n                }\n            }\n        }\n\n        /* Transitions out of non-root channels. */\n        for (hmm = rhmm->next; hmm; hmm = hmm->next) {\n            if (hmm_frame(&hmm->hmm) >= cf) {\n                /* Propagate forward HMMs inside the beam. */\n                if (hmm_bestscore(&hmm->hmm) BETTER_THAN thresh) {\n                    hmm_frame(&hmm->hmm) = nf;\n                    bitvec_set(ngs->word_active, w);\n\n                    newscore = hmm_out_score(&hmm->hmm);\n                    /* Word-internal phones */\n                    if (hmm->info.rc_id < 0) {\n                        newscore += pip;\n                        if (newscore BETTER_THAN thresh) {\n                            nexthmm = hmm->next;\n                            /* Enter all right-context phones. */\n                            if (nexthmm->info.rc_id >= 0) {\n                                 for (; nexthmm; nexthmm = nexthmm->next) {\n                                    if ((hmm_frame(&nexthmm->hmm) < cf)\n                                        || (newscore BETTER_THAN\n                                            hmm_in_score(&nexthmm->hmm))) {\n                                        hmm_enter(&nexthmm->hmm,\n                                                  newscore,\n                                                  hmm_out_history(&hmm->hmm),\n                                                  nf);\n                                    }\n                                }\n                            }\n                            /* Enter single word-internal phone. */\n                            else {\n                                if ((hmm_frame(&nexthmm->hmm) < cf)\n                                    || (newscore BETTER_THAN\n                                        hmm_in_score(&nexthmm->hmm))) {\n                                    hmm_enter(&nexthmm->hmm, newscore,\n                                              hmm_out_history(&hmm->hmm), nf);\n                                }\n                            }\n                        }\n                    }\n                    /* Right-context phones - apply word beam and exit. */\n                    else {\n                        if (newscore BETTER_THAN wordthresh) {\n                            ngram_search_save_bp(ngs, cf, w, newscore,\n                                                 hmm_out_history(&hmm->hmm),\n                                                 hmm->info.rc_id);\n                        }\n                    }\n                }\n                /* Zero out inactive HMMs. */\n                else if (hmm_frame(&hmm->hmm) != nf) {\n                    hmm_clear_scores(&hmm->hmm);\n                }\n            }\n        }\n    }\n}\n\nstatic void\nget_expand_wordlist(ngram_search_t *ngs, int32 frm, int32 win)\n{\n    int32 f, sf, ef;\n    ps_latnode_t *node;\n\n    if (!ngs->fwdtree) {\n        ngs->st.n_fwdflat_word_transition += ngs->n_expand_words;\n        return;\n    }\n\n    sf = frm - win;\n    if (sf < 0)\n        sf = 0;\n    ef = frm + win;\n    if (ef > ngs->n_frame)\n        ef = ngs->n_frame;\n\n    bitvec_clear_all(ngs->expand_word_flag, ps_search_n_words(ngs));\n    ngs->n_expand_words = 0;\n\n    for (f = sf; f < ef; f++) {\n        for (node = ngs->frm_wordlist[f]; node; node = node->next) {\n            if (!bitvec_is_set(ngs->expand_word_flag, node->wid)) {\n                ngs->expand_word_list[ngs->n_expand_words++] = node->wid;\n                bitvec_set(ngs->expand_word_flag, node->wid);\n            }\n        }\n    }\n    ngs->expand_word_list[ngs->n_expand_words] = -1;\n    ngs->st.n_fwdflat_word_transition += ngs->n_expand_words;\n}\n\nstatic void\nfwdflat_word_transition(ngram_search_t *ngs, int frame_idx)\n{\n    int32 cf, nf, b, thresh, pip, i, nw, w, newscore;\n    int32 best_silrc_score = 0, best_silrc_bp = 0;      /* FIXME: good defaults? */\n    bptbl_t *bp;\n    int32 *rcss;\n    root_chan_t *rhmm;\n    int32 *awl;\n    float32 lwf;\n    dict_t *dict = ps_search_dict(ngs);\n    dict2pid_t *d2p = ps_search_dict2pid(ngs);\n\n    cf = frame_idx;\n    nf = cf + 1;\n    thresh = ngs->best_score + ngs->fwdflatbeam;\n    pip = ngs->pip;\n    best_silrc_score = WORST_SCORE;\n    lwf = ngs->fwdflat_fwdtree_lw_ratio;\n\n    /* Search for all words starting within a window of this frame.\n     * These are the successors for words exiting now. */\n    get_expand_wordlist(ngs, cf, ngs->max_sf_win);\n\n    /* Scan words exited in current frame */\n    for (b = ngs->bp_table_idx[cf]; b < ngs->bpidx; b++) {\n        xwdssid_t *rssid;\n        int32 silscore;\n\n        bp = ngs->bp_table + b;\n        ngs->word_lat_idx[bp->wid] = NO_BP;\n\n        if (bp->wid == ps_search_finish_wid(ngs))\n            continue;\n\n        /* DICT2PID location */\n        /* Get the mapping from right context phone ID to index in the\n         * right context table and the bscore_stack. */\n        rcss = ngs->bscore_stack + bp->s_idx;\n        if (bp->last2_phone == -1)\n            rssid = NULL;\n        else\n            rssid = dict2pid_rssid(d2p, bp->last_phone, bp->last2_phone);\n\n        /* Transition to all successor words. */\n        for (i = 0; ngs->expand_word_list[i] >= 0; i++) {\n            int32 n_used;\n\n            w = ngs->expand_word_list[i];\n\n            /* Get the exit score we recorded in save_bwd_ptr(), or\n             * something approximating it. */\n            if (rssid)\n                newscore = rcss[rssid->cimap[dict_first_phone(dict, w)]];\n            else\n                newscore = bp->score;\n            if (newscore == WORST_SCORE)\n                continue;\n            /* FIXME: Floating point... */\n            newscore += lwf\n                * (ngram_tg_score(ngs->lmset,\n                                  dict_basewid(dict, w),\n                                  bp->real_wid,\n                                  bp->prev_real_wid,\n                                  &n_used) >> SENSCR_SHIFT);\n            newscore += pip;\n\n            /* Enter the next word */\n            if (newscore BETTER_THAN thresh) {\n                rhmm = (root_chan_t *) ngs->word_chan[w];\n                if ((hmm_frame(&rhmm->hmm) < cf)\n                    || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n                    hmm_enter(&rhmm->hmm, newscore, b, nf);\n                    /* DICT2PID: This is where mpx ssids get introduced. */\n                    /* Look up the ssid to use when entering this mpx triphone. */\n                    hmm_mpx_ssid(&rhmm->hmm, 0) =\n                        dict2pid_ldiph_lc(d2p, rhmm->ciphone, rhmm->ci2phone,\n                                          dict_last_phone(dict, bp->wid));\n                    assert(IS_S3SSID(hmm_mpx_ssid(&rhmm->hmm, 0)));\n                    E_DEBUG(\"ssid %d(%d,%d) = %d\\n\",\n                            rhmm->ciphone, dict_last_phone(dict, bp->wid), rhmm->ci2phone,\n                            hmm_mpx_ssid(&rhmm->hmm, 0));\n                    bitvec_set(ngs->word_active, w);\n                }\n            }\n        }\n\n        /* Get the best exit into silence. */\n        if (rssid)\n            silscore = rcss[rssid->cimap[ps_search_acmod(ngs)->mdef->sil]];\n        else\n            silscore = bp->score;\n        if (silscore BETTER_THAN best_silrc_score) {\n            best_silrc_score = silscore;\n            best_silrc_bp = b;\n        }\n    }\n\n    /* Transition to <sil> */\n    newscore = best_silrc_score + ngs->silpen + pip;\n    if ((newscore BETTER_THAN thresh) && (newscore BETTER_THAN WORST_SCORE)) {\n        w = ps_search_silence_wid(ngs);\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if ((hmm_frame(&rhmm->hmm) < cf)\n            || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n            hmm_enter(&rhmm->hmm, newscore,\n                      best_silrc_bp, nf);\n            bitvec_set(ngs->word_active, w);\n        }\n    }\n    /* Transition to noise words */\n    newscore = best_silrc_score + ngs->fillpen + pip;\n    if ((newscore BETTER_THAN thresh) && (newscore BETTER_THAN WORST_SCORE)) {\n        for (w = dict_filler_start(dict); w <= dict_filler_end(dict); w++) {\n            if (w == ps_search_silence_wid(ngs))\n                continue;\n\n            rhmm = (root_chan_t *) ngs->word_chan[w];\n            /* Noise words that aren't a single phone will have NULL here. */\n            if (rhmm == NULL)\n                continue;\n            if ((hmm_frame(&rhmm->hmm) < cf)\n                || (newscore BETTER_THAN hmm_in_score(&rhmm->hmm))) {\n                hmm_enter(&rhmm->hmm, newscore,\n                          best_silrc_bp, nf);\n                bitvec_set(ngs->word_active, w);\n            }\n        }\n    }\n\n    /* Reset initial channels of words that have become inactive even after word trans. */\n    nw = ngs->n_active_word[cf & 0x1];\n    awl = ngs->active_word_list[cf & 0x1];\n    for (i = 0; i < nw; i++) {\n        w = *(awl++);\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) == cf) {\n            hmm_clear_scores(&rhmm->hmm);\n        }\n    }\n}\n\nstatic void\nfwdflat_renormalize_scores(ngram_search_t *ngs, int frame_idx, int32 norm)\n{\n    root_chan_t *rhmm;\n    chan_t *hmm;\n    int32 i, nw, cf, w, *awl;\n\n    cf = frame_idx;\n\n    /* Renormalize individual word channels */\n    nw = ngs->n_active_word[cf & 0x1];\n    awl = ngs->active_word_list[cf & 0x1];\n    for (i = 0; i < nw; i++) {\n        w = *(awl++);\n        rhmm = (root_chan_t *) ngs->word_chan[w];\n        if (hmm_frame(&rhmm->hmm) == cf) {\n            hmm_normalize(&rhmm->hmm, norm);\n        }\n        for (hmm = rhmm->next; hmm; hmm = hmm->next) {\n            if (hmm_frame(&hmm->hmm) == cf) {\n                hmm_normalize(&hmm->hmm, norm);\n            }\n        }\n    }\n\n    ngs->renormalized = TRUE;\n}\n\nint\nngram_fwdflat_search(ngram_search_t *ngs, int frame_idx)\n{\n    int16 const *senscr;\n    int32 nf, i, j;\n    int32 *nawl;\n\n    /* Activate our HMMs for the current frame if need be. */\n    if (!ps_search_acmod(ngs)->compallsen)\n        compute_fwdflat_sen_active(ngs, frame_idx);\n\n    /* Compute GMM scores for the current frame. */\n    senscr = acmod_score(ps_search_acmod(ngs), &frame_idx);\n    ngs->st.n_senone_active_utt += ps_search_acmod(ngs)->n_senone_active;\n\n    /* Mark backpointer table for current frame. */\n    ngram_search_mark_bptable(ngs, frame_idx);\n\n    /* If the best score is equal to or worse than WORST_SCORE,\n     * recognition has failed, don't bother to keep trying. */\n    if (ngs->best_score == WORST_SCORE || ngs->best_score WORSE_THAN WORST_SCORE)\n        return 0;\n    /* Renormalize if necessary */\n    if (ngs->best_score + (2 * ngs->beam) WORSE_THAN WORST_SCORE) {\n        E_INFO(\"Renormalizing Scores at frame %d, best score %d\\n\",\n               frame_idx, ngs->best_score);\n        fwdflat_renormalize_scores(ngs, frame_idx, ngs->best_score);\n    }\n\n    ngs->best_score = WORST_SCORE;\n    hmm_context_set_senscore(ngs->hmmctx, senscr);\n\n    /* Evaluate HMMs */\n    fwdflat_eval_chan(ngs, frame_idx);\n    /* Prune HMMs and do phone transitions. */\n    fwdflat_prune_chan(ngs, frame_idx);\n    /* Do word transitions. */\n    fwdflat_word_transition(ngs, frame_idx);\n\n    /* Create next active word list, skip fillers */\n    nf = frame_idx + 1;\n    nawl = ngs->active_word_list[nf & 0x1];\n    for (i = 0, j = 0; ngs->fwdflat_wordlist[i] >= 0; i++) {\n        int32 wid = ngs->fwdflat_wordlist[i];\n        if (bitvec_is_set(ngs->word_active, wid) && wid < ps_search_start_wid(ngs)) {\n            *(nawl++) = wid;\n            j++;\n        }\n    }\n    /* Add fillers */\n    for (i = ps_search_start_wid(ngs); i < ps_search_n_words(ngs); i++) {\n        if (bitvec_is_set(ngs->word_active, i)) {\n            *(nawl++) = i;\n            j++;\n        }\n    }\n    if (!ngs->fwdtree)\n        ++ngs->n_frame;\n    ngs->n_active_word[nf & 0x1] = j;\n\n    /* Return the number of frames processed. */\n    return 1;\n}\n\n/**\n * Destroy wordlist from the current utterance.\n */\nstatic void\ndestroy_fwdflat_wordlist(ngram_search_t *ngs)\n{\n    ps_latnode_t *node, *tnode;\n    int32 f;\n\n    if (!ngs->fwdtree)\n        return;\n\n    for (f = 0; f < ngs->n_frame; f++) {\n        for (node = ngs->frm_wordlist[f]; node; node = tnode) {\n            tnode = node->next;\n            listelem_free(ngs->latnode_alloc, node);\n        }\n    }\n}\n\n/**\n * Free HMM network for one utterance of fwdflat search.\n */\nstatic void\ndestroy_fwdflat_chan(ngram_search_t *ngs)\n{\n    int32 i, wid;\n\n    for (i = 0; ngs->fwdflat_wordlist[i] >= 0; i++) {\n        root_chan_t *rhmm;\n        chan_t *thmm;\n        wid = ngs->fwdflat_wordlist[i];\n        if (dict_is_single_phone(ps_search_dict(ngs),wid))\n            continue;\n        assert(ngs->word_chan[wid] != NULL);\n\n        /* The first HMM in ngs->word_chan[wid] was allocated with\n         * ngs->root_chan_alloc, but this will attempt to free it\n         * using ngs->chan_alloc, which will not work.  Therefore we\n         * free it manually and move the list forward before handing\n         * it off. */\n        rhmm = (root_chan_t *)ngs->word_chan[wid];\n        thmm = rhmm->next;\n        listelem_free(ngs->root_chan_alloc, rhmm);\n        ngs->word_chan[wid] = thmm;\n        ngram_search_free_all_rc(ngs, wid);\n    }\n}\n\nvoid\nngram_fwdflat_finish(ngram_search_t *ngs)\n{\n    int32 cf;\n\n    destroy_fwdflat_chan(ngs);\n    destroy_fwdflat_wordlist(ngs);\n    bitvec_clear_all(ngs->word_active, ps_search_n_words(ngs));\n\n    /* This is the number of frames processed. */\n    cf = ps_search_acmod(ngs)->output_frame;\n    /* Add a mark in the backpointer table for one past the final frame. */\n    ngram_search_mark_bptable(ngs, cf);\n\n    ptmr_stop(&ngs->fwdflat_perf);\n    /* Print out some statistics. */\n    if (cf > 0) {\n        double n_speech = (double)(cf + 1)\n            / cmd_ln_int32_r(ps_search_config(ngs), \"-frate\");\n        E_INFO(\"%8d words recognized (%d/fr)\\n\",\n               ngs->bpidx, (ngs->bpidx + (cf >> 1)) / (cf + 1));\n        E_INFO(\"%8d senones evaluated (%d/fr)\\n\", ngs->st.n_senone_active_utt,\n               (ngs->st.n_senone_active_utt + (cf >> 1)) / (cf + 1));\n        E_INFO(\"%8d channels searched (%d/fr)\\n\",\n               ngs->st.n_fwdflat_chan, ngs->st.n_fwdflat_chan / (cf + 1));\n        E_INFO(\"%8d words searched (%d/fr)\\n\",\n               ngs->st.n_fwdflat_words, ngs->st.n_fwdflat_words / (cf + 1));\n        E_INFO(\"%8d word transitions (%d/fr)\\n\",\n               ngs->st.n_fwdflat_word_transition,\n               ngs->st.n_fwdflat_word_transition / (cf + 1));\n        E_INFO(\"fwdflat %.2f CPU %.3f xRT\\n\",\n               ngs->fwdflat_perf.t_cpu,\n               ngs->fwdflat_perf.t_cpu / n_speech);\n        E_INFO(\"fwdflat %.2f wall %.3f xRT\\n\",\n               ngs->fwdflat_perf.t_elapsed,\n               ngs->fwdflat_perf.t_elapsed / n_speech);\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file phone_loop_search.h Fast and rough context-independent phoneme loop search.\n */\n\n#include <sphinxbase/err.h>\n\n#include \"phone_loop_search.h\"\n\nstatic int phone_loop_search_start(ps_search_t *search);\nstatic int phone_loop_search_step(ps_search_t *search, int frame_idx);\nstatic int phone_loop_search_finish(ps_search_t *search);\nstatic int phone_loop_search_reinit(ps_search_t *search, dict_t *dict, dict2pid_t *d2p);\nstatic void phone_loop_search_free(ps_search_t *search);\nstatic char const *phone_loop_search_hyp(ps_search_t *search, int32 *out_score);\nstatic int32 phone_loop_search_prob(ps_search_t *search);\nstatic ps_seg_t *phone_loop_search_seg_iter(ps_search_t *search);\n\nstatic ps_searchfuncs_t phone_loop_search_funcs = {\n    /* start: */  phone_loop_search_start,\n    /* step: */   phone_loop_search_step,\n    /* finish: */ phone_loop_search_finish,\n    /* reinit: */ phone_loop_search_reinit,\n    /* free: */   phone_loop_search_free,\n    /* lattice: */  NULL,\n    /* hyp: */      phone_loop_search_hyp,\n    /* prob: */     phone_loop_search_prob,\n    /* seg_iter: */ phone_loop_search_seg_iter,\n};\n\nstatic int\nphone_loop_search_reinit(ps_search_t *search, dict_t *dict, dict2pid_t *d2p)\n{\n    phone_loop_search_t *pls = (phone_loop_search_t *)search;\n    cmd_ln_t *config = ps_search_config(search);\n    acmod_t *acmod = ps_search_acmod(search);\n    int i;\n\n    /* Free old dict2pid, dict, if necessary. */\n    ps_search_base_reinit(search, dict, d2p);\n\n    /* Initialize HMM context. */\n    if (pls->hmmctx)\n        hmm_context_free(pls->hmmctx);\n    pls->hmmctx = hmm_context_init(bin_mdef_n_emit_state(acmod->mdef),\n                                   acmod->tmat->tp, NULL, acmod->mdef->sseq);\n    if (pls->hmmctx == NULL)\n        return -1;\n\n    /* Initialize penalty storage */\n    pls->n_phones = bin_mdef_n_ciphone(acmod->mdef);\n    pls->window = cmd_ln_int32_r(config, \"-pl_window\");\n    if (pls->penalties)\n        ckd_free(pls->penalties);\n    pls->penalties = (int32 *)ckd_calloc(pls->n_phones, sizeof(*pls->penalties));\n    if (pls->pen_buf)\n        ckd_free_2d(pls->pen_buf);\n    pls->pen_buf = (int32 **)ckd_calloc_2d(pls->window, pls->n_phones, sizeof(**pls->pen_buf));\n\n    /* Initialize phone HMMs. */\n    if (pls->hmms) {\n        for (i = 0; i < pls->n_phones; ++i)\n            hmm_deinit((hmm_t *)&pls->hmms[i]);\n        ckd_free(pls->hmms);\n    }\n    pls->hmms = (hmm_t *)ckd_calloc(pls->n_phones, sizeof(*pls->hmms));\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_init(pls->hmmctx, (hmm_t *)&pls->hmms[i],\n                 FALSE,\n                 bin_mdef_pid2ssid(acmod->mdef, i),\n                 bin_mdef_pid2tmatid(acmod->mdef, i));\n    }\n    pls->penalty_weight = cmd_ln_float64_r(config, \"-pl_weight\");\n    pls->beam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-pl_beam\")) >> SENSCR_SHIFT;\n    pls->pbeam = logmath_log(acmod->lmath, cmd_ln_float64_r(config, \"-pl_pbeam\")) >> SENSCR_SHIFT;\n    pls->pip = logmath_log(acmod->lmath, cmd_ln_float32_r(config, \"-pl_pip\")) >> SENSCR_SHIFT;\n    E_INFO(\"State beam %d Phone exit beam %d Insertion penalty %d\\n\",\n           pls->beam, pls->pbeam, pls->pip);\n\n    return 0;\n}\n\nps_search_t *\nphone_loop_search_init(cmd_ln_t *config,\n               acmod_t *acmod,\n               dict_t *dict)\n{\n    phone_loop_search_t *pls;\n\n    /* Allocate and initialize. */\n    pls = (phone_loop_search_t *)ckd_calloc(1, sizeof(*pls));\n    ps_search_init(ps_search_base(pls), &phone_loop_search_funcs,\n\t\t   PS_SEARCH_TYPE_PHONE_LOOP, PS_DEFAULT_PL_SEARCH,\n                   config, acmod, dict, NULL);\n    phone_loop_search_reinit(ps_search_base(pls), ps_search_dict(pls),\n                             ps_search_dict2pid(pls));\n\n    return ps_search_base(pls);\n}\n\nstatic void\nphone_loop_search_free_renorm(phone_loop_search_t *pls)\n{\n    gnode_t *gn;\n    for (gn = pls->renorm; gn; gn = gnode_next(gn))\n        ckd_free(gnode_ptr(gn));\n    glist_free(pls->renorm);\n    pls->renorm = NULL;\n}\n\nstatic void\nphone_loop_search_free(ps_search_t *search)\n{\n    phone_loop_search_t *pls = (phone_loop_search_t *)search;\n    int i;\n\n    ps_search_base_free(search);\n    for (i = 0; i < pls->n_phones; ++i)\n        hmm_deinit((hmm_t *)&pls->hmms[i]);\n    phone_loop_search_free_renorm(pls);\n    ckd_free_2d(pls->pen_buf);\n    ckd_free(pls->hmms);\n    ckd_free(pls->penalties);\n    hmm_context_free(pls->hmmctx);\n    ckd_free(pls);\n}\n\nstatic int\nphone_loop_search_start(ps_search_t *search)\n{\n    phone_loop_search_t *pls = (phone_loop_search_t *)search;\n    int i;\n\n    /* Reset and enter all phone HMMs. */\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_t *hmm = (hmm_t *)&pls->hmms[i];\n        hmm_clear(hmm);\n        hmm_enter(hmm, 0, -1, 0);\n    }\n    memset(pls->penalties, 0, pls->n_phones * sizeof(*pls->penalties));\n    for (i = 0; i < pls->window; i++)\n        memset(pls->pen_buf[i], 0, pls->n_phones * sizeof(*pls->pen_buf[i]));\n    phone_loop_search_free_renorm(pls);\n    pls->best_score = 0;\n    pls->pen_buf_ptr = 0;\n\n    return 0;\n}\n\nstatic void\nrenormalize_hmms(phone_loop_search_t *pls, int frame_idx, int32 norm)\n{\n    phone_loop_renorm_t *rn = (phone_loop_renorm_t *)ckd_calloc(1, sizeof(*rn));\n    int i;\n\n    pls->renorm = glist_add_ptr(pls->renorm, rn);\n    rn->frame_idx = frame_idx;\n    rn->norm = norm;\n\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_normalize((hmm_t *)&pls->hmms[i], norm);\n    }\n}\n\nstatic void\nevaluate_hmms(phone_loop_search_t *pls, int16 const *senscr, int frame_idx)\n{\n    int32 bs = WORST_SCORE;\n    int i;\n\n    hmm_context_set_senscore(pls->hmmctx, senscr);\n\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_t *hmm = (hmm_t *)&pls->hmms[i];\n        int32 score;\n\n        if (hmm_frame(hmm) < frame_idx)\n            continue;\n        score = hmm_vit_eval(hmm);\n        if (score BETTER_THAN bs) {\n            bs = score;\n        }\n    }\n    pls->best_score = bs;\n}\n\nstatic void\nstore_scores(phone_loop_search_t *pls, int frame_idx)\n{\n    int i, j, itr;\n\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_t *hmm = (hmm_t *)&pls->hmms[i];\n        pls->pen_buf[pls->pen_buf_ptr][i] = (hmm_bestscore(hmm) - pls->best_score) * pls->penalty_weight;\n    }\n    pls->pen_buf_ptr++;\n    pls->pen_buf_ptr = pls->pen_buf_ptr % pls->window;\n\n    /* update penalties */\n    for (i = 0; i < pls->n_phones; ++i) {\n        pls->penalties[i] = WORST_SCORE;\n        for (j = 0, itr = pls->pen_buf_ptr + 1; j < pls->window; j++, itr++) {\n            itr = itr % pls->window;\n            if (pls->pen_buf[itr][i] > pls->penalties[i])\n                pls->penalties[i] = pls->pen_buf[itr][i];\n        }\n    }\n}\n\nstatic void\nprune_hmms(phone_loop_search_t *pls, int frame_idx)\n{\n    int32 thresh = pls->best_score + pls->beam;\n    int nf = frame_idx + 1;\n    int i;\n\n    /* Check all phones to see if they remain active in the next frame. */\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_t *hmm = (hmm_t *)&pls->hmms[i];\n\n        if (hmm_frame(hmm) < frame_idx)\n            continue;\n        /* Retain if score better than threshold. */\n        if (hmm_bestscore(hmm) BETTER_THAN thresh) {\n            hmm_frame(hmm) = nf;\n        }\n        else\n            hmm_clear_scores(hmm);\n    }\n}\n\nstatic void\nphone_transition(phone_loop_search_t *pls, int frame_idx)\n{\n    int32 thresh = pls->best_score + pls->pbeam;\n    int nf = frame_idx + 1;\n    int i;\n\n    /* Now transition out of phones whose last states are inside the\n     * phone transition beam. */\n    for (i = 0; i < pls->n_phones; ++i) {\n        hmm_t *hmm = (hmm_t *)&pls->hmms[i];\n        int32 newphone_score;\n        int j;\n\n        if (hmm_frame(hmm) != nf)\n            continue;\n\n        newphone_score = hmm_out_score(hmm) + pls->pip;\n        if (newphone_score BETTER_THAN thresh) {\n            /* Transition into all phones using the usual Viterbi rule. */\n            for (j = 0; j < pls->n_phones; ++j) {\n                hmm_t *nhmm = (hmm_t *)&pls->hmms[j];\n\n                if (hmm_frame(nhmm) < frame_idx\n                    || newphone_score BETTER_THAN hmm_in_score(nhmm)) {\n                    hmm_enter(nhmm, newphone_score, hmm_out_history(hmm), nf);\n                }\n            }\n        }\n    }\n}\n\nstatic int\nphone_loop_search_step(ps_search_t *search, int frame_idx)\n{\n    phone_loop_search_t *pls = (phone_loop_search_t *)search;\n    acmod_t *acmod = ps_search_acmod(search);\n    int16 const *senscr;\n    int i;\n\n    /* All CI senones are active all the time. */\n    if (!ps_search_acmod(pls)->compallsen) {\n        acmod_clear_active(ps_search_acmod(pls));\n        for (i = 0; i < pls->n_phones; ++i)\n            acmod_activate_hmm(acmod, (hmm_t *)&pls->hmms[i]);\n    }\n\n    /* Calculate senone scores for current frame. */\n    senscr = acmod_score(acmod, &frame_idx);\n\n    /* Renormalize, if necessary. */\n    if (pls->best_score + (2 * pls->beam) WORSE_THAN WORST_SCORE) {\n        E_INFO(\"Renormalizing Scores at frame %d, best score %d\\n\",\n               frame_idx, pls->best_score);\n        renormalize_hmms(pls, frame_idx, pls->best_score);\n    }\n\n    /* Evaluate phone HMMs for current frame. */\n    evaluate_hmms(pls, senscr, frame_idx);\n\n    /* Store hmm scores for senone penaly calculation */\n    store_scores(pls, frame_idx);\n\n    /* Prune phone HMMs. */\n    prune_hmms(pls, frame_idx);\n\n    /* Do phone transitions. */\n    phone_transition(pls, frame_idx);\n\n    return 0;\n}\n\nstatic int\nphone_loop_search_finish(ps_search_t *search)\n{\n    /* Actually nothing to do here really. */\n    return 0;\n}\n\nstatic char const *\nphone_loop_search_hyp(ps_search_t *search, int32 *out_score)\n{\n    E_WARN(\"Hypotheses are not returned from phone loop search\");\n    return NULL;\n}\n\nstatic int32\nphone_loop_search_prob(ps_search_t *search)\n{\n    /* FIXME: Actually... they ought to be. */\n    E_WARN(\"Posterior probabilities are not returned from phone loop search\");\n    return 0;\n}\n\nstatic ps_seg_t *\nphone_loop_search_seg_iter(ps_search_t *search)\n{\n    E_WARN(\"Hypotheses are not returned from phone loop search\");\n    return NULL;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced\n * Research Projects Agency and the National Science Foundation of the\n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* System headers. */\n#include <stdio.h>\n#include <assert.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n/* SphinxBase headers. */\n#include <sphinxbase/err.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/filename.h>\n#include <sphinxbase/pio.h>\n#include <sphinxbase/jsgf.h>\n#include <sphinxbase/hash_table.h>\n\n/* Local headers. */\n#include \"cmdln_macro.h\"\n#include \"pocketsphinx.h\"\n#include \"pocketsphinx_internal.h\"\n#include \"ps_lattice_internal.h\"\n#include \"phone_loop_search.h\"\n#include \"kws_search.h\"\n#include \"fsg_search_internal.h\"\n#include \"ngram_search.h\"\n#include \"ngram_search_fwdtree.h\"\n#include \"ngram_search_fwdflat.h\"\n#include \"allphone_search.h\"\n\nstatic const arg_t ps_args_def[] = {\n    POCKETSPHINX_OPTIONS,\n    CMDLN_EMPTY_OPTION\n};\n\n/* I'm not sure what the portable way to do this is. */\nstatic int\nfile_exists(const char *path)\n{\n    FILE *tmp;\n\n    tmp = fopen(path, \"rb\");\n    if (tmp) fclose(tmp);\n    return (tmp != NULL);\n}\n\n#ifdef MODELDIR\nstatic int\nhmmdir_exists(const char *path)\n{\n    FILE *tmp;\n    char *mdef = string_join(path, \"/mdef\", NULL);\n\n    tmp = fopen(mdef, \"rb\");\n    if (tmp) fclose(tmp);\n    ckd_free(mdef);\n    return (tmp != NULL);\n}\n#endif\n\nstatic void\nps_expand_file_config(ps_decoder_t *ps, const char *arg, const char *extra_arg,\n\t              const char *hmmdir, const char *file)\n{\n    const char *val;\n    if ((val = cmd_ln_str_r(ps->config, arg)) != NULL) {\n\tcmd_ln_set_str_extra_r(ps->config, extra_arg, val);\n    } else if (hmmdir == NULL) {\n        cmd_ln_set_str_extra_r(ps->config, extra_arg, NULL);\n    } else {\n        char *tmp = string_join(hmmdir, \"/\", file, NULL);\n        if (file_exists(tmp))\n\t    cmd_ln_set_str_extra_r(ps->config, extra_arg, tmp);\n\telse\n\t    cmd_ln_set_str_extra_r(ps->config, extra_arg, NULL);\n        ckd_free(tmp);\n    }\n}\n\n/* Feature and front-end parameters that may be in feat.params */\nstatic const arg_t feat_defn[] = {\n    waveform_to_cepstral_command_line_macro(),\n    cepstral_to_feature_command_line_macro(),\n    CMDLN_EMPTY_OPTION\n};\n\nstatic void\nps_expand_model_config(ps_decoder_t *ps)\n{\n    char const *hmmdir, *featparams;\n\n    /* Disable memory mapping on Blackfin (FIXME: should be uClinux in general). */\n#ifdef __ADSPBLACKFIN__\n    E_INFO(\"Will not use mmap() on uClinux/Blackfin.\");\n    cmd_ln_set_boolean_r(ps->config, \"-mmap\", FALSE);\n#endif\n\n    /* Get acoustic model filenames and add them to the command-line */\n    hmmdir = cmd_ln_str_r(ps->config, \"-hmm\");\n    ps_expand_file_config(ps, \"-mdef\", \"_mdef\", hmmdir, \"mdef\");\n    ps_expand_file_config(ps, \"-mean\", \"_mean\", hmmdir, \"means\");\n    ps_expand_file_config(ps, \"-var\", \"_var\", hmmdir, \"variances\");\n    ps_expand_file_config(ps, \"-tmat\", \"_tmat\", hmmdir, \"transition_matrices\");\n    ps_expand_file_config(ps, \"-mixw\", \"_mixw\", hmmdir, \"mixture_weights\");\n    ps_expand_file_config(ps, \"-sendump\", \"_sendump\", hmmdir, \"sendump\");\n    ps_expand_file_config(ps, \"-fdict\", \"_fdict\", hmmdir, \"noisedict\");\n    ps_expand_file_config(ps, \"-lda\", \"_lda\", hmmdir, \"feature_transform\");\n    ps_expand_file_config(ps, \"-featparams\", \"_featparams\", hmmdir, \"feat.params\");\n    ps_expand_file_config(ps, \"-senmgau\", \"_senmgau\", hmmdir, \"senmgau\");\n\n    /* Look for feat.params in acoustic model dir. */\n    if ((featparams = cmd_ln_str_r(ps->config, \"_featparams\"))) {\n        if (NULL !=\n            cmd_ln_parse_file_r(ps->config, feat_defn, featparams, FALSE))\n            E_INFO(\"Parsed model-specific feature parameters from %s\\n\",\n                    featparams);\n    }\n\n    /* Print here because acmod_init might load feat.params file */\n    if (err_get_logfp() != NULL) {\n\tcmd_ln_print_values_r(ps->config, err_get_logfp(), ps_args());\n    }\n}\n\nstatic void\nps_free_searches(ps_decoder_t *ps)\n{\n    if (ps->searches) {\n        hash_iter_t *search_it;\n        for (search_it = hash_table_iter(ps->searches); search_it;\n             search_it = hash_table_iter_next(search_it)) {\n            ps_search_free(hash_entry_val(search_it->ent));\n        }\n        hash_table_free(ps->searches);\n    }\n\n    ps->searches = NULL;\n    ps->search = NULL;\n}\n\nstatic ps_search_t *\nps_find_search(ps_decoder_t *ps, char const *name)\n{\n    void *search = NULL;\n    hash_table_lookup(ps->searches, name, &search);\n\n    return (ps_search_t *) search;\n}\n\n/* Set default acoustic and language models if they are not defined in configuration. */\nvoid\nps_default_search_args(cmd_ln_t *config)\n{\n#ifdef MODELDIR\n    const char *hmmdir = cmd_ln_str_r(config, \"-hmm\");\n    const char *lmfile = cmd_ln_str_r(config, \"-lm\");\n    const char *dictfile = cmd_ln_str_r(config, \"-dict\");\n\n    if (hmmdir == NULL && hmmdir_exists(MODELDIR \"/en-us/en-us\")) {\n        hmmdir = MODELDIR \"/en-us/en-us\";\n        cmd_ln_set_str_r(config, \"-hmm\", hmmdir);\n    }\n\n    if (lmfile == NULL && !cmd_ln_str_r(config, \"-fsg\")\n        && !cmd_ln_str_r(config, \"-jsgf\")\n        && !cmd_ln_str_r(config, \"-lmctl\")\n        && !cmd_ln_str_r(config, \"-kws\")\n        && !cmd_ln_str_r(config, \"-keyphrase\")\n        && file_exists(MODELDIR \"/en-us/en-us.lm.bin\")) {\n        lmfile = MODELDIR \"/en-us/en-us.lm.bin\";\n        cmd_ln_set_str_r(config, \"-lm\", lmfile);\n    }\n\n    if (dictfile == NULL && file_exists(MODELDIR \"/en-us/cmudict-en-us.dict\")) {\n        dictfile = MODELDIR \"/en-us/cmudict-en-us.dict\";\n        cmd_ln_set_str_r(config, \"-dict\", dictfile);\n    }\n#endif\n}\n\nint\nps_reinit(ps_decoder_t *ps, cmd_ln_t *config)\n{\n    const char *path;\n    const char *keyphrase;\n    int32 lw;\n\n    if (config && config != ps->config) {\n        cmd_ln_free_r(ps->config);\n        ps->config = cmd_ln_retain(config);\n    }\n\n    /* Set up logging. We need to do this earlier because we want to dump\n     * the information to the configured log, not to the stderr. */\n    if (config && cmd_ln_str_r(ps->config, \"-logfn\")) {\n        if (err_set_logfile(cmd_ln_str_r(ps->config, \"-logfn\")) < 0) {\n            E_ERROR(\"Cannot redirect log output\\n\");\n    \t    return -1;\n        }\n    }\n    \n    ps->mfclogdir = cmd_ln_str_r(ps->config, \"-mfclogdir\");\n    ps->rawlogdir = cmd_ln_str_r(ps->config, \"-rawlogdir\");\n    ps->senlogdir = cmd_ln_str_r(ps->config, \"-senlogdir\");\n\n    /* Fill in some default arguments. */\n    ps_expand_model_config(ps);\n\n    /* Free old searches (do this before other reinit) */\n    ps_free_searches(ps);\n    ps->searches = hash_table_new(3, HASH_CASE_YES);\n\n    /* Free old acmod. */\n    acmod_free(ps->acmod);\n    ps->acmod = NULL;\n\n    /* Free old dictionary (must be done after the two things above) */\n    dict_free(ps->dict);\n    ps->dict = NULL;\n\n    /* Free d2p */\n    dict2pid_free(ps->d2p);\n    ps->d2p = NULL;\n\n    /* Logmath computation (used in acmod and search) */\n    if (ps->lmath == NULL\n        || (logmath_get_base(ps->lmath) !=\n            (float64)cmd_ln_float32_r(ps->config, \"-logbase\"))) {\n        if (ps->lmath)\n            logmath_free(ps->lmath);\n        ps->lmath = logmath_init\n            ((float64)cmd_ln_float32_r(ps->config, \"-logbase\"), 0,\n             cmd_ln_boolean_r(ps->config, \"-bestpath\"));\n    }\n\n    /* Acoustic model (this is basically everything that\n     * uttproc.c, senscr.c, and others used to do) */\n    if ((ps->acmod = acmod_init(ps->config, ps->lmath, NULL, NULL)) == NULL)\n        return -1;\n\n\n\n    if (cmd_ln_int32_r(ps->config, \"-pl_window\") > 0) {\n        /* Initialize an auxiliary phone loop search, which will run in\n         * \"parallel\" with FSG or N-Gram search. */\n        if ((ps->phone_loop =\n             phone_loop_search_init(ps->config, ps->acmod, ps->dict)) == NULL)\n            return -1;\n        hash_table_enter(ps->searches,\n                         ps_search_name(ps->phone_loop),\n                         ps->phone_loop);\n    }\n\n    /* Dictionary and triphone mappings (depends on acmod). */\n    /* FIXME: pass config, change arguments, implement LTS, etc. */\n    if ((ps->dict = dict_init(ps->config, ps->acmod->mdef)) == NULL)\n        return -1;\n    if ((ps->d2p = dict2pid_build(ps->acmod->mdef, ps->dict)) == NULL)\n        return -1;\n\n    lw = cmd_ln_float32_r(ps->config, \"-lw\");\n\n    /* Determine whether we are starting out in FSG or N-Gram search mode.\n     * If neither is used skip search initialization. */\n\n    /* Load KWS if one was specified in config */\n    if ((keyphrase = cmd_ln_str_r(ps->config, \"-keyphrase\"))) {\n        if (ps_set_keyphrase(ps, PS_DEFAULT_SEARCH, keyphrase))\n            return -1;\n        ps_set_search(ps, PS_DEFAULT_SEARCH);\n    }\n\n    if ((path = cmd_ln_str_r(ps->config, \"-kws\"))) {\n        if (ps_set_kws(ps, PS_DEFAULT_SEARCH, path))\n            return -1;\n        ps_set_search(ps, PS_DEFAULT_SEARCH);\n    }\n\n    /* Load an FSG if one was specified in config */\n    if ((path = cmd_ln_str_r(ps->config, \"-fsg\"))) {\n        fsg_model_t *fsg = fsg_model_readfile(path, ps->lmath, lw);\n        if (!fsg)\n            return -1;\n        if (ps_set_fsg(ps, PS_DEFAULT_SEARCH, fsg)) {\n            fsg_model_free(fsg);\n            return -1;\n        }\n        fsg_model_free(fsg);\n        ps_set_search(ps, PS_DEFAULT_SEARCH);\n    }\n    \n    /* Or load a JSGF grammar */\n    if ((path = cmd_ln_str_r(ps->config, \"-jsgf\"))) {\n        if (ps_set_jsgf_file(ps, PS_DEFAULT_SEARCH, path)\n            || ps_set_search(ps, PS_DEFAULT_SEARCH))\n            return -1;\n    }\n\n    if ((path = cmd_ln_str_r(ps->config, \"-allphone\"))) {\n        if (ps_set_allphone_file(ps, PS_DEFAULT_SEARCH, path)\n                || ps_set_search(ps, PS_DEFAULT_SEARCH))\n                return -1;\n    }\n\n    if ((path = cmd_ln_str_r(ps->config, \"-lm\")) && \n        !cmd_ln_boolean_r(ps->config, \"-allphone\")) {\n        if (ps_set_lm_file(ps, PS_DEFAULT_SEARCH, path)\n            || ps_set_search(ps, PS_DEFAULT_SEARCH))\n            return -1;\n    }\n\n    if ((path = cmd_ln_str_r(ps->config, \"-lmctl\"))) {\n        const char *name;\n        ngram_model_t *lmset;\n        ngram_model_set_iter_t *lmset_it;\n\n        if (!(lmset = ngram_model_set_read(ps->config, path, ps->lmath))) {\n            E_ERROR(\"Failed to read language model control file: %s\\n\", path);\n            return -1;\n        }\n\n        for(lmset_it = ngram_model_set_iter(lmset);\n            lmset_it; lmset_it = ngram_model_set_iter_next(lmset_it)) {    \n            ngram_model_t *lm = ngram_model_set_iter_model(lmset_it, &name);            \n            E_INFO(\"adding search %s\\n\", name);\n            if (ps_set_lm(ps, name, lm)) {\n                ngram_model_set_iter_free(lmset_it);\n        \tngram_model_free(lmset);\n                return -1;\n            }\n        }\n        ngram_model_free(lmset);\n\n        name = cmd_ln_str_r(ps->config, \"-lmname\");\n        if (name)\n            ps_set_search(ps, name);\n        else {\n            E_ERROR(\"No default LM name (-lmname) for `-lmctl'\\n\");\n            return -1;\n        }\n    }\n\n    /* Initialize performance timer. */\n    ps->perf.name = \"decode\";\n    ptmr_init(&ps->perf);\n\n    return 0;\n}\n\nps_decoder_t *\nps_init(cmd_ln_t *config)\n{\n    ps_decoder_t *ps;\n    \n    if (!config) {\n\tE_ERROR(\"No configuration specified\");\n\treturn NULL;\n    }\n\n    ps = ckd_calloc(1, sizeof(*ps));\n    ps->refcount = 1;\n    if (ps_reinit(ps, config) < 0) {\n        ps_free(ps);\n        return NULL;\n    }\n    return ps;\n}\n\narg_t const *\nps_args(void)\n{\n    return ps_args_def;\n}\n\nps_decoder_t *\nps_retain(ps_decoder_t *ps)\n{\n    ++ps->refcount;\n    return ps;\n}\n\nint\nps_free(ps_decoder_t *ps)\n{\n    if (ps == NULL)\n        return 0;\n    if (--ps->refcount > 0)\n        return ps->refcount;\n    ps_free_searches(ps);\n    dict_free(ps->dict);\n    dict2pid_free(ps->d2p);\n    acmod_free(ps->acmod);\n    logmath_free(ps->lmath);\n    cmd_ln_free_r(ps->config);\n    ckd_free(ps);\n    return 0;\n}\n\ncmd_ln_t *\nps_get_config(ps_decoder_t *ps)\n{\n    return ps->config;\n}\n\nlogmath_t *\nps_get_logmath(ps_decoder_t *ps)\n{\n    return ps->lmath;\n}\n\nfe_t *\nps_get_fe(ps_decoder_t *ps)\n{\n    return ps->acmod->fe;\n}\n\nfeat_t *\nps_get_feat(ps_decoder_t *ps)\n{\n    return ps->acmod->fcb;\n}\n\nps_mllr_t *\nps_update_mllr(ps_decoder_t *ps, ps_mllr_t *mllr)\n{\n    return acmod_update_mllr(ps->acmod, mllr);\n}\n\nint\nps_set_search(ps_decoder_t *ps, const char *name)\n{\n    ps_search_t *search;\n\n    if (ps->acmod->state != ACMOD_ENDED && ps->acmod->state != ACMOD_IDLE) {\n        E_ERROR(\"Cannot change search while decoding, end utterance first\\n\");\n        return -1;\n    }\n\n    if (!(search = ps_find_search(ps, name))) {\n        return -1;\n    }\n\n    ps->search = search;\n    /* Set pl window depending on the search */\n    if (!strcmp(PS_SEARCH_TYPE_NGRAM, ps_search_type(search))) {\n        ps->pl_window = cmd_ln_int32_r(ps->config, \"-pl_window\");\n    } else {\n        ps->pl_window = 0;\n    }\n\n    return 0;\n}\n\nconst char*\nps_get_search(ps_decoder_t *ps)\n{\n    hash_iter_t *search_it;\n    const char* name = NULL;\n    for (search_it = hash_table_iter(ps->searches); search_it;\n        search_it = hash_table_iter_next(search_it)) {\n        if (hash_entry_val(search_it->ent) == ps->search) {\n            name = hash_entry_key(search_it->ent);\n            break;\n        }\n    }\n    return name;\n}\n\nint \nps_unset_search(ps_decoder_t *ps, const char *name)\n{\n    ps_search_t *search = hash_table_delete(ps->searches, name);\n    if (!search)\n        return -1;\n    if (ps->search == search)\n        ps->search = NULL;\n    ps_search_free(search);\n    return 0;\n}\n\nps_search_iter_t *\nps_search_iter(ps_decoder_t *ps)\n{\n   return (ps_search_iter_t *)hash_table_iter(ps->searches);\n}\n\nps_search_iter_t *\nps_search_iter_next(ps_search_iter_t *itor)\n{\n   return (ps_search_iter_t *)hash_table_iter_next((hash_iter_t *)itor);\n}\n\nconst char* \nps_search_iter_val(ps_search_iter_t *itor)\n{\n   return (const char*)(((hash_iter_t *)itor)->ent->key);\n}\n\nvoid \nps_search_iter_free(ps_search_iter_t *itor)\n{\n    hash_table_iter_free((hash_iter_t *)itor);\n}\n\nngram_model_t *\nps_get_lm(ps_decoder_t *ps, const char *name)\n{\n    ps_search_t *search =  ps_find_search(ps, name);\n    if (search && strcmp(PS_SEARCH_TYPE_NGRAM, ps_search_type(search)))\n        return NULL;\n    return search ? ((ngram_search_t *) search)->lmset : NULL;\n}\n\nfsg_model_t *\nps_get_fsg(ps_decoder_t *ps, const char *name)\n{\n    ps_search_t *search = ps_find_search(ps, name);\n    if (search && strcmp(PS_SEARCH_TYPE_FSG, ps_search_type(search)))\n        return NULL;\n    return search ? ((fsg_search_t *) search)->fsg : NULL;\n}\n\nconst char*\nps_get_kws(ps_decoder_t *ps, const char* name)\n{\n    ps_search_t *search = ps_find_search(ps, name);\n    if (search && strcmp(PS_SEARCH_TYPE_KWS, ps_search_type(search)))\n        return NULL;\n    return search ? kws_search_get_keyphrases(search) : NULL;\n}\n\nstatic int\nset_search_internal(ps_decoder_t *ps, ps_search_t *search)\n{\n    ps_search_t *old_search;\n    \n    if (!search)\n\treturn -1;\n\n    search->pls = ps->phone_loop;\n    old_search = (ps_search_t *) hash_table_replace(ps->searches, ps_search_name(search), search);\n    if (old_search != search)\n        ps_search_free(old_search);\n\n    return 0;\n}\n\nint\nps_set_lm(ps_decoder_t *ps, const char *name, ngram_model_t *lm)\n{\n    ps_search_t *search;\n    search = ngram_search_init(name, lm, ps->config, ps->acmod, ps->dict, ps->d2p);\n    return set_search_internal(ps, search);\n}\n\nint\nps_set_lm_file(ps_decoder_t *ps, const char *name, const char *path)\n{\n  ngram_model_t *lm;\n  int result;\n\n  lm = ngram_model_read(ps->config, path, NGRAM_AUTO, ps->lmath);\n  if (!lm)\n      return -1;\n\n  result = ps_set_lm(ps, name, lm);\n  ngram_model_free(lm);\n  return result;\n}\n\nint\nps_set_allphone(ps_decoder_t *ps, const char *name, ngram_model_t *lm)\n{\n    ps_search_t *search;\n    search = allphone_search_init(name, lm, ps->config, ps->acmod, ps->dict, ps->d2p);\n    return set_search_internal(ps, search);\n}\n\nint\nps_set_allphone_file(ps_decoder_t *ps, const char *name, const char *path)\n{\n  ngram_model_t *lm;\n  int result;\n\n  lm = NULL;\n  if (path)\n    lm = ngram_model_read(ps->config, path, NGRAM_AUTO, ps->lmath);\n  result = ps_set_allphone(ps, name, lm);\n  if (lm)\n      ngram_model_free(lm);\n  return result;\n}\n\nint\nps_set_kws(ps_decoder_t *ps, const char *name, const char *keyfile)\n{\n    ps_search_t *search;\n    search = kws_search_init(name, NULL, keyfile, ps->config, ps->acmod, ps->dict, ps->d2p);\n    return set_search_internal(ps, search);\n}\n\nint\nps_set_keyphrase(ps_decoder_t *ps, const char *name, const char *keyphrase)\n{\n    ps_search_t *search;\n    search = kws_search_init(name, keyphrase, NULL, ps->config, ps->acmod, ps->dict, ps->d2p);\n    return set_search_internal(ps, search);\n}\n\nint\nps_set_fsg(ps_decoder_t *ps, const char *name, fsg_model_t *fsg)\n{\n    ps_search_t *search;\n    search = fsg_search_init(name, fsg, ps->config, ps->acmod, ps->dict, ps->d2p);\n    return set_search_internal(ps, search);\n}\n\nint \nps_set_jsgf_file(ps_decoder_t *ps, const char *name, const char *path)\n{\n  fsg_model_t *fsg;\n  jsgf_rule_t *rule;\n  char const *toprule;\n  jsgf_t *jsgf = jsgf_parse_file(path, NULL);\n  float lw;\n  int result;\n\n  if (!jsgf)\n      return -1;\n\n  rule = NULL;\n  /* Take the -toprule if specified. */\n  if ((toprule = cmd_ln_str_r(ps->config, \"-toprule\"))) {\n      rule = jsgf_get_rule(jsgf, toprule);\n      if (rule == NULL) {\n          E_ERROR(\"Start rule %s not found\\n\", toprule);\n          jsgf_grammar_free(jsgf);\n          return -1;\n      }\n  } else {\n      rule = jsgf_get_public_rule(jsgf);\n      if (rule == NULL) {\n          E_ERROR(\"No public rules found in %s\\n\", path);\n          jsgf_grammar_free(jsgf);\n          return -1;\n      }\n  }\n\n  lw = cmd_ln_float32_r(ps->config, \"-lw\");\n  fsg = jsgf_build_fsg(jsgf, rule, ps->lmath, lw);\n  result = ps_set_fsg(ps, name, fsg);\n  fsg_model_free(fsg);\n  jsgf_grammar_free(jsgf);\n  return result;\n}\n\nint \nps_set_jsgf_string(ps_decoder_t *ps, const char *name, const char *jsgf_string)\n{\n  fsg_model_t *fsg;\n  jsgf_rule_t *rule;\n  char const *toprule;\n  jsgf_t *jsgf = jsgf_parse_string(jsgf_string, NULL);\n  float lw;\n  int result;\n\n  if (!jsgf)\n      return -1;\n\n  rule = NULL;\n  /* Take the -toprule if specified. */\n  if ((toprule = cmd_ln_str_r(ps->config, \"-toprule\"))) {\n      rule = jsgf_get_rule(jsgf, toprule);\n      if (rule == NULL) {\n          E_ERROR(\"Start rule %s not found\\n\", toprule);\n          jsgf_grammar_free(jsgf);\n          return -1;\n      }\n  } else {\n      rule = jsgf_get_public_rule(jsgf);\n      if (rule == NULL) {\n          E_ERROR(\"No public rules found in input string\\n\");\n          jsgf_grammar_free(jsgf);\n          return -1;\n      }\n  }\n\n  lw = cmd_ln_float32_r(ps->config, \"-lw\");\n  fsg = jsgf_build_fsg(jsgf, rule, ps->lmath, lw);\n  result = ps_set_fsg(ps, name, fsg);\n  fsg_model_free(fsg);\n  jsgf_grammar_free(jsgf);\n  return result;\n}\n\n\nint\nps_load_dict(ps_decoder_t *ps, char const *dictfile,\n             char const *fdictfile, char const *format)\n{\n    dict2pid_t *d2p;\n    dict_t *dict;\n    hash_iter_t *search_it;\n    cmd_ln_t *newconfig;\n\n    /* Create a new scratch config to load this dict (so existing one\n     * won't be affected if it fails) */\n    newconfig = cmd_ln_init(NULL, ps_args(), TRUE, NULL);\n    cmd_ln_set_boolean_r(newconfig, \"-dictcase\",\n                         cmd_ln_boolean_r(ps->config, \"-dictcase\"));\n    cmd_ln_set_str_r(newconfig, \"-dict\", dictfile);\n    if (fdictfile)\n        cmd_ln_set_str_extra_r(newconfig, \"_fdict\", fdictfile);\n    else\n        cmd_ln_set_str_extra_r(newconfig, \"_fdict\",\n                               cmd_ln_str_r(ps->config, \"_fdict\"));\n\n    /* Try to load it. */\n    if ((dict = dict_init(newconfig, ps->acmod->mdef)) == NULL) {\n        cmd_ln_free_r(newconfig);\n        return -1;\n    }\n\n    /* Reinit the dict2pid. */\n    if ((d2p = dict2pid_build(ps->acmod->mdef, dict)) == NULL) {\n        cmd_ln_free_r(newconfig);\n        return -1;\n    }\n\n    /* Success!  Update the existing config to reflect new dicts and\n     * drop everything into place. */\n    cmd_ln_free_r(newconfig);\n    dict_free(ps->dict);\n    ps->dict = dict;\n    dict2pid_free(ps->d2p);\n    ps->d2p = d2p;\n\n    /* And tell all searches to reconfigure themselves. */\n    for (search_it = hash_table_iter(ps->searches); search_it;\n       search_it = hash_table_iter_next(search_it)) {\n        if (ps_search_reinit(hash_entry_val(search_it->ent), dict, d2p) < 0) {\n            hash_table_iter_free(search_it);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nint\nps_save_dict(ps_decoder_t *ps, char const *dictfile,\n             char const *format)\n{\n    return dict_write(ps->dict, dictfile, format);\n}\n\nint\nps_add_word(ps_decoder_t *ps,\n            char const *word,\n            char const *phones,\n            int update)\n{\n    int32 wid;\n    s3cipid_t *pron;\n    hash_iter_t *search_it;\n    char **phonestr, *tmp;\n    int np, i, rv;\n\n    /* Parse phones into an array of phone IDs. */\n    tmp = ckd_salloc(phones);\n    np = str2words(tmp, NULL, 0);\n    phonestr = ckd_calloc(np, sizeof(*phonestr));\n    str2words(tmp, phonestr, np);\n    pron = ckd_calloc(np, sizeof(*pron));\n    for (i = 0; i < np; ++i) {\n        pron[i] = bin_mdef_ciphone_id(ps->acmod->mdef, phonestr[i]);\n        if (pron[i] == -1) {\n            E_ERROR(\"Unknown phone %s in phone string %s\\n\",\n                    phonestr[i], tmp);\n            ckd_free(phonestr);\n            ckd_free(tmp);\n            ckd_free(pron);\n            return -1;\n        }\n    }\n    /* No longer needed. */\n    ckd_free(phonestr);\n    ckd_free(tmp);\n\n    /* Add it to the dictionary. */\n    if ((wid = dict_add_word(ps->dict, word, pron, np)) == -1) {\n        ckd_free(pron);\n        return -1;\n    }\n    /* No longer needed. */\n    ckd_free(pron);\n\n    /* Now we also have to add it to dict2pid. */\n    dict2pid_add_word(ps->d2p, wid);\n\n    /* TODO: we definitely need to refactor this */\n    for (search_it = hash_table_iter(ps->searches); search_it;\n         search_it = hash_table_iter_next(search_it)) {\n        ps_search_t *search = hash_entry_val(search_it->ent);\n        if (!strcmp(PS_SEARCH_TYPE_NGRAM, ps_search_type(search))) {\n            ngram_model_t *lmset = ((ngram_search_t *) search)->lmset;\n            if (ngram_model_add_word(lmset, word, 1.0) == NGRAM_INVALID_WID) {\n                hash_table_iter_free(search_it);\n                return -1;\n            }\n        }\n\n        if (update) {\n            if ((rv = ps_search_reinit(search, ps->dict, ps->d2p) < 0)) {\n                hash_table_iter_free(search_it);\n                return rv;\n            }\n        }\n    }\n\n    /* Rebuild the widmap and search tree if requested. */\n    return wid;\n}\n\nchar *\nps_lookup_word(ps_decoder_t *ps, const char *word)\n{\n    s3wid_t wid;\n    int32 phlen, j;\n    char *phones;\n    dict_t *dict = ps->dict;\n    \n    wid = dict_wordid(dict, word);\n    if (wid == BAD_S3WID)\n\treturn NULL;\n\n    for (phlen = j = 0; j < dict_pronlen(dict, wid); ++j)\n        phlen += strlen(dict_ciphone_str(dict, wid, j)) + 1;\n    phones = ckd_calloc(1, phlen);\n    for (j = 0; j < dict_pronlen(dict, wid); ++j) {\n        strcat(phones, dict_ciphone_str(dict, wid, j));\n        if (j != dict_pronlen(dict, wid) - 1)\n            strcat(phones, \" \");\n    }\n    return phones;\n}\n\nlong\nps_decode_raw(ps_decoder_t *ps, FILE *rawfh,\n              long maxsamps)\n{\n    int16 *data;\n    long total, pos, endpos;\n\n    ps_start_stream(ps);\n    ps_start_utt(ps);\n\n    /* If this file is seekable or maxsamps is specified, then decode\n     * the whole thing at once. */\n    if (maxsamps != -1) {\n        data = ckd_calloc(maxsamps, sizeof(*data));\n        total = fread(data, sizeof(*data), maxsamps, rawfh);\n        ps_process_raw(ps, data, total, FALSE, TRUE);\n        ckd_free(data);\n    } else if ((pos = ftell(rawfh)) >= 0) {\n        fseek(rawfh, 0, SEEK_END);\n        endpos = ftell(rawfh);\n        fseek(rawfh, pos, SEEK_SET);\n        maxsamps = endpos - pos;\n\n        data = ckd_calloc(maxsamps, sizeof(*data));\n        total = fread(data, sizeof(*data), maxsamps, rawfh);\n        ps_process_raw(ps, data, total, FALSE, TRUE);\n        ckd_free(data);\n    } else {\n        /* Otherwise decode it in a stream. */\n        total = 0;\n        while (!feof(rawfh)) {\n            int16 data[256];\n            size_t nread;\n\n            nread = fread(data, sizeof(*data), sizeof(data)/sizeof(*data), rawfh);\n            ps_process_raw(ps, data, nread, FALSE, FALSE);\n            total += nread;\n        }\n    }\n    ps_end_utt(ps);\n    return total;\n}\n\nint\nps_start_stream(ps_decoder_t *ps)\n{\n    acmod_start_stream(ps->acmod);\n    return 0;\n}\n\nint\nps_start_utt(ps_decoder_t *ps)\n{\n    int rv;\n    char uttid[16];\n    \n    if (ps->acmod->state == ACMOD_STARTED || ps->acmod->state == ACMOD_PROCESSING) {\n\tE_ERROR(\"Utterance already started\\n\");\n\treturn -1;\n    }\n\n    if (ps->search == NULL) {\n        E_ERROR(\"No search module is selected, did you forget to \"\n                \"specify a language model or grammar?\\n\");\n        return -1;\n    }\n\n    ptmr_reset(&ps->perf);\n    ptmr_start(&ps->perf);\n\n    sprintf(uttid, \"%09u\", ps->uttno);\n    ++ps->uttno;\n\n    /* Remove any residual word lattice and hypothesis. */\n    ps_lattice_free(ps->search->dag);\n    ps->search->dag = NULL;\n    ps->search->last_link = NULL;\n    ps->search->post = 0;\n    ckd_free(ps->search->hyp_str);\n    ps->search->hyp_str = NULL;\n    if ((rv = acmod_start_utt(ps->acmod)) < 0)\n        return rv;\n\n    /* Start logging features and audio if requested. */\n    if (ps->mfclogdir) {\n        char *logfn = string_join(ps->mfclogdir, \"/\",\n                                  uttid, \".mfc\", NULL);\n        FILE *mfcfh;\n        E_INFO(\"Writing MFCC file: %s\\n\", logfn);\n        if ((mfcfh = fopen(logfn, \"wb\")) == NULL) {\n            E_ERROR_SYSTEM(\"Failed to open MFCC file %s\", logfn);\n            ckd_free(logfn);\n            return -1;\n        }\n        ckd_free(logfn);\n        acmod_set_mfcfh(ps->acmod, mfcfh);\n    }\n    if (ps->rawlogdir) {\n        char *logfn = string_join(ps->rawlogdir, \"/\",\n                                  uttid, \".raw\", NULL);\n        FILE *rawfh;\n        E_INFO(\"Writing raw audio file: %s\\n\", logfn);\n        if ((rawfh = fopen(logfn, \"wb\")) == NULL) {\n            E_ERROR_SYSTEM(\"Failed to open raw audio file %s\", logfn);\n            ckd_free(logfn);\n            return -1;\n        }\n        ckd_free(logfn);\n        acmod_set_rawfh(ps->acmod, rawfh);\n    }\n    if (ps->senlogdir) {\n        char *logfn = string_join(ps->senlogdir, \"/\",\n                                  uttid, \".sen\", NULL);\n        FILE *senfh;\n        E_INFO(\"Writing senone score file: %s\\n\", logfn);\n        if ((senfh = fopen(logfn, \"wb\")) == NULL) {\n            E_ERROR_SYSTEM(\"Failed to open senone score file %s\", logfn);\n            ckd_free(logfn);\n            return -1;\n        }\n        ckd_free(logfn);\n        acmod_set_senfh(ps->acmod, senfh);\n    }\n\n    /* Start auxiliary phone loop search. */\n    if (ps->phone_loop)\n        ps_search_start(ps->phone_loop);\n\n    return ps_search_start(ps->search);\n}\n\nstatic int\nps_search_forward(ps_decoder_t *ps)\n{\n    int nfr;\n\n    nfr = 0;\n    while (ps->acmod->n_feat_frame > 0) {\n        int k;\n        if (ps->pl_window > 0)\n            if ((k = ps_search_step(ps->phone_loop, ps->acmod->output_frame)) < 0)\n                return k;\n        if (ps->acmod->output_frame >= ps->pl_window)\n            if ((k = ps_search_step(ps->search,\n                                    ps->acmod->output_frame - ps->pl_window)) < 0)\n                return k;\n        acmod_advance(ps->acmod);\n        ++ps->n_frame;\n        ++nfr;\n    }\n    return nfr;\n}\n\nint\nps_decode_senscr(ps_decoder_t *ps, FILE *senfh)\n{\n    int nfr, n_searchfr;\n\n    ps_start_utt(ps);\n    n_searchfr = 0;\n    acmod_set_insenfh(ps->acmod, senfh);\n    while ((nfr = acmod_read_scores(ps->acmod)) > 0) {\n        if ((nfr = ps_search_forward(ps)) < 0) {\n            ps_end_utt(ps);\n            return nfr;\n        }\n        n_searchfr += nfr;\n    }\n    ps_end_utt(ps);\n    acmod_set_insenfh(ps->acmod, NULL);\n\n    return n_searchfr;\n}\n\nint\nps_process_raw(ps_decoder_t *ps,\n               int16 const *data,\n               size_t n_samples,\n               int no_search,\n               int full_utt)\n{\n    int n_searchfr = 0;\n\n    if (ps->acmod->state == ACMOD_IDLE) {\n\tE_ERROR(\"Failed to process data, utterance is not started. Use start_utt to start it\\n\");\n\treturn 0;\n    }\n\n    if (no_search)\n        acmod_set_grow(ps->acmod, TRUE);\n\n    while (n_samples) {\n        int nfr;\n\n        /* Process some data into features. */\n        if ((nfr = acmod_process_raw(ps->acmod, &data,\n                                     &n_samples, full_utt)) < 0)\n            return nfr;\n\n        /* Score and search as much data as possible */\n        if (no_search)\n            continue;\n        if ((nfr = ps_search_forward(ps)) < 0)\n            return nfr;\n        n_searchfr += nfr;\n    }\n\n    return n_searchfr;\n}\n\nint\nps_process_cep(ps_decoder_t *ps,\n               mfcc_t **data,\n               int32 n_frames,\n               int no_search,\n               int full_utt)\n{\n    int n_searchfr = 0;\n\n    if (no_search)\n        acmod_set_grow(ps->acmod, TRUE);\n\n    while (n_frames) {\n        int nfr;\n\n        /* Process some data into features. */\n        if ((nfr = acmod_process_cep(ps->acmod, &data,\n                                     &n_frames, full_utt)) < 0)\n            return nfr;\n\n        /* Score and search as much data as possible */\n        if (no_search)\n            continue;\n        if ((nfr = ps_search_forward(ps)) < 0)\n            return nfr;\n        n_searchfr += nfr;\n    }\n\n    return n_searchfr;\n}\n\nint\nps_end_utt(ps_decoder_t *ps)\n{\n    int rv, i;\n\n    if (ps->acmod->state == ACMOD_ENDED || ps->acmod->state == ACMOD_IDLE) {\n\tE_ERROR(\"Utterance is not started\\n\");\n\treturn -1;\n    }\n    acmod_end_utt(ps->acmod);\n\n    /* Search any remaining frames. */\n    if ((rv = ps_search_forward(ps)) < 0) {\n        ptmr_stop(&ps->perf);\n        return rv;\n    }\n    /* Finish phone loop search. */\n    if (ps->phone_loop) {\n        if ((rv = ps_search_finish(ps->phone_loop)) < 0) {\n            ptmr_stop(&ps->perf);\n            return rv;\n        }\n    }\n    /* Search any frames remaining in the lookahead window. */\n    if (ps->acmod->output_frame >= ps->pl_window) {\n        for (i = ps->acmod->output_frame - ps->pl_window;\n             i < ps->acmod->output_frame; ++i)\n            ps_search_step(ps->search, i);\n    }\n    /* Finish main search. */\n    if ((rv = ps_search_finish(ps->search)) < 0) {\n        ptmr_stop(&ps->perf);\n        return rv;\n    }\n    ptmr_stop(&ps->perf);\n\n    /* Log a backtrace if requested. */\n    if (cmd_ln_boolean_r(ps->config, \"-backtrace\")) {\n        const char* hyp;\n        ps_seg_t *seg;\n        int32 score;\n\n        hyp = ps_get_hyp(ps, &score);\n        \n        if (hyp != NULL) {\n    \t    E_INFO(\"%s (%d)\\n\", hyp, score);\n    \t    E_INFO_NOFN(\"%-20s %-5s %-5s %-5s %-10s %-10s %-3s\\n\",\n                    \"word\", \"start\", \"end\", \"pprob\", \"ascr\", \"lscr\", \"lback\");\n    \t    for (seg = ps_seg_iter(ps); seg;\n        \t seg = ps_seg_next(seg)) {\n    \t        char const *word;\n        \tint sf, ef;\n        \tint32 post, lscr, ascr, lback;\n\n        \tword = ps_seg_word(seg);\n        \tps_seg_frames(seg, &sf, &ef);\n        \tpost = ps_seg_prob(seg, &ascr, &lscr, &lback);\n        \tE_INFO_NOFN(\"%-20s %-5d %-5d %-1.3f %-10d %-10d %-3d\\n\",\n                    \t    word, sf, ef, logmath_exp(ps_get_logmath(ps), post),\n                    \tascr, lscr, lback);\n    \t    }\n        }\n    }\n    return rv;\n}\n\nchar const *\nps_get_hyp(ps_decoder_t *ps, int32 *out_best_score)\n{\n    char const *hyp;\n\n    ptmr_start(&ps->perf);\n    hyp = ps_search_hyp(ps->search, out_best_score);\n    ptmr_stop(&ps->perf);\n    return hyp;\n}\n\nint32\nps_get_prob(ps_decoder_t *ps)\n{\n    int32 prob;\n\n    ptmr_start(&ps->perf);\n    prob = ps_search_prob(ps->search);\n    ptmr_stop(&ps->perf);\n    return prob;\n}\n\nps_seg_t *\nps_seg_iter(ps_decoder_t *ps)\n{\n    ps_seg_t *itor;\n\n    ptmr_start(&ps->perf);\n    itor = ps_search_seg_iter(ps->search);\n    ptmr_stop(&ps->perf);\n    return itor;\n}\n\nps_seg_t *\nps_seg_next(ps_seg_t *seg)\n{\n    return ps_search_seg_next(seg);\n}\n\nchar const *\nps_seg_word(ps_seg_t *seg)\n{\n    return seg->word;\n}\n\nvoid\nps_seg_frames(ps_seg_t *seg, int *out_sf, int *out_ef)\n{\n    int uf;\n    uf = acmod_stream_offset(seg->search->acmod);\n    if (out_sf) *out_sf = seg->sf + uf;\n    if (out_ef) *out_ef = seg->ef + uf;\n}\n\nint32\nps_seg_prob(ps_seg_t *seg, int32 *out_ascr, int32 *out_lscr, int32 *out_lback)\n{\n    if (out_ascr) *out_ascr = seg->ascr;\n    if (out_lscr) *out_lscr = seg->lscr;\n    if (out_lback) *out_lback = seg->lback;\n    return seg->prob;\n}\n\nvoid\nps_seg_free(ps_seg_t *seg)\n{\n    ps_search_seg_free(seg);\n}\n\nps_lattice_t *\nps_get_lattice(ps_decoder_t *ps)\n{\n    return ps_search_lattice(ps->search);\n}\n\nps_nbest_t *\nps_nbest(ps_decoder_t *ps)\n{\n    ps_lattice_t *dag;\n    ngram_model_t *lmset;\n    ps_astar_t *nbest;\n    float32 lwf;\n\n    if (ps->search == NULL)\n        return NULL;\n    if ((dag = ps_get_lattice(ps)) == NULL)\n        return NULL;\n\n    /* FIXME: This is all quite specific to N-Gram search.  Either we\n     * should make N-best a method for each search module or it needs\n     * to be abstracted to work for N-Gram and FSG. */\n    if (0 != strcmp(ps_search_type(ps->search), PS_SEARCH_TYPE_NGRAM)) {\n        lmset = NULL;\n        lwf = 1.0f;\n    } else {\n        lmset = ((ngram_search_t *)ps->search)->lmset;\n        lwf = ((ngram_search_t *)ps->search)->bestpath_fwdtree_lw_ratio;\n    }\n\n    nbest = ps_astar_start(dag, lmset, lwf, 0, -1, -1, -1);\n\n    nbest = ps_nbest_next(nbest);\n\n    return (ps_nbest_t *)nbest;\n}\n\nvoid\nps_nbest_free(ps_nbest_t *nbest)\n{\n    ps_astar_finish(nbest);\n}\n\nps_nbest_t *\nps_nbest_next(ps_nbest_t *nbest)\n{\n    ps_latpath_t *next;\n\n    next = ps_astar_next(nbest);\n    if (next == NULL) {\n        ps_nbest_free(nbest);\n        return NULL;\n    }\n    return nbest;\n}\n\nchar const *\nps_nbest_hyp(ps_nbest_t *nbest, int32 *out_score)\n{\n    assert(nbest != NULL);\n\n    if (nbest->top == NULL)\n        return NULL;\n    if (out_score) *out_score = nbest->top->score;\n    return ps_astar_hyp(nbest, nbest->top);\n}\n\nps_seg_t *\nps_nbest_seg(ps_nbest_t *nbest)\n{\n    if (nbest->top == NULL)\n        return NULL;\n\n    return ps_astar_seg_iter(nbest, nbest->top, 1.0);\n}\n\nint\nps_get_n_frames(ps_decoder_t *ps)\n{\n    return ps->acmod->output_frame + 1;\n}\n\nvoid\nps_get_utt_time(ps_decoder_t *ps, double *out_nspeech,\n                double *out_ncpu, double *out_nwall)\n{\n    int32 frate;\n\n    frate = cmd_ln_int32_r(ps->config, \"-frate\");\n    *out_nspeech = (double)ps->acmod->output_frame / frate;\n    *out_ncpu = ps->perf.t_cpu;\n    *out_nwall = ps->perf.t_elapsed;\n}\n\nvoid\nps_get_all_time(ps_decoder_t *ps, double *out_nspeech,\n                double *out_ncpu, double *out_nwall)\n{\n    int32 frate;\n\n    frate = cmd_ln_int32_r(ps->config, \"-frate\");\n    *out_nspeech = (double)ps->n_frame / frate;\n    *out_ncpu = ps->perf.t_tot_cpu;\n    *out_nwall = ps->perf.t_tot_elapsed;\n}\n\nuint8 \nps_get_in_speech(ps_decoder_t *ps)\n{\n    return fe_get_vad_state(ps->acmod->fe);\n}\n\nvoid\nps_search_init(ps_search_t *search, ps_searchfuncs_t *vt,\n\t       const char *type,\n\t       const char *name,\n               cmd_ln_t *config, acmod_t *acmod, dict_t *dict,\n               dict2pid_t *d2p)\n{\n    search->vt = vt;\n    search->name = ckd_salloc(name);\n    search->type = ckd_salloc(type);\n\n    search->config = config;\n    search->acmod = acmod;\n    if (d2p)\n        search->d2p = dict2pid_retain(d2p);\n    else\n        search->d2p = NULL;\n    if (dict) {\n        search->dict = dict_retain(dict);\n        search->start_wid = dict_startwid(dict);\n        search->finish_wid = dict_finishwid(dict);\n        search->silence_wid = dict_silwid(dict);\n        search->n_words = dict_size(dict);\n    }\n    else {\n        search->dict = NULL;\n        search->start_wid = search->finish_wid = search->silence_wid = -1;\n        search->n_words = 0;\n    }\n}\n\nvoid\nps_search_base_free(ps_search_t *search)\n{\n    /* FIXME: We will have refcounting on acmod, config, etc, at which\n     * point we will free them here too. */\n    ckd_free(search->name);\n    ckd_free(search->type);\n    dict_free(search->dict);\n    dict2pid_free(search->d2p);\n    ckd_free(search->hyp_str);\n    ps_lattice_free(search->dag);\n}\n\nvoid\nps_search_base_reinit(ps_search_t *search, dict_t *dict,\n                      dict2pid_t *d2p)\n{\n    dict_free(search->dict);\n    dict2pid_free(search->d2p);\n    /* FIXME: _retain() should just return NULL if passed NULL. */\n    if (dict) {\n        search->dict = dict_retain(dict);\n        search->start_wid = dict_startwid(dict);\n        search->finish_wid = dict_finishwid(dict);\n        search->silence_wid = dict_silwid(dict);\n        search->n_words = dict_size(dict);\n    }\n    else {\n        search->dict = NULL;\n        search->start_wid = search->finish_wid = search->silence_wid = -1;\n        search->n_words = 0;\n    }\n    if (d2p)\n        search->d2p = dict2pid_retain(d2p);\n    else\n        search->d2p = NULL;\n}\n\nvoid\nps_set_rawdata_size(ps_decoder_t *ps, int32 size) \n{\n    acmod_set_rawdata_size(ps->acmod, size);\n}\n\nvoid\nps_get_rawdata(ps_decoder_t *ps, int16 **buffer, int32 *size)\n{\n    acmod_get_rawdata(ps->acmod, buffer, size);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file ps_lattice.c Word graph search.\n */\n\n/* System headers. */\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/listelem_alloc.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/pio.h>\n\n/* Local headers. */\n#include \"pocketsphinx_internal.h\"\n#include \"ps_lattice_internal.h\"\n#include \"ngram_search.h\"\n#include \"dict.h\"\n\n/*\n * Create a directed link between \"from\" and \"to\" nodes, but if a link already exists,\n * choose one with the best ascr.\n */\nvoid\nps_lattice_link(ps_lattice_t *dag, ps_latnode_t *from, ps_latnode_t *to,\n                int32 score, int32 ef)\n{\n    latlink_list_t *fwdlink;\n\n    /* Look for an existing link between \"from\" and \"to\" nodes */\n    for (fwdlink = from->exits; fwdlink; fwdlink = fwdlink->next)\n        if (fwdlink->link->to == to)\n            break;\n\n    if (fwdlink == NULL) {\n        latlink_list_t *revlink;\n        ps_latlink_t *link;\n\n        /* No link between the two nodes; create a new one */\n        link = listelem_malloc(dag->latlink_alloc);\n        fwdlink = listelem_malloc(dag->latlink_list_alloc);\n        revlink = listelem_malloc(dag->latlink_list_alloc);\n\n        link->from = from;\n        link->to = to;\n        link->ascr = score;\n        link->ef = ef;\n        link->best_prev = NULL;\n\n        fwdlink->link = revlink->link = link;\n        fwdlink->next = from->exits;\n        from->exits = fwdlink;\n        revlink->next = to->entries;\n        to->entries = revlink;\n    }\n    else {\n        /* Link already exists; just retain the best ascr */\n        if (score BETTER_THAN fwdlink->link->ascr) {\n            fwdlink->link->ascr = score;\n            fwdlink->link->ef = ef;\n        }\n    }           \n}\n\nvoid\nps_lattice_penalize_fillers(ps_lattice_t *dag, int32 silpen, int32 fillpen)\n{\n    ps_latnode_t *node;\n\n    for (node = dag->nodes; node; node = node->next) {\n        latlink_list_t *linklist;\n        if (node != dag->start && node != dag->end && dict_filler_word(dag->dict, node->basewid)) {\n            for (linklist = node->entries; linklist; linklist = linklist->next)\n                linklist->link->ascr += (node->basewid == dag->silence) ? silpen : fillpen;\n        }\n    }\n}\n\nstatic void\ndelete_node(ps_lattice_t *dag, ps_latnode_t *node)\n{\n    latlink_list_t *x, *next_x;\n\n    for (x = node->exits; x; x = next_x) {\n        next_x = x->next;\n        x->link->from = NULL;\n        listelem_free(dag->latlink_list_alloc, x);\n    }\n    for (x = node->entries; x; x = next_x) {\n        next_x = x->next;\n        x->link->to = NULL;\n        listelem_free(dag->latlink_list_alloc, x);\n    }\n    listelem_free(dag->latnode_alloc, node);\n}\n\n\nstatic void\nremove_dangling_links(ps_lattice_t *dag, ps_latnode_t *node)\n{\n    latlink_list_t *x, *prev_x, *next_x;\n\n    prev_x = NULL;\n    for (x = node->exits; x; x = next_x) {\n        next_x = x->next;\n        if (x->link->to == NULL) {\n            if (prev_x)\n                prev_x->next = next_x;\n            else\n                node->exits = next_x;\n            listelem_free(dag->latlink_alloc, x->link);\n            listelem_free(dag->latlink_list_alloc, x);\n        }\n        else\n            prev_x = x;\n    }\n    prev_x = NULL;\n    for (x = node->entries; x; x = next_x) {\n        next_x = x->next;\n        if (x->link->from == NULL) {\n            if (prev_x)\n                prev_x->next = next_x;\n            else\n                node->entries = next_x;\n            listelem_free(dag->latlink_alloc, x->link);\n            listelem_free(dag->latlink_list_alloc, x);\n        }\n        else\n            prev_x = x;\n    }\n}\n\nvoid\nps_lattice_delete_unreachable(ps_lattice_t *dag)\n{\n    ps_latnode_t *node, *prev_node, *next_node;\n    int i;\n\n    /* Remove unreachable nodes from the list of nodes. */\n    prev_node = NULL;\n    for (node = dag->nodes; node; node = next_node) {\n        next_node = node->next;\n        if (!node->reachable) {\n            if (prev_node)\n                prev_node->next = next_node;\n            else\n                dag->nodes = next_node;\n            /* Delete this node and NULLify links to it. */\n            delete_node(dag, node);\n        }\n        else\n            prev_node = node;\n    }\n\n    /* Remove all links to and from unreachable nodes. */\n    i = 0;\n    for (node = dag->nodes; node; node = node->next) {\n        /* Assign sequence numbers. */\n        node->id = i++;\n\n        /* We should obviously not encounter unreachable nodes here! */\n        assert(node->reachable);\n\n        /* Remove all links that go nowhere. */\n        remove_dangling_links(dag, node);\n    }\n}\n\nint32\nps_lattice_write(ps_lattice_t *dag, char const *filename)\n{\n    FILE *fp;\n    int32 i;\n    ps_latnode_t *d, *initial, *final;\n\n    initial = dag->start;\n    final = dag->end;\n\n    E_INFO(\"Writing lattice file: %s\\n\", filename);\n    if ((fp = fopen(filename, \"w\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open lattice file '%s' for writing\", filename);\n        return -1;\n    }\n\n    /* Stupid Sphinx-III lattice code expects 'getcwd:' here */\n    fprintf(fp, \"# getcwd: /this/is/bogus\\n\");\n    fprintf(fp, \"# -logbase %e\\n\", logmath_get_base(dag->lmath));\n    fprintf(fp, \"#\\n\");\n\n    fprintf(fp, \"Frames %d\\n\", dag->n_frames);\n    fprintf(fp, \"#\\n\");\n\n    for (i = 0, d = dag->nodes; d; d = d->next, i++);\n    fprintf(fp,\n            \"Nodes %d (NODEID WORD STARTFRAME FIRST-ENDFRAME LAST-ENDFRAME)\\n\",\n            i);\n    for (i = 0, d = dag->nodes; d; d = d->next, i++) {\n        d->id = i;\n        fprintf(fp, \"%d %s %d %d %d ; %d\\n\",\n                i, dict_wordstr(dag->dict, d->wid),\n                d->sf, d->fef, d->lef, d->node_id);\n    }\n    fprintf(fp, \"#\\n\");\n\n    fprintf(fp, \"Initial %d\\nFinal %d\\n\", initial->id, final->id);\n    fprintf(fp, \"#\\n\");\n\n    /* Don't bother with this, it's not used by anything. */\n    fprintf(fp, \"BestSegAscr %d (NODEID ENDFRAME ASCORE)\\n\",\n            0 /* #BPTable entries */ );\n    fprintf(fp, \"#\\n\");\n\n    fprintf(fp, \"Edges (FROM-NODEID TO-NODEID ASCORE)\\n\");\n    for (d = dag->nodes; d; d = d->next) {\n        latlink_list_t *l;\n        for (l = d->exits; l; l = l->next) {\n            if (l->link->ascr WORSE_THAN WORST_SCORE || l->link->ascr BETTER_THAN 0)\n                continue;\n            fprintf(fp, \"%d %d %d\\n\",\n                    d->id, l->link->to->id, l->link->ascr << SENSCR_SHIFT);\n        }\n    }\n    fprintf(fp, \"End\\n\");\n    fclose(fp);\n\n    return 0;\n}\n\nint32\nps_lattice_write_htk(ps_lattice_t *dag, char const *filename)\n{\n    FILE *fp;\n    ps_latnode_t *d, *initial, *final;\n    int32 j, n_links, n_nodes;\n\n    initial = dag->start;\n    final = dag->end;\n\n    E_INFO(\"Writing lattice file: %s\\n\", filename);\n    if ((fp = fopen(filename, \"w\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open lattice file '%s' for writing\", filename);\n        return -1;\n    }\n\n    for (n_links = n_nodes = 0, d = dag->nodes; d; d = d->next) {\n        latlink_list_t *l;\n        if (!d->reachable)\n            continue;\n        d->id = n_nodes;\n        for (l = d->exits; l; l = l->next) {\n            if (l->link->to == NULL || !l->link->to->reachable)\n                continue;\n            if (l->link->ascr WORSE_THAN WORST_SCORE || l->link->ascr BETTER_THAN 0)\n                continue;\n            ++n_links;\n        }\n        ++n_nodes;\n    }\n\n    fprintf(fp, \"# Lattice generated by PocketSphinx\\n\");\n    fprintf(fp, \"#\\n# Header\\n#\\n\");\n    fprintf(fp, \"VERSION=1.0\\n\");\n    fprintf(fp, \"start=%d\\n\", initial->id);\n    fprintf(fp, \"end=%d\\n\", final->id);\n    fprintf(fp, \"#\\n\");\n\n    fprintf(fp, \"N=%d\\tL=%d\\n\", n_nodes, n_links);\n    fprintf(fp, \"#\\n# Node definitions\\n#\\n\");\n    for (d = dag->nodes; d; d = d->next) {\n        char const *word = dict_wordstr(dag->dict, d->wid);\n        char const *c = strrchr(word, '(');\n        int altpron = 1;\n        if (!d->reachable)\n            continue;\n        if (c)\n            altpron = atoi(c + 1);\n        word = dict_basestr(dag->dict, d->wid);\n        if (d->wid == dict_startwid(dag->dict))\n            word = \"!SENT_START\";\n        else if (d->wid == dict_finishwid(dag->dict))\n            word = \"!SENT_END\";\n        else if (dict_filler_word(dag->dict, d->wid))\n            word = \"!NULL\";\n        fprintf(fp, \"I=%d\\tt=%.2f\\tW=%s\\tv=%d\\n\",\n                d->id, (double)d->sf / dag->frate,\n                word, altpron);\n    }\n    fprintf(fp, \"#\\n# Link definitions\\n#\\n\");\n    for (j = 0, d = dag->nodes; d; d = d->next) {\n        latlink_list_t *l;\n        if (!d->reachable)\n            continue;\n        for (l = d->exits; l; l = l->next) {\n            if (l->link->to == NULL || !l->link->to->reachable)\n                continue;\n            if (l->link->ascr WORSE_THAN WORST_SCORE || l->link->ascr BETTER_THAN 0)\n                continue;\n            fprintf(fp, \"J=%d\\tS=%d\\tE=%d\\ta=%f\\tp=%g\\n\", j++,\n                    d->id, l->link->to->id,\n                    logmath_log_to_ln(dag->lmath, l->link->ascr << SENSCR_SHIFT),\n                    logmath_exp(dag->lmath, l->link->alpha + l->link->beta - dag->norm));\n        }\n    }\n    fclose(fp);\n\n    return 0;\n}\n\n/* Read parameter from a lattice file*/\nstatic int\ndag_param_read(lineiter_t *li, char *param)\n{\n    int32 n;\n\n    while ((li = lineiter_next(li)) != NULL) {\n        char *c;\n\n        /* Ignore comments. */\n        if (li->buf[0] == '#')\n            continue;\n\n        /* Find the first space. */\n        c = strchr(li->buf, ' ');\n        if (c == NULL) continue;\n\n        /* Check that the first field equals param and that there's a number after it. */\n        if (strncmp(li->buf, param, strlen(param)) == 0\n            && sscanf(c + 1, \"%d\", &n) == 1)\n            return n;\n    }\n    return -1;\n}\n\n/* Mark every node that has a path to the argument dagnode as \"reachable\". */\nstatic void\ndag_mark_reachable(ps_latnode_t * d)\n{\n    latlink_list_t *l;\n\n    d->reachable = 1;\n    for (l = d->entries; l; l = l->next)\n        if (l->link->from && !l->link->from->reachable)\n            dag_mark_reachable(l->link->from);\n}\n\nps_lattice_t *\nps_lattice_read(ps_decoder_t *ps,\n                char const *file)\n{\n    FILE *fp;\n    int32 ispipe;\n    lineiter_t *line;\n    float64 lb;\n    float32 logratio;\n    ps_latnode_t *tail;\n    ps_latnode_t **darray;\n    ps_lattice_t *dag;\n    int i, k, n_nodes;\n    int32 pip, silpen, fillpen;\n\n    dag = ckd_calloc(1, sizeof(*dag));\n\n    if (ps) {\n        dag->search = ps->search;\n        dag->dict = dict_retain(ps->dict);\n        dag->lmath = logmath_retain(ps->lmath);\n        dag->frate = cmd_ln_int32_r(dag->search->config, \"-frate\");\n    }\n    else {\n        dag->dict = dict_init(NULL, NULL);\n        dag->lmath = logmath_init(1.0001, 0, FALSE);\n        dag->frate = 100;\n    }\n    dag->silence = dict_silwid(dag->dict);\n    dag->latnode_alloc = listelem_alloc_init(sizeof(ps_latnode_t));\n    dag->latlink_alloc = listelem_alloc_init(sizeof(ps_latlink_t));\n    dag->latlink_list_alloc = listelem_alloc_init(sizeof(latlink_list_t));\n    dag->refcount = 1;\n\n    tail = NULL;\n    darray = NULL;\n\n    E_INFO(\"Reading DAG file: %s\\n\", file);\n    if ((fp = fopen_compchk(file, &ispipe)) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open DAG file '%s' for reading\", file);\n        return NULL;\n    }\n    line = lineiter_start(fp);\n\n    /* Read and verify logbase (ONE BIG HACK!!) */\n    if (line == NULL) {\n        E_ERROR(\"Premature EOF(%s)\\n\", file);\n        goto load_error;\n    }\n    if (strncmp(line->buf, \"# getcwd: \", 10) != 0) {\n        E_ERROR(\"%s does not begin with '# getcwd: '\\n%s\", file, line->buf);\n        goto load_error;\n    }\n    if ((line = lineiter_next(line)) == NULL) {\n        E_ERROR(\"Premature EOF(%s)\\n\", file);\n        goto load_error;\n    }\n    if ((strncmp(line->buf, \"# -logbase \", 11) != 0)\n        || (sscanf(line->buf + 11, \"%lf\", &lb) != 1)) {\n        E_WARN(\"%s: Cannot find -logbase in header\\n\", file);\n        lb = 1.0001;\n    }\n    logratio = 1.0f;\n    if (dag->lmath == NULL)\n        dag->lmath = logmath_init(lb, 0, TRUE);\n    else {\n        float32 pb = logmath_get_base(dag->lmath);\n        if (fabs(lb - pb) >= 0.0001) {\n            E_WARN(\"Inconsistent logbases: %f vs %f: will compensate\\n\", lb, pb);\n            logratio = (float32)(log(lb) / log(pb));\n            E_INFO(\"Lattice log ratio: %f\\n\", logratio);\n        }\n    }\n    /* Read Frames parameter */\n    dag->n_frames = dag_param_read(line, \"Frames\");\n    if (dag->n_frames <= 0) {\n        E_ERROR(\"Frames parameter missing or invalid\\n\");\n        goto load_error;\n    }\n    /* Read Nodes parameter */\n    n_nodes = dag_param_read(line, \"Nodes\");\n    if (n_nodes <= 0) {\n        E_ERROR(\"Nodes parameter missing or invalid\\n\");\n        goto load_error;\n    }\n\n    /* Read nodes */\n    darray = ckd_calloc(n_nodes, sizeof(*darray));\n    for (i = 0; i < n_nodes; i++) {\n        ps_latnode_t *d;\n        int32 w;\n        int seqid, sf, fef, lef;\n        char wd[256];\n\n        if ((line = lineiter_next(line)) == NULL) {\n            E_ERROR(\"Premature EOF while loading Nodes(%s)\\n\", file);\n            goto load_error;\n        }\n\n        if ((k =\n             sscanf(line->buf, \"%d %255s %d %d %d\", &seqid, wd, &sf, &fef,\n                    &lef)) != 5) {\n            E_ERROR(\"Cannot parse line: %s, value of count %d\\n\", line->buf, k);\n            goto load_error;\n        }\n\n        w = dict_wordid(dag->dict, wd);\n        if (w < 0) {\n            if (dag->search == NULL) {\n                char *ww = ckd_salloc(wd);\n                if (dict_word2basestr(ww) != -1) {\n                    if (dict_wordid(dag->dict, ww) == BAD_S3WID)\n                        dict_add_word(dag->dict, ww, NULL, 0);\n                }\n                ckd_free(ww);\n                w = dict_add_word(dag->dict, wd, NULL, 0);\n            }\n            if (w < 0) {\n                E_ERROR(\"Unknown word in line: %s\\n\", line->buf);\n                goto load_error;\n            }\n        }\n\n        if (seqid != i) {\n            E_ERROR(\"Seqno error: %s\\n\", line->buf);\n            goto load_error;\n        }\n\n        d = listelem_malloc(dag->latnode_alloc);\n        darray[i] = d;\n        d->wid = w;\n        d->basewid = dict_basewid(dag->dict, w);\n        d->id = seqid;\n        d->sf = sf;\n        d->fef = fef;\n        d->lef = lef;\n        d->reachable = 0;\n        d->exits = d->entries = NULL;\n        d->next = NULL;\n\n        if (!dag->nodes)\n            dag->nodes = d;\n        else\n            tail->next = d;\n        tail = d;\n    }\n\n    /* Read initial node ID */\n    k = dag_param_read(line, \"Initial\");\n    if ((k < 0) || (k >= n_nodes)) {\n        E_ERROR(\"Initial node parameter missing or invalid\\n\");\n        goto load_error;\n    }\n    dag->start = darray[k];\n\n    /* Read final node ID */\n    k = dag_param_read(line, \"Final\");\n    if ((k < 0) || (k >= n_nodes)) {\n        E_ERROR(\"Final node parameter missing or invalid\\n\");\n        goto load_error;\n    }\n    dag->end = darray[k];\n\n    /* Read bestsegscore entries and ignore them. */\n    if ((k = dag_param_read(line, \"BestSegAscr\")) < 0) {\n        E_ERROR(\"BestSegAscr parameter missing\\n\");\n        goto load_error;\n    }\n    for (i = 0; i < k; i++) {\n        if ((line = lineiter_next(line)) == NULL) {\n            E_ERROR(\"Premature EOF while (%s) ignoring BestSegAscr\\n\",\n                    line);\n            goto load_error;\n        }\n    }\n\n    /* Read in edges. */\n    while ((line = lineiter_next(line)) != NULL) {\n        if (line->buf[0] == '#')\n            continue;\n        if (0 == strncmp(line->buf, \"Edges\", 5))\n            break;\n    }\n    if (line == NULL) {\n        E_ERROR(\"Edges missing\\n\");\n        goto load_error;\n    }\n    while ((line = lineiter_next(line)) != NULL) {\n        int from, to, ascr;\n        ps_latnode_t *pd, *d;\n\n        if (sscanf(line->buf, \"%d %d %d\", &from, &to, &ascr) != 3)\n            break;\n        if (ascr WORSE_THAN WORST_SCORE)\n            continue;\n        pd = darray[from];\n        d = darray[to];\n        if (logratio != 1.0f)\n            ascr = (int32)(ascr * logratio);\n        ps_lattice_link(dag, pd, d, ascr, d->sf - 1);\n    }\n    if (strcmp(line->buf, \"End\\n\") != 0) {\n        E_ERROR(\"Terminating 'End' missing\\n\");\n        goto load_error;\n    }\n    lineiter_free(line);\n    fclose_comp(fp, ispipe);\n    ckd_free(darray);\n\n    /* Minor hack: If the final node is a filler word and not </s>,\n     * then set its base word ID to </s>, so that the language model\n     * scores won't be screwed up. */\n    if (dict_filler_word(dag->dict, dag->end->wid))\n        dag->end->basewid = dag->search\n            ? ps_search_finish_wid(dag->search)\n            : dict_wordid(dag->dict, S3_FINISH_WORD);\n\n    /* Mark reachable from dag->end */\n    dag_mark_reachable(dag->end);\n\n    /* Free nodes unreachable from dag->end and their links */\n    ps_lattice_delete_unreachable(dag);\n\n    if (ps) {\n        /* Build links around silence and filler words, since they do\n         * not exist in the language model.  FIXME: This is\n         * potentially buggy, as we already do this before outputing\n         * lattices. */\n        pip = logmath_log(dag->lmath, cmd_ln_float32_r(ps->config, \"-pip\"));\n        silpen = pip + logmath_log(dag->lmath,\n                                   cmd_ln_float32_r(ps->config, \"-silprob\"));\n        fillpen = pip + logmath_log(dag->lmath,\n                                    cmd_ln_float32_r(ps->config, \"-fillprob\"));\n        ps_lattice_penalize_fillers(dag, silpen, fillpen);\n    }\n\n    return dag;\n\n  load_error:\n    E_ERROR(\"Failed to load %s\\n\", file);\n    lineiter_free(line);\n    if (fp) fclose_comp(fp, ispipe);\n    ckd_free(darray);\n    return NULL;\n}\n\nint\nps_lattice_n_frames(ps_lattice_t *dag)\n{\n    return dag->n_frames;\n}\n\nps_lattice_t *\nps_lattice_init_search(ps_search_t *search, int n_frame)\n{\n    ps_lattice_t *dag;\n\n    dag = ckd_calloc(1, sizeof(*dag));\n    dag->search = search;\n    dag->dict = dict_retain(search->dict);\n    dag->lmath = logmath_retain(search->acmod->lmath);\n    dag->frate = cmd_ln_int32_r(dag->search->config, \"-frate\");\n    dag->silence = dict_silwid(dag->dict);\n    dag->n_frames = n_frame;\n    dag->latnode_alloc = listelem_alloc_init(sizeof(ps_latnode_t));\n    dag->latlink_alloc = listelem_alloc_init(sizeof(ps_latlink_t));\n    dag->latlink_list_alloc = listelem_alloc_init(sizeof(latlink_list_t));\n    dag->refcount = 1;\n    return dag;\n}\n\nps_lattice_t *\nps_lattice_retain(ps_lattice_t *dag)\n{\n    ++dag->refcount;\n    return dag;\n}\n\nint\nps_lattice_free(ps_lattice_t *dag)\n{\n    if (dag == NULL)\n        return 0;\n    if (--dag->refcount > 0)\n        return dag->refcount;\n    logmath_free(dag->lmath);\n    dict_free(dag->dict);\n    listelem_alloc_free(dag->latnode_alloc);\n    listelem_alloc_free(dag->latlink_alloc);\n    listelem_alloc_free(dag->latlink_list_alloc);    \n    ckd_free(dag->hyp_str);\n    ckd_free(dag);\n    return 0;\n}\n\nlogmath_t *\nps_lattice_get_logmath(ps_lattice_t *dag)\n{\n    return dag->lmath;\n}\n\nps_latnode_iter_t *\nps_latnode_iter(ps_lattice_t *dag)\n{\n    return dag->nodes;\n}\n\nps_latnode_iter_t *\nps_latnode_iter_next(ps_latnode_iter_t *itor)\n{\n    return itor->next;\n}\n\nvoid\nps_latnode_iter_free(ps_latnode_iter_t *itor)\n{\n    /* Do absolutely nothing. */\n}\n\nps_latnode_t *\nps_latnode_iter_node(ps_latnode_iter_t *itor)\n{\n    return itor;\n}\n\nint\nps_latnode_times(ps_latnode_t *node, int16 *out_fef, int16 *out_lef)\n{\n    if (out_fef) *out_fef = (int16)node->fef;\n    if (out_lef) *out_lef = (int16)node->lef;\n    return node->sf;\n}\n\nchar const *\nps_latnode_word(ps_lattice_t *dag, ps_latnode_t *node)\n{\n    return dict_wordstr(dag->dict, node->wid);\n}\n\nchar const *\nps_latnode_baseword(ps_lattice_t *dag, ps_latnode_t *node)\n{\n    return dict_wordstr(dag->dict, node->basewid);\n}\n\nint32\nps_latnode_prob(ps_lattice_t *dag, ps_latnode_t *node,\n                ps_latlink_t **out_link)\n{\n    latlink_list_t *links;\n    int32 bestpost = logmath_get_zero(dag->lmath);\n\n    for (links = node->exits; links; links = links->next) {\n        int32 post = links->link->alpha + links->link->beta - dag->norm;\n        if (post > bestpost) {\n            if (out_link) *out_link = links->link;\n            bestpost = post;\n        }\n    }\n    return bestpost;\n}\n\nps_latlink_iter_t *\nps_latnode_exits(ps_latnode_t *node)\n{\n    return node->exits;\n}\n\nps_latlink_iter_t *\nps_latnode_entries(ps_latnode_t *node)\n{\n    return node->entries;\n}\n\nps_latlink_iter_t *\nps_latlink_iter_next(ps_latlink_iter_t *itor)\n{\n    return itor->next;\n}\n\nvoid\nps_latlink_iter_free(ps_latlink_iter_t *itor)\n{\n    /* Do absolutely nothing. */\n}\n\nps_latlink_t *\nps_latlink_iter_link(ps_latlink_iter_t *itor)\n{\n    return itor->link;\n}\n\nint\nps_latlink_times(ps_latlink_t *link, int16 *out_sf)\n{\n    if (out_sf) {\n        if (link->from) {\n            *out_sf = link->from->sf;\n        }\n        else {\n            *out_sf = 0;\n        }\n    }\n    return link->ef;\n}\n\nps_latnode_t *\nps_latlink_nodes(ps_latlink_t *link, ps_latnode_t **out_src)\n{\n    if (out_src) *out_src = link->from;\n    return link->to;\n}\n\nchar const *\nps_latlink_word(ps_lattice_t *dag, ps_latlink_t *link)\n{\n    if (link->from == NULL)\n        return NULL;\n    return dict_wordstr(dag->dict, link->from->wid);\n}\n\nchar const *\nps_latlink_baseword(ps_lattice_t *dag, ps_latlink_t *link)\n{\n    if (link->from == NULL)\n        return NULL;\n    return dict_wordstr(dag->dict, link->from->basewid);\n}\n\nps_latlink_t *\nps_latlink_pred(ps_latlink_t *link)\n{\n    return link->best_prev;\n}\n\nint32\nps_latlink_prob(ps_lattice_t *dag, ps_latlink_t *link, int32 *out_ascr)\n{\n    int32 post = link->alpha + link->beta - dag->norm;\n    if (out_ascr) *out_ascr = link->ascr << SENSCR_SHIFT;\n    return post;\n}\n\nchar const *\nps_lattice_hyp(ps_lattice_t *dag, ps_latlink_t *link)\n{\n    ps_latlink_t *l;\n    size_t len;\n    char *c;\n\n    /* Backtrace once to get hypothesis length. */\n    len = 0;\n    /* FIXME: There may not be a search, but actually there should be a dict. */\n    if (dict_real_word(dag->dict, link->to->basewid)) {\n\tchar *wstr = dict_wordstr(dag->dict, link->to->basewid);\n\tif (wstr != NULL)\n\t    len += strlen(wstr) + 1;\n    }\n    for (l = link; l; l = l->best_prev) {\n        if (dict_real_word(dag->dict, l->from->basewid)) {\n    \t    char *wstr = dict_wordstr(dag->dict, l->from->basewid);\n            if (wstr != NULL)\n        \tlen += strlen(wstr) + 1;\n        }\n    }\n\n    /* Backtrace again to construct hypothesis string. */\n    ckd_free(dag->hyp_str);\n    dag->hyp_str = ckd_calloc(1, len+1); /* extra one incase the hyp is empty */\n    c = dag->hyp_str + len - 1;\n    if (dict_real_word(dag->dict, link->to->basewid)) {\n\tchar *wstr = dict_wordstr(dag->dict, link->to->basewid);\n\tif (wstr != NULL) {\n    \t    len = strlen(wstr);\n\t    c -= len;\n    \t    memcpy(c, wstr, len);\n    \t    if (c > dag->hyp_str) {\n        \t--c;\n        \t*c = ' ';\n\t    }\n        }\n    }\n    for (l = link; l; l = l->best_prev) {\n        if (dict_real_word(dag->dict, l->from->basewid)) {\n    \t    char *wstr = dict_wordstr(dag->dict, l->from->basewid);\n    \t    if (wstr != NULL) {\n\t        len = strlen(wstr);            \n    \t\tc -= len;\n    \t\tmemcpy(c, wstr, len);\n        \tif (c > dag->hyp_str) {\n            \t    --c;\n            \t    *c = ' ';\n        \t}\n    \t    }\n        }\n    }\n\n    return dag->hyp_str;\n}\n\nstatic void\nps_lattice_compute_lscr(ps_seg_t *seg, ps_latlink_t *link, int to)\n{\n    ngram_model_t *lmset;\n\n    /* Language model score is included in the link score for FSG\n     * search.  FIXME: Of course, this is sort of a hack :( */\n    if (0 != strcmp(ps_search_type(seg->search), PS_SEARCH_TYPE_NGRAM)) {\n        seg->lback = 1; /* Unigram... */\n        seg->lscr = 0;\n        return;\n    }\n        \n    lmset = ((ngram_search_t *)seg->search)->lmset;\n\n    if (link->best_prev == NULL) {\n        if (to) /* Sentence has only two words. */\n            seg->lscr = ngram_bg_score(lmset, link->to->basewid,\n                                       link->from->basewid, &seg->lback)\n                >> SENSCR_SHIFT;\n        else {/* This is the start symbol, its lscr is always 0. */\n            seg->lscr = 0;\n            seg->lback = 1;\n        }\n    }\n    else {\n        /* Find the two predecessor words. */\n        if (to) {\n            seg->lscr = ngram_tg_score(lmset, link->to->basewid,\n                                       link->from->basewid,\n                                       link->best_prev->from->basewid,\n                                       &seg->lback) >> SENSCR_SHIFT;\n        }\n        else {\n            if (link->best_prev->best_prev)\n                seg->lscr = ngram_tg_score(lmset, link->from->basewid,\n                                           link->best_prev->from->basewid,\n                                           link->best_prev->best_prev->from->basewid,\n                                           &seg->lback) >> SENSCR_SHIFT;\n            else\n                seg->lscr = ngram_bg_score(lmset, link->from->basewid,\n                                           link->best_prev->from->basewid,\n                                           &seg->lback) >> SENSCR_SHIFT;\n        }\n    }\n}\n\nstatic void\nps_lattice_link2itor(ps_seg_t *seg, ps_latlink_t *link, int to)\n{\n    dag_seg_t *itor = (dag_seg_t *)seg;\n    ps_latnode_t *node;\n\n    if (to) {\n        node = link->to;\n        seg->ef = node->lef;\n        seg->prob = 0; /* norm + beta - norm */\n    }\n    else {\n        latlink_list_t *x;\n        ps_latnode_t *n;\n        logmath_t *lmath = ps_search_acmod(seg->search)->lmath;\n\n        node = link->from;\n        seg->ef = link->ef;\n        seg->prob = link->alpha + link->beta - itor->norm;\n        /* Sum over all exits for this word and any alternate\n           pronunciations at the same frame. */\n        for (n = node; n; n = n->alt) {\n            for (x = n->exits; x; x = x->next) {\n                if (x->link == link)\n                    continue;\n                seg->prob = logmath_add(lmath, seg->prob,\n                                        x->link->alpha + x->link->beta - itor->norm);\n            }\n        }\n    }\n    seg->word = dict_wordstr(ps_search_dict(seg->search), node->wid);\n    seg->sf = node->sf;\n    seg->ascr = link->ascr << SENSCR_SHIFT;\n    /* Compute language model score from best predecessors. */\n    ps_lattice_compute_lscr(seg, link, to);\n}\n\nstatic void\nps_lattice_seg_free(ps_seg_t *seg)\n{\n    dag_seg_t *itor = (dag_seg_t *)seg;\n    \n    ckd_free(itor->links);\n    ckd_free(itor);\n}\n\nstatic ps_seg_t *\nps_lattice_seg_next(ps_seg_t *seg)\n{\n    dag_seg_t *itor = (dag_seg_t *)seg;\n\n    ++itor->cur;\n    if (itor->cur == itor->n_links + 1) {\n        ps_lattice_seg_free(seg);\n        return NULL;\n    }\n    else if (itor->cur == itor->n_links) {\n        /* Re-use the last link but with the \"to\" node. */\n        ps_lattice_link2itor(seg, itor->links[itor->cur - 1], TRUE);\n    }\n    else {\n        ps_lattice_link2itor(seg, itor->links[itor->cur], FALSE);\n    }\n\n    return seg;\n}\n\nstatic ps_segfuncs_t ps_lattice_segfuncs = {\n    /* seg_next */ ps_lattice_seg_next,\n    /* seg_free */ ps_lattice_seg_free\n};\n\nps_seg_t *\nps_lattice_seg_iter(ps_lattice_t *dag, ps_latlink_t *link, float32 lwf)\n{\n    dag_seg_t *itor;\n    ps_latlink_t *l;\n    int cur;\n\n    /* Calling this an \"iterator\" is a bit of a misnomer since we have\n     * to get the entire backtrace in order to produce it.\n     */\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->base.vt = &ps_lattice_segfuncs;\n    itor->base.search = dag->search;\n    itor->base.lwf = lwf;\n    itor->n_links = 0;\n    itor->norm = dag->norm;\n\n    for (l = link; l; l = l->best_prev) {\n        ++itor->n_links;\n    }\n    if (itor->n_links == 0) {\n        ckd_free(itor);\n        return NULL;\n    }\n\n    itor->links = ckd_calloc(itor->n_links, sizeof(*itor->links));\n    cur = itor->n_links - 1;\n    for (l = link; l; l = l->best_prev) {\n        itor->links[cur] = l;\n        --cur;\n    }\n\n    ps_lattice_link2itor((ps_seg_t *)itor, itor->links[0], FALSE);\n    return (ps_seg_t *)itor;\n}\n\nlatlink_list_t *\nlatlink_list_new(ps_lattice_t *dag, ps_latlink_t *link, latlink_list_t *next)\n{\n    latlink_list_t *ll;\n\n    ll = listelem_malloc(dag->latlink_list_alloc);\n    ll->link = link;\n    ll->next = next;\n\n    return ll;\n}\n\nvoid\nps_lattice_pushq(ps_lattice_t *dag, ps_latlink_t *link)\n{\n    if (dag->q_head == NULL)\n        dag->q_head = dag->q_tail = latlink_list_new(dag, link, NULL);\n    else {\n        dag->q_tail->next = latlink_list_new(dag, link, NULL);\n        dag->q_tail = dag->q_tail->next;\n    }\n\n}\n\nps_latlink_t *\nps_lattice_popq(ps_lattice_t *dag)\n{\n    latlink_list_t *x;\n    ps_latlink_t *link;\n\n    if (dag->q_head == NULL)\n        return NULL;\n    link = dag->q_head->link;\n    x = dag->q_head->next;\n    listelem_free(dag->latlink_list_alloc, dag->q_head);\n    dag->q_head = x;\n    if (dag->q_head == NULL)\n        dag->q_tail = NULL;\n    return link;\n}\n\nvoid\nps_lattice_delq(ps_lattice_t *dag)\n{\n    while (ps_lattice_popq(dag)) {\n        /* Do nothing. */\n    }\n}\n\nps_latlink_t *\nps_lattice_traverse_edges(ps_lattice_t *dag, ps_latnode_t *start, ps_latnode_t *end)\n{\n    ps_latnode_t *node;\n    latlink_list_t *x;\n\n    /* Cancel any unfinished traversal. */\n    ps_lattice_delq(dag);\n\n    /* Initialize node fanin counts and path scores. */\n    for (node = dag->nodes; node; node = node->next)\n        node->info.fanin = 0;\n    for (node = dag->nodes; node; node = node->next) {\n        for (x = node->exits; x; x = x->next)\n            (x->link->to->info.fanin)++;\n    }\n\n    /* Initialize agenda with all exits from start. */\n    if (start == NULL) start = dag->start;\n    for (x = start->exits; x; x = x->next)\n        ps_lattice_pushq(dag, x->link);\n\n    /* Pull the first edge off the queue. */\n    return ps_lattice_traverse_next(dag, end);\n}\n\nps_latlink_t *\nps_lattice_traverse_next(ps_lattice_t *dag, ps_latnode_t *end)\n{\n    ps_latlink_t *next;\n\n    next = ps_lattice_popq(dag);\n    if (next == NULL)\n        return NULL;\n\n    /* Decrease fanin count for destination node and expand outgoing\n     * edges if all incoming edges have been seen. */\n    --next->to->info.fanin;\n    if (next->to->info.fanin == 0) {\n        latlink_list_t *x;\n\n        if (end == NULL) end = dag->end;\n        if (next->to == end) {\n            /* If we have traversed all links entering the end node,\n             * clear the queue, causing future calls to this function\n             * to return NULL. */\n            ps_lattice_delq(dag);\n            return next;\n        }\n\n        /* Extend all outgoing edges. */\n        for (x = next->to->exits; x; x = x->next)\n            ps_lattice_pushq(dag, x->link);\n    }\n    return next;\n}\n\nps_latlink_t *\nps_lattice_reverse_edges(ps_lattice_t *dag, ps_latnode_t *start, ps_latnode_t *end)\n{\n    ps_latnode_t *node;\n    latlink_list_t *x;\n\n    /* Cancel any unfinished traversal. */\n    ps_lattice_delq(dag);\n\n    /* Initialize node fanout counts and path scores. */\n    for (node = dag->nodes; node; node = node->next) {\n        node->info.fanin = 0;\n        for (x = node->exits; x; x = x->next)\n            ++node->info.fanin;\n    }\n\n    /* Initialize agenda with all entries from end. */\n    if (end == NULL) end = dag->end;\n    for (x = end->entries; x; x = x->next)\n        ps_lattice_pushq(dag, x->link);\n\n    /* Pull the first edge off the queue. */\n    return ps_lattice_reverse_next(dag, start);\n}\n\nps_latlink_t *\nps_lattice_reverse_next(ps_lattice_t *dag, ps_latnode_t *start)\n{\n    ps_latlink_t *next;\n\n    next = ps_lattice_popq(dag);\n    if (next == NULL)\n        return NULL;\n\n    /* Decrease fanout count for source node and expand incoming\n     * edges if all incoming edges have been seen. */\n    --next->from->info.fanin;\n    if (next->from->info.fanin == 0) {\n        latlink_list_t *x;\n\n        if (start == NULL) start = dag->start;\n        if (next->from == start) {\n            /* If we have traversed all links entering the start node,\n             * clear the queue, causing future calls to this function\n             * to return NULL. */\n            ps_lattice_delq(dag);\n            return next;\n        }\n\n        /* Extend all outgoing edges. */\n        for (x = next->from->entries; x; x = x->next)\n            ps_lattice_pushq(dag, x->link);\n    }\n    return next;\n}\n\n/*\n * Find the best score from dag->start to end point of any link and\n * use it to update links further down the path.  This is like\n * single-source shortest path search, except that it is done over\n * edges rather than nodes, which allows us to do exact trigram scoring.\n *\n * Helpfully enough, we get half of the posterior probability\n * calculation for free that way too.  (interesting research topic: is\n * there a reliable Viterbi analogue to word-level Forward-Backward\n * like there is for state-level?  Or, is it just lattice density?)\n */\nps_latlink_t *\nps_lattice_bestpath(ps_lattice_t *dag, ngram_model_t *lmset,\n                    float32 lwf, float32 ascale)\n{\n    ps_search_t *search;\n    ps_latnode_t *node;\n    ps_latlink_t *link;\n    ps_latlink_t *bestend;\n    latlink_list_t *x;\n    logmath_t *lmath;\n    int32 bestescr;\n\n    search = dag->search;\n    lmath = dag->lmath;\n\n    /* Initialize path scores for all links exiting dag->start, and\n     * set all other scores to the minimum.  Also initialize alphas to\n     * log-zero. */\n    for (node = dag->nodes; node; node = node->next) {\n        for (x = node->exits; x; x = x->next) {\n            x->link->path_scr = MAX_NEG_INT32;\n            x->link->alpha = logmath_get_zero(lmath);\n        }\n    }\n    for (x = dag->start->exits; x; x = x->next) {\n        int32 n_used;\n        int16 to_is_fil;\n\n        to_is_fil = dict_filler_word(ps_search_dict(search), x->link->to->basewid) && x->link->to != dag->end;\n\n        /* Best path points to dag->start, obviously. */\n        x->link->path_scr = x->link->ascr;\n        if (lmset && !to_is_fil)\n            x->link->path_scr += (ngram_bg_score(lmset, x->link->to->basewid,\n                                ps_search_start_wid(search), &n_used) >> SENSCR_SHIFT) * lwf;\n        x->link->best_prev = NULL;\n        /* No predecessors for start links. */\n        x->link->alpha = 0;\n    }\n\n    /* Traverse the edges in the graph, updating path scores. */\n    for (link = ps_lattice_traverse_edges(dag, NULL, NULL);\n         link; link = ps_lattice_traverse_next(dag, NULL)) {\n        int32 bprob, n_used;\n        int32 w3_wid, w2_wid;\n        int16 w3_is_fil, w2_is_fil;\n        ps_latlink_t *prev_link;\n\n        /* Sanity check, we should not be traversing edges that\n         * weren't previously updated, otherwise nasty overflows will result. */\n        assert(link->path_scr != MAX_NEG_INT32);\n\n        /* Find word predecessor if from-word is filler */\n        w3_wid = link->from->basewid;\n        w2_wid = link->to->basewid;\n        w3_is_fil = dict_filler_word(ps_search_dict(search), link->from->basewid) && link->from != dag->start;\n        w2_is_fil = dict_filler_word(ps_search_dict(search), w2_wid) && link->to != dag->end;\n        prev_link = link;\n\n        if (w3_is_fil) {\n            while (prev_link->best_prev != NULL) {\n                prev_link = prev_link->best_prev;\n                w3_wid = prev_link->from->basewid;\n                if (!dict_filler_word(ps_search_dict(search), w3_wid) || prev_link->from == dag->start) {\n                    w3_is_fil = FALSE;\n                    break;\n                }\n            }\n        }\n\n        /* Calculate common bigram probability for all alphas. */\n        if (lmset && !w3_is_fil && !w2_is_fil)\n            bprob = ngram_ng_prob(lmset, w2_wid, &w3_wid, 1, &n_used);\n        else\n            bprob = 0;\n        /* Add in this link's acoustic score, which was a constant\n           factor in previous computations (if any). */\n        link->alpha += (link->ascr << SENSCR_SHIFT) * ascale;\n\n        if (w2_is_fil) {\n            w2_is_fil = w3_is_fil;\n            w3_is_fil = TRUE;\n            w2_wid = w3_wid;\n            while (prev_link->best_prev != NULL) {\n                prev_link = prev_link->best_prev;\n                w3_wid = prev_link->from->basewid;\n                if (!dict_filler_word(ps_search_dict(search), w3_wid) || prev_link->from == dag->start) {\n                    w3_is_fil = FALSE;\n                    break;\n                }\n            }\n        }\n\n        /* Update scores for all paths exiting link->to. */\n        for (x = link->to->exits; x; x = x->next) {\n            int32 score;\n            int32 w1_wid;\n            int16 w1_is_fil;\n\n            w1_wid = x->link->to->basewid;\n            w1_is_fil = dict_filler_word(ps_search_dict(search), w1_wid) && x->link->to != dag->end;\n\n            /* Update alpha with sum of previous alphas. */\n            x->link->alpha = logmath_add(lmath, x->link->alpha, link->alpha + bprob);\n\n            /* Update link score with maximum link score. */\n            score = link->path_scr + x->link->ascr;\n            /* Calculate language score for bestpath if possible */\n            if (lmset && !w1_is_fil && !w2_is_fil) {\n                if (w3_is_fil)\n                    /* partial context available */\n                    score += (ngram_bg_score(lmset, w1_wid, w2_wid, &n_used) >> SENSCR_SHIFT) * lwf;\n                else\n                    /* full context available */\n                    score += (ngram_tg_score(lmset, w1_wid, w2_wid, w3_wid, &n_used) >> SENSCR_SHIFT) * lwf;\n            }\n\n            if (score BETTER_THAN x->link->path_scr) {\n                x->link->path_scr = score;\n                x->link->best_prev = link;\n            }\n        }\n    }\n\n    /* Find best link entering final node, and calculate normalizer\n     * for posterior probabilities. */\n    bestend = NULL;\n    bestescr = MAX_NEG_INT32;\n\n    /* Normalizer is the alpha for the imaginary link exiting the\n       final node. */\n    dag->norm = logmath_get_zero(lmath);\n    for (x = dag->end->entries; x; x = x->next) {\n        int32 bprob, n_used;\n        int32 from_wid;\n        int16 from_is_fil;\n\n        from_wid = x->link->from->basewid;\n        from_is_fil = dict_filler_word(ps_search_dict(search), from_wid) && x->link->from != dag->start;\n        if (from_is_fil) {\n            ps_latlink_t *prev_link = x->link;\n            while (prev_link->best_prev != NULL) {\n                prev_link = prev_link->best_prev;\n                from_wid = prev_link->from->basewid;\n                if (!dict_filler_word(ps_search_dict(search), from_wid) || prev_link->from == dag->start) {\n                    from_is_fil = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (lmset && !from_is_fil)\n            bprob = ngram_ng_prob(lmset,\n                                  x->link->to->basewid,\n                                  &from_wid, 1, &n_used);\n        else\n            bprob = 0;\n        dag->norm = logmath_add(lmath, dag->norm, x->link->alpha + bprob);\n        if (x->link->path_scr BETTER_THAN bestescr) {\n            bestescr = x->link->path_scr;\n            bestend = x->link;\n        }\n    }\n    /* FIXME: floating point... */\n    dag->norm += (int32)(dag->final_node_ascr << SENSCR_SHIFT) * ascale;\n\n    E_INFO(\"Bestpath score: %d\\n\", bestescr);\n    E_INFO(\"Normalizer P(O) = alpha(%s:%d:%d) = %d\\n\",\n           dict_wordstr(dag->search->dict, dag->end->wid),\n           dag->end->sf, dag->end->lef,\n           dag->norm);\n    return bestend;\n}\n\nstatic int32\nps_lattice_joint(ps_lattice_t *dag, ps_latlink_t *link, float32 ascale)\n{\n    ngram_model_t *lmset;\n    int32 jprob;\n\n    /* Sort of a hack... */\n    if (dag->search && 0 == strcmp(ps_search_type(dag->search), PS_SEARCH_TYPE_NGRAM))\n        lmset = ((ngram_search_t *)dag->search)->lmset;\n    else\n        lmset = NULL;\n\n    jprob = (dag->final_node_ascr << SENSCR_SHIFT) * ascale;\n    while (link) {\n        if (lmset) {\n            int lback;\n            int32 from_wid, to_wid;\n            int16 from_is_fil, to_is_fil;\n\n            from_wid = link->from->basewid;\n            to_wid = link->to->basewid;\n            from_is_fil = dict_filler_word(dag->dict, from_wid) && link->from != dag->start;\n            to_is_fil = dict_filler_word(dag->dict, to_wid) && link->to != dag->end;\n\n            /* Find word predecessor if from-word is filler */\n            if (!to_is_fil && from_is_fil) {\n                ps_latlink_t *prev_link = link;\n                while (prev_link->best_prev != NULL) {\n                    prev_link = prev_link->best_prev;\n                    from_wid = prev_link->from->basewid;\n                    if (!dict_filler_word(dag->dict, from_wid) || prev_link->from == dag->start) {\n                        from_is_fil = FALSE;\n                        break;\n                    }\n                }\n            }\n\n            /* Compute unscaled language model probability.  Note that\n               this is actually not the language model probability\n               that corresponds to this link, but that is okay,\n               because we are just taking the sum over all links in\n               the best path. */\n            if (!from_is_fil && !to_is_fil)\n                jprob += ngram_ng_prob(lmset, to_wid,\n                                       &from_wid, 1, &lback);\n        }\n        /* If there is no language model, we assume that the language\n           model probability (such as it is) has been included in the\n           link score. */\n        jprob += (link->ascr << SENSCR_SHIFT) * ascale;\n        link = link->best_prev;\n    }\n\n    E_INFO(\"Joint P(O,S) = %d P(S|O) = %d\\n\", jprob, jprob - dag->norm);\n    return jprob;\n}\n\nint32\nps_lattice_posterior(ps_lattice_t *dag, ngram_model_t *lmset,\n                     float32 ascale)\n{\n    logmath_t *lmath;\n    ps_latnode_t *node;\n    ps_latlink_t *link;\n    latlink_list_t *x;\n    ps_latlink_t *bestend;\n    int32 bestescr;\n\n    lmath = dag->lmath;\n\n    /* Reset all betas to zero. */\n    for (node = dag->nodes; node; node = node->next) {\n        for (x = node->exits; x; x = x->next) {\n            x->link->beta = logmath_get_zero(lmath);\n        }\n    }\n\n    bestend = NULL;\n    bestescr = MAX_NEG_INT32;\n    /* Accumulate backward probabilities for all links. */\n    for (link = ps_lattice_reverse_edges(dag, NULL, NULL);\n         link; link = ps_lattice_reverse_next(dag, NULL)) {\n        int32 bprob, n_used;\n        int32 from_wid, to_wid;\n        int16 from_is_fil, to_is_fil;\n\n        from_wid = link->from->basewid;\n        to_wid = link->to->basewid;\n        from_is_fil = dict_filler_word(dag->dict, from_wid) && link->from != dag->start;\n        to_is_fil = dict_filler_word(dag->dict, to_wid) && link->to != dag->end;\n\n        /* Find word predecessor if from-word is filler */\n        if (!to_is_fil && from_is_fil) {\n            ps_latlink_t *prev_link = link;\n            while (prev_link->best_prev != NULL) {\n                prev_link = prev_link->best_prev;\n                from_wid = prev_link->from->basewid;\n                if (!dict_filler_word(dag->dict, from_wid) || prev_link->from == dag->start) {\n                    from_is_fil = FALSE;\n                    break;\n                }\n            }\n        }\n\n        /* Calculate LM probability. */\n        if (lmset && !from_is_fil && !to_is_fil)\n            bprob = ngram_ng_prob(lmset, to_wid, &from_wid, 1, &n_used);\n        else\n            bprob = 0;\n\n        if (link->to == dag->end) {\n            /* Track the best path - we will backtrace in order to\n               calculate the unscaled joint probability for sentence\n               posterior. */\n            if (link->path_scr BETTER_THAN bestescr) {\n                bestescr = link->path_scr;\n                bestend = link;\n            }\n            /* Imaginary exit link from final node has beta = 1.0 */\n            link->beta = bprob + (dag->final_node_ascr << SENSCR_SHIFT) * ascale;\n        }\n        else {\n            /* Update beta from all outgoing betas. */\n            for (x = link->to->exits; x; x = x->next) {\n                link->beta = logmath_add(lmath, link->beta,\n                                         x->link->beta + bprob\n                                         + (x->link->ascr << SENSCR_SHIFT) * ascale);\n            }\n        }\n    }\n\n    /* Return P(S|O) = P(O,S)/P(O) */\n    return ps_lattice_joint(dag, bestend, ascale) - dag->norm;\n}\n\nint32\nps_lattice_posterior_prune(ps_lattice_t *dag, int32 beam)\n{\n    ps_latlink_t *link;\n    int npruned = 0;\n\n    for (link = ps_lattice_traverse_edges(dag, dag->start, dag->end);\n         link; link = ps_lattice_traverse_next(dag, dag->end)) {\n        link->from->reachable = FALSE;\n        if (link->alpha + link->beta - dag->norm < beam) {\n            latlink_list_t *x, *tmp, *next;\n            tmp = NULL;\n            for (x = link->from->exits; x; x = next) {\n                next = x->next;\n                if (x->link == link) {\n                    listelem_free(dag->latlink_list_alloc, x);\n                }\n                else {\n                    x->next = tmp;\n                    tmp = x;\n                }\n            }\n            link->from->exits = tmp;\n            tmp = NULL;\n            for (x = link->to->entries; x; x = next) {\n                next = x->next;\n                if (x->link == link) {\n                    listelem_free(dag->latlink_list_alloc, x);\n                }\n                else {\n                    x->next = tmp;\n                    tmp = x;\n                }\n            }\n            link->to->entries = tmp;\n            listelem_free(dag->latlink_alloc, link);\n            ++npruned;\n        }\n    }\n    dag_mark_reachable(dag->end);\n    ps_lattice_delete_unreachable(dag);\n    return npruned;\n}\n\n\n/* Parameters to prune n-best alternatives search */\n#define MAX_PATHS\t500     /* Max allowed active paths at any time */\n#define MAX_HYP_TRIES\t10000\n\n/*\n * For each node in any path between from and end of utt, find the\n * best score from \"from\".sf to end of utt.  (NOTE: Uses bigram probs;\n * this is an estimate of the best score from \"from\".)  (NOTE #2: yes,\n * this is the \"heuristic score\" used in A* search)\n */\nstatic int32\nbest_rem_score(ps_astar_t *nbest, ps_latnode_t * from)\n{\n    latlink_list_t *x;\n    int32 bestscore, score;\n\n    if (from->info.rem_score <= 0)\n        return (from->info.rem_score);\n\n    /* Best score from \"from\" to end of utt not known; compute from successors */\n    bestscore = WORST_SCORE;\n    for (x = from->exits; x; x = x->next) {\n        int32 n_used;\n\n        score = best_rem_score(nbest, x->link->to);\n        score += x->link->ascr;\n        if (nbest->lmset)\n            score += (ngram_bg_score(nbest->lmset, x->link->to->basewid,\n                                     from->basewid, &n_used) >> SENSCR_SHIFT)\n                      * nbest->lwf;\n        if (score BETTER_THAN bestscore)\n            bestscore = score;\n    }\n    from->info.rem_score = bestscore;\n\n    return bestscore;\n}\n\n/*\n * Insert newpath in sorted (by path score) list of paths.  But if newpath is\n * too far down the list, drop it (FIXME: necessary?)\n * total_score = path score (newpath) + rem_score to end of utt.\n */\nstatic void\npath_insert(ps_astar_t *nbest, ps_latpath_t *newpath, int32 total_score)\n{\n    ps_latpath_t *prev, *p;\n    int32 i;\n\n    prev = NULL;\n    for (i = 0, p = nbest->path_list; (i < MAX_PATHS) && p; p = p->next, i++) {\n        if ((p->score + p->node->info.rem_score) < total_score)\n            break;\n        prev = p;\n    }\n\n    /* newpath should be inserted between prev and p */\n    if (i < MAX_PATHS) {\n        /* Insert new partial hyp */\n        newpath->next = p;\n        if (!prev)\n            nbest->path_list = newpath;\n        else\n            prev->next = newpath;\n        if (!p)\n            nbest->path_tail = newpath;\n\n        nbest->n_path++;\n        nbest->n_hyp_insert++;\n        nbest->insert_depth += i;\n    }\n    else {\n        /* newpath score too low; reject it and also prune paths beyond MAX_PATHS */\n        nbest->path_tail = prev;\n        prev->next = NULL;\n        nbest->n_path = MAX_PATHS;\n        listelem_free(nbest->latpath_alloc, newpath);\n\n        nbest->n_hyp_reject++;\n        for (; p; p = newpath) {\n            newpath = p->next;\n            listelem_free(nbest->latpath_alloc, p);\n            nbest->n_hyp_reject++;\n        }\n    }\n}\n\n/* Find all possible extensions to given partial path */\nstatic void\npath_extend(ps_astar_t *nbest, ps_latpath_t * path)\n{\n    latlink_list_t *x;\n    ps_latpath_t *newpath;\n    int32 total_score, tail_score;\n\n    /* Consider all successors of path->node */\n    for (x = path->node->exits; x; x = x->next) {\n        int32 n_used;\n\n        /* Skip successor if no path from it reaches the final node */\n        if (x->link->to->info.rem_score <= WORST_SCORE)\n            continue;\n\n        /* Create path extension and compute exact score for this extension */\n        newpath = listelem_malloc(nbest->latpath_alloc);\n        newpath->node = x->link->to;\n        newpath->parent = path;\n        newpath->score = path->score + x->link->ascr;\n        if (nbest->lmset) {\n            if (path->parent) {\n                newpath->score += nbest->lwf\n                    * (ngram_tg_score(nbest->lmset, newpath->node->basewid,\n                                      path->node->basewid,\n                                      path->parent->node->basewid, &n_used)\n                       >> SENSCR_SHIFT);\n            }\n            else \n                newpath->score += nbest->lwf\n                    * (ngram_bg_score(nbest->lmset, newpath->node->basewid,\n                                      path->node->basewid, &n_used)\n                       >> SENSCR_SHIFT);\n        }\n\n        /* Insert new partial path hypothesis into sorted path_list */\n        nbest->n_hyp_tried++;\n        total_score = newpath->score + newpath->node->info.rem_score;\n\n        /* First see if hyp would be worse than the worst */\n        if (nbest->n_path >= MAX_PATHS) {\n            tail_score =\n                nbest->path_tail->score\n                + nbest->path_tail->node->info.rem_score;\n            if (total_score < tail_score) {\n                listelem_free(nbest->latpath_alloc, newpath);\n                nbest->n_hyp_reject++;\n                continue;\n            }\n        }\n\n        path_insert(nbest, newpath, total_score);\n    }\n}\n\nps_astar_t *\nps_astar_start(ps_lattice_t *dag,\n                  ngram_model_t *lmset,\n                  float32 lwf,\n                  int sf, int ef,\n                  int w1, int w2)\n{\n    ps_astar_t *nbest;\n    ps_latnode_t *node;\n\n    nbest = ckd_calloc(1, sizeof(*nbest));\n    nbest->dag = dag;\n    nbest->lmset = lmset;\n    nbest->lwf = lwf;\n    nbest->sf = sf;\n    if (ef < 0)\n        nbest->ef = dag->n_frames + 1;\n    else\n        nbest->ef = ef;\n    nbest->w1 = w1;\n    nbest->w2 = w2;\n    nbest->latpath_alloc = listelem_alloc_init(sizeof(ps_latpath_t));\n\n    /* Initialize rem_score (A* heuristic) to default values */\n    for (node = dag->nodes; node; node = node->next) {\n        if (node == dag->end)\n            node->info.rem_score = 0;\n        else if (node->exits == NULL)\n            node->info.rem_score = WORST_SCORE;\n        else\n            node->info.rem_score = 1;   /* +ve => unknown value */\n    }\n\n    /* Create initial partial hypotheses list consisting of nodes starting at sf */\n    nbest->path_list = nbest->path_tail = NULL;\n    for (node = dag->nodes; node; node = node->next) {\n        if (node->sf == sf) {\n            ps_latpath_t *path;\n            int32 n_used;\n\n            best_rem_score(nbest, node);\n            path = listelem_malloc(nbest->latpath_alloc);\n            path->node = node;\n            path->parent = NULL;\n            if (nbest->lmset)\n                path->score = nbest->lwf *\n                    ((w1 < 0)\n                    ? ngram_bg_score(nbest->lmset, node->basewid, w2, &n_used)\n                    : ngram_tg_score(nbest->lmset, node->basewid, w2, w1, &n_used));\n            else\n                path->score = 0;\n            path->score >>= SENSCR_SHIFT;\n            path_insert(nbest, path, path->score + node->info.rem_score);\n        }\n    }\n\n    return nbest;\n}\n\nps_latpath_t *\nps_astar_next(ps_astar_t *nbest)\n{\n    ps_lattice_t *dag;\n\n    dag = nbest->dag;\n\n    /* Pop the top (best) partial hypothesis */\n    while ((nbest->top = nbest->path_list) != NULL) {\n        nbest->path_list = nbest->path_list->next;\n        if (nbest->top == nbest->path_tail)\n            nbest->path_tail = NULL;\n        nbest->n_path--;\n\n        /* Complete hypothesis? */\n        if ((nbest->top->node->sf >= nbest->ef)\n            || ((nbest->top->node == dag->end) &&\n                (nbest->ef > dag->end->sf))) {\n            /* FIXME: Verify that it is non-empty.  Also we may want\n             * to verify that it is actually distinct from other\n             * paths, since often this is not the case*/\n            return nbest->top;\n        }\n        else {\n            if (nbest->top->node->fef < nbest->ef)\n                path_extend(nbest, nbest->top);\n        }\n    }\n\n    /* Did not find any more paths to extend. */\n    return NULL;\n}\n\nchar const *\nps_astar_hyp(ps_astar_t *nbest, ps_latpath_t *path)\n{\n    ps_search_t *search;\n    ps_latpath_t *p;\n    size_t len;\n    char *c;\n    char *hyp;\n\n    search = nbest->dag->search;\n\n    /* Backtrace once to get hypothesis length. */\n    len = 0;\n    for (p = path; p; p = p->parent) {\n        if (dict_real_word(ps_search_dict(search), p->node->basewid)) {\n    \t    char *wstr = dict_wordstr(ps_search_dict(search), p->node->basewid);\n    \t    if (wstr != NULL)\n    \t        len += strlen(wstr) + 1;\n        }\n    }\n\n    if (len == 0) {\n\treturn NULL;\n    }\n\n    /* Backtrace again to construct hypothesis string. */\n    hyp = ckd_calloc(1, len);\n    c = hyp + len - 1;\n    for (p = path; p; p = p->parent) {\n        if (dict_real_word(ps_search_dict(search), p->node->basewid)) {\n    \t    char *wstr = dict_wordstr(ps_search_dict(search), p->node->basewid);\n    \t    if (wstr != NULL) {\n\t        len = strlen(wstr);\n    \t\tc -= len;\n        \tmemcpy(c, wstr, len);\n    \t\tif (c > hyp) {\n            \t    --c;\n        \t    *c = ' ';\n    \t\t}\n    \t    }\n        }\n    }\n\n    nbest->hyps = glist_add_ptr(nbest->hyps, hyp);\n    return hyp;\n}\n\nstatic void\nps_astar_node2itor(astar_seg_t *itor)\n{\n    ps_seg_t *seg = (ps_seg_t *)itor;\n    ps_latnode_t *node;\n\n    assert(itor->cur < itor->n_nodes);\n    node = itor->nodes[itor->cur];\n    if (itor->cur == itor->n_nodes - 1)\n        seg->ef = node->lef;\n    else\n        seg->ef = itor->nodes[itor->cur + 1]->sf - 1;\n    seg->word = dict_wordstr(ps_search_dict(seg->search), node->wid);\n    seg->sf = node->sf;\n    seg->prob = 0; /* FIXME: implement forward-backward */\n}\n\nstatic void\nps_astar_seg_free(ps_seg_t *seg)\n{\n    astar_seg_t *itor = (astar_seg_t *)seg;\n    ckd_free(itor->nodes);\n    ckd_free(itor);\n}\n\nstatic ps_seg_t *\nps_astar_seg_next(ps_seg_t *seg)\n{\n    astar_seg_t *itor = (astar_seg_t *)seg;\n\n    ++itor->cur;\n    if (itor->cur == itor->n_nodes) {\n        ps_astar_seg_free(seg);\n        return NULL;\n    }\n    else {\n        ps_astar_node2itor(itor);\n    }\n\n    return seg;\n}\n\nstatic ps_segfuncs_t ps_astar_segfuncs = {\n    /* seg_next */ ps_astar_seg_next,\n    /* seg_free */ ps_astar_seg_free\n};\n\nps_seg_t *\nps_astar_seg_iter(ps_astar_t *astar, ps_latpath_t *path, float32 lwf)\n{\n    astar_seg_t *itor;\n    ps_latpath_t *p;\n    int cur;\n\n    /* Backtrace and make an iterator, this should look familiar by now. */\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->base.vt = &ps_astar_segfuncs;\n    itor->base.search = astar->dag->search;\n    itor->base.lwf = lwf;\n    itor->n_nodes = itor->cur = 0;\n    for (p = path; p; p = p->parent) {\n        ++itor->n_nodes;\n    }\n    itor->nodes = ckd_calloc(itor->n_nodes, sizeof(*itor->nodes));\n    cur = itor->n_nodes - 1;\n    for (p = path; p; p = p->parent) {\n        itor->nodes[cur] = p->node;\n        --cur;\n    }\n\n    ps_astar_node2itor(itor);\n    return (ps_seg_t *)itor;\n}\n\nvoid\nps_astar_finish(ps_astar_t *nbest)\n{\n    gnode_t *gn;\n\n    /* Free all hyps. */\n    for (gn = nbest->hyps; gn; gn = gnode_next(gn)) {\n        ckd_free(gnode_ptr(gn));\n    }\n    glist_free(nbest->hyps);\n    /* Free all paths. */\n    listelem_alloc_free(nbest->latpath_alloc);\n    /* Free the Henge. */\n    ckd_free(nbest);\n}\n\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2009 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file ps_mllr.c Model-space linear transforms for speaker adaptation\n */\n\n/* System headers. */\n#include <stdio.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/ckd_alloc.h>\n\n/* Local headers. */\n#include \"acmod.h\"\n\nps_mllr_t *\nps_mllr_read(char const *regmatfile)\n{\n    ps_mllr_t *mllr;\n    FILE *fp;\n    int n, i, m, j, k;\n\n    mllr = ckd_calloc(1, sizeof(*mllr));\n    mllr->refcnt = 1;\n\n    if ((fp = fopen(regmatfile, \"r\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open MLLR file '%s' for reading\", regmatfile);\n        goto error_out;\n    }\n    else\n        E_INFO(\"Reading MLLR transformation file '%s'\\n\", regmatfile);\n\n    if ((fscanf(fp, \"%d\", &n) != 1) || (n < 1)) {\n        E_ERROR(\"Failed to read number of MLLR classes\\n\");\n        goto error_out;\n    }\n    mllr->n_class = n;\n\n    if ((fscanf(fp, \"%d\", &n) != 1)) {\n        E_ERROR(\"Failed to read number of feature streams\\n\");\n        goto error_out;\n    }\n    mllr->n_feat = n;\n    mllr->veclen = ckd_calloc(mllr->n_feat, sizeof(*mllr->veclen));\n\n    mllr->A = (float32 ****) ckd_calloc(mllr->n_feat, sizeof(float32 **));\n    mllr->b = (float32 ***) ckd_calloc(mllr->n_feat, sizeof(float32 *));\n    mllr->h = (float32 ***) ckd_calloc(mllr->n_feat, sizeof(float32 *));\n\n    for (i = 0; i < mllr->n_feat; ++i) {\n        if (fscanf(fp, \"%d\", &n) != 1) {\n            E_ERROR(\"Failed to read stream length for feature %d\\n\", i);\n            goto error_out;\n        }\n        mllr->veclen[i] = n;\n        mllr->A[i] =\n            (float32 ***) ckd_calloc_3d(mllr->n_class, mllr->veclen[i],\n                                        mllr->veclen[i], sizeof(float32));\n        mllr->b[i] =\n            (float32 **) ckd_calloc_2d(mllr->n_class, mllr->veclen[i],\n                                       sizeof(float32));\n        mllr->h[i] =\n            (float32 **) ckd_calloc_2d(mllr->n_class, mllr->veclen[i],\n                                       sizeof(float32));\n\n        for (m = 0; m < mllr->n_class; ++m) {\n            for (j = 0; j < mllr->veclen[i]; ++j) {\n                for (k = 0; k < mllr->veclen[i]; ++k) {\n                    if (fscanf(fp, \"%f \", &mllr->A[i][m][j][k]) != 1) {\n                        E_ERROR(\"Failed reading MLLR rotation (%d,%d,%d,%d)\\n\",\n                                i, m, j, k);\n                        goto error_out;\n                    }\n                }\n            }\n            for (j = 0; j < mllr->veclen[i]; ++j) {\n                if (fscanf(fp, \"%f \", &mllr->b[i][m][j]) != 1) {\n                    E_ERROR(\"Failed reading MLLR bias (%d,%d,%d)\\n\",\n                            i, m, j);\n                    goto error_out;\n                }\n            }\n            for (j = 0; j < mllr->veclen[i]; ++j) {\n                if (fscanf(fp, \"%f \", &mllr->h[i][m][j]) != 1) {\n                    E_ERROR(\"Failed reading MLLR variance scale (%d,%d,%d)\\n\",\n                            i, m, j);\n                    goto error_out;\n                }\n            }\n        }\n    }\n    fclose(fp);\n    return mllr;\n\nerror_out:\n    if (fp)\n        fclose(fp);\n    ps_mllr_free(mllr);\n    return NULL;\n}\n\nps_mllr_t *\nps_mllr_retain(ps_mllr_t *mllr)\n{\n    ++mllr->refcnt;\n    return mllr;\n}\n\nint\nps_mllr_free(ps_mllr_t *mllr)\n{\n    int i;\n\n    if (mllr == NULL)\n        return 0;\n    if (--mllr->refcnt > 0)\n        return mllr->refcnt;\n\n    for (i = 0; i < mllr->n_feat; ++i) {\n        if (mllr->A)\n            ckd_free_3d(mllr->A[i]);\n        if (mllr->b)\n            ckd_free_2d(mllr->b[i]);\n        if (mllr->h)\n            ckd_free_2d(mllr->h[i]);\n    }\n    ckd_free(mllr->veclen);\n    ckd_free(mllr->A);\n    ckd_free(mllr->b);\n    ckd_free(mllr->h);\n    ckd_free(mllr);\n\n    return 0;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2010 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* System headers */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#if defined(__ADSPBLACKFIN__)\n#elif !defined(_WIN32_WCE)\n#include <sys/types.h>\n#endif\n\n/* SphinxBase headers */\n#include <sphinx_config.h>\n#include <sphinxbase/cmd_ln.h>\n#include <sphinxbase/fixpoint.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/bio.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/prim_type.h>\n\n/* Local headers */\n#include \"tied_mgau_common.h\"\n#include \"ptm_mgau.h\"\n\nstatic ps_mgaufuncs_t ptm_mgau_funcs = {\n    \"ptm\",\n    ptm_mgau_frame_eval,      /* frame_eval */\n    ptm_mgau_mllr_transform,  /* transform */\n    ptm_mgau_free             /* free */\n};\n\n#define COMPUTE_GMM_MAP(_idx)                           \\\n    diff[_idx] = obs[_idx] - mean[_idx];                \\\n    sqdiff[_idx] = MFCCMUL(diff[_idx], diff[_idx]);     \\\n    compl[_idx] = MFCCMUL(sqdiff[_idx], var[_idx]);\n#define COMPUTE_GMM_REDUCE(_idx)                \\\n    d = GMMSUB(d, compl[_idx]);\n\nstatic void\ninsertion_sort_topn(ptm_topn_t *topn, int i, int32 d)\n{\n    ptm_topn_t vtmp;\n    int j;\n\n    topn[i].score = d;\n    if (i == 0)\n        return;\n    vtmp = topn[i];\n    for (j = i - 1; j >= 0 && d > topn[j].score; j--) {\n        topn[j + 1] = topn[j];\n    }\n    topn[j + 1] = vtmp;\n}\n\nstatic int\neval_topn(ptm_mgau_t *s, int cb, int feat, mfcc_t *z)\n{\n    ptm_topn_t *topn;\n    int i, ceplen;\n\n    topn = s->f->topn[cb][feat];\n    ceplen = s->g->featlen[feat];\n\n    for (i = 0; i < s->max_topn; i++) {\n        mfcc_t *mean, diff[4], sqdiff[4], compl[4]; /* diff, diff^2, component likelihood */\n        mfcc_t *var, d;\n        mfcc_t *obs;\n        int32 cw, j;\n\n        cw = topn[i].cw;\n        mean = s->g->mean[cb][feat][0] + cw * ceplen;\n        var = s->g->var[cb][feat][0] + cw * ceplen;\n        d = s->g->det[cb][feat][cw];\n        obs = z;\n        for (j = 0; j < ceplen % 4; ++j) {\n            diff[0] = *obs++ - *mean++;\n            sqdiff[0] = MFCCMUL(diff[0], diff[0]);\n            compl[0] = MFCCMUL(sqdiff[0], *var);\n            d = GMMSUB(d, compl[0]);\n            ++var;\n        }\n        /* We could vectorize this but it's unlikely to make much\n         * difference as the outer loop here isn't very big. */\n        for (;j < ceplen; j += 4) {\n            COMPUTE_GMM_MAP(0);\n            COMPUTE_GMM_MAP(1);\n            COMPUTE_GMM_MAP(2);\n            COMPUTE_GMM_MAP(3);\n            COMPUTE_GMM_REDUCE(0);\n            COMPUTE_GMM_REDUCE(1);\n            COMPUTE_GMM_REDUCE(2);\n            COMPUTE_GMM_REDUCE(3);\n            var += 4;\n            obs += 4;\n            mean += 4;\n        }\n        insertion_sort_topn(topn, i, (int32)d);\n    }\n\n    return topn[0].score;\n}\n\n/* This looks bad, but it actually isn't.  Less than 1% of eval_cb's\n * time is spent doing this. */\nstatic void\ninsertion_sort_cb(ptm_topn_t **cur, ptm_topn_t *worst, ptm_topn_t *best,\n                  int cw, int32 intd)\n{\n    for (*cur = worst - 1; *cur >= best && intd >= (*cur)->score; --*cur)\n        memcpy(*cur + 1, *cur, sizeof(**cur));\n    ++*cur;\n    (*cur)->cw = cw;\n    (*cur)->score = intd;\n}\n\nstatic int\neval_cb(ptm_mgau_t *s, int cb, int feat, mfcc_t *z)\n{\n    ptm_topn_t *worst, *best, *topn;\n    mfcc_t *mean;\n    mfcc_t *var, *det, *detP, *detE;\n    int32 i, ceplen;\n\n    best = topn = s->f->topn[cb][feat];\n    worst = topn + (s->max_topn - 1);\n    mean = s->g->mean[cb][feat][0];\n    var = s->g->var[cb][feat][0];\n    det = s->g->det[cb][feat];\n    detE = det + s->g->n_density;\n    ceplen = s->g->featlen[feat];\n\n    for (detP = det; detP < detE; ++detP) {\n        mfcc_t diff[4], sqdiff[4], compl[4]; /* diff, diff^2, component likelihood */\n        mfcc_t d, thresh;\n        mfcc_t *obs;\n        ptm_topn_t *cur;\n        int32 cw, j;\n\n        d = *detP;\n        thresh = (mfcc_t) worst->score; /* Avoid int-to-float conversions */\n        obs = z;\n        cw = (int)(detP - det);\n\n        /* Unroll the loop starting with the first dimension(s).  In\n         * theory this might be a bit faster if this Gaussian gets\n         * \"knocked out\" by C0. In practice not. */\n        for (j = 0; (j < ceplen % 4) && (d >= thresh); ++j) {\n            diff[0] = *obs++ - *mean++;\n            sqdiff[0] = MFCCMUL(diff[0], diff[0]);\n            compl[0] = MFCCMUL(sqdiff[0], *var++);\n            d = GMMSUB(d, compl[0]);\n        }\n        /* Now do 4 dimensions at a time.  You'd think that GCC would\n         * vectorize this?  Apparently not.  And it's right, because\n         * that won't make this any faster, at least on x86-64. */\n        for (; j < ceplen && d >= thresh; j += 4) {\n            COMPUTE_GMM_MAP(0);\n            COMPUTE_GMM_MAP(1);\n            COMPUTE_GMM_MAP(2);\n            COMPUTE_GMM_MAP(3);\n            COMPUTE_GMM_REDUCE(0);\n            COMPUTE_GMM_REDUCE(1);\n            COMPUTE_GMM_REDUCE(2);\n            COMPUTE_GMM_REDUCE(3);\n            var += 4;\n            obs += 4;\n            mean += 4;\n        }\n        if (j < ceplen) {\n            /* terminated early, so not in topn */\n            mean += (ceplen - j);\n            var += (ceplen - j);\n            continue;\n        }\n        if (d < thresh)\n            continue;\n        for (i = 0; i < s->max_topn; i++) {\n            /* already there, so don't need to insert */\n            if (topn[i].cw == cw)\n                break;\n        }\n        if (i < s->max_topn)\n            continue;       /* already there.  Don't insert */\n        insertion_sort_cb(&cur, worst, best, cw, (int32)d);\n    }\n\n    return best->score;\n}\n\n/**\n * Compute top-N densities for active codebooks (and prune)\n */\nstatic int\nptm_mgau_codebook_eval(ptm_mgau_t *s, mfcc_t **z, int frame)\n{\n    int i, j;\n\n    /* First evaluate top-N from previous frame. */\n    for (i = 0; i < s->g->n_mgau; ++i)\n        for (j = 0; j < s->g->n_feat; ++j)\n            eval_topn(s, i, j, z[j]);\n\n    /* If frame downsampling is in effect, possibly do nothing else. */\n    if (frame % s->ds_ratio)\n        return 0;\n\n    /* Evaluate remaining codebooks. */\n    for (i = 0; i < s->g->n_mgau; ++i) {\n        if (bitvec_is_clear(s->f->mgau_active, i))\n            continue;\n        for (j = 0; j < s->g->n_feat; ++j) {\n            eval_cb(s, i, j, z[j]);\n        }\n    }\n    return 0;\n}\n\n/**\n * Normalize densities to produce \"posterior probabilities\",\n * i.e. things with a reasonable dynamic range, then scale and\n * clamp them to the acceptable range.  This is actually done\n * solely to ensure that we can use fast_logmath_add().  Note that\n * unless we share the same normalizer across all codebooks for\n * each feature stream we get defective scores (that's why these\n * loops are inside out - doing it per-feature should give us\n * greater precision). */\nstatic int\nptm_mgau_codebook_norm(ptm_mgau_t *s, mfcc_t **z, int frame)\n{\n    int i, j;\n\n    for (j = 0; j < s->g->n_feat; ++j) {\n        int32 norm = WORST_SCORE;\n        for (i = 0; i < s->g->n_mgau; ++i) {\n            if (bitvec_is_clear(s->f->mgau_active, i))\n                continue;\n            if (norm < s->f->topn[i][j][0].score >> SENSCR_SHIFT)\n                norm = s->f->topn[i][j][0].score >> SENSCR_SHIFT;\n        }\n        assert(norm != WORST_SCORE);\n        for (i = 0; i < s->g->n_mgau; ++i) {\n            int32 k;\n            if (bitvec_is_clear(s->f->mgau_active, i))\n                continue;\n            for (k = 0; k < s->max_topn; ++k) {\n                s->f->topn[i][j][k].score >>= SENSCR_SHIFT;\n                s->f->topn[i][j][k].score -= norm;\n                s->f->topn[i][j][k].score = -s->f->topn[i][j][k].score;\n                if (s->f->topn[i][j][k].score > MAX_NEG_ASCR) \n                    s->f->topn[i][j][k].score = MAX_NEG_ASCR;\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nptm_mgau_calc_cb_active(ptm_mgau_t *s, uint8 *senone_active,\n                        int32 n_senone_active, int compallsen)\n{\n    int i, lastsen;\n\n    if (compallsen) {\n        bitvec_set_all(s->f->mgau_active, s->g->n_mgau);\n        return 0;\n    }\n    bitvec_clear_all(s->f->mgau_active, s->g->n_mgau);\n    for (lastsen = i = 0; i < n_senone_active; ++i) {\n        int sen = senone_active[i] + lastsen;\n        int cb = s->sen2cb[sen];\n        bitvec_set(s->f->mgau_active, cb);\n        lastsen = sen;\n    }\n    E_DEBUG(\"Active codebooks:\");\n    for (i = 0; i < s->g->n_mgau; ++i) {\n        if (bitvec_is_clear(s->f->mgau_active, i))\n            continue;\n        E_DEBUG(\" %d\", i);\n    }\n    return 0;\n}\n\n/**\n * Compute senone scores from top-N densities for active codebooks.\n */\nstatic int\nptm_mgau_senone_eval(ptm_mgau_t *s, int16 *senone_scores,\n                     uint8 *senone_active, int32 n_senone_active,\n                     int compall)\n{\n    int i, lastsen, bestscore;\n\n    memset(senone_scores, 0, s->n_sen * sizeof(*senone_scores));\n    /* FIXME: This is the non-cache-efficient way to do this.  We want\n     * to evaluate one codeword at a time but this requires us to have\n     * a reverse codebook to senone mapping, which we don't have\n     * (yet), since different codebooks have different top-N\n     * codewords. */\n    if (compall)\n        n_senone_active = s->n_sen;\n    bestscore = 0x7fffffff;\n    for (lastsen = i = 0; i < n_senone_active; ++i) {\n        int sen, f, cb;\n        int ascore;\n\n        if (compall)\n            sen = i;\n        else\n            sen = senone_active[i] + lastsen;\n        lastsen = sen;\n        cb = s->sen2cb[sen];\n\n        if (bitvec_is_clear(s->f->mgau_active, cb)) {\n            int j;\n            /* Because senone_active is deltas we can't really \"knock\n             * out\" senones from pruned codebooks, and in any case,\n             * it wouldn't make any difference to the search code,\n             * which doesn't expect senone_active to change. */\n            for (f = 0; f < s->g->n_feat; ++f) {\n                for (j = 0; j < s->max_topn; ++j) {\n                    s->f->topn[cb][f][j].score = MAX_NEG_ASCR;\n                }\n            }\n        }\n        /* For each feature, log-sum codeword scores + mixw to get\n         * feature density, then sum (multiply) to get ascore */\n        ascore = 0;\n        for (f = 0; f < s->g->n_feat; ++f) {\n            ptm_topn_t *topn;\n            int j, fden = 0;\n            topn = s->f->topn[cb][f];\n            for (j = 0; j < s->max_topn; ++j) {\n                int mixw;\n                /* Find mixture weight for this codeword. */\n                if (s->mixw_cb) {\n                    int dcw = s->mixw[f][topn[j].cw][sen/2];\n                    dcw = (dcw & 1) ? dcw >> 4 : dcw & 0x0f;\n                    mixw = s->mixw_cb[dcw];\n                }\n                else {\n                    mixw = s->mixw[f][topn[j].cw][sen];\n                }\n                if (j == 0)\n                    fden = mixw + topn[j].score;\n                else\n                    fden = fast_logmath_add(s->lmath_8b, fden,\n                                       mixw + topn[j].score);\n                E_DEBUG(\"fden[%d][%d] l+= %d + %d = %d\\n\",\n                        sen, f, mixw, topn[j].score, fden);\n            }\n            ascore += fden;\n        }\n        if (ascore < bestscore) bestscore = ascore;\n        senone_scores[sen] = ascore;\n    }\n    /* Normalize the scores again (finishing the job we started above\n     * in ptm_mgau_codebook_eval...) */\n    for (i = 0; i < s->n_sen; ++i) {\n        senone_scores[i] -= bestscore;\n    }\n\n    return 0;\n}\n\n/**\n * Compute senone scores for the active senones.\n */\nint32\nptm_mgau_frame_eval(ps_mgau_t *ps,\n                    int16 *senone_scores,\n                    uint8 *senone_active,\n                    int32 n_senone_active,\n                    mfcc_t ** featbuf, int32 frame,\n                    int32 compallsen)\n{\n    ptm_mgau_t *s = (ptm_mgau_t *)ps;\n    int fast_eval_idx;\n\n    /* Find the appropriate frame in the rotating history buffer\n     * corresponding to the requested input frame.  No bounds checking\n     * is done here, which just means you'll get semi-random crap if\n     * you request a frame in the future or one that's too far in the\n     * past.  Since the history buffer is just used for fast match\n     * that might not be fatal. */\n    fast_eval_idx = frame % s->n_fast_hist;\n    s->f = s->hist + fast_eval_idx;\n    /* Compute the top-N codewords for every codebook, unless this\n     * is a past frame, in which case we already have them (we\n     * hope!) */\n    if (frame >= ps_mgau_base(ps)->frame_idx) {\n        ptm_fast_eval_t *lastf;\n        /* Get the previous frame's top-N information (on the\n         * first frame of the input this is just all WORST_DIST,\n         * no harm in that) */\n        if (fast_eval_idx == 0)\n            lastf = s->hist + s->n_fast_hist - 1;\n        else\n            lastf = s->hist + fast_eval_idx - 1;\n        /* Copy in initial top-N info */\n        memcpy(s->f->topn[0][0], lastf->topn[0][0],\n               s->g->n_mgau * s->g->n_feat * s->max_topn * sizeof(ptm_topn_t));\n        /* Generate initial active codebook list (this might not be\n         * necessary) */\n        ptm_mgau_calc_cb_active(s, senone_active, n_senone_active, compallsen);\n        /* Now evaluate top-N, prune, and evaluate remaining codebooks. */\n        ptm_mgau_codebook_eval(s, featbuf, frame);\n        ptm_mgau_codebook_norm(s, featbuf, frame);\n    }\n    /* Evaluate intersection of active senones and active codebooks. */\n    ptm_mgau_senone_eval(s, senone_scores, senone_active,\n                         n_senone_active, compallsen);\n\n    return 0;\n}\n\nstatic int32\nread_sendump(ptm_mgau_t *s, bin_mdef_t *mdef, char const *file)\n{\n    FILE *fp;\n    char line[1000];\n    int32 i, n, r, c;\n    int32 do_swap, do_mmap;\n    size_t offset;\n    int n_clust = 0;\n    int n_feat = s->g->n_feat;\n    int n_density = s->g->n_density;\n    int n_sen = bin_mdef_n_sen(mdef);\n    int n_bits = 8;\n\n    s->n_sen = n_sen; /* FIXME: Should have been done earlier */\n    do_mmap = cmd_ln_boolean_r(s->config, \"-mmap\");\n\n    if ((fp = fopen(file, \"rb\")) == NULL)\n        return -1;\n\n    E_INFO(\"Loading senones from dump file %s\\n\", file);\n    /* Read title size, title */\n    if (fread(&n, sizeof(int32), 1, fp) != 1) {\n        E_ERROR_SYSTEM(\"Failed to read title size from %s\", file);\n        goto error_out;\n    }\n    /* This is extremely bogus */\n    do_swap = 0;\n    if (n < 1 || n > 999) {\n        SWAP_INT32(&n);\n        if (n < 1 || n > 999) {\n            E_ERROR(\"Title length %x in dump file %s out of range\\n\", n, file);\n            goto error_out;\n        }\n        do_swap = 1;\n    }\n    if (fread(line, sizeof(char), n, fp) != n) {\n        E_ERROR_SYSTEM(\"Cannot read title\");\n        goto error_out;\n    }\n    if (line[n - 1] != '\\0') {\n        E_ERROR(\"Bad title in dump file\\n\");\n        goto error_out;\n    }\n    E_INFO(\"%s\\n\", line);\n\n    /* Read header size, header */\n    if (fread(&n, sizeof(n), 1, fp) != 1) {\n        E_ERROR_SYSTEM(\"Failed to read header size from %s\", file);\n        goto error_out;\n    }\n    if (do_swap) SWAP_INT32(&n);\n    if (fread(line, sizeof(char), n, fp) != n) {\n        E_ERROR_SYSTEM(\"Cannot read header\");\n        goto error_out;\n    }\n    if (line[n - 1] != '\\0') {\n        E_ERROR(\"Bad header in dump file\\n\");\n        goto error_out;\n    }\n\n    /* Read other header strings until string length = 0 */\n    for (;;) {\n        if (fread(&n, sizeof(n), 1, fp) != 1) {\n            E_ERROR_SYSTEM(\"Failed to read header string size from %s\", file);\n            goto error_out;\n        }\n        if (do_swap) SWAP_INT32(&n);\n        if (n == 0)\n            break;\n        if (fread(line, sizeof(char), n, fp) != n) {\n            E_ERROR_SYSTEM(\"Cannot read header\");\n            goto error_out;\n        }\n        /* Look for a cluster count, if present */\n        if (!strncmp(line, \"feature_count \", strlen(\"feature_count \"))) {\n            n_feat = atoi(line + strlen(\"feature_count \"));\n        }\n        if (!strncmp(line, \"mixture_count \", strlen(\"mixture_count \"))) {\n            n_density = atoi(line + strlen(\"mixture_count \"));\n        }\n        if (!strncmp(line, \"model_count \", strlen(\"model_count \"))) {\n            n_sen = atoi(line + strlen(\"model_count \"));\n        }\n        if (!strncmp(line, \"cluster_count \", strlen(\"cluster_count \"))) {\n            n_clust = atoi(line + strlen(\"cluster_count \"));\n        }\n        if (!strncmp(line, \"cluster_bits \", strlen(\"cluster_bits \"))) {\n            n_bits = atoi(line + strlen(\"cluster_bits \"));\n        }\n    }\n\n    /* Defaults for #rows, #columns in mixw array. */\n    c = n_sen;\n    r = n_density;\n    if (n_clust == 0) {\n        /* Older mixw files have them here, and they might be padded. */\n        if (fread(&r, sizeof(r), 1, fp) != 1) {\n            E_ERROR_SYSTEM(\"Cannot read #rows\");\n            goto error_out;\n        }\n        if (do_swap) SWAP_INT32(&r);\n        if (fread(&c, sizeof(c), 1, fp) != 1) {\n            E_ERROR_SYSTEM(\"Cannot read #columns\");\n            goto error_out;\n        }\n        if (do_swap) SWAP_INT32(&c);\n        E_INFO(\"Rows: %d, Columns: %d\\n\", r, c);\n    }\n\n    if (n_feat != s->g->n_feat) {\n        E_ERROR(\"Number of feature streams mismatch: %d != %d\\n\",\n                n_feat, s->g->n_feat);\n        goto error_out;\n    }\n    if (n_density != s->g->n_density) {\n        E_ERROR(\"Number of densities mismatch: %d != %d\\n\",\n                n_density, s->g->n_density);\n        goto error_out;\n    }\n    if (n_sen != s->n_sen) {\n        E_ERROR(\"Number of senones mismatch: %d != %d\\n\",\n                n_sen, s->n_sen);\n        goto error_out;\n    }\n\n    if (!((n_clust == 0) || (n_clust == 15) || (n_clust == 16))) {\n        E_ERROR(\"Cluster count must be 0, 15, or 16\\n\");\n        goto error_out;\n    }\n    if (n_clust == 15)\n        ++n_clust;\n\n    if (!((n_bits == 8) || (n_bits == 4))) {\n        E_ERROR(\"Cluster count must be 4 or 8\\n\");\n        goto error_out;\n    }\n\n    if (do_mmap) {\n            E_INFO(\"Using memory-mapped I/O for senones\\n\");\n    }\n    offset = ftell(fp);\n\n    /* Allocate memory for pdfs (or memory map them) */\n    if (do_mmap) {\n        s->sendump_mmap = mmio_file_read(file);\n        /* Get cluster codebook if any. */\n        if (n_clust) {\n            s->mixw_cb = ((uint8 *) mmio_file_ptr(s->sendump_mmap)) + offset;\n            offset += n_clust;\n        }\n    }\n    else {\n        /* Get cluster codebook if any. */\n        if (n_clust) {\n            s->mixw_cb = ckd_calloc(1, n_clust);\n            if (fread(s->mixw_cb, 1, n_clust, fp) != (size_t) n_clust) {\n                E_ERROR(\"Failed to read %d bytes from sendump\\n\", n_clust);\n                goto error_out;\n            }\n        }\n    }\n\n    /* Set up pointers, or read, or whatever */\n    if (s->sendump_mmap) {\n        s->mixw = ckd_calloc_2d(n_feat, n_density, sizeof(*s->mixw));\n        for (n = 0; n < n_feat; n++) {\n            int step = c;\n            if (n_bits == 4)\n                step = (step + 1) / 2;\n            for (i = 0; i < r; i++) {\n                s->mixw[n][i] = ((uint8 *) mmio_file_ptr(s->sendump_mmap)) + offset;\n                offset += step;\n            }\n        }\n    }\n    else {\n        s->mixw = ckd_calloc_3d(n_feat, n_density, n_sen, sizeof(***s->mixw));\n        /* Read pdf values and ids */\n        for (n = 0; n < n_feat; n++) {\n            int step = c;\n            if (n_bits == 4)\n                step = (step + 1) / 2;\n            for (i = 0; i < r; i++) {\n                if (fread(s->mixw[n][i], sizeof(***s->mixw), step, fp)\n                    != (size_t) step) {\n                    E_ERROR(\"Failed to read %d bytes from sendump\\n\", step);\n                    goto error_out;\n                }\n            }\n        }\n    }\n\n    fclose(fp);\n    return 0;\nerror_out:\n    fclose(fp);\n    return -1;\n}\n\nstatic int32\nread_mixw(ptm_mgau_t * s, char const *file_name, double SmoothMin)\n{\n    char **argname, **argval;\n    char eofchk;\n    FILE *fp;\n    int32 byteswap, chksum_present;\n    uint32 chksum;\n    float32 *pdf;\n    int32 i, f, c, n;\n    int32 n_sen;\n    int32 n_feat;\n    int32 n_comp;\n    int32 n_err;\n\n    E_INFO(\"Reading mixture weights file '%s'\\n\", file_name);\n\n    if ((fp = fopen(file_name, \"rb\")) == NULL)\n        E_FATAL_SYSTEM(\"Failed to open mixture file '%s' for reading\", file_name);\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0)\n        E_FATAL(\"Failed to read header from '%s'\\n\", file_name);\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], MGAU_MIXW_VERSION) != 0)\n                E_WARN(\"Version mismatch(%s): %s, expecting %s\\n\",\n                       file_name, argval[i], MGAU_MIXW_VERSION);\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            chksum_present = 1; /* Ignore the associated value */\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    /* Read #senones, #features, #codewords, arraysize */\n    if ((bio_fread(&n_sen, sizeof(int32), 1, fp, byteswap, &chksum) != 1)\n        || (bio_fread(&n_feat, sizeof(int32), 1, fp, byteswap, &chksum) !=\n            1)\n        || (bio_fread(&n_comp, sizeof(int32), 1, fp, byteswap, &chksum) !=\n            1)\n        || (bio_fread(&n, sizeof(int32), 1, fp, byteswap, &chksum) != 1)) {\n        E_FATAL(\"bio_fread(%s) (arraysize) failed\\n\", file_name);\n    }\n    if (n_feat != s->g->n_feat)\n        E_FATAL(\"#Features streams(%d) != %d\\n\", n_feat, s->g->n_feat);\n    if (n != n_sen * n_feat * n_comp) {\n        E_FATAL\n            (\"%s: #float32s(%d) doesn't match header dimensions: %d x %d x %d\\n\",\n             file_name, i, n_sen, n_feat, n_comp);\n    }\n\n    /* n_sen = number of mixture weights per codeword, which is\n     * fixed at the number of senones since we have only one codebook.\n     */\n    s->n_sen = n_sen;\n\n    /* Quantized mixture weight arrays. */\n    s->mixw = ckd_calloc_3d(s->g->n_feat, s->g->n_density,\n                            n_sen, sizeof(***s->mixw));\n\n    /* Temporary structure to read in floats before conversion to (int32) logs3 */\n    pdf = (float32 *) ckd_calloc(n_comp, sizeof(float32));\n\n    /* Read senone probs data, normalize, floor, convert to logs3, truncate to 8 bits */\n    n_err = 0;\n    for (i = 0; i < n_sen; i++) {\n        for (f = 0; f < n_feat; f++) {\n            if (bio_fread((void *) pdf, sizeof(float32),\n                          n_comp, fp, byteswap, &chksum) != n_comp) {\n                E_FATAL(\"bio_fread(%s) (arraydata) failed\\n\", file_name);\n            }\n\n            /* Normalize and floor */\n            if (vector_sum_norm(pdf, n_comp) <= 0.0)\n                n_err++;\n            vector_floor(pdf, n_comp, SmoothMin);\n            vector_sum_norm(pdf, n_comp);\n\n            /* Convert to LOG, quantize, and transpose */\n            for (c = 0; c < n_comp; c++) {\n                int32 qscr;\n\n                qscr = -logmath_log(s->lmath_8b, pdf[c]);\n                if ((qscr > MAX_NEG_MIXW) || (qscr < 0))\n                    qscr = MAX_NEG_MIXW;\n                s->mixw[f][c][i] = qscr;\n            }\n        }\n    }\n    if (n_err > 0)\n        E_WARN(\"Weight normalization failed for %d mixture weights components\\n\", n_err);\n\n    ckd_free(pdf);\n\n    if (chksum_present)\n        bio_verify_chksum(fp, byteswap, chksum);\n\n    if (fread(&eofchk, 1, 1, fp) == 1)\n        E_FATAL(\"More data than expected in %s\\n\", file_name);\n\n    fclose(fp);\n\n    E_INFO(\"Read %d x %d x %d mixture weights\\n\", n_sen, n_feat, n_comp);\n    return n_sen;\n}\n\nps_mgau_t *\nptm_mgau_init(acmod_t *acmod, bin_mdef_t *mdef)\n{\n    ptm_mgau_t *s;\n    ps_mgau_t *ps;\n    char const *sendump_path;\n    int i;\n\n    s = ckd_calloc(1, sizeof(*s));\n    s->config = acmod->config;\n\n    s->lmath = logmath_retain(acmod->lmath);\n    /* Log-add table. */\n    s->lmath_8b = logmath_init(logmath_get_base(acmod->lmath), SENSCR_SHIFT, TRUE);\n    if (s->lmath_8b == NULL)\n        goto error_out;\n    /* Ensure that it is only 8 bits wide so that fast_logmath_add() works. */\n    if (logmath_get_width(s->lmath_8b) != 1) {\n        E_ERROR(\"Log base %f is too small to represent add table in 8 bits\\n\",\n                logmath_get_base(s->lmath_8b));\n        goto error_out;\n    }\n\n    /* Read means and variances. */\n    if ((s->g = gauden_init(cmd_ln_str_r(s->config, \"_mean\"),\n                            cmd_ln_str_r(s->config, \"_var\"),\n                            cmd_ln_float32_r(s->config, \"-varfloor\"),\n                            s->lmath)) == NULL) {\n        E_ERROR(\"Failed to read means and variances\\n\");\t\n        goto error_out;\n    }\n\n    /* We only support 256 codebooks or less (like 640k or 2GB, this\n     * should be enough for anyone) */\n    if (s->g->n_mgau > 256) {\n        E_INFO(\"Number of codebooks exceeds 256: %d\\n\", s->g->n_mgau);\n        goto error_out;\n    }\n    if (s->g->n_mgau != bin_mdef_n_ciphone(mdef)) {\n        E_INFO(\"Number of codebooks doesn't match number of ciphones, doesn't look like PTM: %d != %d\\n\", s->g->n_mgau, bin_mdef_n_ciphone(mdef));\n        goto error_out;\n    }\n    /* Verify n_feat and veclen, against acmod. */\n    if (s->g->n_feat != feat_dimension1(acmod->fcb)) {\n        E_ERROR(\"Number of streams does not match: %d != %d\\n\",\n                s->g->n_feat, feat_dimension1(acmod->fcb));\n        goto error_out;\n    }\n    for (i = 0; i < s->g->n_feat; ++i) {\n        if (s->g->featlen[i] != feat_dimension2(acmod->fcb, i)) {\n            E_ERROR(\"Dimension of stream %d does not match: %d != %d\\n\",\n                    s->g->featlen[i], feat_dimension2(acmod->fcb, i));\n            goto error_out;\n        }\n    }\n    /* Read mixture weights. */\n    if ((sendump_path = cmd_ln_str_r(s->config, \"_sendump\"))) {\n        if (read_sendump(s, acmod->mdef, sendump_path) < 0) {\n            goto error_out;\n        }\n    }\n    else {\n        if (read_mixw(s, cmd_ln_str_r(s->config, \"_mixw\"),\n                      cmd_ln_float32_r(s->config, \"-mixwfloor\")) < 0) {\n            goto error_out;\n        }\n    }\n    s->ds_ratio = cmd_ln_int32_r(s->config, \"-ds\");\n    s->max_topn = cmd_ln_int32_r(s->config, \"-topn\");\n    E_INFO(\"Maximum top-N: %d\\n\", s->max_topn);\n\n    /* Assume mapping of senones to their base phones, though this\n     * will become more flexible in the future. */\n    s->sen2cb = ckd_calloc(s->n_sen, sizeof(*s->sen2cb));\n    for (i = 0; i < s->n_sen; ++i)\n        s->sen2cb[i] = bin_mdef_sen2cimap(acmod->mdef, i);\n\n    /* Allocate fast-match history buffers.  We need enough for the\n     * phoneme lookahead window, plus the current frame, plus one for\n     * good measure? (FIXME: I don't remember why) */\n    s->n_fast_hist = cmd_ln_int32_r(s->config, \"-pl_window\") + 2;\n    s->hist = ckd_calloc(s->n_fast_hist, sizeof(*s->hist));\n    /* s->f will be a rotating pointer into s->hist. */\n    s->f = s->hist;\n    for (i = 0; i < s->n_fast_hist; ++i) {\n        int j, k, m;\n        /* Top-N codewords for every codebook and feature. */\n        s->hist[i].topn = ckd_calloc_3d(s->g->n_mgau, s->g->n_feat,\n                                        s->max_topn, sizeof(ptm_topn_t));\n        /* Initialize them to sane (yet arbitrary) defaults. */\n        for (j = 0; j < s->g->n_mgau; ++j) {\n            for (k = 0; k < s->g->n_feat; ++k) {\n                for (m = 0; m < s->max_topn; ++m) {\n                    s->hist[i].topn[j][k][m].cw = m;\n                    s->hist[i].topn[j][k][m].score = WORST_DIST;\n                }\n            }\n        }\n        /* Active codebook mapping (just codebook, not features,\n           at least not yet) */\n        s->hist[i].mgau_active = bitvec_alloc(s->g->n_mgau);\n        /* Start with them all on, prune them later. */\n        bitvec_set_all(s->hist[i].mgau_active, s->g->n_mgau);\n    }\n\n    ps = (ps_mgau_t *)s;\n    ps->vt = &ptm_mgau_funcs;\n    return ps;\nerror_out:\n    ptm_mgau_free(ps_mgau_base(s));\n    return NULL;\n}\n\nint\nptm_mgau_mllr_transform(ps_mgau_t *ps,\n                            ps_mllr_t *mllr)\n{\n    ptm_mgau_t *s = (ptm_mgau_t *)ps;\n    return gauden_mllr_transform(s->g, mllr, s->config);\n}\n\nvoid\nptm_mgau_free(ps_mgau_t *ps)\n{\n    int i;\n    ptm_mgau_t *s = (ptm_mgau_t *)ps;\n\n    logmath_free(s->lmath);\n    logmath_free(s->lmath_8b);\n    if (s->sendump_mmap) {\n        ckd_free_2d(s->mixw); \n        mmio_file_unmap(s->sendump_mmap);\n    }\n    else {\n        ckd_free_3d(s->mixw);\n    }\n    ckd_free(s->sen2cb);\n    \n    for (i = 0; i < s->n_fast_hist; i++) {\n\tckd_free_3d(s->hist[i].topn);\n\tbitvec_free(s->hist[i].mgau_active);\n    }\n    ckd_free(s->hist);\n    \n    gauden_free(s->g);\n    ckd_free(s);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2010 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/**\n * @file tied_mgau_common.h\n * @brief Common code shared between SC and PTM (tied-state) models.\n */\n\n#ifndef __TIED_MGAU_COMMON_H__\n#define __TIED_MGAU_COMMON_H__\n\n#include <sphinxbase/logmath.h>\n#include <sphinxbase/fixpoint.h>\n\n#define MGAU_MIXW_VERSION\t\"1.0\"   /* Sphinx-3 file format version for mixw */\n#define MGAU_PARAM_VERSION\t\"1.0\"   /* Sphinx-3 file format version for mean/var */\n#define NONE\t\t-1\n#define WORST_DIST\t(int32)(0x80000000)\n\n/** Subtract GMM component b (assumed to be positive) and saturate */\n#ifdef FIXED_POINT\n#define GMMSUB(a,b) \\\n\t(((a)-(b) > a) ? (INT_MIN) : ((a)-(b)))\n/** Add GMM component b (assumed to be positive) and saturate */\n#define GMMADD(a,b) \\\n\t(((a)+(b) < a) ? (INT_MAX) : ((a)+(b)))\n#else\n#define GMMSUB(a,b) ((a)-(b))\n#define GMMADD(a,b) ((a)+(b))\n#endif\n\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#define LOGMATH_INLINE static inline\n#elif defined(_MSC_VER)\n#define LOGMATH_INLINE __inline\n#else\n#define LOGMATH_INLINE static\n#endif\n\n/* Allocate 0..159 for negated quantized mixture weights and 0..96 for\n * negated normalized acoustic scores, so that the combination of the\n * two (for a single mixture) can never exceed 255. */\n#define MAX_NEG_MIXW 159 /**< Maximum negated mixture weight value. */\n#define MAX_NEG_ASCR 96  /**< Maximum negated acoustic score value. */\n\n/**\n * Quickly log-add two negated log probabilities.\n *\n * @param lmath The log-math object\n * @param mlx A negative log probability (0 < mlx < 255)\n * @param mly A negative log probability (0 < mly < 255)\n * @return -log(exp(-mlx)+exp(-mly))\n *\n * We can do some extra-fast log addition since we know that\n * mixw+ascr is always less than 256 and hence x-y is also always less\n * than 256.  This relies on some cooperation from logmath_t which\n * will never produce a logmath table smaller than 256 entries.\n *\n * Note that the parameters are *negated* log probabilities (and\n * hence, are positive numbers), as is the return value.  This is the\n * key to the \"fastness\" of this function.\n */\nLOGMATH_INLINE int\nfast_logmath_add(logmath_t *lmath, int mlx, int mly)\n{\n    logadd_t *t = LOGMATH_TABLE(lmath);\n    int d, r;\n\n    /* d must be positive, obviously. */\n    if (mlx > mly) {\n        d = (mlx - mly);\n        r = mly;\n    }\n    else {\n        d = (mly - mlx);\n        r = mlx;\n    }\n\n    return r - (((uint8 *)t->table)[d]);\n}\n\n#endif /* __TIED_MGAU_COMMON_H__ */\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* System headers */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#if defined(__ADSPBLACKFIN__)\n#elif !defined(_WIN32_WCE)\n#include <sys/types.h>\n#endif\n\n/* SphinxBase headers */\n#include <sphinx_config.h>\n#include <sphinxbase/cmd_ln.h>\n#include <sphinxbase/fixpoint.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/bio.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/prim_type.h>\n\n/* Local headers */\n#include \"s2_semi_mgau.h\"\n#include \"tied_mgau_common.h\"\n\nstatic ps_mgaufuncs_t s2_semi_mgau_funcs = {\n    \"s2_semi\",\n    s2_semi_mgau_frame_eval,      /* frame_eval */\n    s2_semi_mgau_mllr_transform,  /* transform */\n    s2_semi_mgau_free             /* free */\n};\n\nstruct vqFeature_s {\n    int32 score; /* score or distance */\n    int32 codeword; /* codeword (vector index) */\n};\n\nstatic void\neval_topn(s2_semi_mgau_t *s, int32 feat, mfcc_t *z)\n{\n    int i, ceplen;\n    vqFeature_t *topn;\n\n    topn = s->f[feat];\n    ceplen = s->g->featlen[feat];\n\n    for (i = 0; i < s->max_topn; i++) {\n        mfcc_t *mean, diff, sqdiff, compl; /* diff, diff^2, component likelihood */\n        vqFeature_t vtmp;\n        mfcc_t *var, d;\n        mfcc_t *obs;\n        int32 cw, j;\n\n        cw = topn[i].codeword;\n        mean = s->g->mean[0][feat][0] + cw * ceplen;\n        var = s->g->var[0][feat][0] + cw * ceplen;\n        d = s->g->det[0][feat][cw];\n        obs = z;\n        for (j = 0; j < ceplen; j++) {\n            diff = *obs++ - *mean++;\n            sqdiff = MFCCMUL(diff, diff);\n            compl = MFCCMUL(sqdiff, *var);\n            d = GMMSUB(d, compl);\n            ++var;\n        }\n        topn[i].score = (int32)d;\n        if (i == 0)\n            continue;\n        vtmp = topn[i];\n        for (j = i - 1; j >= 0 && (int32)d > topn[j].score; j--) {\n            topn[j + 1] = topn[j];\n        }\n        topn[j + 1] = vtmp;\n    }\n}\n\nstatic void\neval_cb(s2_semi_mgau_t *s, int32 feat, mfcc_t *z)\n{\n    vqFeature_t *worst, *best, *topn;\n    mfcc_t *mean;\n    mfcc_t *var, *det, *detP, *detE;\n    int32 i, ceplen;\n\n    best = topn = s->f[feat];\n    worst = topn + (s->max_topn - 1);\n    mean = s->g->mean[0][feat][0];\n    var = s->g->var[0][feat][0];\n    det = s->g->det[0][feat];\n    detE = det + s->g->n_density;\n    ceplen = s->g->featlen[feat];\n\n    for (detP = det; detP < detE; ++detP) {\n        mfcc_t diff, sqdiff, compl; /* diff, diff^2, component likelihood */\n        mfcc_t d;\n        mfcc_t *obs;\n        vqFeature_t *cur;\n        int32 cw, j;\n\n        d = *detP;\n        obs = z;\n        cw = (int)(detP - det);\n        for (j = 0; (j < ceplen) && (d >= worst->score); ++j) {\n            diff = *obs++ - *mean++;\n            sqdiff = MFCCMUL(diff, diff);\n            compl = MFCCMUL(sqdiff, *var);\n            d = GMMSUB(d, compl);\n            ++var;\n        }\n        if (j < ceplen) {\n            /* terminated early, so not in topn */\n            mean += (ceplen - j);\n            var += (ceplen - j);\n            continue;\n        }\n        if ((int32)d < worst->score)\n            continue;\n        for (i = 0; i < s->max_topn; i++) {\n            /* already there, so don't need to insert */\n            if (topn[i].codeword == cw)\n                break;\n        }\n        if (i < s->max_topn)\n            continue;       /* already there.  Don't insert */\n        /* remaining code inserts codeword and dist in correct spot */\n        for (cur = worst - 1; cur >= best && (int32)d >= cur->score; --cur)\n            memcpy(cur + 1, cur, sizeof(vqFeature_t));\n        ++cur;\n        cur->codeword = cw;\n        cur->score = (int32)d;\n    }\n}\n\nstatic void\nmgau_dist(s2_semi_mgau_t * s, int32 frame, int32 feat, mfcc_t * z)\n{\n    eval_topn(s, feat, z);\n\n    /* If this frame is skipped, do nothing else. */\n    if (frame % s->ds_ratio)\n        return;\n\n    /* Evaluate the rest of the codebook (or subset thereof). */\n    eval_cb(s, feat, z);\n}\n\nstatic int\nmgau_norm(s2_semi_mgau_t *s, int feat)\n{\n    int32 norm;\n    int j;\n\n    /* Compute quantized normalizing constant. */\n    norm = s->f[feat][0].score >> SENSCR_SHIFT;\n\n    /* Normalize the scores, negate them, and clamp their dynamic range. */\n    for (j = 0; j < s->max_topn; ++j) {\n        s->f[feat][j].score = -((s->f[feat][j].score >> SENSCR_SHIFT) - norm);\n        if (s->f[feat][j].score > MAX_NEG_ASCR)\n            s->f[feat][j].score = MAX_NEG_ASCR;\n        if (s->topn_beam[feat] && s->f[feat][j].score > s->topn_beam[feat])\n            break;\n    }\n    return j;\n}\n\nstatic int32\nget_scores_8b_feat_6(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2, *pid_cw3, *pid_cw4, *pid_cw5;\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n    pid_cw3 = s->mixw[i][s->f[i][3].codeword];\n    pid_cw4 = s->mixw[i][s->f[i][4].codeword];\n    pid_cw5 = s->mixw[i][s->f[i][5].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        int32 tmp = pid_cw0[sen] + s->f[i][0].score;\n\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw1[sen] + s->f[i][1].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw2[sen] + s->f[i][2].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw3[sen] + s->f[i][3].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw4[sen] + s->f[i][4].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw5[sen] + s->f[i][5].score);\n\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat_5(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2, *pid_cw3, *pid_cw4;\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n    pid_cw3 = s->mixw[i][s->f[i][3].codeword];\n    pid_cw4 = s->mixw[i][s->f[i][4].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        int32 tmp = pid_cw0[sen] + s->f[i][0].score;\n\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw1[sen] + s->f[i][1].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw2[sen] + s->f[i][2].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw3[sen] + s->f[i][3].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw4[sen] + s->f[i][4].score);\n\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat_4(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2, *pid_cw3;\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n    pid_cw3 = s->mixw[i][s->f[i][3].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        int32 tmp = pid_cw0[sen] + s->f[i][0].score;\n\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw1[sen] + s->f[i][1].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw2[sen] + s->f[i][2].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw3[sen] + s->f[i][3].score);\n\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat_3(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2;\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        int32 tmp = pid_cw0[sen] + s->f[i][0].score;\n\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw1[sen] + s->f[i][1].score);\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw2[sen] + s->f[i][2].score);\n\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat_2(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1;\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        int32 tmp = pid_cw0[sen] + s->f[i][0].score;\n\n        tmp = fast_logmath_add(s->lmath_8b, tmp,\n                               pid_cw1[sen] + s->f[i][1].score);\n\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat_1(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0;\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        int32 tmp = pid_cw0[sen] + s->f[i][0].score;\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat_any(s2_semi_mgau_t * s, int i, int topn,\n                       int16 *senone_scores, uint8 *senone_active,\n                       int32 n_senone_active)\n{\n    int32 j, k, l;\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int sen = senone_active[j] + l;\n        uint8 *pid_cw;\n        int32 tmp;\n        pid_cw = s->mixw[i][s->f[i][0].codeword];\n        tmp = pid_cw[sen] + s->f[i][0].score;\n        for (k = 1; k < topn; ++k) {\n            pid_cw = s->mixw[i][s->f[i][k].codeword];\n            tmp = fast_logmath_add(s->lmath_8b, tmp,\n                                   pid_cw[sen] + s->f[i][k].score);\n        }\n        senone_scores[sen] += tmp;\n        l = sen;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_8b_feat(s2_semi_mgau_t * s, int i, int topn,\n                   int16 *senone_scores, uint8 *senone_active, int32 n_senone_active)\n{\n    switch (topn) {\n    case 6:\n        return get_scores_8b_feat_6(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 5:\n        return get_scores_8b_feat_5(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 4:\n        return get_scores_8b_feat_4(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 3:\n        return get_scores_8b_feat_3(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 2:\n        return get_scores_8b_feat_2(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 1:\n        return get_scores_8b_feat_1(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    default:\n        return get_scores_8b_feat_any(s, i, topn, senone_scores,\n                                      senone_active, n_senone_active);\n    }\n}\n\nstatic int32\nget_scores_8b_feat_all(s2_semi_mgau_t * s, int i, int topn, int16 *senone_scores)\n{\n    int32 j, k;\n\n    for (j = 0; j < s->n_sen; j++) {\n        uint8 *pid_cw;\n        int32 tmp;\n        pid_cw = s->mixw[i][s->f[i][0].codeword];\n        tmp = pid_cw[j] + s->f[i][0].score;\n        for (k = 1; k < topn; ++k) {\n            pid_cw = s->mixw[i][s->f[i][k].codeword];\n            tmp = fast_logmath_add(s->lmath_8b, tmp,\n                                   pid_cw[j] + s->f[i][k].score);\n        }\n        senone_scores[j] += tmp;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_6(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2, *pid_cw3, *pid_cw4, *pid_cw5;\n    uint8 w_den[6][16];\n\n    /* Precompute scaled densities. */\n    for (j = 0; j < 16; ++j) {\n        w_den[0][j] = s->mixw_cb[j] + s->f[i][0].score;\n        w_den[1][j] = s->mixw_cb[j] + s->f[i][1].score;\n        w_den[2][j] = s->mixw_cb[j] + s->f[i][2].score;\n        w_den[3][j] = s->mixw_cb[j] + s->f[i][3].score;\n        w_den[4][j] = s->mixw_cb[j] + s->f[i][4].score;\n        w_den[5][j] = s->mixw_cb[j] + s->f[i][5].score;\n    }\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n    pid_cw3 = s->mixw[i][s->f[i][3].codeword];\n    pid_cw4 = s->mixw[i][s->f[i][4].codeword];\n    pid_cw5 = s->mixw[i][s->f[i][5].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n\n        if (n & 1) {\n            cw = pid_cw0[n/2] >> 4;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n            cw = pid_cw3[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[3][cw]);\n            cw = pid_cw4[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[4][cw]);\n            cw = pid_cw5[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[5][cw]);\n        }\n        else {\n            cw = pid_cw0[n/2] & 0x0f;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n            cw = pid_cw3[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[3][cw]);\n            cw = pid_cw4[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[4][cw]);\n            cw = pid_cw5[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[5][cw]);\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_5(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2, *pid_cw3, *pid_cw4;\n    uint8 w_den[5][16];\n\n    /* Precompute scaled densities. */\n    for (j = 0; j < 16; ++j) {\n        w_den[0][j] = s->mixw_cb[j] + s->f[i][0].score;\n        w_den[1][j] = s->mixw_cb[j] + s->f[i][1].score;\n        w_den[2][j] = s->mixw_cb[j] + s->f[i][2].score;\n        w_den[3][j] = s->mixw_cb[j] + s->f[i][3].score;\n        w_den[4][j] = s->mixw_cb[j] + s->f[i][4].score;\n    }\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n    pid_cw3 = s->mixw[i][s->f[i][3].codeword];\n    pid_cw4 = s->mixw[i][s->f[i][4].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n\n        if (n & 1) {\n            cw = pid_cw0[n/2] >> 4;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n            cw = pid_cw3[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[3][cw]);\n            cw = pid_cw4[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[4][cw]);\n        }\n        else {\n            cw = pid_cw0[n/2] & 0x0f;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n            cw = pid_cw3[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[3][cw]);\n            cw = pid_cw4[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[4][cw]);\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_4(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2, *pid_cw3;\n    uint8 w_den[4][16];\n\n    /* Precompute scaled densities. */\n    for (j = 0; j < 16; ++j) {\n        w_den[0][j] = s->mixw_cb[j] + s->f[i][0].score;\n        w_den[1][j] = s->mixw_cb[j] + s->f[i][1].score;\n        w_den[2][j] = s->mixw_cb[j] + s->f[i][2].score;\n        w_den[3][j] = s->mixw_cb[j] + s->f[i][3].score;\n    }\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n    pid_cw3 = s->mixw[i][s->f[i][3].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n\n        if (n & 1) {\n            cw = pid_cw0[n/2] >> 4;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n            cw = pid_cw3[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[3][cw]);\n        }\n        else {\n            cw = pid_cw0[n/2] & 0x0f;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n            cw = pid_cw3[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[3][cw]);\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_3(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1, *pid_cw2;\n    uint8 w_den[3][16];\n\n    /* Precompute scaled densities. */\n    for (j = 0; j < 16; ++j) {\n        w_den[0][j] = s->mixw_cb[j] + s->f[i][0].score;\n        w_den[1][j] = s->mixw_cb[j] + s->f[i][1].score;\n        w_den[2][j] = s->mixw_cb[j] + s->f[i][2].score;\n    }\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n    pid_cw2 = s->mixw[i][s->f[i][2].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n\n        if (n & 1) {\n            cw = pid_cw0[n/2] >> 4;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n        }\n        else {\n            cw = pid_cw0[n/2] & 0x0f;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n            cw = pid_cw2[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[2][cw]);\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_2(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0, *pid_cw1;\n    uint8 w_den[2][16];\n\n    /* Precompute scaled densities. */\n    for (j = 0; j < 16; ++j) {\n        w_den[0][j] = s->mixw_cb[j] + s->f[i][0].score;\n        w_den[1][j] = s->mixw_cb[j] + s->f[i][1].score;\n    }\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n    pid_cw1 = s->mixw[i][s->f[i][1].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n\n        if (n & 1) {\n            cw = pid_cw0[n/2] >> 4;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] >> 4;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n        }\n        else {\n            cw = pid_cw0[n/2] & 0x0f;\n            tmp = w_den[0][cw];\n            cw = pid_cw1[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp, w_den[1][cw]);\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_1(s2_semi_mgau_t * s, int i,\n                     int16 *senone_scores, uint8 *senone_active,\n                     int32 n_senone_active)\n{\n    int32 j, l;\n    uint8 *pid_cw0;\n    uint8 w_den[16];\n\n    /* Precompute scaled densities. */\n    for (j = 0; j < 16; ++j) {\n        w_den[j] = s->mixw_cb[j] + s->f[i][0].score;\n    }\n\n    pid_cw0 = s->mixw[i][s->f[i][0].codeword];\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n\n        if (n & 1) {\n            cw = pid_cw0[n/2] >> 4;\n            tmp = w_den[cw];\n        }\n        else {\n            cw = pid_cw0[n/2] & 0x0f;\n            tmp = w_den[cw];\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat_any(s2_semi_mgau_t * s, int i, int topn,\n                       int16 *senone_scores, uint8 *senone_active,\n                       int32 n_senone_active)\n{\n    int32 j, k, l;\n\n    for (l = j = 0; j < n_senone_active; j++) {\n        int n = senone_active[j] + l;\n        int tmp, cw;\n        uint8 *pid_cw;\n    \n        pid_cw = s->mixw[i][s->f[i][0].codeword];\n        if (n & 1)\n            cw = pid_cw[n/2] >> 4;\n        else\n            cw = pid_cw[n/2] & 0x0f;\n        tmp = s->mixw_cb[cw] + s->f[i][0].score;\n        for (k = 1; k < topn; ++k) {\n            pid_cw = s->mixw[i][s->f[i][k].codeword];\n            if (n & 1)\n                cw = pid_cw[n/2] >> 4;\n            else\n                cw = pid_cw[n/2] & 0x0f;\n            tmp = fast_logmath_add(s->lmath_8b, tmp,\n                                   s->mixw_cb[cw] + s->f[i][k].score);\n        }\n        senone_scores[n] += tmp;\n        l = n;\n    }\n    return 0;\n}\n\nstatic int32\nget_scores_4b_feat(s2_semi_mgau_t * s, int i, int topn,\n                   int16 *senone_scores, uint8 *senone_active, int32 n_senone_active)\n{\n    switch (topn) {\n    case 6:\n        return get_scores_4b_feat_6(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 5:\n        return get_scores_4b_feat_5(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 4:\n        return get_scores_4b_feat_4(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 3:\n        return get_scores_4b_feat_3(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 2:\n        return get_scores_4b_feat_2(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    case 1:\n        return get_scores_4b_feat_1(s, i, senone_scores,\n                                    senone_active, n_senone_active);\n    default:\n        return get_scores_4b_feat_any(s, i, topn, senone_scores,\n                                      senone_active, n_senone_active);\n    }\n}\n\nstatic int32\nget_scores_4b_feat_all(s2_semi_mgau_t * s, int i, int topn, int16 *senone_scores)\n{\n    int j, last_sen;\n\n    j = 0;\n    /* Number of senones is always even, but don't overrun if it isn't. */\n    last_sen = s->n_sen & ~1;\n    while (j < last_sen) {\n        uint8 *pid_cw;\n        int32 tmp0, tmp1;\n        int k;\n\n        pid_cw = s->mixw[i][s->f[i][0].codeword];\n        tmp0 = s->mixw_cb[pid_cw[j/2] & 0x0f] + s->f[i][0].score;\n        tmp1 = s->mixw_cb[pid_cw[j/2] >> 4] + s->f[i][0].score;\n        for (k = 1; k < topn; ++k) {\n            int32 w_den0, w_den1;\n\n            pid_cw = s->mixw[i][s->f[i][k].codeword];\n            w_den0 = s->mixw_cb[pid_cw[j/2] & 0x0f] + s->f[i][k].score;\n            w_den1 = s->mixw_cb[pid_cw[j/2] >> 4] + s->f[i][k].score;\n            tmp0 = fast_logmath_add(s->lmath_8b, tmp0, w_den0);\n            tmp1 = fast_logmath_add(s->lmath_8b, tmp1, w_den1);\n        }\n        senone_scores[j++] += tmp0;\n        senone_scores[j++] += tmp1;\n    }\n    return 0;\n}\n\n/*\n * Compute senone scores for the active senones.\n */\nint32\ns2_semi_mgau_frame_eval(ps_mgau_t *ps,\n                        int16 *senone_scores,\n                        uint8 *senone_active,\n                        int32 n_senone_active,\n\t\t\tmfcc_t ** featbuf, int32 frame,\n\t\t\tint32 compallsen)\n{\n    s2_semi_mgau_t *s = (s2_semi_mgau_t *)ps;\n    int i, topn_idx;\n    int n_feat = s->g->n_feat;\n\n    memset(senone_scores, 0, s->n_sen * sizeof(*senone_scores));\n    /* No bounds checking is done here, which just means you'll get\n     * semi-random crap if you request a frame in the future or one\n     * that's too far in the past. */\n    topn_idx = frame % s->n_topn_hist;\n    s->f = s->topn_hist[topn_idx];\n    for (i = 0; i < n_feat; ++i) {\n        /* For past frames this will already be computed. */\n        if (frame >= ps_mgau_base(ps)->frame_idx) {\n            vqFeature_t **lastf;\n            if (topn_idx == 0)\n                lastf = s->topn_hist[s->n_topn_hist-1];\n            else\n                lastf = s->topn_hist[topn_idx-1];\n            memcpy(s->f[i], lastf[i], sizeof(vqFeature_t) * s->max_topn);\n            mgau_dist(s, frame, i, featbuf[i]);\n            s->topn_hist_n[topn_idx][i] = mgau_norm(s, i);\n        }\n        if (s->mixw_cb) {\n            if (compallsen)\n                get_scores_4b_feat_all(s, i, s->topn_hist_n[topn_idx][i], senone_scores);\n            else\n                get_scores_4b_feat(s, i, s->topn_hist_n[topn_idx][i], senone_scores,\n                                   senone_active, n_senone_active);\n        }\n        else {\n            if (compallsen)\n                get_scores_8b_feat_all(s, i, s->topn_hist_n[topn_idx][i], senone_scores);\n            else\n                get_scores_8b_feat(s, i, s->topn_hist_n[topn_idx][i], senone_scores,\n                                   senone_active, n_senone_active);\n        }\n    }\n\n    return 0;\n}\n\nstatic int32\nread_sendump(s2_semi_mgau_t *s, bin_mdef_t *mdef, char const *file)\n{\n    FILE *fp;\n    char line[1000];\n    int32 i, n, r, c;\n    int32 do_swap, do_mmap;\n    size_t offset;\n    int n_clust = 0;\n    int n_feat = s->g->n_feat;\n    int n_density = s->g->n_density;\n    int n_sen = bin_mdef_n_sen(mdef);\n    int n_bits = 8;\n\n    s->n_sen = n_sen; /* FIXME: Should have been done earlier */\n    do_mmap = cmd_ln_boolean_r(s->config, \"-mmap\");\n\n    if ((fp = fopen(file, \"rb\")) == NULL)\n        return -1;\n\n    E_INFO(\"Loading senones from dump file %s\\n\", file);\n    /* Read title size, title */\n    if (fread(&n, sizeof(int32), 1, fp) != 1) {\n        E_ERROR_SYSTEM(\"Failed to read title size from %s\", file);\n        goto error_out;\n    }\n    /* This is extremely bogus */\n    do_swap = 0;\n    if (n < 1 || n > 999) {\n        SWAP_INT32(&n);\n        if (n < 1 || n > 999) {\n            E_ERROR(\"Title length %x in dump file %s out of range\\n\", n, file);\n            goto error_out;\n        }\n        do_swap = 1;\n    }\n    if (fread(line, sizeof(char), n, fp) != n) {\n        E_ERROR_SYSTEM(\"Cannot read title\");\n        goto error_out;\n    }\n    if (line[n - 1] != '\\0') {\n        E_ERROR(\"Bad title in dump file\\n\");\n        goto error_out;\n    }\n    E_INFO(\"%s\\n\", line);\n\n    /* Read header size, header */\n    if (fread(&n, sizeof(n), 1, fp) != 1) {\n        E_ERROR_SYSTEM(\"Failed to read header size from %s\", file);\n        goto error_out;\n    }\n    if (do_swap) SWAP_INT32(&n);\n    if (fread(line, sizeof(char), n, fp) != n) {\n        E_ERROR_SYSTEM(\"Cannot read header\");\n        goto error_out;\n    }\n    if (line[n - 1] != '\\0') {\n        E_ERROR(\"Bad header in dump file\\n\");\n        goto error_out;\n    }\n\n    /* Read other header strings until string length = 0 */\n    for (;;) {\n        if (fread(&n, sizeof(n), 1, fp) != 1) {\n            E_ERROR_SYSTEM(\"Failed to read header string size from %s\", file);\n            goto error_out;\n        }\n        if (do_swap) SWAP_INT32(&n);\n        if (n == 0)\n            break;\n        if (fread(line, sizeof(char), n, fp) != n) {\n            E_ERROR_SYSTEM(\"Cannot read header\");\n            goto error_out;\n        }\n        /* Look for a cluster count, if present */\n        if (!strncmp(line, \"feature_count \", strlen(\"feature_count \"))) {\n            n_feat = atoi(line + strlen(\"feature_count \"));\n        }\n        if (!strncmp(line, \"mixture_count \", strlen(\"mixture_count \"))) {\n            n_density = atoi(line + strlen(\"mixture_count \"));\n        }\n        if (!strncmp(line, \"model_count \", strlen(\"model_count \"))) {\n            n_sen = atoi(line + strlen(\"model_count \"));\n        }\n        if (!strncmp(line, \"cluster_count \", strlen(\"cluster_count \"))) {\n            n_clust = atoi(line + strlen(\"cluster_count \"));\n        }\n        if (!strncmp(line, \"cluster_bits \", strlen(\"cluster_bits \"))) {\n            n_bits = atoi(line + strlen(\"cluster_bits \"));\n        }\n    }\n\n    /* Defaults for #rows, #columns in mixw array. */\n    c = n_sen;\n    r = n_density;\n    if (n_clust == 0) {\n        /* Older mixw files have them here, and they might be padded. */\n        if (fread(&r, sizeof(r), 1, fp) != 1) {\n            E_ERROR_SYSTEM(\"Cannot read #rows\");\n            goto error_out;\n        }\n        if (do_swap) SWAP_INT32(&r);\n        if (fread(&c, sizeof(c), 1, fp) != 1) {\n            E_ERROR_SYSTEM(\"Cannot read #columns\");\n            goto error_out;\n        }\n        if (do_swap) SWAP_INT32(&c);\n        E_INFO(\"Rows: %d, Columns: %d\\n\", r, c);\n    }\n\n    if (n_feat != s->g->n_feat) {\n        E_ERROR(\"Number of feature streams mismatch: %d != %d\\n\",\n                n_feat, s->g->n_feat);\n        goto error_out;\n    }\n    if (n_density != s->g->n_density) {\n        E_ERROR(\"Number of densities mismatch: %d != %d\\n\",\n                n_density, s->g->n_density);\n        goto error_out;\n    }\n    if (n_sen != s->n_sen) {\n        E_ERROR(\"Number of senones mismatch: %d != %d\\n\",\n                n_sen, s->n_sen);\n        goto error_out;\n    }\n\n    if (!((n_clust == 0) || (n_clust == 15) || (n_clust == 16))) {\n        E_ERROR(\"Cluster count must be 0, 15, or 16\\n\");\n        goto error_out;\n    }\n    if (n_clust == 15)\n        ++n_clust;\n\n    if (!((n_bits == 8) || (n_bits == 4))) {\n        E_ERROR(\"Cluster count must be 4 or 8\\n\");\n        goto error_out;\n    }\n\n    if (do_mmap) {\n            E_INFO(\"Using memory-mapped I/O for senones\\n\");\n    }\n    offset = ftell(fp);\n\n    /* Allocate memory for pdfs (or memory map them) */\n    if (do_mmap) {\n        s->sendump_mmap = mmio_file_read(file);\n        /* Get cluster codebook if any. */\n        if (n_clust) {\n            s->mixw_cb = ((uint8 *) mmio_file_ptr(s->sendump_mmap)) + offset;\n            offset += n_clust;\n        }\n    }\n    else {\n        /* Get cluster codebook if any. */\n        if (n_clust) {\n            s->mixw_cb = ckd_calloc(1, n_clust);\n            if (fread(s->mixw_cb, 1, n_clust, fp) != (size_t) n_clust) {\n                E_ERROR(\"Failed to read %d bytes from sendump\\n\", n_clust);\n                goto error_out;\n            }\n        }\n    }\n\n    /* Set up pointers, or read, or whatever */\n    if (s->sendump_mmap) {\n        s->mixw = ckd_calloc_2d(n_feat, n_density, sizeof(*s->mixw));\n        for (n = 0; n < n_feat; n++) {\n            int step = c;\n            if (n_bits == 4)\n                step = (step + 1) / 2;\n            for (i = 0; i < r; i++) {\n                s->mixw[n][i] = ((uint8 *) mmio_file_ptr(s->sendump_mmap)) + offset;\n                offset += step;\n            }\n        }\n    }\n    else {\n        s->mixw = ckd_calloc_3d(n_feat, n_density, n_sen, sizeof(***s->mixw));\n        /* Read pdf values and ids */\n        for (n = 0; n < n_feat; n++) {\n            int step = c;\n            if (n_bits == 4)\n                step = (step + 1) / 2;\n            for (i = 0; i < r; i++) {\n                if (fread(s->mixw[n][i], sizeof(***s->mixw), step, fp)\n                    != (size_t) step) {\n                    E_ERROR(\"Failed to read %d bytes from sendump\\n\", step);\n                    goto error_out;\n                }\n            }\n        }\n    }\n\n    fclose(fp);\n    return 0;\nerror_out:\n    fclose(fp);\n    return -1;\n}\n\nstatic int32\nread_mixw(s2_semi_mgau_t * s, char const *file_name, double SmoothMin)\n{\n    char **argname, **argval;\n    char eofchk;\n    FILE *fp;\n    int32 byteswap, chksum_present;\n    uint32 chksum;\n    float32 *pdf;\n    int32 i, f, c, n;\n    int32 n_sen;\n    int32 n_feat;\n    int32 n_comp;\n    int32 n_err;\n\n    E_INFO(\"Reading mixture weights file '%s'\\n\", file_name);\n\n    if ((fp = fopen(file_name, \"rb\")) == NULL)\n        E_FATAL_SYSTEM(\"Failed to open mixture weights file '%s' for reading\", file_name);\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0)\n        E_FATAL(\"Failed to read header from file '%s'\\n\", file_name);\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], MGAU_MIXW_VERSION) != 0)\n                E_WARN(\"Version mismatch(%s): %s, expecting %s\\n\",\n                       file_name, argval[i], MGAU_MIXW_VERSION);\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            chksum_present = 1; /* Ignore the associated value */\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    /* Read #senones, #features, #codewords, arraysize */\n    if ((bio_fread(&n_sen, sizeof(int32), 1, fp, byteswap, &chksum) != 1)\n        || (bio_fread(&n_feat, sizeof(int32), 1, fp, byteswap, &chksum) !=\n            1)\n        || (bio_fread(&n_comp, sizeof(int32), 1, fp, byteswap, &chksum) !=\n            1)\n        || (bio_fread(&n, sizeof(int32), 1, fp, byteswap, &chksum) != 1)) {\n        E_FATAL(\"bio_fread(%s) (arraysize) failed\\n\", file_name);\n    }\n    if (n_feat != s->g->n_feat)\n        E_FATAL(\"#Features streams(%d) != %d\\n\", n_feat, s->g->n_feat);\n    if (n != n_sen * n_feat * n_comp) {\n        E_FATAL\n            (\"%s: #float32s(%d) doesn't match header dimensions: %d x %d x %d\\n\",\n             file_name, i, n_sen, n_feat, n_comp);\n    }\n\n    /* n_sen = number of mixture weights per codeword, which is\n     * fixed at the number of senones since we have only one codebook.\n     */\n    s->n_sen = n_sen;\n\n    /* Quantized mixture weight arrays. */\n    s->mixw = ckd_calloc_3d(n_feat, s->g->n_density, n_sen, sizeof(***s->mixw));\n\n    /* Temporary structure to read in floats before conversion to (int32) logs3 */\n    pdf = (float32 *) ckd_calloc(n_comp, sizeof(float32));\n\n    /* Read senone probs data, normalize, floor, convert to logs3, truncate to 8 bits */\n    n_err = 0;\n    for (i = 0; i < n_sen; i++) {\n        for (f = 0; f < n_feat; f++) {\n            if (bio_fread((void *) pdf, sizeof(float32),\n                          n_comp, fp, byteswap, &chksum) != n_comp) {\n                E_FATAL(\"bio_fread(%s) (arraydata) failed\\n\", file_name);\n            }\n\n            /* Normalize and floor */\n            if (vector_sum_norm(pdf, n_comp) <= 0.0)\n                n_err++;\n            vector_floor(pdf, n_comp, SmoothMin);\n            vector_sum_norm(pdf, n_comp);\n\n            /* Convert to LOG, quantize, and transpose */\n            for (c = 0; c < n_comp; c++) {\n                int32 qscr;\n\n                qscr = -logmath_log(s->lmath_8b, pdf[c]);\n                if ((qscr > MAX_NEG_MIXW) || (qscr < 0))\n                    qscr = MAX_NEG_MIXW;\n                s->mixw[f][c][i] = qscr;\n            }\n        }\n    }\n    if (n_err > 0)\n        E_WARN(\"Weight normalization failed for %d mixture weights components\\n\", n_err);\n\n    ckd_free(pdf);\n\n    if (chksum_present)\n        bio_verify_chksum(fp, byteswap, chksum);\n\n    if (fread(&eofchk, 1, 1, fp) == 1)\n        E_FATAL(\"More data than expected in %s\\n\", file_name);\n\n    fclose(fp);\n\n    E_INFO(\"Read %d x %d x %d mixture weights\\n\", n_sen, n_feat, n_comp);\n    return n_sen;\n}\n\n\nstatic int\nsplit_topn(char const *str, uint8 *out, int nfeat)\n{\n    char *topn_list = ckd_salloc(str);\n    char *c, *cc;\n    int i, maxn;\n\n    c = topn_list;\n    i = 0;\n    maxn = 0;\n    while (i < nfeat && (cc = strchr(c, ',')) != NULL) {\n        *cc = '\\0';\n        out[i] = atoi(c);\n        if (out[i] > maxn) maxn = out[i];\n        c = cc + 1;\n        ++i;\n    }\n    if (i < nfeat && *c != '\\0') {\n        out[i] = atoi(c);\n        if (out[i] > maxn) maxn = out[i];\n        ++i;\n    }\n    while (i < nfeat)\n        out[i++] = maxn;\n\n    ckd_free(topn_list);\n    return maxn;\n}\n\n\nps_mgau_t *\ns2_semi_mgau_init(acmod_t *acmod)\n{\n    s2_semi_mgau_t *s;\n    ps_mgau_t *ps;\n    char const *sendump_path;\n    int i;\n    int n_feat;\n\n    s = ckd_calloc(1, sizeof(*s));\n    s->config = acmod->config;\n\n    s->lmath = logmath_retain(acmod->lmath);\n    /* Log-add table. */\n    s->lmath_8b = logmath_init(logmath_get_base(acmod->lmath), SENSCR_SHIFT, TRUE);\n    if (s->lmath_8b == NULL)\n        goto error_out;\n    /* Ensure that it is only 8 bits wide so that fast_logmath_add() works. */\n    if (logmath_get_width(s->lmath_8b) != 1) {\n        E_ERROR(\"Log base %f is too small to represent add table in 8 bits\\n\",\n                logmath_get_base(s->lmath_8b));\n        goto error_out;\n    }\n\n    /* Read means and variances. */\n    if ((s->g = gauden_init(cmd_ln_str_r(s->config, \"_mean\"),\n                            cmd_ln_str_r(s->config, \"_var\"),\n                            cmd_ln_float32_r(s->config, \"-varfloor\"),\n                            s->lmath)) == NULL) {\n        E_ERROR(\"Failed to read means and variances\\n\");\t\n        goto error_out;\n    }\n\n    /* Currently only a single codebook is supported. */\n    if (s->g->n_mgau != 1)\n        goto error_out;\n\n    n_feat = s->g->n_feat;\n\n    /* Verify n_feat and veclen, against acmod. */\n    if (n_feat != feat_dimension1(acmod->fcb)) {\n        E_ERROR(\"Number of streams does not match: %d != %d\\n\",\n                n_feat, feat_dimension1(acmod->fcb));\n        goto error_out;\n    }\n    for (i = 0; i < n_feat; ++i) {\n        if (s->g->featlen[i] != feat_dimension2(acmod->fcb, i)) {\n            E_ERROR(\"Dimension of stream %d does not match: %d != %d\\n\",\n                    i, s->g->featlen[i], feat_dimension2(acmod->fcb, i));\n            goto error_out;\n        }\n    }\n    /* Read mixture weights */\n    if ((sendump_path = cmd_ln_str_r(s->config, \"_sendump\"))) {\n        if (read_sendump(s, acmod->mdef, sendump_path) < 0) {\n            goto error_out;\n        }\n    }\n    else {\n        if (read_mixw(s, cmd_ln_str_r(s->config, \"_mixw\"),\n                      cmd_ln_float32_r(s->config, \"-mixwfloor\")) < 0) {\n            goto error_out;\n        }\n    }\n    s->ds_ratio = cmd_ln_int32_r(s->config, \"-ds\");\n\n    /* Determine top-N for each feature */\n    s->topn_beam = ckd_calloc(n_feat, sizeof(*s->topn_beam));\n    s->max_topn = cmd_ln_int32_r(s->config, \"-topn\");\n    split_topn(cmd_ln_str_r(s->config, \"-topn_beam\"), s->topn_beam, n_feat);\n    E_INFO(\"Maximum top-N: %d \", s->max_topn);\n    E_INFOCONT(\"Top-N beams:\");\n    for (i = 0; i < n_feat; ++i) {\n        E_INFOCONT(\" %d\", s->topn_beam[i]);\n    }\n    E_INFOCONT(\"\\n\");\n\n    /* Top-N scores from recent frames */\n    s->n_topn_hist = cmd_ln_int32_r(s->config, \"-pl_window\") + 2;\n    s->topn_hist = (vqFeature_t ***)\n        ckd_calloc_3d(s->n_topn_hist, n_feat, s->max_topn,\n                      sizeof(***s->topn_hist));\n    s->topn_hist_n = ckd_calloc_2d(s->n_topn_hist, n_feat,\n                                   sizeof(**s->topn_hist_n));\n    for (i = 0; i < s->n_topn_hist; ++i) {\n        int j;\n        for (j = 0; j < n_feat; ++j) {\n            int k;\n            for (k = 0; k < s->max_topn; ++k) {\n                s->topn_hist[i][j][k].score = WORST_DIST;\n                s->topn_hist[i][j][k].codeword = k;\n            }\n        }\n    }\n\n    ps = (ps_mgau_t *)s;\n    ps->vt = &s2_semi_mgau_funcs;\n    return ps;\nerror_out:\n    s2_semi_mgau_free(ps_mgau_base(s));\n    return NULL;\n}\n\nint\ns2_semi_mgau_mllr_transform(ps_mgau_t *ps,\n                            ps_mllr_t *mllr)\n{\n    s2_semi_mgau_t *s = (s2_semi_mgau_t *)ps;\n    return gauden_mllr_transform(s->g, mllr, s->config);\n}\n\nvoid\ns2_semi_mgau_free(ps_mgau_t *ps)\n{\n    s2_semi_mgau_t *s = (s2_semi_mgau_t *)ps;\n\n    logmath_free(s->lmath);\n    logmath_free(s->lmath_8b);\n    if (s->sendump_mmap) {\n        ckd_free_2d(s->mixw); \n        mmio_file_unmap(s->sendump_mmap);\n    }\n    else {\n        ckd_free_3d(s->mixw);\n        if (s->mixw_cb)\n            ckd_free(s->mixw_cb);\n    }\n    gauden_free(s->g);\n    ckd_free(s->topn_beam);\n    ckd_free_2d(s->topn_hist_n);\n    ckd_free_3d((void **)s->topn_hist);\n    ckd_free(s);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* System headers. */\n#include <string.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/logmath.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/bio.h>\n\n/* Local headers. */\n#include \"tmat.h\"\n#include \"hmm.h\"\n#include \"vector.h\"\n\n#define TMAT_PARAM_VERSION\t\t\"1.0\"\n\n\n/**\n * Checks that no transition matrix in the given object contains backward arcs.\n * @returns 0 if successful, -1 if check failed.\n */\nstatic int32 tmat_chk_uppertri(tmat_t *tmat, logmath_t *lmath);\n\n\n/**\n * Checks that transition matrix arcs in the given object skip over\n * at most 1 state.  \n * @returns 0 if successful, -1 if check failed.  \n */\n\nstatic int32 tmat_chk_1skip(tmat_t *tmat, logmath_t *lmath);\n\n\nvoid\ntmat_dump(tmat_t * tmat, FILE * fp)\n{\n    int32 i, src, dst;\n\n    for (i = 0; i < tmat->n_tmat; i++) {\n        fprintf(fp, \"TMAT %d = %d x %d\\n\", i, tmat->n_state,\n                tmat->n_state + 1);\n        for (src = 0; src < tmat->n_state; src++) {\n            for (dst = 0; dst <= tmat->n_state; dst++)\n                fprintf(fp, \" %12d\", tmat->tp[i][src][dst]);\n            fprintf(fp, \"\\n\");\n        }\n        fprintf(fp, \"\\n\");\n    }\n    fflush(fp);\n}\n\n\n/*\n * Check model tprob matrices that they conform to upper-triangular assumption;\n * i.e. no \"backward\" transitions allowed.\n */\nint32\ntmat_chk_uppertri(tmat_t * tmat, logmath_t *lmath)\n{\n    int32 i, src, dst;\n\n    /* Check that each tmat is upper-triangular */\n    for (i = 0; i < tmat->n_tmat; i++) {\n        for (dst = 0; dst < tmat->n_state; dst++)\n            for (src = dst + 1; src < tmat->n_state; src++)\n                if (tmat->tp[i][src][dst] < 255) {\n                    E_ERROR(\"tmat[%d][%d][%d] = %d\\n\",\n                            i, src, dst, tmat->tp[i][src][dst]);\n                    return -1;\n                }\n    }\n\n    return 0;\n}\n\n\nint32\ntmat_chk_1skip(tmat_t * tmat, logmath_t *lmath)\n{\n    int32 i, src, dst;\n\n    for (i = 0; i < tmat->n_tmat; i++) {\n        for (src = 0; src < tmat->n_state; src++)\n            for (dst = src + 3; dst <= tmat->n_state; dst++)\n                if (tmat->tp[i][src][dst] < 255) {\n                    E_ERROR(\"tmat[%d][%d][%d] = %d\\n\",\n                            i, src, dst, tmat->tp[i][src][dst]);\n                    return -1;\n                }\n    }\n\n    return 0;\n}\n\n\ntmat_t *\ntmat_init(char const *file_name, logmath_t *lmath, float64 tpfloor, int32 breport)\n{\n    char tmp;\n    int32 n_src, n_dst, n_tmat;\n    FILE *fp;\n    int32 byteswap, chksum_present;\n    uint32 chksum;\n    float32 **tp;\n    int32 i, j, k, tp_per_tmat;\n    char **argname, **argval;\n    tmat_t *t;\n\n\n    if (breport) {\n        E_INFO(\"Reading HMM transition probability matrices: %s\\n\",\n               file_name);\n    }\n\n    t = (tmat_t *) ckd_calloc(1, sizeof(tmat_t));\n\n    if ((fp = fopen(file_name, \"rb\")) == NULL)\n        E_FATAL_SYSTEM(\"Failed to open transition file '%s' for reading\", file_name);\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0)\n        E_FATAL(\"Failed to read header from file '%s'\\n\", file_name);\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], TMAT_PARAM_VERSION) != 0)\n                E_WARN(\"Version mismatch(%s): %s, expecting %s\\n\",\n                       file_name, argval[i], TMAT_PARAM_VERSION);\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            chksum_present = 1; /* Ignore the associated value */\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    /* Read #tmat, #from-states, #to-states, arraysize */\n    if ((bio_fread(&n_tmat, sizeof(int32), 1, fp, byteswap, &chksum)\n         != 1)\n        || (bio_fread(&n_src, sizeof(int32), 1, fp, byteswap, &chksum) !=\n            1)\n        || (bio_fread(&n_dst, sizeof(int32), 1, fp, byteswap, &chksum) !=\n            1)\n        || (bio_fread(&i, sizeof(int32), 1, fp, byteswap, &chksum) != 1)) {\n        E_FATAL(\"Failed to read header from '%s'\\n\", file_name);\n    }\n    if (n_tmat >= MAX_INT16)\n        E_FATAL(\"%s: Number of transition matrices (%d) exceeds limit (%d)\\n\", file_name,\n                n_tmat, MAX_INT16);\n    t->n_tmat = n_tmat;\n    \n    if (n_dst != n_src + 1)\n        E_FATAL(\"%s: Unsupported transition matrix. Number of source states (%d) != number of target states (%d)-1\\n\", file_name,\n                n_src, n_dst);\n    t->n_state = n_src;\n\n    if (i != t->n_tmat * n_src * n_dst) {\n        E_FATAL\n            (\"%s: Invalid transitions. Number of coefficients (%d) doesn't match expected array dimension: %d x %d x %d\\n\",\n             file_name, i, t->n_tmat, n_src, n_dst);\n    }\n\n    /* Allocate memory for tmat data */\n    t->tp = ckd_calloc_3d(t->n_tmat, n_src, n_dst, sizeof(***t->tp));\n\n    /* Temporary structure to read in the float data */\n    tp = ckd_calloc_2d(n_src, n_dst, sizeof(**tp));\n\n    /* Read transition matrices, normalize and floor them, and convert to log domain */\n    tp_per_tmat = n_src * n_dst;\n    for (i = 0; i < t->n_tmat; i++) {\n        if (bio_fread(tp[0], sizeof(float32), tp_per_tmat, fp,\n                      byteswap, &chksum) != tp_per_tmat) {\n            E_FATAL(\"Failed to read transition matrix %d from '%s'\\n\", i, file_name);\n        }\n\n        /* Normalize and floor */\n        for (j = 0; j < n_src; j++) {\n            if (vector_sum_norm(tp[j], n_dst) == 0.0)\n                E_WARN(\"Normalization failed for transition matrix %d from state %d\\n\",\n                       i, j);\n            vector_nz_floor(tp[j], n_dst, tpfloor);\n            vector_sum_norm(tp[j], n_dst);\n\n            /* Convert to logs3. */\n            for (k = 0; k < n_dst; k++) {\n                int ltp;\n#if 0 /* No, don't do this!  It will subtly break 3-state HMMs. */\n                /* For these ones, we floor them even if they are\n                 * zero, otherwise HMM evaluation goes nuts. */\n                if (k >= j && k-j < 3 && tp[j][k] == 0.0f)\n                    tp[j][k] = tpfloor;\n#endif\n                /* Log and quantize them. */\n                ltp = -logmath_log(lmath, tp[j][k]) >> SENSCR_SHIFT;\n                if (ltp > 255) ltp = 255;\n                t->tp[i][j][k] = (uint8)ltp;\n            }\n        }\n    }\n\n    ckd_free_2d(tp);\n\n    if (chksum_present)\n        bio_verify_chksum(fp, byteswap, chksum);\n\n    if (fread(&tmp, 1, 1, fp) == 1)\n        E_ERROR(\"Non-empty file beyond end of data\\n\");\n\n    fclose(fp);\n\n    if (tmat_chk_uppertri(t, lmath) < 0)\n        E_FATAL(\"Tmat not upper triangular\\n\");\n    if (tmat_chk_1skip(t, lmath) < 0)\n        E_FATAL(\"Topology not Left-to-Right or Bakis\\n\");\n\n    return t;\n}\n\nvoid\ntmat_report(tmat_t * t)\n{\n    E_INFO_NOFN(\"Initialization of tmat_t, report:\\n\");\n    E_INFO_NOFN(\"Read %d transition matrices of size %dx%d\\n\",\n                t->n_tmat, t->n_state, t->n_state + 1);\n    E_INFO_NOFN(\"\\n\");\n\n}\n\n/* \n *  RAH, Free memory allocated in tmat_init ()\n */\nvoid\ntmat_free(tmat_t * t)\n{\n    if (t) {\n        if (t->tp)\n            ckd_free_3d(t->tp);\n        ckd_free(t);\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n * vector.c\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1997 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * \n * 22-Nov-2004\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tImported from s3.2, for supporting s3 format continuous\n * \t\tacoustic models.\n * \n * 10-Mar-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tAdded vector_accum(), vector_vqlabel(), and vector_vqgen().\n * \n * 09-Mar-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tAdded vector_is_zero(), vector_cmp(), and vector_dist_eucl().\n * \t\tChanged the name vector_dist_eval to vector_dist_maha.\n * \n * 07-Oct-98\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tAdded distance computation related functions.\n * \n * 12-Nov-95\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University.\n * \t\tCopied from Eric Thayer.\n */\n\n/* System headers. */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <math.h>\n\n/* SphinxBase headers. */\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/bitvec.h>\n\n/* Local headers. */\n#include \"vector.h\"\n\n#if defined(_WIN32)\n#define srandom\tsrand\n#define random\trand\n#endif\n\n\nfloat64\nvector_sum_norm(float32 * vec, int32 len)\n{\n    float64 sum, f;\n    int32 i;\n\n    sum = 0.0;\n    for (i = 0; i < len; i++)\n        sum += vec[i];\n\n    if (sum != 0.0) {\n        f = 1.0 / sum;\n        for (i = 0; i < len; i++)\n            vec[i] *= f;\n    }\n\n    return sum;\n}\n\n\nvoid\nvector_floor(float32 * vec, int32 len, float64 flr)\n{\n    int32 i;\n\n    for (i = 0; i < len; i++)\n        if (vec[i] < flr)\n            vec[i] = (float32) flr;\n}\n\n\nvoid\nvector_nz_floor(float32 * vec, int32 len, float64 flr)\n{\n    int32 i;\n\n    for (i = 0; i < len; i++)\n        if ((vec[i] != 0.0) && (vec[i] < flr))\n            vec[i] = (float32) flr;\n}\n\n\nvoid\nvector_print(FILE * fp, vector_t v, int32 dim)\n{\n    int32 i;\n\n    for (i = 0; i < dim; i++)\n        fprintf(fp, \" %11.4e\", v[i]);\n    fprintf(fp, \"\\n\");\n    fflush(fp);\n}\n\n\nint32\nvector_is_zero(float32 * vec, int32 len)\n{\n    int32 i;\n\n    for (i = 0; (i < len) && (vec[i] == 0.0); i++);\n    return (i == len);          /* TRUE iff all mean values are 0.0 */\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2013 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n* kws_search.c -- Search object for key phrase spotting.\n*/\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/pio.h>\n#include <sphinxbase/cmd_ln.h>\n\n#include \"pocketsphinx_internal.h\"\n#include \"kws_search.h\"\n\n/** Access macros */\n#define hmm_is_active(hmm) ((hmm)->frame > 0)\n#define kws_nth_hmm(keyphrase,n) (&((keyphrase)->hmms[n]))\n\n/* Value selected experimentally as maximum difference between triphone\nscore and phone loop score, used in confidence computation to make sure\nthat confidence value is less than 1. This might be different for\ndifferent models. Corresponds to threshold of about 1e+50 */ \n#define KWS_MAX 1500\n\nstatic ps_lattice_t *\nkws_search_lattice(ps_search_t * search)\n{\n    return NULL;\n}\n\nstatic int\nkws_search_prob(ps_search_t * search)\n{\n    return 0;\n}\n\nstatic void\nkws_seg_free(ps_seg_t *seg)\n{\n    kws_seg_t *itor = (kws_seg_t *)seg;\n    ckd_free(itor);\n}\n\nstatic void\nkws_seg_fill(kws_seg_t *itor)\n{\n    kws_detection_t* detection = (kws_detection_t*)gnode_ptr(itor->detection);\n\n    itor->base.word = detection->keyphrase;\n    itor->base.sf = detection->sf;\n    itor->base.ef = detection->ef;\n    itor->base.prob = detection->prob;\n    itor->base.ascr = detection->ascr;\n    itor->base.lscr = 0;\n}\n\nstatic ps_seg_t *\nkws_seg_next(ps_seg_t *seg)\n{\n    kws_seg_t *itor = (kws_seg_t *)seg;\n\n    gnode_t *detect_head = gnode_next(itor->detection);\n    while (detect_head != NULL && ((kws_detection_t*)gnode_ptr(detect_head))->ef > itor->last_frame)\n         detect_head = gnode_next(detect_head);\n    itor->detection = detect_head;\n\n    if (!itor->detection) {\n        kws_seg_free(seg);\n        return NULL;\n    }\n\n    kws_seg_fill(itor);\n\n    return seg;\n}\n\nstatic ps_segfuncs_t kws_segfuncs = {\n    /* seg_next */ kws_seg_next,\n    /* seg_free */ kws_seg_free\n};\n\nstatic ps_seg_t *\nkws_search_seg_iter(ps_search_t * search)\n{\n    kws_search_t *kwss = (kws_search_t *)search;\n    kws_seg_t *itor;\n    gnode_t *detect_head = kwss->detections->detect_list;\n    \n    while (detect_head != NULL && ((kws_detection_t*)gnode_ptr(detect_head))->ef > kwss->frame - kwss->delay)\n\tdetect_head = gnode_next(detect_head);\n    \n    if (!detect_head)\n        return NULL;\n\n    itor = (kws_seg_t *)ckd_calloc(1, sizeof(*itor));\n    itor->base.vt = &kws_segfuncs;\n    itor->base.search = search;\n    itor->base.lwf = 1.0;\n    itor->detection = detect_head;\n    itor->last_frame = kwss->frame - kwss->delay;\n    kws_seg_fill(itor);\n    return (ps_seg_t *)itor;\n}\n\nstatic ps_searchfuncs_t kws_funcs = {\n    /* start: */ kws_search_start,\n    /* step: */ kws_search_step,\n    /* finish: */ kws_search_finish,\n    /* reinit: */ kws_search_reinit,\n    /* free: */ kws_search_free,\n    /* lattice: */ kws_search_lattice,\n    /* hyp: */ kws_search_hyp,\n    /* prob: */ kws_search_prob,\n    /* seg_iter: */ kws_search_seg_iter,\n};\n\n\n/* Activate senones for scoring */\nstatic void\nkws_search_sen_active(kws_search_t * kwss)\n{\n    int i;\n    gnode_t *gn;\n\n    acmod_clear_active(ps_search_acmod(kwss));\n\n    /* active phone loop hmms */\n    for (i = 0; i < kwss->n_pl; i++)\n        acmod_activate_hmm(ps_search_acmod(kwss), &kwss->pl_hmms[i]);\n\n    /* activate hmms in active nodes */\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        kws_keyphrase_t *keyphrase = gnode_ptr(gn);\n        for (i = 0; i < keyphrase->n_hmms; i++) {\n            if (hmm_is_active(kws_nth_hmm(keyphrase, i)))\n                acmod_activate_hmm(ps_search_acmod(kwss), kws_nth_hmm(keyphrase, i));\n        }\n    }\n}\n\n/*\n* Evaluate all the active HMMs.\n* (Executed once per frame.)\n*/\nstatic void\nkws_search_hmm_eval(kws_search_t * kwss, int16 const *senscr)\n{\n    int32 i;\n    gnode_t *gn;\n    int32 bestscore = WORST_SCORE;\n\n    hmm_context_set_senscore(kwss->hmmctx, senscr);\n\n    /* evaluate hmms from phone loop */\n    for (i = 0; i < kwss->n_pl; ++i) {\n        hmm_t *hmm = &kwss->pl_hmms[i];\n        int32 score;\n\n        score = hmm_vit_eval(hmm);\n        if (score BETTER_THAN bestscore)\n            bestscore = score;\n    }\n    /* evaluate hmms for active nodes */\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        kws_keyphrase_t *keyphrase = gnode_ptr(gn);\n        for (i = 0; i < keyphrase->n_hmms; i++) {\n            hmm_t *hmm = kws_nth_hmm(keyphrase, i);\n\n            if (hmm_is_active(hmm)) {\n                int32 score;\n                score = hmm_vit_eval(hmm);\n                if (score BETTER_THAN bestscore)\n                    bestscore = score;\n            }\n        }\n    }\n\n    kwss->bestscore = bestscore;\n}\n\n/*\n* (Beam) prune the just evaluated HMMs, determine which ones remain\n* active. Executed once per frame.\n*/\nstatic void\nkws_search_hmm_prune(kws_search_t * kwss)\n{\n    int32 thresh, i;\n    gnode_t *gn;\n\n    thresh = kwss->bestscore + kwss->beam;\n\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        kws_keyphrase_t *keyphrase = gnode_ptr(gn);\n        for (i = 0; i < keyphrase->n_hmms; i++) {\n    \t    hmm_t *hmm = kws_nth_hmm(keyphrase, i);\n            if (hmm_is_active(hmm) && hmm_bestscore(hmm) < thresh)\n                hmm_clear(hmm);\n        }\n    }\n}\n\n\n/**\n* Do phone transitions\n*/\nstatic void\nkws_search_trans(kws_search_t * kwss)\n{\n    hmm_t *pl_best_hmm = NULL;\n    int32 best_out_score = WORST_SCORE;\n    int i;\n    gnode_t *gn;\n\n    /* select best hmm in phone-loop to be a predecessor */\n    for (i = 0; i < kwss->n_pl; i++)\n        if (hmm_out_score(&kwss->pl_hmms[i]) BETTER_THAN best_out_score) {\n            best_out_score = hmm_out_score(&kwss->pl_hmms[i]);\n            pl_best_hmm = &kwss->pl_hmms[i];\n        }\n\n    /* out probs are not ready yet */\n    if (!pl_best_hmm)\n        return;\n\n    /* Check whether keyphrase wasn't spotted yet */\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        kws_keyphrase_t *keyphrase = gnode_ptr(gn);\n        hmm_t *last_hmm;\n        \n        if (keyphrase->n_hmms < 1)\n    \t    continue;\n        \n        last_hmm = kws_nth_hmm(keyphrase, keyphrase->n_hmms - 1);\n\n        if (hmm_is_active(last_hmm)\n            && hmm_out_score(pl_best_hmm) BETTER_THAN WORST_SCORE) {\n\n            if (hmm_out_score(last_hmm) - hmm_out_score(pl_best_hmm) \n                >= keyphrase->threshold) {\n\n                int32 prob = hmm_out_score(last_hmm) - hmm_out_score(pl_best_hmm) - KWS_MAX;\n                kws_detections_add(kwss->detections, keyphrase->word,\n                                  hmm_out_history(last_hmm),\n                                  kwss->frame, prob,\n                                  hmm_out_score(last_hmm));\n            } /* keyphrase is spotted */\n        } /* last hmm of keyphrase is active */\n    } /* keyphrase loop */\n\n    /* Make transition for all phone loop hmms */\n    for (i = 0; i < kwss->n_pl; i++) {\n        if (hmm_out_score(pl_best_hmm) + kwss->plp BETTER_THAN\n            hmm_in_score(&kwss->pl_hmms[i])) {\n            hmm_enter(&kwss->pl_hmms[i],\n                      hmm_out_score(pl_best_hmm) + kwss->plp,\n                      hmm_out_history(pl_best_hmm), kwss->frame + 1);\n        }\n    }\n\n    /* Activate new keyphrase nodes, enter their hmms */\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        kws_keyphrase_t *keyphrase = gnode_ptr(gn);\n        \n        if (keyphrase->n_hmms < 1)\n    \t    continue;\n        \n        for (i = keyphrase->n_hmms - 1; i > 0; i--) {\n            hmm_t *pred_hmm = kws_nth_hmm(keyphrase, i - 1);\n            hmm_t *hmm = kws_nth_hmm(keyphrase, i);\n\n            if (hmm_is_active(pred_hmm)) {    \n                if (!hmm_is_active(hmm)\n                    || hmm_out_score(pred_hmm) BETTER_THAN\n                    hmm_in_score(hmm))\n                        hmm_enter(hmm, hmm_out_score(pred_hmm),\n                                  hmm_out_history(pred_hmm), kwss->frame + 1);\n            }\n        }\n\n        /* Enter keyphrase start node from phone loop */\n        if (hmm_out_score(pl_best_hmm) BETTER_THAN\n            hmm_in_score(kws_nth_hmm(keyphrase, 0)))\n                hmm_enter(kws_nth_hmm(keyphrase, 0), hmm_out_score(pl_best_hmm),\n                    kwss->frame, kwss->frame + 1);\n    }\n}\n\nstatic int\nkws_search_read_list(kws_search_t *kwss, const char* keyfile)\n{\n    FILE *list_file;\n    lineiter_t *li;\n    char *line;\n    \n    if ((list_file = fopen(keyfile, \"r\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open keyphrase file '%s'\", keyfile);\n        return -1;\n    }\n\n    kwss->keyphrases = NULL;\n\n    /* read keyphrases */\n    for (li = lineiter_start_clean(list_file); li; li = lineiter_next(li)) {\n        size_t begin, end;\n        kws_keyphrase_t *keyphrase;\n\t\n\tif (li->len == 0)\n\t    continue;\n\n\tkeyphrase = ckd_calloc(1, sizeof(kws_keyphrase_t));\n\n        line = li->buf;\n        end = strlen(line) - 1;\n\tbegin = end - 1;\n        if (line[end] == '/') {\n            while (line[begin] != '/' && begin > 0)\n                begin--;\n            line[end] = 0;\n            line[begin] = 0;\n            keyphrase->threshold = (int32) logmath_log(kwss->base.acmod->lmath, atof_c(line + begin + 1)) \n                                          >> SENSCR_SHIFT;\n        } else {\n            keyphrase->threshold = kwss->def_threshold;\n        }\n\n        keyphrase->word = ckd_salloc(line);\n\n        kwss->keyphrases = glist_add_ptr(kwss->keyphrases, keyphrase);\n    }\n\n    fclose(list_file);\n    return 0;\n}\n\nps_search_t *\nkws_search_init(const char *name,\n                const char *keyphrase,\n                const char *keyfile,\n                cmd_ln_t * config,\n                acmod_t * acmod, dict_t * dict, dict2pid_t * d2p)\n{\n    kws_search_t *kwss = (kws_search_t *) ckd_calloc(1, sizeof(*kwss));\n    ps_search_init(ps_search_base(kwss), &kws_funcs, PS_SEARCH_TYPE_KWS, name, config, acmod, dict,\n                   d2p);\n\n    kwss->detections = (kws_detections_t *)ckd_calloc(1, sizeof(*kwss->detections));\n\n    kwss->beam =\n        (int32) logmath_log(acmod->lmath,\n                            cmd_ln_float64_r(config,\n                                             \"-beam\")) >> SENSCR_SHIFT;\n\n    kwss->plp =\n        (int32) logmath_log(acmod->lmath,\n                            cmd_ln_float32_r(config,\n                                             \"-kws_plp\")) >> SENSCR_SHIFT;\n\n\n    kwss->def_threshold =\n        (int32) logmath_log(acmod->lmath,\n                            cmd_ln_float64_r(config,\n                                             \"-kws_threshold\")) >>\n        SENSCR_SHIFT;\n\n    kwss->delay = (int32) cmd_ln_int32_r(config, \"-kws_delay\");\n\n    E_INFO(\"KWS(beam: %d, plp: %d, default threshold %d, delay %d)\\n\",\n           kwss->beam, kwss->plp, kwss->def_threshold, kwss->delay);\n\n    if (keyfile) {\n\tif (kws_search_read_list(kwss, keyfile) < 0) {\n\t    E_ERROR(\"Failed to create kws search\\n\");\n\t    kws_search_free(ps_search_base(kwss));\n\t    return NULL;\n\t}\n    } else {\n        kws_keyphrase_t *k = ckd_calloc(1, sizeof(kws_keyphrase_t));\n        k->threshold = kwss->def_threshold;\n        k->word = ckd_salloc(keyphrase);\n        kwss->keyphrases = glist_add_ptr(NULL, k);\n    }\n\n    /* Reinit for provided keyphrase */\n    if (kws_search_reinit(ps_search_base(kwss),\n                          ps_search_dict(kwss),\n                          ps_search_dict2pid(kwss)) < 0) {\n        ps_search_free(ps_search_base(kwss));\n        return NULL;\n    }\n    \n    ptmr_init(&kwss->perf);\n\n    return ps_search_base(kwss);\n}\n\nvoid\nkws_search_free(ps_search_t * search)\n{\n    kws_search_t *kwss;\n    double n_speech;\n    gnode_t *gn;\n\n    kwss = (kws_search_t *) search;\n\n    n_speech = (double)kwss->n_tot_frame\n        / cmd_ln_int32_r(ps_search_config(kwss), \"-frate\");\n\n    E_INFO(\"TOTAL kws %.2f CPU %.3f xRT\\n\",\n           kwss->perf.t_tot_cpu,\n           kwss->perf.t_tot_cpu / n_speech);\n    E_INFO(\"TOTAL kws %.2f wall %.3f xRT\\n\",\n           kwss->perf.t_tot_elapsed,\n           kwss->perf.t_tot_elapsed / n_speech);\n\n\n    ps_search_base_free(search);\n    hmm_context_free(kwss->hmmctx);\n    kws_detections_reset(kwss->detections);\n    ckd_free(kwss->detections);\n\n    ckd_free(kwss->pl_hmms);\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n\tkws_keyphrase_t *keyphrase = gnode_ptr(gn);\n        ckd_free(keyphrase->hmms);\n        ckd_free(keyphrase->word);\n        ckd_free(keyphrase);\n    }\n    glist_free(kwss->keyphrases);\n    ckd_free(kwss);\n}\n\nint\nkws_search_reinit(ps_search_t * search, dict_t * dict, dict2pid_t * d2p)\n{\n    char **wrdptr;\n    char *tmp_keyphrase;\n    int32 wid, pronlen, in_dict;\n    int32 n_hmms, n_wrds;\n    int32 ssid, tmatid;\n    int i, j, p;\n    kws_search_t *kwss = (kws_search_t *) search;\n    bin_mdef_t *mdef = search->acmod->mdef;\n    int32 silcipid = bin_mdef_silphone(mdef);\n    gnode_t *gn;\n\n    /* Free old dict2pid, dict */\n    ps_search_base_reinit(search, dict, d2p);\n\n    /* Initialize HMM context. */\n    if (kwss->hmmctx)\n        hmm_context_free(kwss->hmmctx);\n    kwss->hmmctx =\n        hmm_context_init(bin_mdef_n_emit_state(search->acmod->mdef),\n                         search->acmod->tmat->tp, NULL,\n                         search->acmod->mdef->sseq);\n    if (kwss->hmmctx == NULL)\n        return -1;\n\n    /* Initialize phone loop HMMs. */\n    if (kwss->pl_hmms) {\n        for (i = 0; i < kwss->n_pl; ++i)\n            hmm_deinit((hmm_t *) & kwss->pl_hmms[i]);\n        ckd_free(kwss->pl_hmms);\n    }\n    kwss->n_pl = bin_mdef_n_ciphone(search->acmod->mdef);\n    kwss->pl_hmms =\n        (hmm_t *) ckd_calloc(kwss->n_pl, sizeof(*kwss->pl_hmms));\n    for (i = 0; i < kwss->n_pl; ++i) {\n        hmm_init(kwss->hmmctx, (hmm_t *) & kwss->pl_hmms[i],\n                 FALSE,\n                 bin_mdef_pid2ssid(search->acmod->mdef, i),\n                 bin_mdef_pid2tmatid(search->acmod->mdef, i));\n    }\n\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        kws_keyphrase_t *keyphrase = gnode_ptr(gn);\n\n        /* Initialize keyphrase HMMs */\n        tmp_keyphrase = (char *) ckd_salloc(keyphrase->word);\n        n_wrds = str2words(tmp_keyphrase, NULL, 0);\n        wrdptr = (char **) ckd_calloc(n_wrds, sizeof(*wrdptr));\n        str2words(tmp_keyphrase, wrdptr, n_wrds);\n\n        /* count amount of hmms */\n        n_hmms = 0;\n        in_dict = TRUE;\n        for (i = 0; i < n_wrds; i++) {\n            wid = dict_wordid(dict, wrdptr[i]);\n            if (wid == BAD_S3WID) {\n        \tE_ERROR(\"Word '%s' in phrase '%s' is missing in the dictionary\\n\", wrdptr[i], keyphrase->word);\n        \tin_dict = FALSE;\n        \tbreak;\n            }\n            pronlen = dict_pronlen(dict, wid);\n            n_hmms += pronlen;\n        }\n        \n        if (!in_dict) {\n            ckd_free(wrdptr);\n            ckd_free(tmp_keyphrase);\n    \t    continue;\n        }\n\n        /* allocate node array */\n        if (keyphrase->hmms)\n            ckd_free(keyphrase->hmms);\n        keyphrase->hmms = (hmm_t *) ckd_calloc(n_hmms, sizeof(hmm_t));\n        keyphrase->n_hmms = n_hmms;\n\n        /* fill node array */\n        j = 0;\n        for (i = 0; i < n_wrds; i++) {\n            wid = dict_wordid(dict, wrdptr[i]);\n            pronlen = dict_pronlen(dict, wid);\n            for (p = 0; p < pronlen; p++) {\n                int32 ci = dict_pron(dict, wid, p);\n                if (p == 0) {\n                    /* first phone of word */\n                    int32 rc =\n                        pronlen > 1 ? dict_pron(dict, wid, 1) : silcipid;\n                    ssid = dict2pid_ldiph_lc(d2p, ci, rc, silcipid);\n                }\n                else if (p == pronlen - 1) {\n                    /* last phone of the word */\n                    int32 lc = dict_pron(dict, wid, p - 1);\n                    xwdssid_t *rssid = dict2pid_rssid(d2p, ci, lc);\n                    int j = rssid->cimap[silcipid];\n                    ssid = rssid->ssid[j];\n                }\n                else {\n                    /* word internal phone */\n                    ssid = dict2pid_internal(d2p, wid, p);\n                }\n                tmatid = bin_mdef_pid2tmatid(mdef, ci);\n                hmm_init(kwss->hmmctx, &keyphrase->hmms[j], FALSE, ssid,\n                         tmatid);\n                j++;\n            }\n        }\n\n        ckd_free(wrdptr);\n        ckd_free(tmp_keyphrase);\n    }\n\n    \n\n    return 0;\n}\n\nint\nkws_search_start(ps_search_t * search)\n{\n    int i;\n    kws_search_t *kwss = (kws_search_t *) search;\n\n    kwss->frame = 0;\n    kwss->bestscore = 0;\n    kws_detections_reset(kwss->detections);\n\n    /* Reset and enter all phone-loop HMMs. */\n    for (i = 0; i < kwss->n_pl; ++i) {\n        hmm_t *hmm = (hmm_t *) & kwss->pl_hmms[i];\n        hmm_clear(hmm);\n        hmm_enter(hmm, 0, -1, 0);\n    }\n\n    ptmr_reset(&kwss->perf);\n    ptmr_start(&kwss->perf);\n\n    return 0;\n}\n\nint\nkws_search_step(ps_search_t * search, int frame_idx)\n{\n    int16 const *senscr;\n    kws_search_t *kwss = (kws_search_t *) search;\n    acmod_t *acmod = search->acmod;\n\n    /* Activate senones */\n    if (!acmod->compallsen)\n        kws_search_sen_active(kwss);\n\n    /* Calculate senone scores for current frame. */\n    senscr = acmod_score(acmod, &frame_idx);\n\n    /* Evaluate hmms in phone loop and in active keyphrase nodes */\n    kws_search_hmm_eval(kwss, senscr);\n\n    /* Prune hmms with low prob */\n    kws_search_hmm_prune(kwss);\n\n    /* Do hmms transitions */\n    kws_search_trans(kwss);\n\n    ++kwss->frame;\n    return 0;\n}\n\nint\nkws_search_finish(ps_search_t * search)\n{\n    kws_search_t *kwss;\n    int32 cf;\n\n    kwss = (kws_search_t *) search;\n\n    kwss->n_tot_frame += kwss->frame;\n\n    /* Print out some statistics. */\n    ptmr_stop(&kwss->perf);\n    /* This is the number of frames processed. */\n    cf = ps_search_acmod(kwss)->output_frame;\n    if (cf > 0) {\n        double n_speech = (double) (cf + 1)\n            / cmd_ln_int32_r(ps_search_config(kwss), \"-frate\");\n        E_INFO(\"kws %.2f CPU %.3f xRT\\n\",\n               kwss->perf.t_cpu, kwss->perf.t_cpu / n_speech);\n        E_INFO(\"kws %.2f wall %.3f xRT\\n\",\n               kwss->perf.t_elapsed, kwss->perf.t_elapsed / n_speech);\n    }\n\n    return 0;\n}\n\nchar const *\nkws_search_hyp(ps_search_t * search, int32 * out_score)\n{\n    kws_search_t *kwss = (kws_search_t *) search;\n    if (out_score)\n        *out_score = 0;\n\n    if (search->hyp_str)\n        ckd_free(search->hyp_str);\n    search->hyp_str = kws_detections_hyp_str(kwss->detections, kwss->frame, kwss->delay);\n\n    return search->hyp_str;\n}\n\nchar * \nkws_search_get_keyphrases(ps_search_t * search)\n{\n    int c, len;\n    kws_search_t *kwss;\n    char* line;\n    gnode_t *gn;\n\n    kwss = (kws_search_t *) search;\n\n    len = 0;\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn))\n        len += strlen(((kws_keyphrase_t *)gnode_ptr(gn))->word) + 1;\n\n    c = 0;\n    line = (char *)ckd_calloc(len, sizeof(*line));\n    for (gn = kwss->keyphrases; gn; gn = gnode_next(gn)) {\n        const char *str = ((kws_keyphrase_t *)gnode_ptr(gn))->word;\n        memcpy(&line[c], str, strlen(str));\n        c += strlen(str);\n        line[c++] = '\\n';\n    }\n    line[--c] = '\\0';\n\n    return line;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2014 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n* kws_detections.c -- Object for storing keyphrase search results\n*/\n\n#include \"kws_detections.h\"\n\nvoid\nkws_detections_reset(kws_detections_t *detections)\n{\n    gnode_t *gn;\n\n    if (!detections->detect_list)\n        return;\n\n    for (gn = detections->detect_list; gn; gn = gnode_next(gn))\n        ckd_free(gnode_ptr(gn));\n    glist_free(detections->detect_list);\n    detections->detect_list = NULL;\n}\n\nvoid\nkws_detections_add(kws_detections_t *detections, const char* keyphrase, int sf, int ef, int prob, int ascr)\n{\n    gnode_t *gn;\n    kws_detection_t* detection;\n    for (gn = detections->detect_list; gn; gn = gnode_next(gn)) {\n        kws_detection_t *det = (kws_detection_t *)gnode_ptr(gn);\n        if (strcmp(keyphrase, det->keyphrase) == 0 && det->sf < ef && det->ef > sf) {\n            if (det->prob < prob) {\n                det->sf = sf;\n                det->ef = ef;\n                det->prob = prob;\n                det->ascr = ascr;\n            }\n            return;\n        }\n    }\n\n    /* Nothing found */\n    detection = (kws_detection_t *)ckd_calloc(1, sizeof(*detection));\n    detection->sf = sf;\n    detection->ef = ef;\n    detection->keyphrase = keyphrase;\n    detection->prob = prob;\n    detection->ascr = ascr;\n    detections->detect_list = glist_add_ptr(detections->detect_list, detection);\n}\n\nchar *\nkws_detections_hyp_str(kws_detections_t *detections, int frame, int delay)\n{\n    gnode_t *gn;\n    char *c;\n    int len;\n    char *hyp_str;\n\n    len = 0;\n    for (gn = detections->detect_list; gn; gn = gnode_next(gn)) {\n\tkws_detection_t *det = (kws_detection_t *)gnode_ptr(gn);\n\tif (det->ef < frame - delay) {\n\t    len += strlen(det->keyphrase) + 1;\n\t}\n    }\n\n    if (len == 0) {\n        return NULL;\n    }\n\n    hyp_str = (char *)ckd_calloc(len, sizeof(char));\n    c = hyp_str;\n    for (gn = detections->detect_list; gn; gn = gnode_next(gn)) {\n\tkws_detection_t *det = (kws_detection_t *)gnode_ptr(gn);\n\tif (det->ef < frame - delay) {\n            memcpy(c, det->keyphrase, strlen(det->keyphrase));\n    \t    c += strlen(det->keyphrase);\n    \t    *c = ' ';\n    \t    c++;\n    \t}\n    }\n    if (c > hyp_str) {\n        c--;\n\t*c = '\\0';\n    }\n    return hyp_str;\n}\n\n","/* ====================================================================\n * Copyright (c) 2014 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n* allphone_search.c -- Search for phonetic decoding.\n*/\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include <sphinxbase/err.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/pio.h>\n#include <sphinxbase/cmd_ln.h>\n\n#include \"pocketsphinx_internal.h\"\n#include \"allphone_search.h\"\n\nstatic ps_lattice_t *\nallphone_search_lattice(ps_search_t * search)\n{\n    return NULL;\n}\n\nstatic int\nallphone_search_prob(ps_search_t * search)\n{\n    return 0;\n}\n\nstatic void\nallphone_backtrace(allphone_search_t * allphs, int32 f, int32 *out_score);\n\nstatic void\nallphone_search_seg_free(ps_seg_t * seg)\n{\n    ckd_free(seg);\n}\n\nstatic void\nallphone_search_fill_iter(ps_seg_t *seg, phseg_t *phseg)\n{\n    seg->sf = phseg->sf;\n    seg->ef = phseg->ef;\n    seg->ascr = phseg->score;\n    seg->lscr = phseg->tscore;\n    seg->word = bin_mdef_ciphone_str(ps_search_acmod(seg->search)->mdef, phseg->ci);\n}\n\nstatic ps_seg_t *\nallphone_search_seg_next(ps_seg_t * seg)\n{\n    phseg_iter_t *itor = (phseg_iter_t *) seg;\n    phseg_t *phseg;\n\n    itor->seg = itor->seg->next;\n    \n    if (itor->seg == NULL) {\n\tallphone_search_seg_free(seg);\n        return NULL;\n    }\n    phseg = gnode_ptr(itor->seg);\n    allphone_search_fill_iter(seg, phseg);\n\n    return seg;\n}\n\nstatic ps_segfuncs_t fsg_segfuncs = {\n    /* seg_next */ allphone_search_seg_next,\n    /* seg_free */ allphone_search_seg_free\n};\n\n\nstatic ps_seg_t *\nallphone_search_seg_iter(ps_search_t * search)\n{\n    allphone_search_t *allphs = (allphone_search_t *) search;\n    phseg_iter_t *iter;\n\n    allphone_backtrace(allphs, allphs->frame - 1, NULL);\n    if (allphs->segments == NULL)\n        return NULL;\n    \n    iter = ckd_calloc(1, sizeof(phseg_iter_t));\n\n    iter->base.vt = &fsg_segfuncs;\n    iter->base.search = search;\n    iter->seg = allphs->segments;\n    allphone_search_fill_iter((ps_seg_t *)iter, gnode_ptr(iter->seg));\n\n    return (ps_seg_t *) iter;\n}\n\nstatic ps_searchfuncs_t allphone_funcs = {\n    /* start: */ allphone_search_start,\n    /* step: */ allphone_search_step,\n    /* finish: */ allphone_search_finish,\n    /* reinit: */ allphone_search_reinit,\n    /* free: */ allphone_search_free,\n    /* lattice: */ allphone_search_lattice,\n    /* hyp: */ allphone_search_hyp,\n    /* prob: */ allphone_search_prob,\n    /* seg_iter: */ allphone_search_seg_iter,\n};\n\n/**\n * Find PHMM node with same senone sequence and tmat id as the given triphone.\n * Return ptr to PHMM node if found, NULL otherwise.\n */\nstatic phmm_t *\nphmm_lookup(allphone_search_t * allphs, s3pid_t pid)\n{\n    phmm_t *p;\n    bin_mdef_t *mdef;\n    phmm_t **ci_phmm;\n\n    mdef = ((ps_search_t *) allphs)->acmod->mdef;\n    ci_phmm = allphs->ci_phmm;\n\n    for (p = ci_phmm[bin_mdef_pid2ci(mdef, pid)]; p; p = p->next) {\n        if (mdef_pid2tmatid(mdef, p->pid) == mdef_pid2tmatid(mdef, pid))\n            if (mdef_pid2ssid(mdef, p->pid) == mdef_pid2ssid(mdef, pid))\n                return p;\n    }\n\n    return NULL;\n}\n\nstatic int32\nphmm_link(allphone_search_t * allphs)\n{\n    s3cipid_t ci, rc;\n    phmm_t *p, *p2;\n    int32 *rclist;\n    int32 i, n_link;\n    plink_t *l;\n    bin_mdef_t *mdef;\n    phmm_t **ci_phmm;\n\n    mdef = ((ps_search_t *) allphs)->acmod->mdef;\n    ci_phmm = allphs->ci_phmm;\n\n    rclist = (int32 *) ckd_calloc(mdef->n_ciphone + 1, sizeof(int32));\n\n    /* Create successor links between PHMM nodes */\n    n_link = 0;    \n    for (ci = 0; ci < mdef->n_ciphone; ci++) {\n        for (p = ci_phmm[ci]; p; p = p->next) {\n            /* Build rclist for p */\n            i = 0;\n            for (rc = 0; rc < mdef->n_ciphone; rc++) {\n                if (bitvec_is_set(p->rc, rc))\n                    rclist[i++] = rc;\n            }\n            rclist[i] = BAD_S3CIPID;\n\n            /* For each rc in rclist, transition to PHMMs for rc if left context = ci */\n            for (i = 0; IS_S3CIPID(rclist[i]); i++) {\n                for (p2 = ci_phmm[rclist[i]]; p2; p2 = p2->next) {\n                    if (bitvec_is_set(p2->lc, ci)) {\n                        /* transition from p to p2 */\n                        l = (plink_t *) ckd_calloc(1, sizeof(*l));\n                        l->phmm = p2;\n                        l->next = p->succlist;\n                        p->succlist = l;\n\n                        n_link++;\n                    }\n                }\n            }\n        }\n    }\n\n    ckd_free(rclist);\n\n    return n_link;\n}\n\n/**\n * Build net from phone HMMs\n */\nstatic int\nphmm_build(allphone_search_t * allphs)\n{\n    phmm_t *p, **pid2phmm;\n    bin_mdef_t *mdef;\n    int32 lrc_size;\n    uint32 *lc, *rc;\n    s3pid_t pid;\n    s3cipid_t ci;\n    s3cipid_t *filler;\n    int n_phmm, n_link;\n    int i, nphone;\n\n    mdef = ((ps_search_t *) allphs)->acmod->mdef;\n    allphs->ci_phmm =\n        (phmm_t **) ckd_calloc(bin_mdef_n_ciphone(mdef), sizeof(phmm_t *));\n    pid2phmm =\n        (phmm_t **) ckd_calloc(bin_mdef_n_phone(mdef), sizeof(phmm_t *));\n\n    /* For each unique ciphone/triphone entry in mdef, create a PHMM node */\n    n_phmm = 0;\n    nphone = allphs->ci_only ? bin_mdef_n_ciphone(mdef) : bin_mdef_n_phone(mdef);\n    E_INFO(\"Building PHMM net of %d phones\\n\", nphone);\n    for (pid = 0; pid < nphone; pid++) {\n        if ((p = phmm_lookup(allphs, pid)) == NULL) {\n            /* not found, should be created */\n            p = (phmm_t *) ckd_calloc(1, sizeof(*p));\n            hmm_init(allphs->hmmctx, &(p->hmm), FALSE,\n                     mdef_pid2ssid(mdef, pid), mdef->phone[pid].tmat);\n            p->pid = pid;\n            p->ci = bin_mdef_pid2ci(mdef, pid);\n            p->succlist = NULL;\n            p->next = allphs->ci_phmm[p->ci];\n            allphs->ci_phmm[p->ci] = p;\n            n_phmm++;\n        }\n        pid2phmm[pid] = p;\n    }\n\n    /* Fill out bitvecs of each PHMM node, alloc continuous memory chunk for context bitvectors */\n    lrc_size = bitvec_size(bin_mdef_n_ciphone(mdef));\n    lc = ckd_calloc(n_phmm * 2 * lrc_size, sizeof(bitvec_t));\n    rc = lc + (n_phmm * lrc_size);\n    for (ci = 0; ci < mdef->n_ciphone; ci++) {\n        for (p = allphs->ci_phmm[ci]; p; p = p->next) {\n            p->lc = lc;\n            lc += lrc_size;\n            p->rc = rc;\n            rc += lrc_size;\n        }\n    }\n\n    /* Fill out lc and rc bitmaps (remember to map all fillers to each other!!) */\n    filler =\n        (s3cipid_t *) ckd_calloc(bin_mdef_n_ciphone(mdef) + 1,\n                                 sizeof(s3cipid_t));\n\n    /* Connect fillers */\n    i = 0;\n    for (ci = 0; ci < bin_mdef_n_ciphone(mdef); ci++) {\n        p = pid2phmm[ci];\n        bitvec_set_all(p->lc, bin_mdef_n_ciphone(mdef));\n        bitvec_set_all(p->rc, bin_mdef_n_ciphone(mdef));\n        if (mdef->phone[ci].info.ci.filler) {\n            filler[i++] = ci;\n        }\n    }\n    filler[i] = BAD_S3CIPID;\n\n\n    /* Loop over cdphones only if ci_only is not set */\n    for (pid = bin_mdef_n_ciphone(mdef); pid < nphone;\n         pid++) {\n        p = pid2phmm[pid];\n\n        if (mdef->phone[mdef->phone[pid].info.cd.ctx[1]].info.ci.filler) {\n            for (i = 0; IS_S3CIPID(filler[i]); i++)\n                bitvec_set(p->lc, filler[i]);\n        }\n        else\n            bitvec_set(p->lc, mdef->phone[pid].info.cd.ctx[1]);\n\n        if (mdef->phone[mdef->phone[pid].info.cd.ctx[2]].info.ci.filler) {\n            for (i = 0; IS_S3CIPID(filler[i]); i++)\n                bitvec_set(p->rc, filler[i]);\n        }\n        else\n            bitvec_set(p->rc, mdef->phone[pid].info.cd.ctx[2]);\n    }\n    ckd_free(pid2phmm);\n    ckd_free(filler);\n\n    /* Create links between PHMM nodes */\n    n_link = phmm_link(allphs);\n\n    E_INFO(\"%d nodes, %d links\\n\", n_phmm, n_link);\n    return 0;\n}\n\nstatic void\nphmm_free(allphone_search_t * allphs)\n{\n    s3cipid_t ci;\n    bin_mdef_t *mdef;\n\n    if (!allphs->ci_phmm)\n        return;\n    ckd_free(allphs->ci_phmm[0]->lc);\n    mdef = ((ps_search_t *) allphs)->acmod->mdef;\n    for (ci = 0; ci < mdef_n_ciphone(mdef); ++ci) {\n        phmm_t *p, *next;\n\n        for (p = allphs->ci_phmm[ci]; p; p = next) {\n            plink_t *l, *lnext;\n\n            next = p->next;\n            for (l = p->succlist; l; l = lnext) {\n                lnext = l->next;\n                ckd_free(l);\n            }\n            hmm_deinit(&(p->hmm));\n            ckd_free(p);\n        }\n    }\n    ckd_free(allphs->ci_phmm);\n}\n\n/** Evaluate active PHMMs */\nstatic int32\nphmm_eval_all(allphone_search_t * allphs, const int16 * senscr)\n{\n    s3cipid_t ci;\n    phmm_t *p;\n    int32 best;\n    bin_mdef_t *mdef;\n    phmm_t **ci_phmm;\n\n    mdef = ((ps_search_t *) allphs)->acmod->mdef;\n    ci_phmm = allphs->ci_phmm;\n\n    best = WORST_SCORE;\n\n    hmm_context_set_senscore(allphs->hmmctx, senscr);\n    for (ci = 0; ci < mdef->n_ciphone; ci++) {\n        for (p = ci_phmm[(unsigned) ci]; p; p = p->next) {\n            if (hmm_frame(&(p->hmm)) == allphs->frame) {\n                int32 score;\n                allphs->n_hmm_eval++;\n                score = hmm_vit_eval((hmm_t *) p);\n                if (score > best)\n                    best = score;\n            }\n        }\n    }\n\n    return best;\n}\n\nstatic void\nphmm_exit(allphone_search_t * allphs, int32 best)\n{\n    s3cipid_t ci;\n    phmm_t *p;\n    int32 th, nf;\n    history_t *h;\n    blkarray_list_t *history;\n    bin_mdef_t *mdef;\n    int32 curfrm;\n    phmm_t **ci_phmm;\n    int32 *ci2lmwid;\n\n    th = best + allphs->pbeam;\n\n    history = allphs->history;\n    mdef = ps_search_acmod(allphs)->mdef;\n    curfrm = allphs->frame;\n    ci_phmm = allphs->ci_phmm;\n    ci2lmwid = allphs->ci2lmwid;\n\n    nf = curfrm + 1;\n\n    for (ci = 0; ci < mdef->n_ciphone; ci++) {\n        for (p = ci_phmm[(unsigned) ci]; p; p = p->next) {\n            if (hmm_frame(&(p->hmm)) == curfrm) {\n\n                if (hmm_bestscore(&(p->hmm)) >= th) {\n\n                    h = (history_t *) ckd_calloc(1, sizeof(*h));\n                    h->ef = curfrm;\n                    h->phmm = p;\n                    h->hist = hmm_out_history(&(p->hmm));\n                    h->score = hmm_out_score(&(p->hmm));\n\n                    if (!allphs->lm) {\n                        h->tscore = allphs->inspen;\n                    }\n                    else {\n                        if (h->hist > 0) {\n                            int32 n_used;\n                            history_t *pred =\n                                blkarray_list_get(history, h->hist);\n\n                            if (pred->hist > 0) {\n                                history_t *pred_pred =\n                                    blkarray_list_get(history,\n                                                      h->hist);\n                                h->tscore =\n                                    ngram_tg_score(allphs->lm,\n                                                   ci2lmwid\n                                                   [pred_pred->phmm->ci],\n                                                   ci2lmwid[pred->\n                                                            phmm->ci],\n                                                   ci2lmwid[p->ci],\n                                                   &n_used) >>\n                                    SENSCR_SHIFT;\n                            }\n                            else {\n                                h->tscore =\n                                    ngram_bg_score(allphs->lm,\n                                                   ci2lmwid\n                                                   [pred->phmm->ci],\n                                                   ci2lmwid[p->ci],\n                                                   &n_used) >>\n                                    SENSCR_SHIFT;\n                            }\n                        }\n                        else {\n                            /*\n                             * This is the beginning SIL and in srch_allphone_begin()\n                             * it's inscore is set to 0.\n                             */\n                            h->tscore = 0;\n                        }\n                    }\n\n                    blkarray_list_append(history, h);\n\n                    /* Mark PHMM active in next frame */\n                    hmm_frame(&(p->hmm)) = nf;\n                }\n                else {\n                    /* Reset state scores */\n                    hmm_clear(&(p->hmm));\n                }\n            }\n        }\n    }\n}\n\nstatic void\nphmm_trans(allphone_search_t * allphs, int32 best,\n           int32 frame_history_start)\n{\n    history_t *h;\n    phmm_t *from, *to;\n    plink_t *l;\n    int32 newscore, nf, curfrm;\n    int32 *ci2lmwid;\n    int32 hist_idx;\n\n    curfrm = allphs->frame;\n    nf = curfrm + 1;\n    ci2lmwid = allphs->ci2lmwid;\n\n    /* Transition from exited nodes to initial states of HMMs */\n    for (hist_idx = frame_history_start;\n         hist_idx < blkarray_list_n_valid(allphs->history); hist_idx++) {\n        h = blkarray_list_get(allphs->history, hist_idx);\n        from = h->phmm;\n        for (l = from->succlist; l; l = l->next) {\n            int32 tscore;\n            to = l->phmm;\n\n            /* No LM, just use uniform (insertion penalty). */\n            if (!allphs->lm)\n                tscore = allphs->inspen;\n            else {\n                int32 n_used;\n                if (h->hist > 0) {\n                    history_t *pred =\n                        blkarray_list_get(allphs->history, h->hist);\n                    tscore =\n                        ngram_tg_score(allphs->lm,\n                                       ci2lmwid[pred->phmm->ci],\n                                       ci2lmwid[from->ci],\n                                       ci2lmwid[to->ci],\n                                       &n_used) >> SENSCR_SHIFT;\n                }\n                else {\n                    tscore = ngram_bg_score(allphs->lm,\n                                            ci2lmwid[from->ci],\n                                            ci2lmwid[to->ci],\n                                            &n_used) >> SENSCR_SHIFT;\n                }\n            }\n\n            newscore = h->score + tscore;\n            if ((newscore > best + allphs->beam)\n                && (newscore > hmm_in_score(&(to->hmm)))) {\n                hmm_enter(&(to->hmm), newscore, hist_idx, nf);\n            }\n        }\n    }\n}\n\nps_search_t *\nallphone_search_init(const char *name,\n                     ngram_model_t * lm,\n                     cmd_ln_t * config,\n                     acmod_t * acmod, dict_t * dict, dict2pid_t * d2p)\n{\n    int i;\n    bin_mdef_t *mdef;\n    allphone_search_t *allphs;\n\n    allphs = (allphone_search_t *) ckd_calloc(1, sizeof(*allphs));\n    ps_search_init(ps_search_base(allphs), &allphone_funcs, PS_SEARCH_TYPE_ALLPHONE, name, config, acmod,\n                   dict, d2p);\n    mdef = acmod->mdef;\n\n    allphs->hmmctx = hmm_context_init(bin_mdef_n_emit_state(mdef),\n                                      acmod->tmat->tp, NULL, mdef->sseq);\n    if (allphs->hmmctx == NULL) {\n        ps_search_free(ps_search_base(allphs));\n        return NULL;\n    }\n\n    allphs->ci_only = cmd_ln_boolean_r(config, \"-allphone_ci\");\n    allphs->lw = cmd_ln_float32_r(config, \"-lw\");\n\n    phmm_build(allphs);\n\n    if (lm) {\n\tint32 silwid;\n\t\n        allphs->lm = ngram_model_retain(lm);\n        \n        silwid = ngram_wid(allphs->lm, bin_mdef_ciphone_str(mdef,\n                                                            mdef_silphone\n                                                            (mdef)));\n\tif (silwid == ngram_unknown_wid(allphs->lm)) {\n\t    E_ERROR(\"Phonetic LM does not have SIL phone in vocabulary\\n\");\n\t    allphone_search_free((ps_search_t *) allphs);\n\t    return NULL;\n\t}\n        \n        allphs->ci2lmwid =\n            (int32 *) ckd_calloc(mdef->n_ciphone,\n                                 sizeof(*allphs->ci2lmwid));\n        for (i = 0; i < mdef->n_ciphone; i++) {\n            allphs->ci2lmwid[i] =\n                ngram_wid(allphs->lm,\n                          (char *) bin_mdef_ciphone_str(mdef, i));\n            /* Map filler phones and other missing phones to silence if not found */\n            if (allphs->ci2lmwid[i] == ngram_unknown_wid(allphs->lm))\n                allphs->ci2lmwid[i] = silwid;\n        }\n    }\n    else {\n        E_WARN\n            (\"Failed to load language model specified in -allphone, doing unconstrained phone-loop decoding\\n\");\n        allphs->inspen =\n            (int32) (logmath_log\n                     (acmod->lmath, cmd_ln_float32_r(config, \"-pip\"))\n                     * allphs->lw) >> SENSCR_SHIFT;\n    }\n\n    allphs->n_tot_frame = 0;\n    allphs->frame = -1;\n    allphs->segments = NULL;\n\n    /* Get search pruning parameters */\n    allphs->beam\n        =\n        (int32) logmath_log(acmod->lmath,\n                            cmd_ln_float64_r(config, \"-beam\"))\n        >> SENSCR_SHIFT;\n    allphs->pbeam\n        =\n        (int32) logmath_log(acmod->lmath,\n                            cmd_ln_float64_r(config, \"-pbeam\"))\n        >> SENSCR_SHIFT;\n\n    /* LM related weights/penalties */\n    allphs->history = blkarray_list_init();\n\n    /* Acoustic score scale for posterior probabilities. */\n    allphs->ascale = 1.0 / cmd_ln_float32_r(config, \"-ascale\");\n\n    E_INFO(\"Allphone(beam: %d, pbeam: %d)\\n\", allphs->beam, allphs->pbeam);\n\n    ptmr_init(&allphs->perf);\n\n    return (ps_search_t *) allphs;\n}\n\nint\nallphone_search_reinit(ps_search_t * search, dict_t * dict,\n                       dict2pid_t * d2p)\n{\n    allphone_search_t *allphs = (allphone_search_t *) search;\n\n    /* Free old dict2pid, dict */\n    ps_search_base_reinit(search, dict, d2p);\n\n    if (!allphs->lm) {\n        E_WARN\n            (\"-lm argument missing; doing unconstrained phone-loop decoding\\n\");\n        allphs->inspen =\n            (int32) (logmath_log\n                     (search->acmod->lmath,\n                      cmd_ln_float32_r(search->config,\n                                       \"-pip\")) *\n                     allphs->lw) >> SENSCR_SHIFT;\n    }\n\n    return 0;\n}\n\nvoid\nallphone_search_free(ps_search_t * search)\n{\n    allphone_search_t *allphs = (allphone_search_t *) search;\n\n    \n    double n_speech = (double)allphs->n_tot_frame\n            / cmd_ln_int32_r(ps_search_config(allphs), \"-frate\");\n\n    E_INFO(\"TOTAL allphone %.2f CPU %.3f xRT\\n\",\n           allphs->perf.t_tot_cpu,\n           allphs->perf.t_tot_cpu / n_speech);\n    E_INFO(\"TOTAL allphone %.2f wall %.3f xRT\\n\",\n           allphs->perf.t_tot_elapsed,\n           allphs->perf.t_tot_elapsed / n_speech);\n\n    ps_search_base_free(search);\n\n    hmm_context_free(allphs->hmmctx);\n    phmm_free(allphs);\n    if (allphs->lm)\n        ngram_model_free(allphs->lm);\n    if (allphs->ci2lmwid)\n        ckd_free(allphs->ci2lmwid);\n    if (allphs->history)\n        blkarray_list_free(allphs->history);\n\n    ckd_free(allphs);\n}\n\nint\nallphone_search_start(ps_search_t * search)\n{\n    allphone_search_t *allphs;\n    bin_mdef_t *mdef;\n    s3cipid_t ci;\n    phmm_t *p;\n\n    allphs = (allphone_search_t *) search;\n    mdef = search->acmod->mdef;\n\n    /* Reset all HMMs. */\n    for (ci = 0; ci < bin_mdef_n_ciphone(mdef); ci++) {\n        for (p = allphs->ci_phmm[(unsigned) ci]; p; p = p->next) {\n            hmm_clear(&(p->hmm));\n        }\n    }\n\n    allphs->n_hmm_eval = 0;\n    allphs->n_sen_eval = 0;\n\n    /* Free history nodes, if any */\n    blkarray_list_reset(allphs->history);\n\n    /* Initialize start state of the SILENCE PHMM */\n    allphs->frame = 0;\n    ci = bin_mdef_silphone(mdef);\n    if (NOT_S3CIPID(ci))\n        E_FATAL(\"Cannot find CI-phone %s\\n\", S3_SILENCE_CIPHONE);\n    for (p = allphs->ci_phmm[ci]; p && (p->pid != ci); p = p->next);\n    if (!p)\n        E_FATAL(\"Cannot find HMM for %s\\n\", S3_SILENCE_CIPHONE);\n    hmm_enter(&(p->hmm), 0, 0, allphs->frame);\n\n    ptmr_reset(&allphs->perf);\n    ptmr_start(&allphs->perf);\n\n    return 0;\n}\n\nstatic void\nallphone_search_sen_active(allphone_search_t * allphs)\n{\n    acmod_t *acmod;\n    bin_mdef_t *mdef;\n    phmm_t *p;\n    int32 ci;\n\n    acmod = ps_search_acmod(allphs);\n    mdef = acmod->mdef;\n\n    acmod_clear_active(acmod);\n    for (ci = 0; ci < bin_mdef_n_ciphone(mdef); ci++)\n        for (p = allphs->ci_phmm[ci]; p; p = p->next)\n            if (hmm_frame(&(p->hmm)) == allphs->frame)\n                acmod_activate_hmm(acmod, &(p->hmm));\n}\n\nint\nallphone_search_step(ps_search_t * search, int frame_idx)\n{\n    int32 bestscr, frame_history_start;\n    const int16 *senscr;\n    allphone_search_t *allphs = (allphone_search_t *) search;\n    acmod_t *acmod = search->acmod;\n\n    if (!acmod->compallsen)\n        allphone_search_sen_active(allphs);\n    senscr = acmod_score(acmod, &frame_idx);\n    allphs->n_sen_eval += acmod->n_senone_active;\n    bestscr = phmm_eval_all(allphs, senscr);\n\n    frame_history_start = blkarray_list_n_valid(allphs->history);\n    phmm_exit(allphs, bestscr);\n    phmm_trans(allphs, bestscr, frame_history_start);\n\n    allphs->frame++;\n\n    return 0;\n}\n\nstatic int32\nascore(allphone_search_t * allphs, history_t * h)\n{\n    int32 score = h->score;\n\n    if (h->hist > 0) {\n        history_t *pred = blkarray_list_get(allphs->history, h->hist);\n        score -= pred->score;\n    }\n\n    return score - h->tscore;\n}\n\nstatic void\nallphone_clear_segments(allphone_search_t * allphs)\n{\t\n    gnode_t *gn;\n    for (gn = allphs->segments; gn; gn = gn->next) {\n        ckd_free(gnode_ptr(gn));\n    }\n    glist_free(allphs->segments);\n    allphs->segments = NULL;\n}\n\nstatic void\nallphone_backtrace(allphone_search_t * allphs, int32 f, int32 *out_score)\n{\n    int32 best, hist_idx, best_idx;\n    int32 frm, last_frm;\n    history_t *h;\n    phseg_t *s;\n\n    /* Clear old list */\n    allphone_clear_segments(allphs);\n\n    frm = last_frm = f;\n    /* Find the first history entry for the requested frame */\n    hist_idx = blkarray_list_n_valid(allphs->history) - 1;\n    while (hist_idx > 0) {\n        h = blkarray_list_get(allphs->history, hist_idx);\n        if (h->ef <= f) {\n            frm = last_frm = h->ef;\n            break;\n        }\n        hist_idx--;\n    }\n\n    if (hist_idx < 0)\n        return;\n\n    /* Find bestscore */\n    best = (int32) 0x80000000;\n    best_idx = -1;\n    while (frm == last_frm && hist_idx > 0) {\n        h = blkarray_list_get(allphs->history, hist_idx);\n        frm = h->ef;\n        if (h->score > best && frm == last_frm) {\n            best = h->score;\n            best_idx = hist_idx;\n        }\n        hist_idx--;\n    }\n\n    if (best_idx < 0)\n        return;\n\n    if (out_score)\n        *out_score = best;\n\n    /* Backtrace */\n    while (best_idx > 0) {\n        h = blkarray_list_get(allphs->history, best_idx);\n        s = (phseg_t *) ckd_calloc(1, sizeof(phseg_t));\n        s->ci = h->phmm->ci;\n        s->sf =\n            (h->hist >\n             0) ? ((history_t *) blkarray_list_get(allphs->history,\n                                                   h->hist))->ef + 1 : 0;\n        s->ef = h->ef;\n        s->score = ascore(allphs, h);\n        s->tscore = h->tscore;\n        allphs->segments = glist_add_ptr(allphs->segments, s);\n\n        best_idx = h->hist;\n    }\n\n    return;\n}\n\nint\nallphone_search_finish(ps_search_t * search)\n{\n    allphone_search_t *allphs;\n    int32 cf, n_hist;\n\n    allphs = (allphone_search_t *) search;\n\n    allphs->n_tot_frame += allphs->frame;\n    n_hist = blkarray_list_n_valid(allphs->history);\n    E_INFO\n        (\"%d frames, %d HMMs (%d/fr), %d senones (%d/fr), %d history entries (%d/fr)\\n\",\n         allphs->frame, allphs->n_hmm_eval,\n         (allphs->frame > 0) ? allphs->n_hmm_eval / allphs->frame : 0,\n         allphs->n_sen_eval,\n         (allphs->frame > 0) ? allphs->n_sen_eval / allphs->frame : 0,\n         n_hist, (allphs->frame > 0) ? n_hist / allphs->frame : 0);\n\n    /* Now backtrace. */\n    allphone_backtrace(allphs, allphs->frame - 1, NULL);\n\n    /* Print out some statistics. */\n    ptmr_stop(&allphs->perf);\n    /* This is the number of frames processed. */\n    cf = ps_search_acmod(allphs)->output_frame;\n    if (cf > 0) {\n        double n_speech = (double) (cf + 1)\n            / cmd_ln_int32_r(ps_search_config(allphs), \"-frate\");\n        E_INFO(\"allphone %.2f CPU %.3f xRT\\n\",\n               allphs->perf.t_cpu, allphs->perf.t_cpu / n_speech);\n        E_INFO(\"allphone %.2f wall %.3f xRT\\n\",\n               allphs->perf.t_elapsed, allphs->perf.t_elapsed / n_speech);\n    }\n\n\n    return 0;\n}\n\nchar const *\nallphone_search_hyp(ps_search_t * search, int32 * out_score)\n{\n    allphone_search_t *allphs;\n    phseg_t *p;\n    gnode_t *gn;\n    const char *phone_str;\n    bin_mdef_t *mdef;\n    int len, hyp_idx, phone_idx;\n\n    allphs = (allphone_search_t *) search;\n    mdef = search->acmod->mdef;\n\n    /* Create hypothesis */\n    if (search->hyp_str)\n        ckd_free(search->hyp_str);\n    search->hyp_str = NULL;\n\n    allphone_backtrace(allphs, allphs->frame - 1, out_score);\n    if (allphs->segments == NULL) {\n        return NULL;\n    }\n\n    len = glist_count(allphs->segments) * 10;  /* maximum length of one phone with spacebar */\n\n    search->hyp_str = (char *) ckd_calloc(len, sizeof(*search->hyp_str));\n    hyp_idx = 0;\n    for (gn = allphs->segments; gn; gn = gn->next) {\n\tp = gnode_ptr(gn);\n        phone_str = bin_mdef_ciphone_str(mdef, p->ci);\n        phone_idx = 0;\n        while (phone_str[phone_idx] != '\\0')\n            search->hyp_str[hyp_idx++] = phone_str[phone_idx++];\n        search->hyp_str[hyp_idx++] = ' ';\n    }\n    search->hyp_str[--hyp_idx] = '\\0';\n    E_INFO(\"Hyp: %s\\n\", search->hyp_str);\n    return search->hyp_str;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1996-2004 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/byteorder.h\"\n#include \"sphinxbase/fixpoint.h\"\n#include \"sphinxbase/genrand.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/cmd_ln.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\n#include \"fe_internal.h\"\n#include \"fe_warp.h\"\n\nstatic const arg_t fe_args[] = {\n    waveform_to_cepstral_command_line_macro(),\n    { NULL, 0, NULL, NULL }\n};\n\nint\nfe_parse_general_params(cmd_ln_t *config, fe_t * fe)\n{\n    int j, frate;\n\n    fe->config = config;\n    fe->sampling_rate = cmd_ln_float32_r(config, \"-samprate\");\n    frate = cmd_ln_int32_r(config, \"-frate\");\n    if (frate > MAX_INT16 || frate > fe->sampling_rate || frate < 1) {\n        E_ERROR\n            (\"Frame rate %d can not be bigger than sample rate %.02f\\n\",\n             frate, fe->sampling_rate);\n        return -1;\n    }\n\n    fe->frame_rate = (int16)frate;\n    if (cmd_ln_boolean_r(config, \"-dither\")) {\n        fe->dither = 1;\n        fe->dither_seed = cmd_ln_int32_r(config, \"-seed\");\n    }\n#ifdef WORDS_BIGENDIAN\n    fe->swap = strcmp(\"big\", cmd_ln_str_r(config, \"-input_endian\")) == 0 ? 0 : 1;\n#else        \n    fe->swap = strcmp(\"little\", cmd_ln_str_r(config, \"-input_endian\")) == 0 ? 0 : 1;\n#endif\n    fe->window_length = cmd_ln_float32_r(config, \"-wlen\");\n    fe->pre_emphasis_alpha = cmd_ln_float32_r(config, \"-alpha\");\n\n    fe->num_cepstra = (uint8)cmd_ln_int32_r(config, \"-ncep\");\n    fe->fft_size = (int16)cmd_ln_int32_r(config, \"-nfft\");\n\n    /* Check FFT size, compute FFT order (log_2(n)) */\n    for (j = fe->fft_size, fe->fft_order = 0; j > 1; j >>= 1, fe->fft_order++) {\n        if (((j % 2) != 0) || (fe->fft_size <= 0)) {\n            E_ERROR(\"fft: number of points must be a power of 2 (is %d)\\n\",\n                    fe->fft_size);\n            return -1;\n        }\n    }\n    /* Verify that FFT size is greater or equal to window length. */\n    if (fe->fft_size < (int)(fe->window_length * fe->sampling_rate)) {\n        E_ERROR(\"FFT: Number of points must be greater or equal to frame size (%d samples)\\n\",\n                (int)(fe->window_length * fe->sampling_rate));\n        return -1;\n    }\n\n    fe->pre_speech = (int16)cmd_ln_int32_r(config, \"-vad_prespeech\");\n    fe->post_speech = (int16)cmd_ln_int32_r(config, \"-vad_postspeech\");\n    fe->start_speech = (int16)cmd_ln_int32_r(config, \"-vad_startspeech\");\n    fe->vad_threshold = cmd_ln_float32_r(config, \"-vad_threshold\");\n\n    fe->remove_dc = cmd_ln_boolean_r(config, \"-remove_dc\");\n    fe->remove_noise = cmd_ln_boolean_r(config, \"-remove_noise\");\n    fe->remove_silence = cmd_ln_boolean_r(config, \"-remove_silence\");\n\n    if (0 == strcmp(cmd_ln_str_r(config, \"-transform\"), \"dct\"))\n        fe->transform = DCT_II;\n    else if (0 == strcmp(cmd_ln_str_r(config, \"-transform\"), \"legacy\"))\n        fe->transform = LEGACY_DCT;\n    else if (0 == strcmp(cmd_ln_str_r(config, \"-transform\"), \"htk\"))\n        fe->transform = DCT_HTK;\n    else {\n        E_ERROR(\"Invalid transform type (values are 'dct', 'legacy', 'htk')\\n\");\n        return -1;\n    }\n\n    if (cmd_ln_boolean_r(config, \"-logspec\"))\n        fe->log_spec = RAW_LOG_SPEC;\n    if (cmd_ln_boolean_r(config, \"-smoothspec\"))\n        fe->log_spec = SMOOTH_LOG_SPEC;\n\n    return 0;\n}\n\nstatic int\nfe_parse_melfb_params(cmd_ln_t *config, fe_t *fe, melfb_t * mel)\n{\n    mel->sampling_rate = fe->sampling_rate;\n    mel->fft_size = fe->fft_size;\n    mel->num_cepstra = fe->num_cepstra;\n    mel->num_filters = cmd_ln_int32_r(config, \"-nfilt\");\n\n    if (fe->log_spec)\n        fe->feature_dimension = mel->num_filters;\n    else\n        fe->feature_dimension = fe->num_cepstra;\n\n    mel->upper_filt_freq = cmd_ln_float32_r(config, \"-upperf\");\n    mel->lower_filt_freq = cmd_ln_float32_r(config, \"-lowerf\");\n\n    mel->doublewide = cmd_ln_boolean_r(config, \"-doublebw\");\n\n    mel->warp_type = cmd_ln_str_r(config, \"-warp_type\");\n    mel->warp_params = cmd_ln_str_r(config, \"-warp_params\");\n    mel->lifter_val = cmd_ln_int32_r(config, \"-lifter\");\n\n    mel->unit_area = cmd_ln_boolean_r(config, \"-unit_area\");\n    mel->round_filters = cmd_ln_boolean_r(config, \"-round_filters\");\n\n    if (fe_warp_set(mel, mel->warp_type) != FE_SUCCESS) {\n        E_ERROR(\"Failed to initialize the warping function.\\n\");\n        return -1;\n    }\n    fe_warp_set_parameters(mel, mel->warp_params, mel->sampling_rate);\n    return 0;\n}\n\nvoid\nfe_print_current(fe_t const *fe)\n{\n    E_INFO(\"Current FE Parameters:\\n\");\n    E_INFO(\"\\tSampling Rate:             %f\\n\", fe->sampling_rate);\n    E_INFO(\"\\tFrame Size:                %d\\n\", fe->frame_size);\n    E_INFO(\"\\tFrame Shift:               %d\\n\", fe->frame_shift);\n    E_INFO(\"\\tFFT Size:                  %d\\n\", fe->fft_size);\n    E_INFO(\"\\tLower Frequency:           %g\\n\",\n           fe->mel_fb->lower_filt_freq);\n    E_INFO(\"\\tUpper Frequency:           %g\\n\",\n           fe->mel_fb->upper_filt_freq);\n    E_INFO(\"\\tNumber of filters:         %d\\n\", fe->mel_fb->num_filters);\n    E_INFO(\"\\tNumber of Overflow Samps:  %d\\n\", fe->num_overflow_samps);\n    E_INFO(\"Will %sremove DC offset at frame level\\n\",\n           fe->remove_dc ? \"\" : \"not \");\n    if (fe->dither) {\n        E_INFO(\"Will add dither to audio\\n\");\n        E_INFO(\"Dither seeded with %d\\n\", fe->dither_seed);\n    }\n    else {\n        E_INFO(\"Will not add dither to audio\\n\");\n    }\n    if (fe->mel_fb->lifter_val) {\n        E_INFO(\"Will apply sine-curve liftering, period %d\\n\",\n               fe->mel_fb->lifter_val);\n    }\n    E_INFO(\"Will %snormalize filters to unit area\\n\",\n           fe->mel_fb->unit_area ? \"\" : \"not \");\n    E_INFO(\"Will %sround filter frequencies to DFT points\\n\",\n           fe->mel_fb->round_filters ? \"\" : \"not \");\n    E_INFO(\"Will %suse double bandwidth in mel filter\\n\",\n           fe->mel_fb->doublewide ? \"\" : \"not \");\n}\n\nfe_t *\nfe_init_auto()\n{\n    return fe_init_auto_r(cmd_ln_get());\n}\n\nfe_t *\nfe_init_auto_r(cmd_ln_t *config)\n{\n    fe_t *fe;\n    int prespch_frame_len;\n\n    fe = (fe_t*)ckd_calloc(1, sizeof(*fe));\n    fe->refcount = 1;\n\n    /* transfer params to front end */\n    if (fe_parse_general_params(cmd_ln_retain(config), fe) < 0) {\n        fe_free(fe);\n        return NULL;\n    }\n\n    /* compute remaining fe parameters */\n    /* We add 0.5 so approximate the float with the closest\n     * integer. E.g., 2.3 is truncate to 2, whereas 3.7 becomes 4\n     */\n    fe->frame_shift = (int32) (fe->sampling_rate / fe->frame_rate + 0.5);\n    fe->frame_size = (int32) (fe->window_length * fe->sampling_rate + 0.5);\n    fe->pre_emphasis_prior = 0;\n    \n    fe_start_stream(fe);\n\n    assert (fe->frame_shift > 1);\n\n    if (fe->frame_size < fe->frame_shift) {\n        E_ERROR\n            (\"Frame size %d (-wlen) must be greater than frame shift %d (-frate)\\n\",\n             fe->frame_size, fe->frame_shift);\n        fe_free(fe);\n        return NULL;\n    }\n\n\n    if (fe->frame_size > (fe->fft_size)) {\n        E_ERROR\n            (\"Number of FFT points has to be a power of 2 higher than %d, it is %d\\n\",\n             fe->frame_size, fe->fft_size);\n        fe_free(fe);\n        return NULL;\n    }\n\n    if (fe->dither)\n        fe_init_dither(fe->dither_seed);\n\n    /* establish buffers for overflow samps and hamming window */\n    fe->overflow_samps = ckd_calloc(fe->frame_size, sizeof(int16));\n    fe->hamming_window = ckd_calloc(fe->frame_size/2, sizeof(window_t));\n\n    /* create hamming window */\n    fe_create_hamming(fe->hamming_window, fe->frame_size);\n\n    /* init and fill appropriate filter structure */\n    fe->mel_fb = ckd_calloc(1, sizeof(*fe->mel_fb));\n\n    /* transfer params to mel fb */\n    fe_parse_melfb_params(config, fe, fe->mel_fb);\n    \n    if (fe->mel_fb->upper_filt_freq > fe->sampling_rate / 2 + 1.0) {\n\tE_ERROR(\"Upper frequency %.1f is higher than samprate/2 (%.1f)\\n\", \n\t\tfe->mel_fb->upper_filt_freq, fe->sampling_rate / 2);\n\tfe_free(fe);\n\treturn NULL;\n    }\n    \n    fe_build_melfilters(fe->mel_fb);\n\n    fe_compute_melcosine(fe->mel_fb);\n    if (fe->remove_noise || fe->remove_silence)\n        fe->noise_stats = fe_init_noisestats(fe->mel_fb->num_filters);\n\n    fe->vad_data = (vad_data_t*)ckd_calloc(1, sizeof(*fe->vad_data));\n    prespch_frame_len = fe->log_spec != RAW_LOG_SPEC ? fe->num_cepstra : fe->mel_fb->num_filters;\n    fe->vad_data->prespch_buf = fe_prespch_init(fe->pre_speech + 1, prespch_frame_len, fe->frame_shift);\n\n    /* Create temporary FFT, spectrum and mel-spectrum buffers. */\n    /* FIXME: Gosh there are a lot of these. */\n    fe->spch = ckd_calloc(fe->frame_size, sizeof(*fe->spch));\n    fe->frame = ckd_calloc(fe->fft_size, sizeof(*fe->frame));\n    fe->spec = ckd_calloc(fe->fft_size, sizeof(*fe->spec));\n    fe->mfspec = ckd_calloc(fe->mel_fb->num_filters, sizeof(*fe->mfspec));\n\n    /* create twiddle factors */\n    fe->ccc = ckd_calloc(fe->fft_size / 4, sizeof(*fe->ccc));\n    fe->sss = ckd_calloc(fe->fft_size / 4, sizeof(*fe->sss));\n    fe_create_twiddle(fe);\n\n    if (cmd_ln_boolean_r(config, \"-verbose\")) {\n        fe_print_current(fe);\n    }\n\n    /*** Initialize the overflow buffers ***/\n    fe_start_utt(fe);\n    return fe;\n}\n\narg_t const *\nfe_get_args(void)\n{\n    return fe_args;\n}\n\nconst cmd_ln_t *\nfe_get_config(fe_t *fe)\n{\n    return fe->config;\n}\n\nvoid\nfe_init_dither(int32 seed)\n{\n    E_INFO(\"Using %d as the seed.\\n\", seed);\n    s3_rand_seed(seed);\n}\n\nstatic void\nfe_reset_vad_data(vad_data_t * vad_data)\n{\n    vad_data->in_speech = 0;\n    vad_data->pre_speech_frames = 0;\n    vad_data->post_speech_frames = 0;\n    fe_prespch_reset_cep(vad_data->prespch_buf);\n}\n\nint32\nfe_start_utt(fe_t * fe)\n{\n    fe->num_overflow_samps = 0;\n    memset(fe->overflow_samps, 0, fe->frame_size * sizeof(int16));\n    fe->pre_emphasis_prior = 0;\n    fe_reset_vad_data(fe->vad_data);\n    return 0;\n}\n\nvoid \nfe_start_stream(fe_t *fe)\n{\n    fe->num_processed_samps = 0;\n    fe_reset_noisestats(fe->noise_stats);\n}\n\nint\nfe_get_output_size(fe_t *fe)\n{\n    return (int)fe->feature_dimension;\n}\n\nvoid\nfe_get_input_size(fe_t *fe, int *out_frame_shift,\n                  int *out_frame_size)\n{\n    if (out_frame_shift)\n        *out_frame_shift = fe->frame_shift;\n    if (out_frame_size)\n        *out_frame_size = fe->frame_size;\n}\n\nuint8\nfe_get_vad_state(fe_t *fe)\n{\n    return fe->vad_data->in_speech;\n}\n\nint\nfe_process_frames(fe_t *fe,\n                  int16 const **inout_spch,\n                  size_t *inout_nsamps,\n                  mfcc_t **buf_cep,\n                  int32 *inout_nframes,\n                  int32 *out_frameidx)\n{\n    return fe_process_frames_ext(fe, inout_spch, inout_nsamps, buf_cep, inout_nframes, NULL, NULL, out_frameidx);\n}\n\n\n/**\n * Copy frames collected in prespeech buffer\n */\nstatic int\nfe_copy_from_prespch(fe_t *fe, int32 *inout_nframes, mfcc_t **buf_cep, int outidx)\n{\n    while ((*inout_nframes) > 0 && fe_prespch_read_cep(fe->vad_data->prespch_buf, buf_cep[outidx]) > 0) {\n\t    outidx++;\n    \t    (*inout_nframes)--;\n    }\n    return outidx;    \n}\n\n/**\n * Update pointers after we processed a frame. A complex logic used in two places in fe_process_frames\n */\nstatic int\nfe_check_prespeech(fe_t *fe, int32 *inout_nframes, mfcc_t **buf_cep, int outidx, int32 *out_frameidx, size_t *inout_nsamps, int orig_nsamps)\n{\n    if (fe->vad_data->in_speech) {    \n\tif (fe_prespch_ncep(fe->vad_data->prespch_buf) > 0) {\n\n    \t    /* Previous frame triggered vad into speech state. Last frame is in the end of \n    \t       prespeech buffer, so overwrite it */\n    \t    outidx = fe_copy_from_prespch(fe, inout_nframes, buf_cep, outidx);\n\n            /* Sets the start frame for the returned data so that caller can update timings */\n\t    if (out_frameidx) {\n    \t        *out_frameidx = (fe->num_processed_samps + orig_nsamps - *inout_nsamps) / fe->frame_shift - fe->pre_speech;\n    \t    }\n    \t} else {\n\t    outidx++;\n    \t    (*inout_nframes)--;\n    \t}\n    }\n    /* Amount of data behind the original input which is still needed. */\n    if (fe->num_overflow_samps > 0)\n        fe->num_overflow_samps -= fe->frame_shift;\n\n    return outidx;\n}\n\nint \nfe_process_frames_ext(fe_t *fe,\n                  int16 const **inout_spch,\n                  size_t *inout_nsamps,\n                  mfcc_t **buf_cep,\n                  int32 *inout_nframes,\n                  int16 *voiced_spch,\n                  int32 *voiced_spch_nsamps,\n                  int32 *out_frameidx)\n{\n    int outidx, n_overflow, orig_n_overflow;\n    int16 const *orig_spch;\n    size_t orig_nsamps;\n    \n    /* The logic here is pretty complex, please be careful with modifications */\n\n    /* FIXME: Dump PCM data if needed */\n\n    /* In the special case where there is no output buffer, return the\n     * maximum number of frames which would be generated. */\n    if (buf_cep == NULL) {\n        if (*inout_nsamps + fe->num_overflow_samps < (size_t)fe->frame_size)\n            *inout_nframes = 0;\n        else \n            *inout_nframes = 1\n                + ((*inout_nsamps + fe->num_overflow_samps - fe->frame_size)\n                   / fe->frame_shift);\n        if (!fe->vad_data->in_speech)\n            *inout_nframes += fe_prespch_ncep(fe->vad_data->prespch_buf);\n        return *inout_nframes;\n    }\n\n    if (out_frameidx)\n        *out_frameidx = 0;\n\n    /* Are there not enough samples to make at least 1 frame? */\n    if (*inout_nsamps + fe->num_overflow_samps < (size_t)fe->frame_size) {\n        if (*inout_nsamps > 0) {\n            /* Append them to the overflow buffer. */\n            memcpy(fe->overflow_samps + fe->num_overflow_samps,\n                   *inout_spch, *inout_nsamps * (sizeof(int16)));\n            fe->num_overflow_samps += *inout_nsamps;\n\t    fe->num_processed_samps += *inout_nsamps;\n            *inout_spch += *inout_nsamps;\n            *inout_nsamps = 0;\n        }\n        /* We produced no frames of output, sorry! */\n        *inout_nframes = 0;\n        return 0;\n    }\n\n    /* Can't write a frame?  Then do nothing! */\n    if (*inout_nframes < 1) {\n        *inout_nframes = 0;\n        return 0;\n    }\n\n    /* Index of output frame. */\n    outidx = 0;\n\n    /* Try to read from prespeech buffer */\n    if (fe->vad_data->in_speech && fe_prespch_ncep(fe->vad_data->prespch_buf) > 0) {\n    \toutidx = fe_copy_from_prespch(fe, inout_nframes, buf_cep, outidx);\n        if ((*inout_nframes) < 1) {\n            /* mfcc buffer is filled from prespeech buffer */\n            *inout_nframes = outidx;\n            return 0;\n        }\n    }\n\n    /* Keep track of the original start of the buffer. */\n    orig_spch = *inout_spch;\n    orig_nsamps = *inout_nsamps;\n    orig_n_overflow = fe->num_overflow_samps;\n\n    /* Start processing, taking care of any incoming overflow. */\n    if (fe->num_overflow_samps > 0) {\n        int offset = fe->frame_size - fe->num_overflow_samps;\n        /* Append start of spch to overflow samples to make a full frame. */\n        memcpy(fe->overflow_samps + fe->num_overflow_samps,\n               *inout_spch, offset * sizeof(**inout_spch));\n        fe_read_frame(fe, fe->overflow_samps, fe->frame_size);\n        /* Update input-output pointers and counters. */\n        *inout_spch += offset;\n        *inout_nsamps -= offset;\n    } else {\n        fe_read_frame(fe, *inout_spch, fe->frame_size);\n        /* Update input-output pointers and counters. */\n        *inout_spch += fe->frame_size;\n        *inout_nsamps -= fe->frame_size;\n    }\n\n    fe_write_frame(fe, buf_cep[outidx], voiced_spch != NULL);\n    outidx = fe_check_prespeech(fe, inout_nframes, buf_cep, outidx, out_frameidx, inout_nsamps, orig_nsamps);\n\n    /* Process all remaining frames. */\n    while (*inout_nframes > 0 && *inout_nsamps >= (size_t)fe->frame_shift) {\n        fe_shift_frame(fe, *inout_spch, fe->frame_shift);\n        fe_write_frame(fe, buf_cep[outidx], voiced_spch != NULL);\n\n\toutidx = fe_check_prespeech(fe, inout_nframes, buf_cep, outidx, out_frameidx, inout_nsamps, orig_nsamps);\n\n        /* Update input-output pointers and counters. */\n        *inout_spch += fe->frame_shift;\n        *inout_nsamps -= fe->frame_shift;\n    }\n\n    /* How many relevant overflow samples are there left? */\n    if (fe->num_overflow_samps <= 0) {\n        /* Maximum number of overflow samples past *inout_spch to save. */\n        n_overflow = *inout_nsamps;\n        if (n_overflow > fe->frame_shift)\n            n_overflow = fe->frame_shift;\n        fe->num_overflow_samps = fe->frame_size - fe->frame_shift;\n        /* Make sure this isn't an illegal read! */\n        if (fe->num_overflow_samps > *inout_spch - orig_spch)\n            fe->num_overflow_samps = *inout_spch - orig_spch;\n        fe->num_overflow_samps += n_overflow;\n        if (fe->num_overflow_samps > 0) {\n            memcpy(fe->overflow_samps,\n                   *inout_spch - (fe->frame_size - fe->frame_shift),\n                   fe->num_overflow_samps * sizeof(**inout_spch));\n            /* Update the input pointer to cover this stuff. */\n            *inout_spch += n_overflow;\n            *inout_nsamps -= n_overflow;\n        }\n    } else {\n        /* There is still some relevant data left in the overflow buffer. */\n        /* Shift existing data to the beginning. */\n        memmove(fe->overflow_samps,\n                fe->overflow_samps + orig_n_overflow - fe->num_overflow_samps,\n                fe->num_overflow_samps * sizeof(*fe->overflow_samps));\n        /* Copy in whatever we had in the original speech buffer. */\n        n_overflow = *inout_spch - orig_spch + *inout_nsamps;\n        if (n_overflow > fe->frame_size - fe->num_overflow_samps)\n            n_overflow = fe->frame_size - fe->num_overflow_samps;\n        memcpy(fe->overflow_samps + fe->num_overflow_samps,\n               orig_spch, n_overflow * sizeof(*orig_spch));\n        fe->num_overflow_samps += n_overflow;\n        /* Advance the input pointers. */\n        if (n_overflow > *inout_spch - orig_spch) {\n            n_overflow -= (*inout_spch - orig_spch);\n            *inout_spch += n_overflow;\n            *inout_nsamps -= n_overflow;\n        }\n    }\n\n    /* Finally update the frame counter with the number of frames\n     * and global sample counter with number of samples we procesed */\n    *inout_nframes = outidx; /* FIXME: Not sure why I wrote it this way... */\n    fe->num_processed_samps += orig_nsamps - *inout_nsamps;\n\n    return 0;\n}\n\nint\nfe_process_utt(fe_t * fe, int16 const * spch, size_t nsamps,\n               mfcc_t *** cep_block, int32 * nframes)\n{\n    mfcc_t **cep;\n    int rv;\n\n    /* Figure out how many frames we will need. */\n    fe_process_frames(fe, NULL, &nsamps, NULL, nframes, NULL);\n    /* Create the output buffer (it has to exist, even if there are no output frames). */\n    if (*nframes)\n        cep = (mfcc_t **)ckd_calloc_2d(*nframes, fe->feature_dimension, sizeof(**cep));\n    else\n        cep = (mfcc_t **)ckd_calloc_2d(1, fe->feature_dimension, sizeof(**cep));\n    /* Now just call fe_process_frames() with the allocated buffer. */\n    rv = fe_process_frames(fe, &spch, &nsamps, cep, nframes, NULL);\n    *cep_block = cep;\n\n    return rv;\n}\n\n\nint32\nfe_end_utt(fe_t * fe, mfcc_t * cepvector, int32 * nframes)\n{\n    /* Process any remaining data, not very accurate for the VAD */\n    *nframes = 0;\n    if (fe->num_overflow_samps > 0) {\n        fe_read_frame(fe, fe->overflow_samps, fe->num_overflow_samps);\n        fe_write_frame(fe, cepvector, FALSE);\n        if (fe->vad_data->in_speech)\n            *nframes = 1;\n    }\n\n    /* reset overflow buffers... */\n    fe->num_overflow_samps = 0;\n\n    return 0;\n}\n\nfe_t *\nfe_retain(fe_t *fe)\n{\n    ++fe->refcount;\n    return fe;\n}\n\nint\nfe_free(fe_t * fe)\n{\n    if (fe == NULL)\n        return 0;\n    if (--fe->refcount > 0)\n        return fe->refcount;\n\n    /* kill FE instance - free everything... */\n    if (fe->mel_fb) {\n        if (fe->mel_fb->mel_cosine)\n            fe_free_2d((void *) fe->mel_fb->mel_cosine);\n        ckd_free(fe->mel_fb->lifter);\n        ckd_free(fe->mel_fb->spec_start);\n        ckd_free(fe->mel_fb->filt_start);\n        ckd_free(fe->mel_fb->filt_width);\n        ckd_free(fe->mel_fb->filt_coeffs);\n        ckd_free(fe->mel_fb);\n    }\n    ckd_free(fe->spch);\n    ckd_free(fe->frame);\n    ckd_free(fe->ccc);\n    ckd_free(fe->sss);\n    ckd_free(fe->spec);\n    ckd_free(fe->mfspec);\n    ckd_free(fe->overflow_samps);\n    ckd_free(fe->hamming_window);\n\n    if (fe->noise_stats)\n        fe_free_noisestats(fe->noise_stats);\n\n    if (fe->vad_data) {\n        fe_prespch_free(fe->vad_data->prespch_buf);\n\tckd_free(fe->vad_data);\n    }\n\n    cmd_ln_free_r(fe->config);\n    ckd_free(fe);\n\n    return 0;\n}\n\n/**\n * Convert a block of mfcc_t to float32 (can be done in-place)\n **/\nint32\nfe_mfcc_to_float(fe_t * fe,\n                 mfcc_t ** input, float32 ** output, int32 nframes)\n{\n    int32 i;\n\n#ifndef FIXED_POINT\n    if ((void *) input == (void *) output)\n        return nframes * fe->feature_dimension;\n#endif\n    for (i = 0; i < nframes * fe->feature_dimension; ++i)\n        output[0][i] = MFCC2FLOAT(input[0][i]);\n\n    return i;\n}\n\n/**\n * Convert a block of float32 to mfcc_t (can be done in-place)\n **/\nint32\nfe_float_to_mfcc(fe_t * fe,\n                 float32 ** input, mfcc_t ** output, int32 nframes)\n{\n    int32 i;\n\n#ifndef FIXED_POINT\n    if ((void *) input == (void *) output)\n        return nframes * fe->feature_dimension;\n#endif\n    for (i = 0; i < nframes * fe->feature_dimension; ++i)\n        output[0][i] = FLOAT2MFCC(input[0][i]);\n\n    return i;\n}\n\nint32\nfe_logspec_to_mfcc(fe_t * fe, const mfcc_t * fr_spec, mfcc_t * fr_cep)\n{\n#ifdef FIXED_POINT\n    fe_spec2cep(fe, fr_spec, fr_cep);\n#else                           /* ! FIXED_POINT */\n    powspec_t *powspec;\n    int32 i;\n\n    powspec = ckd_malloc(fe->mel_fb->num_filters * sizeof(powspec_t));\n    for (i = 0; i < fe->mel_fb->num_filters; ++i)\n        powspec[i] = (powspec_t) fr_spec[i];\n    fe_spec2cep(fe, powspec, fr_cep);\n    ckd_free(powspec);\n#endif                          /* ! FIXED_POINT */\n    return 0;\n}\n\nint32\nfe_logspec_dct2(fe_t * fe, const mfcc_t * fr_spec, mfcc_t * fr_cep)\n{\n#ifdef FIXED_POINT\n    fe_dct2(fe, fr_spec, fr_cep, 0);\n#else                           /* ! FIXED_POINT */\n    powspec_t *powspec;\n    int32 i;\n\n    powspec = ckd_malloc(fe->mel_fb->num_filters * sizeof(powspec_t));\n    for (i = 0; i < fe->mel_fb->num_filters; ++i)\n        powspec[i] = (powspec_t) fr_spec[i];\n    fe_dct2(fe, powspec, fr_cep, 0);\n    ckd_free(powspec);\n#endif                          /* ! FIXED_POINT */\n    return 0;\n}\n\nint32\nfe_mfcc_dct3(fe_t * fe, const mfcc_t * fr_cep, mfcc_t * fr_spec)\n{\n#ifdef FIXED_POINT\n    fe_dct3(fe, fr_cep, fr_spec);\n#else                           /* ! FIXED_POINT */\n    powspec_t *powspec;\n    int32 i;\n\n    powspec = ckd_malloc(fe->mel_fb->num_filters * sizeof(powspec_t));\n    fe_dct3(fe, fr_cep, powspec);\n    for (i = 0; i < fe->mel_fb->num_filters; ++i)\n        fr_spec[i] = (mfcc_t) powspec[i];\n    ckd_free(powspec);\n#endif                          /* ! FIXED_POINT */\n    return 0;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1996-2004 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4244)\n#endif\n\n/**\n * Windows math.h does not contain M_PI\n */\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/byteorder.h\"\n#include \"sphinxbase/fixpoint.h\"\n#include \"sphinxbase/fe.h\"\n#include \"sphinxbase/genrand.h\"\n#include \"sphinxbase/err.h\"\n\n#include \"fe_internal.h\"\n#include \"fe_warp.h\"\n\n/* Use extra precision for cosines, Hamming window, pre-emphasis\n * coefficient, twiddle factors. */\n#ifdef FIXED_POINT\n#define FLOAT2COS(x) FLOAT2FIX_ANY(x,30)\n#define COSMUL(x,y) FIXMUL_ANY(x,y,30)\n#else\n#define FLOAT2COS(x) (x)\n#define COSMUL(x,y) ((x)*(y))\n#endif\n\n#ifdef FIXED_POINT\n\n/* Internal log-addition table for natural log with radix point at 8\n * bits.  Each entry is 256 * log(1 + e^{-n/256}).  This is used in the\n * log-add computation:\n *\n * e^z = e^x + e^y\n * e^z = e^x(1 + e^{y-x})     = e^y(1 + e^{x-y})\n * z   = x + log(1 + e^{y-x}) = y + log(1 + e^{x-y})\n *\n * So when y > x, z = y + logadd_table[-(x-y)]\n *    when x > y, z = x + logadd_table[-(y-x)]\n */\nstatic const unsigned char fe_logadd_table[] = {\n    177, 177, 176, 176, 175, 175, 174, 174, 173, 173,\n    172, 172, 172, 171, 171, 170, 170, 169, 169, 168,\n    168, 167, 167, 166, 166, 165, 165, 164, 164, 163,\n    163, 162, 162, 161, 161, 161, 160, 160, 159, 159,\n    158, 158, 157, 157, 156, 156, 155, 155, 155, 154,\n    154, 153, 153, 152, 152, 151, 151, 151, 150, 150,\n    149, 149, 148, 148, 147, 147, 147, 146, 146, 145,\n    145, 144, 144, 144, 143, 143, 142, 142, 141, 141,\n    141, 140, 140, 139, 139, 138, 138, 138, 137, 137,\n    136, 136, 136, 135, 135, 134, 134, 134, 133, 133,\n    132, 132, 131, 131, 131, 130, 130, 129, 129, 129,\n    128, 128, 128, 127, 127, 126, 126, 126, 125, 125,\n    124, 124, 124, 123, 123, 123, 122, 122, 121, 121,\n    121, 120, 120, 119, 119, 119, 118, 118, 118, 117,\n    117, 117, 116, 116, 115, 115, 115, 114, 114, 114,\n    113, 113, 113, 112, 112, 112, 111, 111, 110, 110,\n    110, 109, 109, 109, 108, 108, 108, 107, 107, 107,\n    106, 106, 106, 105, 105, 105, 104, 104, 104, 103,\n    103, 103, 102, 102, 102, 101, 101, 101, 100, 100,\n    100, 99, 99, 99, 98, 98, 98, 97, 97, 97,\n    96, 96, 96, 96, 95, 95, 95, 94, 94, 94,\n    93, 93, 93, 92, 92, 92, 92, 91, 91, 91,\n    90, 90, 90, 89, 89, 89, 89, 88, 88, 88,\n    87, 87, 87, 87, 86, 86, 86, 85, 85, 85,\n    85, 84, 84, 84, 83, 83, 83, 83, 82, 82,\n    82, 82, 81, 81, 81, 80, 80, 80, 80, 79,\n    79, 79, 79, 78, 78, 78, 78, 77, 77, 77,\n    77, 76, 76, 76, 75, 75, 75, 75, 74, 74,\n    74, 74, 73, 73, 73, 73, 72, 72, 72, 72,\n    71, 71, 71, 71, 71, 70, 70, 70, 70, 69,\n    69, 69, 69, 68, 68, 68, 68, 67, 67, 67,\n    67, 67, 66, 66, 66, 66, 65, 65, 65, 65,\n    64, 64, 64, 64, 64, 63, 63, 63, 63, 63,\n    62, 62, 62, 62, 61, 61, 61, 61, 61, 60,\n    60, 60, 60, 60, 59, 59, 59, 59, 59, 58,\n    58, 58, 58, 58, 57, 57, 57, 57, 57, 56,\n    56, 56, 56, 56, 55, 55, 55, 55, 55, 54,\n    54, 54, 54, 54, 53, 53, 53, 53, 53, 52,\n    52, 52, 52, 52, 52, 51, 51, 51, 51, 51,\n    50, 50, 50, 50, 50, 50, 49, 49, 49, 49,\n    49, 49, 48, 48, 48, 48, 48, 48, 47, 47,\n    47, 47, 47, 47, 46, 46, 46, 46, 46, 46,\n    45, 45, 45, 45, 45, 45, 44, 44, 44, 44,\n    44, 44, 43, 43, 43, 43, 43, 43, 43, 42,\n    42, 42, 42, 42, 42, 41, 41, 41, 41, 41,\n    41, 41, 40, 40, 40, 40, 40, 40, 40, 39,\n    39, 39, 39, 39, 39, 39, 38, 38, 38, 38,\n    38, 38, 38, 37, 37, 37, 37, 37, 37, 37,\n    37, 36, 36, 36, 36, 36, 36, 36, 35, 35,\n    35, 35, 35, 35, 35, 35, 34, 34, 34, 34,\n    34, 34, 34, 34, 33, 33, 33, 33, 33, 33,\n    33, 33, 32, 32, 32, 32, 32, 32, 32, 32,\n    32, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n    30, 30, 30, 30, 30, 30, 30, 30, 30, 29,\n    29, 29, 29, 29, 29, 29, 29, 29, 28, 28,\n    28, 28, 28, 28, 28, 28, 28, 28, 27, 27,\n    27, 27, 27, 27, 27, 27, 27, 27, 26, 26,\n    26, 26, 26, 26, 26, 26, 26, 26, 25, 25,\n    25, 25, 25, 25, 25, 25, 25, 25, 25, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 22, 22, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 21, 21, 21, 21, 21, 21,\n    21, 21, 21, 21, 21, 21, 21, 20, 20, 20,\n    20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n    19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n    19, 19, 19, 19, 18, 18, 18, 18, 18, 18,\n    18, 18, 18, 18, 18, 18, 18, 18, 18, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 11,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n    11, 11, 11, 10, 10, 10, 10, 10, 10, 10,\n    10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n    10, 10, 10, 10, 10, 10, 10, 10, 10, 9,\n    9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n    9, 9, 9, 9, 9, 9, 9, 9, 9, 9,\n    9, 9, 9, 9, 9, 9, 9, 9, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 0\n};\n\nstatic const int fe_logadd_table_size =\n    sizeof(fe_logadd_table) / sizeof(fe_logadd_table[0]);\n\nfixed32\nfe_log_add(fixed32 x, fixed32 y)\n{\n    fixed32 d, r;\n\n    if (x > y) {\n        d = (x - y) >> (DEFAULT_RADIX - 8);\n        r = x;\n    }\n    else {\n        d = (y - x) >> (DEFAULT_RADIX - 8);\n        r = y;\n    }\n\n    if (r <= MIN_FIXLOG)\n\treturn MIN_FIXLOG;\n    else if (d > fe_logadd_table_size - 1)\n        return r;\n    else {\n        r += ((fixed32) fe_logadd_table[d] << (DEFAULT_RADIX - 8));\n/*        printf(\"%d - %d = %d | %f - %f = %f | %f - %f = %f\\n\",\n               x, y, r, FIX2FLOAT(x), FIX2FLOAT(y), FIX2FLOAT(r),\n               exp(FIX2FLOAT(x)), exp(FIX2FLOAT(y)), exp(FIX2FLOAT(r)));\n*/\n        return r;\n    }\n}\n\n/*\n * log_sub for spectral subtraction, similar to logadd but we had\n * to smooth function around zero with fixlog in order to improve\n * table interpolation properties\n *\n * The table is created with the file included into distribution\n *\n * e^z = e^x - e^y\n * e^z = e^x (1 - e^(-(x - y)))\n * z = x + log(1 - e^(-(x - y)))\n * z = x + fixlog(a) + (log(1 - e^(- a)) - log(a))\n *\n * Input radix is 8 output radix is 10\n */\nstatic const uint16 fe_logsub_table[] = {\n1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n21, 23, 25, 27, 29, 31, 33, 35, 37, 39,\n41, 43, 45, 47, 49, 51, 53, 55, 56, 58,\n60, 62, 64, 66, 68, 70, 72, 74, 76, 78,\n80, 82, 84, 86, 88, 90, 92, 94, 95, 97,\n99, 101, 103, 105, 107, 109, 111, 113, 115, 117,\n119, 121, 122, 124, 126, 128, 130, 132, 134, 136,\n138, 140, 142, 143, 145, 147, 149, 151, 153, 155,\n157, 159, 161, 162, 164, 166, 168, 170, 172, 174,\n176, 178, 179, 181, 183, 185, 187, 189, 191, 193,\n194, 196, 198, 200, 202, 204, 206, 207, 209, 211,\n213, 215, 217, 219, 220, 222, 224, 226, 228, 230,\n232, 233, 235, 237, 239, 241, 243, 244, 246, 248,\n250, 252, 254, 255, 257, 259, 261, 263, 265, 266,\n268, 270, 272, 274, 275, 277, 279, 281, 283, 284,\n286, 288, 290, 292, 294, 295, 297, 299, 301, 302,\n304, 306, 308, 310, 311, 313, 315, 317, 319, 320,\n322, 324, 326, 327, 329, 331, 333, 335, 336, 338,\n340, 342, 343, 345, 347, 349, 350, 352, 354, 356,\n357, 359, 361, 363, 364, 366, 368, 370, 371, 373,\n375, 377, 378, 380, 382, 384, 385, 387, 389, 391,\n392, 394, 396, 397, 399, 401, 403, 404, 406, 408,\n410, 411, 413, 415, 416, 418, 420, 422, 423, 425,\n427, 428, 430, 432, 433, 435, 437, 439, 440, 442,\n444, 445, 447, 449, 450, 452, 454, 455, 457, 459,\n460, 462, 464, 465, 467, 469, 471, 472, 474, 476,\n477, 479, 481, 482, 484, 486, 487, 489, 490, 492,\n494, 495, 497, 499, 500, 502, 504, 505, 507, 509,\n510, 512, 514, 515, 517, 518, 520, 522, 523, 525,\n527, 528, 530, 532, 533, 535, 536, 538, 540, 541,\n543, 544, 546, 548, 549, 551, 553, 554, 556, 557,\n559, 561, 562, 564, 565, 567, 569, 570, 572, 573,\n575, 577, 578, 580, 581, 583, 585, 586, 588, 589,\n591, 592, 594, 596, 597, 599, 600, 602, 603, 605,\n607, 608, 610, 611, 613, 614, 616, 618, 619, 621,\n622, 624, 625, 627, 628, 630, 632, 633, 635, 636,\n638, 639, 641, 642, 644, 645, 647, 649, 650, 652,\n653, 655, 656, 658, 659, 661, 662, 664, 665, 667,\n668, 670, 671, 673, 674, 676, 678, 679, 681, 682,\n684, 685, 687, 688, 690, 691, 693, 694, 696, 697,\n699, 700, 702, 703, 705, 706, 708, 709, 711, 712,\n714, 715, 717, 718, 719, 721, 722, 724, 725, 727,\n728, 730, 731, 733, 734, 736, 737, 739, 740, 742,\n743, 745, 746, 747, 749, 750, 752, 753, 755, 756,\n758, 759, 761, 762, 763, 765, 766, 768, 769, 771,\n772, 774, 775, 776, 778, 779, 781, 782, 784, 785,\n786, 788, 789, 791, 792, 794, 795, 796, 798, 799,\n801, 802, 804, 805, 806, 808, 809, 811, 812, 813,\n815, 816, 818, 819, 820, 822, 823, 825, 826, 827,\n829, 830, 832, 833, 834, 836, 837, 839, 840, 841,\n843, 844, 846, 847, 848, 850, 851, 852, 854, 855,\n857, 858, 859, 861, 862, 863, 865, 866, 868, 869,\n870, 872, 873, 874, 876, 877, 878, 880, 881, 883,\n884, 885, 887, 888, 889, 891, 892, 893, 895, 896,\n897, 899, 900, 901, 903, 904, 905, 907, 908, 909,\n911, 912, 913, 915, 916, 917, 919, 920, 921, 923,\n924, 925, 927, 928, 929, 931, 932, 933, 935, 936,\n937, 939, 940, 941, 942, 944, 945, 946, 948, 949,\n950, 952, 953, 954, 956, 957, 958, 959, 961, 962,\n963, 965, 966, 967, 968, 970, 971, 972, 974, 975,\n976, 977, 979, 980, 981, 983, 984, 985, 986, 988,\n989, 990, 991, 993, 994, 995, 997, 998, 999, 1000,\n1002, 1003, 1004, 1005, 1007, 1008, 1009, 1010, 1012, 1013,\n1014, 1015, 1017, 1018, 1019, 1020, 1022, 1023, 1024, 1025,\n1027, 1028, 1029, 1030, 1032, 1033, 1034, 1035, 1037, 1038,\n1039, 1040, 1041, 1043, 1044, 1045, 1046, 1048, 1049, 1050,\n1051, 1052, 1054, 1055, 1056, 1057, 1059, 1060, 1061, 1062,\n1063, 1065, 1066, 1067, 1068, 1069, 1071, 1072, 1073, 1074,\n1076, 1077, 1078, 1079, 1080, 1082, 1083, 1084, 1085, 1086,\n1087, 1089, 1090, 1091, 1092, 1093, 1095, 1096, 1097, 1098,\n1099, 1101, 1102, 1103, 1104, 1105, 1106, 1108, 1109, 1110,\n1111, 1112, 1114, 1115, 1116, 1117, 1118, 1119, 1121, 1122,\n1123, 1124, 1125, 1126, 1128, 1129, 1130, 1131, 1132, 1133,\n1135, 1136, 1137, 1138, 1139, 1140, 1141, 1143, 1144, 1145,\n1146, 1147, 1148, 1149, 1151, 1152, 1153, 1154, 1155, 1156,\n1157, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1167, 1168,\n1169, 1170, 1171, 1172, 1173, 1174, 1176, 1177, 1178, 1179,\n1180, 1181, 1182, 1183, 1185, 1186, 1187, 1188, 1189, 1190,\n1191, 1192, 1193, 1195, 1196, 1197, 1198, 1199, 1200, 1201,\n1202, 1203, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212,\n1213, 1214, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223,\n1224, 1225, 1226, 1228, 1229, 1230, 1231, 1232, 1233, 1234,\n1235, 1236, 1237, 1238, 1239, 1240, 1242, 1243, 1244, 1245,\n1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255,\n1256, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266,\n1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1277,\n1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287,\n1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297,\n1298, 1299, 1300, 1301, 1302, 1303, 1305, 1306, 1307, 1308,\n1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318,\n1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328,\n1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338,\n1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348,\n1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358,\n1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368,\n1369, 1370, 1371, 1372, 1372, 1373, 1374, 1375, 1376, 1377,\n1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387,\n1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397,\n1398, 1399, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406,\n1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416,\n1417, 1418, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425,\n1426, 1427, 1428, 1429, 1430, 1431, 1432, 1432, 1433, 1434,\n1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444,\n1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453,\n1454, 1455, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462,\n1463, 1464, 1465, 1466, 1466, 1467, 1468, 1469, 1470, 1471,\n1472, 1473, 1474, 1475, 1475, 1476, 1477, 1478, 1479, 1480,\n1481, 1482, 1483, 1483, 1484, 1485, 1486, 1487, 1488, 1489,\n1490, 1491, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498,\n1499, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1506,\n1507, 1508, 1509, 1510, 1511, 1512, 1513, 1513, 1514, 1515,\n1516, 1517, 1518, 1519, 1520, 1520, 1521, 1522, 1523, 1524,\n1525, 1526, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1532,\n1533, 1534, 1535, 1536, 1537, 1538, 1538, 1539, 1540, 1541,\n1542, 1543, 1544, 1544, 1545, 1546, 1547, 1548, 1549, 1550,\n1550, 1551, 1552, 1553, 1554, 1555, 1555, 1556, 1557, 1558,\n1559, 1560, 1560, 1561, 1562, 1563, 1564, 1565, 1565, 1566,\n1567, 1568, 1569, 1570, 1570, 1571, 1572, 1573, 1574, 1575,\n1575, 1576, 1577, 1578, 1579, 1580, 1580, 1581, 1582, 1583,\n1584, 1584, 1585, 1586, 1587, 1588, 1589, 1589, 1590, 1591,\n1592, 1593, 1593, 1594, 1595, 1596, 1597, 1598, 1598, 1599,\n1600, 1601, 1602, 1602, 1603, 1604, 1605, 1606, 1606, 1607,\n1608, 1609, 1610, 1610, 1611, 1612, 1613, 1614, 1614, 1615,\n1616, 1617, 1618, 1618, 1619, 1620, 1621, 1622, 1622, 1623,\n1624, 1625, 1626, 1626, 1627, 1628, 1629, 1630, 1630, 1631,\n1632, 1633, 1634, 1634, 1635, 1636, 1637, 1637, 1638, 1639,\n1640, 1641, 1641, 1642, 1643, 1644, 1645, 1645, 1646, 1647,\n1648, 1648, 1649, 1650, 1651, 1652, 1652, 1653, 1654, 1655,\n1655, 1656, 1657, 1658, 1658, 1659, 1660, 1661, 1662, 1662,\n1663, 1664, 1665, 1665, 1666, 1667, 1668, 1668, 1669, 1670,\n1671, 1671, 1672, 1673, 1674, 1675, 1675, 1676, 1677, 1678,\n1678, 1679, 1680, 1681, 1681, 1682, 1683, 1684, 1684, 1685,\n1686, 1687, 1687, 1688, 1689, 1690, 1690, 1691, 1692, 1693,\n1693, 1694, 1695, 1696, 1696, 1697, 1698, 1699, 1699, 1700,\n1701, 1702, 1702, 1703, 1704, 1705, 1705, 1706, 1707, 1707,\n1708, 1709, 1710, 1710, 1711, 1712, 1713, 1713, 1714, 1715,\n1716, 1716, 1717, 1718, 1718, 1719, 1720, 1721, 1721, 1722,\n1723, 1724, 1724, 1725, 1726, 1727, 1727, 1728, 1729, 1729,\n1730, 1731, 1732, 1732, 1733, 1734, 1734, 1735, 1736, 1737,\n1737, 1738, 1739, 1740, 1740, 1741, 1742, 1742, 1743, 1744,\n1745, 1745, 1746, 1747, 1747, 1748, 1749, 1749, 1750, 1751,\n1752, 1752, 1753, 1754, 1754, 1755, 1756, 1757, 1757, 1758,\n1759, 1759, 1760, 1761, 1762, 1762, 1763, 1764, 1764, 1765,\n1766, 1766, 1767, 1768, 1769, 1769, 1770, 1771, 1771, 1772,\n1773, 1773, 1774, 1775, 1776, 1776, 1777, 1778, 1778, 1779,\n1780, 1780, 1781, 1782, 1782, 1783, 1784, 1784, 1785, 1786,\n1787, 1787, 1788, 1789, 1789, 1790, 1791, 1791, 1792, 1793,\n1793, 1794, 1795, 1795, 1796, 1797, 1798, 1798, 1799, 1800,\n1800, 1801, 1802, 1802, 1803, 1804, 1804, 1805, 1806, 1806,\n1807, 1808, 1808, 1809, 1810, 1810, 1811, 1812, 1812, 1813,\n1814, 1814, 1815, 1816, 1816, 1817, 1818, 1818, 1819, 1820,\n1820, 1821, 1822, 1822, 1823, 1824, 1824, 1825, 1826, 1826,\n1827, 1828, 1828, 1829, 1830, 1830, 1831, 1832, 1832, 1833,\n1834, 1834, 1835, 1836, 1836, 1837, 1838, 1838, 1839, 1840,\n1840, 1841, 1842, 1842, 1843, 1844, 1844, 1845, 1845, 1846,\n1847, 1847, 1848, 1849, 1849, 1850, 1851, 1851, 1852, 1853,\n1853, 1854, 1855, 1855, 1856, 1857, 1857, 1858, 1858, 1859,\n1860, 1860, 1861, 1862, 1862, 1863, 1864, 1864, 1865, 1866,\n1866, 1867, 1867, 1868, 1869, 1869, 1870, 1871, 1871, 1872,\n1873, 1873, 1874, 1874, 1875, 1876, 1876, 1877, 1878, 1878,\n1879, 1879, 1880, 1881, 1881, 1882, 1883, 1883, 1884, 1885,\n1885, 1886, 1886, 1887, 1888, 1888, 1889, 1890, 1890, 1891,\n1891, 1892, 1893, 1893, 1894, 1895, 1895, 1896, 1896, 1897,\n1898, 1898, 1899, 1900, 1900, 1901, 1901, 1902, 1903, 1903,\n1904, 1904, 1905, 1906, 1906, 1907, 1908, 1908, 1909, 1909,\n1910, 1911, 1911, 1912, 1912, 1913, 1914, 1914, 1915, 1916,\n1916, 1917, 1917, 1918, 1919, 1919, 1920, 1920, 1921, 1922,\n1922, 1923, 1923, 1924, 1925, 1925, 1926, 1926, 1927, 1928,\n1928, 1929, 1929, 1930, 1931, 1931, 1932, 1932, 1933, 1934,\n1934, 1935, 1935, 1936, 1937, 1937, 1938, 1938, 1939, 1940,\n1940, 1941, 1941, 1942, 1943, 1943, 1944, 1944, 1945, 1946,\n1946, 1947, 1947, 1948, 1949, 1949, 1950, 1950, 1951, 1952,\n1952, 1953, 1953, 1954, 1955, 1955, 1956, 1956, 1957, 1957,\n1958, 1959, 1959, 1960, 1960, 1961, 1962, 1962, 1963, 1963,\n1964, 1964, 1965, 1966, 1966, 1967, 1967, 1968, 1969, 1969,\n1970, 1970, 1971, 1971, 1972, 1973, 1973, 1974, 1974, 1975,\n1976, 1976, 1977, 1977, 1978, 1978, 1979, 1980, 1980, 1981,\n1981, 1982, 1982, 1983, 1984, 1984, 1985, 1985, 1986, 1986,\n1987, 1988, 1988, 1989, 1989, 1990, 1990, 1991, 1992, 1992,\n1993, 1993, 1994, 1994, 1995, 1996, 1996, 1997, 1997, 1998,\n1998, 1999, 1999, 2000, 2001, 2001, 2002, 2002, 2003, 2003,\n2004, 2005, 2005, 2006, 2006, 2007, 2007, 2008, 2008, 2009,\n2010, 2010, 2011, 2011, 2012, 2012, 2013, 2014, 2014, 2015,\n2015, 2016, 2016, 2017, 2017, 2018, 2019, 2019, 2020, 2020,\n2021, 2021, 2022, 2022, 2023, 2023, 2024, 2025, 2025, 2026,\n2026, 2027, 2027, 2028, 2028, 2029, 2030, 2030, 2031, 2031,\n2032, 2032, 2033, 2033, 2034, 2034, 2035, 2036, 2036, 2037,\n2037, 2038, 2038, 2039, 2039, 2040, 2040, 2041, 2042, 2042,\n2043, 2043, 2044, 2044, 2045, 2045, 2046, 2046, 2047, 2048,\n2048, 2049, 2049, 2050, 2050, 2051, 2051, 2052, 2052, 2053,\n2053, 2054, 2054, 2055, 2056, 2056, 2057, 2057, 2058, 2058,\n2059, 2059, 2060, 2060, 2061, 2061, 2062, 2062, 2063, 2064,\n2064, 2065, 2065, 2066, 2066, 2067, 2067, 2068, 2068, 2069,\n2069, 2070, 2070, 2071, 2072, 2072, 2073, 2073, 2074, 2074,\n2075, 2075, 2076, 2076, 2077, 2077, 2078, 2078, 2079, 2079,\n2080, 2080, 2081\n};\n\nstatic const int fe_logsub_table_size =\n    sizeof(fe_logsub_table) / sizeof(fe_logsub_table[0]);\n\nfixed32\nfe_log_sub(fixed32 x, fixed32 y)\n{\n    fixed32 d, r;\n\n    if (x < MIN_FIXLOG || y >= x)\n\treturn MIN_FIXLOG;\n\n    d = (x - y) >> (DEFAULT_RADIX - 8);\n    \n    if (d > fe_logsub_table_size - 1)\n        return x;\n\n    r = fe_logsub_table[d] << (DEFAULT_RADIX - 10);\n/*\n    printf(\"diff=%d\\n\", \n    \t    x + FIXLN(x-y) - r -\n\t    (x + FLOAT2FIX(logf(-expm1f(FIX2FLOAT(y - x))))));\n*/\n    return x + FIXLN(x-y) - r;\n}\n\nstatic fixed32\nfe_log(float32 x)\n{\n    if (x <= 0) {\n        return MIN_FIXLOG;\n    }\n    else {\n        return FLOAT2FIX(log(x));\n    }\n}\n#endif\n\nstatic float32\nfe_mel(melfb_t * mel, float32 x)\n{\n    float32 warped = fe_warp_unwarped_to_warped(mel, x);\n\n    return (float32) (2595.0 * log10(1.0 + warped / 700.0));\n}\n\nstatic float32\nfe_melinv(melfb_t * mel, float32 x)\n{\n    float32 warped = (float32) (700.0 * (pow(10.0, x / 2595.0) - 1.0));\n    return fe_warp_warped_to_unwarped(mel, warped);\n}\n\nint32\nfe_build_melfilters(melfb_t * mel_fb)\n{\n    float32 melmin, melmax, melbw, fftfreq;\n    int n_coeffs, i, j;\n\n\n    /* Filter coefficient matrix, in flattened form. */\n    mel_fb->spec_start =\n        ckd_calloc(mel_fb->num_filters, sizeof(*mel_fb->spec_start));\n    mel_fb->filt_start =\n        ckd_calloc(mel_fb->num_filters, sizeof(*mel_fb->filt_start));\n    mel_fb->filt_width =\n        ckd_calloc(mel_fb->num_filters, sizeof(*mel_fb->filt_width));\n\n    /* First calculate the widths of each filter. */\n    /* Minimum and maximum frequencies in mel scale. */\n    melmin = fe_mel(mel_fb, mel_fb->lower_filt_freq);\n    melmax = fe_mel(mel_fb, mel_fb->upper_filt_freq);\n\n    /* Width of filters in mel scale */\n    melbw = (melmax - melmin) / (mel_fb->num_filters + 1);\n    if (mel_fb->doublewide) {\n        melmin -= melbw;\n        melmax += melbw;\n        if ((fe_melinv(mel_fb, melmin) < 0) ||\n            (fe_melinv(mel_fb, melmax) > mel_fb->sampling_rate / 2)) {\n            E_WARN\n                (\"Out of Range: low  filter edge = %f (%f)\\n\",\n                 fe_melinv(mel_fb, melmin), 0.0);\n            E_WARN\n                (\"              high filter edge = %f (%f)\\n\",\n                 fe_melinv(mel_fb, melmax), mel_fb->sampling_rate / 2);\n            return FE_INVALID_PARAM_ERROR;\n        }\n    }\n\n    /* DFT point spacing */\n    fftfreq = mel_fb->sampling_rate / (float32) mel_fb->fft_size;\n\n    /* Count and place filter coefficients. */\n    n_coeffs = 0;\n    for (i = 0; i < mel_fb->num_filters; ++i) {\n        float32 freqs[3];\n\n        /* Left, center, right frequencies in Hertz */\n        for (j = 0; j < 3; ++j) {\n            if (mel_fb->doublewide)\n                freqs[j] = fe_melinv(mel_fb, (i + j * 2) * melbw + melmin);\n            else\n                freqs[j] = fe_melinv(mel_fb, (i + j) * melbw + melmin);\n            /* Round them to DFT points if requested */\n            if (mel_fb->round_filters)\n                freqs[j] = ((int) (freqs[j] / fftfreq + 0.5)) * fftfreq;\n        }\n\n        /* spec_start is the start of this filter in the power spectrum. */\n        mel_fb->spec_start[i] = -1;\n        /* There must be a better way... */\n        for (j = 0; j < mel_fb->fft_size / 2 + 1; ++j) {\n            float32 hz = j * fftfreq;\n            if (hz < freqs[0])\n                continue;\n            else if (hz > freqs[2] || j == mel_fb->fft_size / 2) {\n                /* filt_width is the width in DFT points of this filter. */\n                mel_fb->filt_width[i] = j - mel_fb->spec_start[i];\n                /* filt_start is the start of this filter in the filt_coeffs array. */\n                mel_fb->filt_start[i] = n_coeffs;\n                n_coeffs += mel_fb->filt_width[i];\n                break;\n            }\n            if (mel_fb->spec_start[i] == -1)\n                mel_fb->spec_start[i] = j;\n        }\n    }\n\n    /* Now go back and allocate the coefficient array. */\n    mel_fb->filt_coeffs =\n        ckd_malloc(n_coeffs * sizeof(*mel_fb->filt_coeffs));\n\n    /* And now generate the coefficients. */\n    n_coeffs = 0;\n    for (i = 0; i < mel_fb->num_filters; ++i) {\n        float32 freqs[3];\n\n        /* Left, center, right frequencies in Hertz */\n        for (j = 0; j < 3; ++j) {\n            if (mel_fb->doublewide)\n                freqs[j] = fe_melinv(mel_fb, (i + j * 2) * melbw + melmin);\n            else\n                freqs[j] = fe_melinv(mel_fb, (i + j) * melbw + melmin);\n            /* Round them to DFT points if requested */\n            if (mel_fb->round_filters)\n                freqs[j] = ((int) (freqs[j] / fftfreq + 0.5)) * fftfreq;\n        }\n\n        for (j = 0; j < mel_fb->filt_width[i]; ++j) {\n            float32 hz, loslope, hislope;\n\n            hz = (mel_fb->spec_start[i] + j) * fftfreq;\n            if (hz < freqs[0] || hz > freqs[2]) {\n                E_FATAL\n                    (\"Failed to create filterbank, frequency range does not match. \"\n                     \"Sample rate %f, FFT size %d, lowerf %f < freq %f > upperf %f.\\n\",\n                     mel_fb->sampling_rate, mel_fb->fft_size, freqs[0], hz,\n                     freqs[2]);\n            }\n            loslope = (hz - freqs[0]) / (freqs[1] - freqs[0]);\n            hislope = (freqs[2] - hz) / (freqs[2] - freqs[1]);\n            if (mel_fb->unit_area) {\n                loslope *= 2 / (freqs[2] - freqs[0]);\n                hislope *= 2 / (freqs[2] - freqs[0]);\n            }\n            if (loslope < hislope) {\n#ifdef FIXED_POINT\n                mel_fb->filt_coeffs[n_coeffs] = fe_log(loslope);\n#else\n                mel_fb->filt_coeffs[n_coeffs] = loslope;\n#endif\n            }\n            else {\n#ifdef FIXED_POINT\n                mel_fb->filt_coeffs[n_coeffs] = fe_log(hislope);\n#else\n                mel_fb->filt_coeffs[n_coeffs] = hislope;\n#endif\n            }\n            ++n_coeffs;\n        }\n    }\n\n    return FE_SUCCESS;\n}\n\nint32\nfe_compute_melcosine(melfb_t * mel_fb)\n{\n\n    float64 freqstep;\n    int32 i, j;\n\n    mel_fb->mel_cosine =\n        (mfcc_t **) ckd_calloc_2d(mel_fb->num_cepstra,\n                                  mel_fb->num_filters, sizeof(mfcc_t));\n\n    freqstep = M_PI / mel_fb->num_filters;\n    /* NOTE: The first row vector is actually unnecessary but we leave\n     * it in to avoid confusion. */\n    for (i = 0; i < mel_fb->num_cepstra; i++) {\n        for (j = 0; j < mel_fb->num_filters; j++) {\n            float64 cosine;\n\n            cosine = cos(freqstep * i * (j + 0.5));\n            mel_fb->mel_cosine[i][j] = FLOAT2COS(cosine);\n        }\n    }\n\n    /* Also precompute normalization constants for unitary DCT. */\n    mel_fb->sqrt_inv_n = FLOAT2COS(sqrt(1.0 / mel_fb->num_filters));\n    mel_fb->sqrt_inv_2n = FLOAT2COS(sqrt(2.0 / mel_fb->num_filters));\n\n    /* And liftering weights */\n    if (mel_fb->lifter_val) {\n        mel_fb->lifter =\n            calloc(mel_fb->num_cepstra, sizeof(*mel_fb->lifter));\n        for (i = 0; i < mel_fb->num_cepstra; ++i) {\n            mel_fb->lifter[i] = FLOAT2MFCC(1 + mel_fb->lifter_val / 2\n                                           * sin(i * M_PI /\n                                                 mel_fb->lifter_val));\n        }\n    }\n\n    return (0);\n}\n\nstatic void\nfe_pre_emphasis(int16 const *in, frame_t * out, int32 len,\n                float32 factor, int16 prior)\n{\n    int i;\n\n#if defined(FIXED_POINT)\n    fixed32 fxd_alpha = FLOAT2FIX(factor);\n    out[0] = ((fixed32) in[0] << DEFAULT_RADIX) - (prior * fxd_alpha);\n    for (i = 1; i < len; ++i)\n        out[i] = ((fixed32) in[i] << DEFAULT_RADIX)\n            - (fixed32) in[i - 1] * fxd_alpha;\n#else\n    out[0] = (frame_t) in[0] - (frame_t) prior *factor;\n    for (i = 1; i < len; i++)\n        out[i] = (frame_t) in[i] - (frame_t) in[i - 1] * factor;\n#endif\n}\n\nstatic void\nfe_short_to_frame(int16 const *in, frame_t * out, int32 len)\n{\n    int i;\n\n#if defined(FIXED_POINT)\n    for (i = 0; i < len; i++)\n        out[i] = (int32) in[i] << DEFAULT_RADIX;\n#else                           /* FIXED_POINT */\n    for (i = 0; i < len; i++)\n        out[i] = (frame_t) in[i];\n#endif                          /* FIXED_POINT */\n}\n\nvoid\nfe_create_hamming(window_t * in, int32 in_len)\n{\n    int i;\n\n    /* Symmetric, so we only create the first half of it. */\n    for (i = 0; i < in_len / 2; i++) {\n        float64 hamm;\n        hamm = (0.54 - 0.46 * cos(2 * M_PI * i /\n                                  ((float64) in_len - 1.0)));\n        in[i] = FLOAT2COS(hamm);\n    }\n}\n\nstatic void\nfe_hamming_window(frame_t * in, window_t * window, int32 in_len,\n                  int32 remove_dc)\n{\n    int i;\n\n    if (remove_dc) {\n        frame_t mean = 0;\n\n        for (i = 0; i < in_len; i++)\n            mean += in[i];\n        mean /= in_len;\n        for (i = 0; i < in_len; i++)\n            in[i] -= (frame_t) mean;\n    }\n\n    for (i = 0; i < in_len / 2; i++) {\n        in[i] = COSMUL(in[i], window[i]);\n        in[in_len - 1 - i] = COSMUL(in[in_len - 1 - i], window[i]);\n    }\n}\n\nstatic int\nfe_spch_to_frame(fe_t * fe, int len)\n{\n    /* Copy to the frame buffer. */\n    if (fe->pre_emphasis_alpha != 0.0) {\n        fe_pre_emphasis(fe->spch, fe->frame, len,\n                        fe->pre_emphasis_alpha, fe->pre_emphasis_prior);\n        if (len >= fe->frame_shift)\n            fe->pre_emphasis_prior = fe->spch[fe->frame_shift - 1];\n        else\n            fe->pre_emphasis_prior = fe->spch[len - 1];\n    }\n    else\n        fe_short_to_frame(fe->spch, fe->frame, len);\n\n    /* Zero pad up to FFT size. */\n    memset(fe->frame + len, 0, (fe->fft_size - len) * sizeof(*fe->frame));\n\n    /* Window. */\n    fe_hamming_window(fe->frame, fe->hamming_window, fe->frame_size,\n                      fe->remove_dc);\n\n    return len;\n}\n\nint\nfe_read_frame(fe_t * fe, int16 const *in, int32 len)\n{\n    int i;\n\n    if (len > fe->frame_size)\n        len = fe->frame_size;\n\n    /* Read it into the raw speech buffer. */\n    memcpy(fe->spch, in, len * sizeof(*in));\n    /* Swap and dither if necessary. */\n    if (fe->swap)\n        for (i = 0; i < len; ++i)\n            SWAP_INT16(&fe->spch[i]);\n    if (fe->dither)\n        for (i = 0; i < len; ++i)\n            fe->spch[i] += (int16) ((!(s3_rand_int31() % 4)) ? 1 : 0);\n\n    return fe_spch_to_frame(fe, len);\n}\n\nint\nfe_shift_frame(fe_t * fe, int16 const *in, int32 len)\n{\n    int offset, i;\n\n    if (len > fe->frame_shift)\n        len = fe->frame_shift;\n    offset = fe->frame_size - fe->frame_shift;\n\n    /* Shift data into the raw speech buffer. */\n    memmove(fe->spch, fe->spch + fe->frame_shift,\n            offset * sizeof(*fe->spch));\n    memcpy(fe->spch + offset, in, len * sizeof(*fe->spch));\n    /* Swap and dither if necessary. */\n    if (fe->swap)\n        for (i = 0; i < len; ++i)\n            SWAP_INT16(&fe->spch[offset + i]);\n    if (fe->dither)\n        for (i = 0; i < len; ++i)\n            fe->spch[offset + i]\n                += (int16) ((!(s3_rand_int31() % 4)) ? 1 : 0);\n\n    return fe_spch_to_frame(fe, offset + len);\n}\n\n/**\n * Create arrays of twiddle factors.\n */\nvoid\nfe_create_twiddle(fe_t * fe)\n{\n    int i;\n\n    for (i = 0; i < fe->fft_size / 4; ++i) {\n        float64 a = 2 * M_PI * i / fe->fft_size;\n#if defined(FIXED_POINT)\n        fe->ccc[i] = FLOAT2COS(cos(a));\n        fe->sss[i] = FLOAT2COS(sin(a));\n#else\n        fe->ccc[i] = cos(a);\n        fe->sss[i] = sin(a);\n#endif\n    }\n}\n\n\nstatic int\nfe_fft_real(fe_t * fe)\n{\n    int i, j, k, m, n;\n    frame_t *x, xt;\n\n    x = fe->frame;\n    m = fe->fft_order;\n    n = fe->fft_size;\n\n    /* Bit-reverse the input. */\n    j = 0;\n    for (i = 0; i < n - 1; ++i) {\n        if (i < j) {\n            xt = x[j];\n            x[j] = x[i];\n            x[i] = xt;\n        }\n        k = n / 2;\n        while (k <= j) {\n            j -= k;\n            k /= 2;\n        }\n        j += k;\n    }\n\n    /* Basic butterflies (2-point FFT, real twiddle factors):\n     * x[i]   = x[i] +  1 * x[i+1]\n     * x[i+1] = x[i] + -1 * x[i+1]\n     */\n    for (i = 0; i < n; i += 2) {\n        xt = x[i];\n        x[i] = (xt + x[i + 1]);\n        x[i + 1] = (xt - x[i + 1]);\n    }\n\n    /* The rest of the butterflies, in stages from 1..m */\n    for (k = 1; k < m; ++k) {\n        int n1, n2, n4;\n\n        n4 = k - 1;\n        n2 = k;\n        n1 = k + 1;\n        /* Stride over each (1 << (k+1)) points */\n        for (i = 0; i < n; i += (1 << n1)) {\n            /* Basic butterfly with real twiddle factors:\n             * x[i]          = x[i] +  1 * x[i + (1<<k)]\n             * x[i + (1<<k)] = x[i] + -1 * x[i + (1<<k)]\n             */\n            xt = x[i];\n            x[i] = (xt + x[i + (1 << n2)]);\n            x[i + (1 << n2)] = (xt - x[i + (1 << n2)]);\n\n            /* The other ones with real twiddle factors:\n             * x[i + (1<<k) + (1<<(k-1))]\n             *   = 0 * x[i + (1<<k-1)] + -1 * x[i + (1<<k) + (1<<k-1)]\n             * x[i + (1<<(k-1))]\n             *   = 1 * x[i + (1<<k-1)] +  0 * x[i + (1<<k) + (1<<k-1)]\n             */\n            x[i + (1 << n2) + (1 << n4)] = -x[i + (1 << n2) + (1 << n4)];\n            x[i + (1 << n4)] = x[i + (1 << n4)];\n\n            /* Butterflies with complex twiddle factors.\n             * There are (1<<k-1) of them.\n             */\n            for (j = 1; j < (1 << n4); ++j) {\n                frame_t cc, ss, t1, t2;\n                int i1, i2, i3, i4;\n\n                i1 = i + j;\n                i2 = i + (1 << n2) - j;\n                i3 = i + (1 << n2) + j;\n                i4 = i + (1 << n2) + (1 << n2) - j;\n\n                /*\n                 * cc = real(W[j * n / (1<<(k+1))])\n                 * ss = imag(W[j * n / (1<<(k+1))])\n                 */\n                cc = fe->ccc[j << (m - n1)];\n                ss = fe->sss[j << (m - n1)];\n\n                /* There are some symmetry properties which allow us\n                 * to get away with only four multiplications here. */\n                t1 = COSMUL(x[i3], cc) + COSMUL(x[i4], ss);\n                t2 = COSMUL(x[i3], ss) - COSMUL(x[i4], cc);\n\n                x[i4] = (x[i2] - t2);\n                x[i3] = (-x[i2] - t2);\n                x[i2] = (x[i1] - t1);\n                x[i1] = (x[i1] + t1);\n            }\n        }\n    }\n\n    /* This isn't used, but return it for completeness. */\n    return m;\n}\n\nstatic void\nfe_spec_magnitude(fe_t * fe)\n{\n    frame_t *fft;\n    powspec_t *spec;\n    int32 j, scale, fftsize;\n\n    /* Do FFT and get the scaling factor back (only actually used in\n     * fixed-point).  Note the scaling factor is expressed in bits. */\n    scale = fe_fft_real(fe);\n\n    /* Convenience pointers to make things less awkward below. */\n    fft = fe->frame;\n    spec = fe->spec;\n    fftsize = fe->fft_size;\n\n    /* We need to scale things up the rest of the way to N. */\n    scale = fe->fft_order - scale;\n\n    /* The first point (DC coefficient) has no imaginary part */\n    {\n#if defined(FIXED_POINT)\n        spec[0] = FIXLN(abs(fft[0]) << scale) * 2;\n#else\n        spec[0] = fft[0] * fft[0];\n#endif\n    }\n\n    for (j = 1; j <= fftsize / 2; j++) {\n#if defined(FIXED_POINT)\n        int32 rr = FIXLN(abs(fft[j]) << scale) * 2;\n        int32 ii = FIXLN(abs(fft[fftsize - j]) << scale) * 2;\n        spec[j] = fe_log_add(rr, ii);\n#else\n        spec[j] = fft[j] * fft[j] + fft[fftsize - j] * fft[fftsize - j];\n#endif\n    }\n}\n\nstatic void\nfe_mel_spec(fe_t * fe)\n{\n    int whichfilt;\n    powspec_t *spec, *mfspec;\n\n    /* Convenience poitners. */\n    spec = fe->spec;\n    mfspec = fe->mfspec;\n    for (whichfilt = 0; whichfilt < fe->mel_fb->num_filters; whichfilt++) {\n        int spec_start, filt_start, i;\n\n        spec_start = fe->mel_fb->spec_start[whichfilt];\n        filt_start = fe->mel_fb->filt_start[whichfilt];\n\n#ifdef FIXED_POINT\n        mfspec[whichfilt] =\n            spec[spec_start] + fe->mel_fb->filt_coeffs[filt_start];\n        for (i = 1; i < fe->mel_fb->filt_width[whichfilt]; i++) {\n            mfspec[whichfilt] = fe_log_add(mfspec[whichfilt],\n                                           spec[spec_start + i] +\n                                           fe->mel_fb->\n                                           filt_coeffs[filt_start + i]);\n        }\n#else                           /* !FIXED_POINT */\n        mfspec[whichfilt] = 0;\n        for (i = 0; i < fe->mel_fb->filt_width[whichfilt]; i++)\n            mfspec[whichfilt] +=\n                spec[spec_start + i] * fe->mel_fb->filt_coeffs[filt_start +\n                                                               i];\n#endif                          /* !FIXED_POINT */\n    }\n\n}\n\n#define LOG_FLOOR 1e-4\n\nstatic void\nfe_mel_cep(fe_t * fe, mfcc_t * mfcep)\n{\n    int32 i;\n    powspec_t *mfspec;\n\n    /* Convenience pointer. */\n    mfspec = fe->mfspec;\n\n    for (i = 0; i < fe->mel_fb->num_filters; ++i) {\n#ifndef FIXED_POINT             /* It's already in log domain for fixed point */\n        mfspec[i] = log(mfspec[i] + LOG_FLOOR);\n#endif                          /* !FIXED_POINT */\n    }\n\n    /* If we are doing LOG_SPEC, then do nothing. */\n    if (fe->log_spec == RAW_LOG_SPEC) {\n        for (i = 0; i < fe->feature_dimension; i++) {\n            mfcep[i] = (mfcc_t) mfspec[i];\n        }\n    }\n    /* For smoothed spectrum, do DCT-II followed by (its inverse) DCT-III */\n    else if (fe->log_spec == SMOOTH_LOG_SPEC) {\n        /* FIXME: This is probably broken for fixed-point. */\n        fe_dct2(fe, mfspec, mfcep, 0);\n        fe_dct3(fe, mfcep, mfspec);\n        for (i = 0; i < fe->feature_dimension; i++) {\n            mfcep[i] = (mfcc_t) mfspec[i];\n        }\n    }\n    else if (fe->transform == DCT_II)\n        fe_dct2(fe, mfspec, mfcep, FALSE);\n    else if (fe->transform == DCT_HTK)\n        fe_dct2(fe, mfspec, mfcep, TRUE);\n    else\n        fe_spec2cep(fe, mfspec, mfcep);\n\n    return;\n}\n\nvoid\nfe_spec2cep(fe_t * fe, const powspec_t * mflogspec, mfcc_t * mfcep)\n{\n    int32 i, j, beta;\n\n    /* Compute C0 separately (its basis vector is 1) to avoid\n     * costly multiplications. */\n    mfcep[0] = mflogspec[0] / 2;        /* beta = 0.5 */\n    for (j = 1; j < fe->mel_fb->num_filters; j++)\n        mfcep[0] += mflogspec[j];       /* beta = 1.0 */\n    mfcep[0] /= (frame_t) fe->mel_fb->num_filters;\n\n    for (i = 1; i < fe->num_cepstra; ++i) {\n        mfcep[i] = 0;\n        for (j = 0; j < fe->mel_fb->num_filters; j++) {\n            if (j == 0)\n                beta = 1;       /* 0.5 */\n            else\n                beta = 2;       /* 1.0 */\n            mfcep[i] += COSMUL(mflogspec[j],\n                               fe->mel_fb->mel_cosine[i][j]) * beta;\n        }\n        /* Note that this actually normalizes by num_filters, like the\n         * original Sphinx front-end, due to the doubled 'beta' factor\n         * above.  */\n        mfcep[i] /= (frame_t) fe->mel_fb->num_filters * 2;\n    }\n}\n\nvoid\nfe_dct2(fe_t * fe, const powspec_t * mflogspec, mfcc_t * mfcep, int htk)\n{\n    int32 i, j;\n\n    /* Compute C0 separately (its basis vector is 1) to avoid\n     * costly multiplications. */\n    mfcep[0] = mflogspec[0];\n    for (j = 1; j < fe->mel_fb->num_filters; j++)\n        mfcep[0] += mflogspec[j];\n    if (htk)\n        mfcep[0] = COSMUL(mfcep[0], fe->mel_fb->sqrt_inv_2n);\n    else                        /* sqrt(1/N) = sqrt(2/N) * 1/sqrt(2) */\n        mfcep[0] = COSMUL(mfcep[0], fe->mel_fb->sqrt_inv_n);\n\n    for (i = 1; i < fe->num_cepstra; ++i) {\n        mfcep[i] = 0;\n        for (j = 0; j < fe->mel_fb->num_filters; j++) {\n            mfcep[i] += COSMUL(mflogspec[j], fe->mel_fb->mel_cosine[i][j]);\n        }\n        mfcep[i] = COSMUL(mfcep[i], fe->mel_fb->sqrt_inv_2n);\n    }\n}\n\nvoid\nfe_lifter(fe_t * fe, mfcc_t * mfcep)\n{\n    int32 i;\n\n    if (fe->mel_fb->lifter_val == 0)\n        return;\n\n    for (i = 0; i < fe->num_cepstra; ++i) {\n        mfcep[i] = MFCCMUL(mfcep[i], fe->mel_fb->lifter[i]);\n    }\n}\n\nvoid\nfe_dct3(fe_t * fe, const mfcc_t * mfcep, powspec_t * mflogspec)\n{\n    int32 i, j;\n\n    for (i = 0; i < fe->mel_fb->num_filters; ++i) {\n        mflogspec[i] = COSMUL(mfcep[0], SQRT_HALF);\n        for (j = 1; j < fe->num_cepstra; j++) {\n            mflogspec[i] += COSMUL(mfcep[j], fe->mel_fb->mel_cosine[j][i]);\n        }\n        mflogspec[i] = COSMUL(mflogspec[i], fe->mel_fb->sqrt_inv_2n);\n    }\n}\n\nvoid\nfe_write_frame(fe_t * fe, mfcc_t * feat, int32 store_pcm)\n{\n    int32 is_speech;\n\n    fe_spec_magnitude(fe);\n    fe_mel_spec(fe);\n    fe_track_snr(fe, &is_speech);\n    fe_mel_cep(fe, feat);\n    fe_lifter(fe, feat);\n    fe_vad_hangover(fe, feat, is_speech, store_pcm);\n}\n\n\nvoid *\nfe_create_2d(int32 d1, int32 d2, int32 elem_size)\n{\n    return (void *) ckd_calloc_2d(d1, d2, elem_size);\n}\n\nvoid\nfe_free_2d(void *arr)\n{\n    ckd_free_2d((void **) arr);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2006 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*********************************************************************\n *\n * File: fe_warp_affine.c\n * \n * Description: \n * \tWarp the frequency axis according to an affine function, i.e.:\n *\n *\t\tw' = a * w + b\n *\t\n *********************************************************************/\n\n/* static char rcsid[] = \"@(#)$Id: fe_warp_affine.c,v 1.2 2006/02/17 00:31:34 egouvea Exp $\"; */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/err.h\"\n\n#include \"fe_warp.h\"\n#include \"fe_warp_affine.h\"\n\n#define N_PARAM\t\t2\n#define YES             1\n#define NO              0\n\n/*\n * params[0] : a\n * params[1] : b\n */\nstatic float params[N_PARAM] = { 1.0f, 0.0f };\nstatic int32 is_neutral = YES;\nstatic char p_str[256] = \"\";\nstatic float nyquist_frequency = 0.0f;\n\f\n\nconst char *\nfe_warp_affine_doc()\n{\n    return \"affine :== < w' = a * x + b >\";\n}\n\f\nuint32\nfe_warp_affine_id()\n{\n    return FE_WARP_ID_AFFINE;\n}\n\f\nuint32\nfe_warp_affine_n_param()\n{\n    return N_PARAM;\n}\n\f\nvoid\nfe_warp_affine_set_parameters(char const *param_str, float sampling_rate)\n{\n    char *tok;\n    char *seps = \" \\t\";\n    char temp_param_str[256];\n    int param_index = 0;\n\n    nyquist_frequency = sampling_rate / 2;\n    if (param_str == NULL) {\n        is_neutral = YES;\n        return;\n    }\n    /* The new parameters are the same as the current ones, so do nothing. */\n    if (strcmp(param_str, p_str) == 0) {\n        return;\n    }\n    is_neutral = NO;\n    strcpy(temp_param_str, param_str);\n    memset(params, 0, N_PARAM * sizeof(float));\n    strcpy(p_str, param_str);\n    /* FIXME: strtok() is not re-entrant... */\n    tok = strtok(temp_param_str, seps);\n    while (tok != NULL) {\n        params[param_index++] = (float) atof_c(tok);\n        tok = strtok(NULL, seps);\n        if (param_index >= N_PARAM) {\n            break;\n        }\n    }\n    if (tok != NULL) {\n        E_INFO\n            (\"Affine warping takes up to two arguments, %s ignored.\\n\",\n             tok);\n    }\n    if (params[0] == 0) {\n        is_neutral = YES;\n        E_INFO\n            (\"Affine warping cannot have slope zero, warping not applied.\\n\");\n    }\n}\n\f\nfloat\nfe_warp_affine_warped_to_unwarped(float nonlinear)\n{\n    if (is_neutral) {\n        return nonlinear;\n    }\n    else {\n        /* linear = (nonlinear - b) / a */\n        float temp = nonlinear - params[1];\n        temp /= params[0];\n        if (temp > nyquist_frequency) {\n            E_WARN\n                (\"Warp factor %g results in frequency (%.1f) higher than Nyquist (%.1f)\\n\",\n                 params[0], temp, nyquist_frequency);\n        }\n        return temp;\n    }\n}\n\f\nfloat\nfe_warp_affine_unwarped_to_warped(float linear)\n{\n    if (is_neutral) {\n        return linear;\n    }\n    else {\n        /* nonlinear = a * linear - b */\n        float temp = linear * params[0];\n        temp += params[1];\n        return temp;\n    }\n}\n\f\nvoid\nfe_warp_affine_print(const char *label)\n{\n    uint32 i;\n\n    for (i = 0; i < N_PARAM; i++) {\n        printf(\"%s[%04u]: %6.3f \", label, i, params[i]);\n    }\n    printf(\"\\n\");\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2006 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*********************************************************************\n *\n * File: fe_warp.c\n * \n * Description: \n *      Allows a caller to choose a warping function.\n *********************************************************************/\n\n/* static char rcsid[] = \"@(#)$Id: fe_warp.c,v 1.2 2006/02/17 00:31:34 egouvea Exp $\";*/\n\n#include \"fe_warp_inverse_linear.h\"\n#include \"fe_warp_affine.h\"\n#include \"fe_warp_piecewise_linear.h\"\n#include \"fe_warp.h\"\n\n#include \"sphinxbase/err.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n\n/* This is for aliases for each of the entries below. Currently not\n   used.\n*/\nstatic char *__name2id[] = {\n    \"inverse\",\n    \"linear\",\n    \"piecewise\",\n    NULL\n};\n\nstatic char *name2id[] = {\n    \"inverse_linear\",\n    \"affine\",\n    \"piecewise_linear\",\n    NULL\n};\n\nstatic fe_warp_conf_t fe_warp_conf[FE_WARP_ID_MAX + 1] = {\n    {fe_warp_inverse_linear_set_parameters,\n     fe_warp_inverse_linear_doc,\n     fe_warp_inverse_linear_id,\n     fe_warp_inverse_linear_n_param,\n     fe_warp_inverse_linear_warped_to_unwarped,\n     fe_warp_inverse_linear_unwarped_to_warped,\n     fe_warp_inverse_linear_print},     /* Inverse linear warping */\n    {fe_warp_affine_set_parameters,\n     fe_warp_affine_doc,\n     fe_warp_affine_id,\n     fe_warp_affine_n_param,\n     fe_warp_affine_warped_to_unwarped,\n     fe_warp_affine_unwarped_to_warped,\n     fe_warp_affine_print},     /* Affine warping */\n    {fe_warp_piecewise_linear_set_parameters,\n     fe_warp_piecewise_linear_doc,\n     fe_warp_piecewise_linear_id,\n     fe_warp_piecewise_linear_n_param,\n     fe_warp_piecewise_linear_warped_to_unwarped,\n     fe_warp_piecewise_linear_unwarped_to_warped,\n     fe_warp_piecewise_linear_print},   /* Piecewise_Linear warping */\n};\n\nint\nfe_warp_set(melfb_t *mel, const char *id_name)\n{\n    uint32 i;\n\n    for (i = 0; name2id[i]; i++) {\n        if (strcmp(id_name, name2id[i]) == 0) {\n            mel->warp_id = i;\n            break;\n        }\n    }\n\n    if (name2id[i] == NULL) {\n        for (i = 0; __name2id[i]; i++) {\n            if (strcmp(id_name, __name2id[i]) == 0) {\n                mel->warp_id = i;\n                break;\n            }\n        }\n        if (__name2id[i] == NULL) {\n            E_ERROR(\"Unimplemented warping function %s\\n\", id_name);\n            E_ERROR(\"Implemented functions are:\\n\");\n            for (i = 0; name2id[i]; i++) {\n                fprintf(stderr, \"\\t%s\\n\", name2id[i]);\n            }\n            mel->warp_id = FE_WARP_ID_NONE;\n\n            return FE_START_ERROR;\n        }\n    }\n\n    return FE_SUCCESS;\n}\n\nvoid\nfe_warp_set_parameters(melfb_t *mel, char const *param_str, float sampling_rate)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        fe_warp_conf[mel->warp_id].set_parameters(param_str, sampling_rate);\n    }\n    else if (mel->warp_id == FE_WARP_ID_NONE) {\n        E_FATAL(\"feat module must be configured w/ a valid ID\\n\");\n    }\n    else {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n}\n\nconst char *\nfe_warp_doc(melfb_t *mel)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        return fe_warp_conf[mel->warp_id].doc();\n    }\n    else if (mel->warp_id == FE_WARP_ID_NONE) {\n        E_FATAL(\"fe_warp module must be configured w/ a valid ID\\n\");\n    }\n    else {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n\n    return NULL;\n}\n\nuint32\nfe_warp_id(melfb_t *mel)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        assert(mel->warp_id == fe_warp_conf[mel->warp_id].id());\n        return mel->warp_id;\n    }\n    else if (mel->warp_id != FE_WARP_ID_NONE) {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n\n    return FE_WARP_ID_NONE;\n}\n\nuint32\nfe_warp_n_param(melfb_t *mel)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        return fe_warp_conf[mel->warp_id].n_param();\n    }\n    else if (mel->warp_id == FE_WARP_ID_NONE) {\n        E_FATAL(\"fe_warp module must be configured w/ a valid ID\\n\");\n    }\n    else {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n\n    return 0;\n}\n\nfloat\nfe_warp_warped_to_unwarped(melfb_t *mel, float nonlinear)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        return fe_warp_conf[mel->warp_id].warped_to_unwarped(nonlinear);\n    }\n    else if (mel->warp_id == FE_WARP_ID_NONE) {\n        E_FATAL(\"fe_warp module must be configured w/ a valid ID\\n\");\n    }\n    else {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n\n    return 0;\n}\n\nfloat\nfe_warp_unwarped_to_warped(melfb_t *mel,float linear)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        return fe_warp_conf[mel->warp_id].unwarped_to_warped(linear);\n    }\n    else if (mel->warp_id == FE_WARP_ID_NONE) {\n        E_FATAL(\"fe_warp module must be configured w/ a valid ID\\n\");\n    }\n    else {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n\n    return 0;\n}\n\nvoid\nfe_warp_print(melfb_t *mel, const char *label)\n{\n    if (mel->warp_id <= FE_WARP_ID_MAX) {\n        fe_warp_conf[mel->warp_id].print(label);\n    }\n    else if (mel->warp_id == FE_WARP_ID_NONE) {\n        E_FATAL(\"fe_warp module must be configured w/ a valid ID\\n\");\n    }\n    else {\n        E_FATAL\n            (\"fe_warp module misconfigured with invalid fe_warp_id %u\\n\",\n             mel->warp_id);\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2006 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*********************************************************************\n *\n * File: fe_warp_inverse_linear.c\n * \n * Description: \n * \tWarp the frequency axis according to an inverse_linear function, i.e.:\n *\n *\t\tw' = w / a\n *\t\n *********************************************************************/\n\n/* static char rcsid[] = \"@(#)$Id: fe_warp_inverse_linear.c,v 1.3 2006/02/23 19:40:11 eht Exp $\"; */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/err.h\"\n\n#include \"fe_warp.h\"\n#include \"fe_warp_inverse_linear.h\"\n\n#define N_PARAM\t\t1\n#define YES             1\n#define NO              0\n\n/*\n * params[0] : a\n */\nstatic float params[N_PARAM] = { 1.0f };\nstatic int32 is_neutral = YES;\nstatic char p_str[256] = \"\";\nstatic float nyquist_frequency = 0.0f;\n\f\n\nconst char *\nfe_warp_inverse_linear_doc()\n{\n    return \"inverse_linear :== < w' = x / a >\";\n}\n\f\nuint32\nfe_warp_inverse_linear_id()\n{\n    return FE_WARP_ID_INVERSE_LINEAR;\n}\n\f\nuint32\nfe_warp_inverse_linear_n_param()\n{\n    return N_PARAM;\n}\n\f\nvoid\nfe_warp_inverse_linear_set_parameters(char const *param_str, float sampling_rate)\n{\n    char *tok;\n    char *seps = \" \\t\";\n    char temp_param_str[256];\n    int param_index = 0;\n\n    nyquist_frequency = sampling_rate / 2;\n    if (param_str == NULL) {\n        is_neutral = YES;\n        return;\n    }\n    /* The new parameters are the same as the current ones, so do nothing. */\n    if (strcmp(param_str, p_str) == 0) {\n        return;\n    }\n    is_neutral = NO;\n    strcpy(temp_param_str, param_str);\n    memset(params, 0, N_PARAM * sizeof(float));\n    strcpy(p_str, param_str);\n    /* FIXME: strtok() is not re-entrant... */\n    tok = strtok(temp_param_str, seps);\n    while (tok != NULL) {\n        params[param_index++] = (float) atof_c(tok);\n        tok = strtok(NULL, seps);\n        if (param_index >= N_PARAM) {\n            break;\n        }\n    }\n    if (tok != NULL) {\n        E_INFO\n            (\"Inverse linear warping takes only one argument, %s ignored.\\n\",\n             tok);\n    }\n    if (params[0] == 0) {\n        is_neutral = YES;\n        E_INFO\n            (\"Inverse linear warping cannot have slope zero, warping not applied.\\n\");\n    }\n}\n\f\nfloat\nfe_warp_inverse_linear_warped_to_unwarped(float nonlinear)\n{\n    if (is_neutral) {\n        return nonlinear;\n    }\n    else {\n        /* linear = nonlinear * a */\n        float temp = nonlinear * params[0];\n        if (temp > nyquist_frequency) {\n            E_WARN\n                (\"Warp factor %g results in frequency (%.1f) higher than Nyquist (%.1f)\\n\",\n                 params[0], temp, nyquist_frequency);\n        }\n        return temp;\n    }\n}\n\f\nfloat\nfe_warp_inverse_linear_unwarped_to_warped(float linear)\n{\n    if (is_neutral) {\n        return linear;\n    }\n    else {\n        /* nonlinear = a / linear */\n        float temp = linear / params[0];\n        return temp;\n    }\n}\n\f\nvoid\nfe_warp_inverse_linear_print(const char *label)\n{\n    uint32 i;\n\n    for (i = 0; i < N_PARAM; i++) {\n        printf(\"%s[%04u]: %6.3f \", label, i, params[i]);\n    }\n    printf(\"\\n\");\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2006 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*********************************************************************\n *\n * File: fe_warp_piecewise_linear.c\n * \n * Description: \n *\n * \tWarp the frequency axis according to an piecewise linear\n * \tfunction. The function is linear up to a frequency F, where\n * \tthe slope changes so that the Nyquist frequency in the warped\n * \taxis maps to the Nyquist frequency in the unwarped.\n *\n *\t\tw' = a * w, w < F\n *              w' = a' * w + b, W > F\n *              w'(0) = 0\n *              w'(F) = F\n *              w'(Nyq) = Nyq\n *\t\n *********************************************************************/\n\n/* static char rcsid[] = \"@(#)$Id: fe_warp_piecewise_linear.c,v 1.2 2006/02/17 00:31:34 egouvea Exp $\"; */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/err.h\"\n\n#include \"fe_warp.h\"\n#include \"fe_warp_piecewise_linear.h\"\n\n#define N_PARAM\t\t2\n#define YES             1\n#define NO              0\n\n/*\n * params[0] : a\n * params[1] : F (the non-differentiable point)\n */\nstatic float params[N_PARAM] = { 1.0f, 6800.0f };\nstatic float final_piece[2];\nstatic int32 is_neutral = YES;\nstatic char p_str[256] = \"\";\nstatic float nyquist_frequency = 0.0f;\n\f\n\nconst char *\nfe_warp_piecewise_linear_doc()\n{\n    return \"piecewise_linear :== < w' = a * w, w < F >\";\n}\n\f\nuint32\nfe_warp_piecewise_linear_id()\n{\n    return FE_WARP_ID_PIECEWISE_LINEAR;\n}\n\f\nuint32\nfe_warp_piecewise_linear_n_param()\n{\n    return N_PARAM;\n}\n\f\nvoid\nfe_warp_piecewise_linear_set_parameters(char const *param_str,\n                                        float sampling_rate)\n{\n    char *tok;\n    char *seps = \" \\t\";\n    char temp_param_str[256];\n    int param_index = 0;\n\n    nyquist_frequency = sampling_rate / 2;\n    if (param_str == NULL) {\n        is_neutral = YES;\n        return;\n    }\n    /* The new parameters are the same as the current ones, so do nothing. */\n    if (strcmp(param_str, p_str) == 0) {\n        return;\n    }\n    is_neutral = NO;\n    strcpy(temp_param_str, param_str);\n    memset(params, 0, N_PARAM * sizeof(float));\n    memset(final_piece, 0, 2 * sizeof(float));\n    strcpy(p_str, param_str);\n    /* FIXME: strtok() is not re-entrant... */\n    tok = strtok(temp_param_str, seps);\n    while (tok != NULL) {\n        params[param_index++] = (float) atof_c(tok);\n        tok = strtok(NULL, seps);\n        if (param_index >= N_PARAM) {\n            break;\n        }\n    }\n    if (tok != NULL) {\n        E_INFO\n            (\"Piecewise linear warping takes up to two arguments, %s ignored.\\n\",\n             tok);\n    }\n    if (params[1] < sampling_rate) {\n        /* Precompute these. These are the coefficients of a\n         * straight line that contains the points (F, aF) and (N,\n         * N), where a = params[0], F = params[1], N = Nyquist\n         * frequency.\n         */\n        if (params[1] == 0) {\n            params[1] = sampling_rate * 0.85f;\n        }\n        final_piece[0] =\n            (nyquist_frequency -\n             params[0] * params[1]) / (nyquist_frequency - params[1]);\n        final_piece[1] =\n            nyquist_frequency * params[1] * (params[0] -\n                                         1.0f) / (nyquist_frequency -\n                                                  params[1]);\n    }\n    else {\n        memset(final_piece, 0, 2 * sizeof(float));\n    }\n    if (params[0] == 0) {\n        is_neutral = YES;\n        E_INFO\n            (\"Piecewise linear warping cannot have slope zero, warping not applied.\\n\");\n    }\n}\n\f\nfloat\nfe_warp_piecewise_linear_warped_to_unwarped(float nonlinear)\n{\n    if (is_neutral) {\n        return nonlinear;\n    }\n    else {\n        /* linear = (nonlinear - b) / a */\n        float temp;\n        if (nonlinear < params[0] * params[1]) {\n            temp = nonlinear / params[0];\n        }\n        else {\n            temp = nonlinear - final_piece[1];\n            temp /= final_piece[0];\n        }\n        if (temp > nyquist_frequency) {\n            E_WARN\n                (\"Warp factor %g results in frequency (%.1f) higher than Nyquist (%.1f)\\n\",\n                 params[0], temp, nyquist_frequency);\n        }\n        return temp;\n    }\n}\n\f\nfloat\nfe_warp_piecewise_linear_unwarped_to_warped(float linear)\n{\n    if (is_neutral) {\n        return linear;\n    }\n    else {\n        float temp;\n        /* nonlinear = a * linear - b */\n        if (linear < params[1]) {\n            temp = linear * params[0];\n        }\n        else {\n            temp = final_piece[0] * linear + final_piece[1];\n        }\n        return temp;\n    }\n}\n\f\nvoid\nfe_warp_piecewise_linear_print(const char *label)\n{\n    uint32 i;\n\n    for (i = 0; i < N_PARAM; i++) {\n        printf(\"%s[%04u]: %6.3f \", label, i, params[i]);\n    }\n    printf(\"\\n\");\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2013 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/* This noise removal algorithm is inspired by the following papers\n * Computationally Efficient Speech Enchancement by Spectral Minina Tracking\n * by G. Doblinger\n *\n * Power-Normalized Cepstral Coefficients (PNCC) for Robust Speech Recognition\n * by C. Kim.\n *\n * For the recent research and state of art see papers about IMRCA and\n * A Minimum-Mean-Square-Error Noise Reduction Algorithm On Mel-Frequency\n * Cepstra For Robust Speech Recognition by Dong Yu and others\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <math.h>\n\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/err.h\"\n\n#include \"fe_noise.h\"\n#include \"fe_internal.h\"\n\n/* Noise supression constants */\n#define SMOOTH_WINDOW 4\n#define LAMBDA_POWER 0.7\n#define LAMBDA_A 0.995\n#define LAMBDA_B 0.5\n#define LAMBDA_T 0.85\n#define MU_T 0.2\n#define MAX_GAIN 20\n#define SLOW_PEAK_FORGET_FACTOR 0.9995\n#define SLOW_PEAK_LEARN_FACTOR 0.9\n#define SPEECH_VOLUME_RANGE 8.0\n\n/* define VAD_DEBUG 1 */\n#ifdef VAD_DEBUG\nstatic FILE *vad_stats;\nstatic int64 low_snr = 0;\nstatic int64 low_volume = 0;\n#endif\n\nstruct noise_stats_s {\n    /* Smoothed power */\n    powspec_t *power;\n    /* Noise estimate */\n    powspec_t *noise;\n    /* Signal floor estimate */\n    powspec_t *floor;\n    /* Peak for temporal masking */\n    powspec_t *peak;\n\n    /* Initialize it next time */\n    uint8 undefined;\n    /* Number of items to process */\n    uint32 num_filters;\n\n    /* Sum of slow peaks for VAD */\n    powspec_t slow_peak_sum;\n\n    /* Precomputed constants */\n    powspec_t lambda_power;\n    powspec_t comp_lambda_power;\n    powspec_t lambda_a;\n    powspec_t comp_lambda_a;\n    powspec_t lambda_b;\n    powspec_t comp_lambda_b;\n    powspec_t lambda_t;\n    powspec_t mu_t;\n    powspec_t max_gain;\n    powspec_t inv_max_gain;\n\n    powspec_t smooth_scaling[2 * SMOOTH_WINDOW + 3];\n};\n\nstatic void\nfe_lower_envelope(noise_stats_t *noise_stats, powspec_t * buf, powspec_t * floor_buf, int32 num_filt)\n{\n    int i;\n\n    for (i = 0; i < num_filt; i++) {\n#ifndef FIXED_POINT\n        if (buf[i] >= floor_buf[i]) {\n            floor_buf[i] =\n                noise_stats->lambda_a * floor_buf[i] + noise_stats->comp_lambda_a * buf[i];\n        }\n        else {\n            floor_buf[i] =\n                noise_stats->lambda_b * floor_buf[i] + noise_stats->comp_lambda_b * buf[i];\n        }\n#else\n        if (buf[i] >= floor_buf[i]) {\n            floor_buf[i] = fe_log_add(noise_stats->lambda_a + floor_buf[i],\n                                  noise_stats->comp_lambda_a + buf[i]);\n        }\n        else {\n            floor_buf[i] = fe_log_add(noise_stats->lambda_b + floor_buf[i],\n                                  noise_stats->comp_lambda_b + buf[i]);\n        }\n#endif\n    }\n}\n\n/* update slow peaks, check if max signal level big enough compared to peak */\nstatic int16\nfe_is_frame_quiet(noise_stats_t *noise_stats, powspec_t *buf, int32 num_filt)\n{\n    int i;\n    int16 is_quiet;\n    powspec_t sum;\n    double smooth_factor;\n\n    sum = 0.0;\n    for (i = 0; i < num_filt; i++) {\n#ifndef FIXED_POINT\n        sum += buf[i];\n#else \n        sum = fe_log_add(sum, buf[i]);\n#endif\n    }\n#ifndef FIXED_POINT\n    sum = log(sum);\n#endif\n    smooth_factor = (sum > noise_stats->slow_peak_sum) ? SLOW_PEAK_LEARN_FACTOR : SLOW_PEAK_FORGET_FACTOR;\n    noise_stats->slow_peak_sum = noise_stats->slow_peak_sum * smooth_factor +\n                                 sum * (1 - smooth_factor);\n\n#ifdef VAD_DEBUG\n#ifndef FIXED_POINT\n    fprintf(vad_stats, \"%.3f %.3f \", noise_stats->slow_peak_sum, sum);\n#else\n    fprintf(vad_stats, \"%d %d \", noise_stats->slow_peak_sum, sum);\n#endif\n#endif\n#ifndef FIXED_POINT\n    is_quiet = noise_stats->slow_peak_sum - SPEECH_VOLUME_RANGE > sum;\n#else\n    is_quiet = noise_stats->slow_peak_sum - FLOAT2FIX(SPEECH_VOLUME_RANGE) > sum;\n#endif\n    return is_quiet;\n}\n\n/* temporal masking */\nstatic void\nfe_temp_masking(noise_stats_t *noise_stats, powspec_t * buf, powspec_t * peak, int32 num_filt)\n{\n    powspec_t cur_in;\n    int i;\n\n    for (i = 0; i < num_filt; i++) {\n        cur_in = buf[i];\n\n#ifndef FIXED_POINT\n        peak[i] *= noise_stats->lambda_t;\n        if (buf[i] < noise_stats->lambda_t * peak[i])\n            buf[i] = peak[i] * noise_stats->mu_t;\n#else\n        peak[i] += noise_stats->lambda_t;\n        if (buf[i] < noise_stats->lambda_t + peak[i])\n            buf[i] = peak[i] + noise_stats->mu_t;\n#endif\n\n        if (cur_in > peak[i])\n            peak[i] = cur_in;\n    }\n}\n\n/* spectral weight smoothing */\nstatic void\nfe_weight_smooth(noise_stats_t *noise_stats, powspec_t * buf, powspec_t * coefs, int32 num_filt)\n{\n    int i, j;\n    int l1, l2;\n    powspec_t coef;\n\n    for (i = 0; i < num_filt; i++) {\n        l1 = ((i - SMOOTH_WINDOW) > 0) ? (i - SMOOTH_WINDOW) : 0;\n        l2 = ((i + SMOOTH_WINDOW) <\n              (num_filt - 1)) ? (i + SMOOTH_WINDOW) : (num_filt - 1);\n\n#ifndef FIXED_POINT\n        coef = 0;\n        for (j = l1; j <= l2; j++) {\n            coef += coefs[j];\n        }\n        buf[i] = buf[i] * (coef / (l2 - l1 + 1));\n#else\n        coef = MIN_FIXLOG;\n        for (j = l1; j <= l2; j++) {\n            coef = fe_log_add(coef, coefs[j]);\n        }        \n        buf[i] = buf[i] + coef - noise_stats->smooth_scaling[l2 - l1 + 1];\n#endif\n\n    }\n}\n\nnoise_stats_t *\nfe_init_noisestats(int num_filters)\n{\n    int i;\n    noise_stats_t *noise_stats;\n\n    noise_stats = (noise_stats_t *) ckd_calloc(1, sizeof(noise_stats_t));\n\n    noise_stats->power =\n        (powspec_t *) ckd_calloc(num_filters, sizeof(powspec_t));\n    noise_stats->noise =\n        (powspec_t *) ckd_calloc(num_filters, sizeof(powspec_t));\n    noise_stats->floor =\n        (powspec_t *) ckd_calloc(num_filters, sizeof(powspec_t));\n    noise_stats->peak =\n        (powspec_t *) ckd_calloc(num_filters, sizeof(powspec_t));\n\n    noise_stats->undefined = TRUE;\n    noise_stats->num_filters = num_filters;\n\n#ifndef FIXED_POINT\n    noise_stats->lambda_power = LAMBDA_POWER;\n    noise_stats->comp_lambda_power = 1 - LAMBDA_POWER;\n    noise_stats->lambda_a = LAMBDA_A;\n    noise_stats->comp_lambda_a = 1 - LAMBDA_A;\n    noise_stats->lambda_b = LAMBDA_B;\n    noise_stats->comp_lambda_b = 1 - LAMBDA_B;\n    noise_stats->lambda_t = LAMBDA_T;\n    noise_stats->mu_t = MU_T;\n    noise_stats->max_gain = MAX_GAIN;\n    noise_stats->inv_max_gain = 1.0 / MAX_GAIN;\n    \n    for (i = 1; i < 2 * SMOOTH_WINDOW + 1; i++) {\n        noise_stats->smooth_scaling[i] = 1.0 / i;\n    }\n#else\n    noise_stats->lambda_power = FLOAT2FIX(log(LAMBDA_POWER));\n    noise_stats->comp_lambda_power = FLOAT2FIX(log(1 - LAMBDA_POWER));\n    noise_stats->lambda_a = FLOAT2FIX(log(LAMBDA_A));\n    noise_stats->comp_lambda_a = FLOAT2FIX(log(1 - LAMBDA_A));\n    noise_stats->lambda_b = FLOAT2FIX(log(LAMBDA_B));\n    noise_stats->comp_lambda_b = FLOAT2FIX(log(1 - LAMBDA_B));\n    noise_stats->lambda_t = FLOAT2FIX(log(LAMBDA_T));\n    noise_stats->mu_t = FLOAT2FIX(log(MU_T));\n    noise_stats->max_gain = FLOAT2FIX(log(MAX_GAIN));\n    noise_stats->inv_max_gain = FLOAT2FIX(log(1.0 / MAX_GAIN));\n\n    for (i = 1; i < 2 * SMOOTH_WINDOW + 3; i++) {\n        noise_stats->smooth_scaling[i] = FLOAT2FIX(log(i));\n    }\n#endif\n\n#ifdef VAD_DEBUG\n    vad_stats = fopen(\"vad_debug\", \"w\");\n#endif\n\n    return noise_stats;\n}\n\nvoid\nfe_reset_noisestats(noise_stats_t * noise_stats)\n{\n    if (noise_stats)\n        noise_stats->undefined = TRUE;\n}\n\nvoid\nfe_free_noisestats(noise_stats_t * noise_stats)\n{\n    ckd_free(noise_stats->power);\n    ckd_free(noise_stats->noise);\n    ckd_free(noise_stats->floor);\n    ckd_free(noise_stats->peak);\n    ckd_free(noise_stats);\n#ifdef VAD_DEBUG\n    fclose(vad_stats);\n    E_INFO(\"Low SNR [%ld] frames; Low volume [%ld] frames\\n\", (long)low_snr, (long)low_volume);\n#endif\n\n}\n\n/**\n * For fixed point we are doing the computation in a fixlog domain,\n * so we have to add many processing cases.\n */\nvoid\nfe_track_snr(fe_t * fe, int32 *in_speech)\n{\n    powspec_t *signal;\n    powspec_t *gain;\n    noise_stats_t *noise_stats;\n    powspec_t *mfspec;\n    int32 i, num_filts;\n    int16 is_quiet;\n    powspec_t lrt, snr;\n\n    if (!(fe->remove_noise || fe->remove_silence)) {\n        *in_speech = TRUE;\n        return;\n    }\n\n    noise_stats = fe->noise_stats;\n    mfspec = fe->mfspec;\n    num_filts = noise_stats->num_filters;\n\n    signal = (powspec_t *) ckd_calloc(num_filts, sizeof(powspec_t));\n\n    if (noise_stats->undefined) {\n        noise_stats->slow_peak_sum = FIX2FLOAT(0.0);\n        for (i = 0; i < num_filts; i++) {\n            noise_stats->power[i] = mfspec[i];\n#ifndef FIXED_POINT\n            noise_stats->noise[i] = mfspec[i] / noise_stats->max_gain;\n            noise_stats->floor[i] = mfspec[i] / noise_stats->max_gain;\n            noise_stats->peak[i] = 0.0;\n#else\n            noise_stats->noise[i] = mfspec[i] - noise_stats->max_gain;;\n            noise_stats->floor[i] = mfspec[i] - noise_stats->max_gain;\n            noise_stats->peak[i] = MIN_FIXLOG;\n#endif\n        }\n        noise_stats->undefined = FALSE;\n    }\n\n    /* Calculate smoothed power */\n    for (i = 0; i < num_filts; i++) {\n#ifndef FIXED_POINT\n        noise_stats->power[i] =\n            noise_stats->lambda_power * noise_stats->power[i] + noise_stats->comp_lambda_power * mfspec[i];   \n#else\n        noise_stats->power[i] = fe_log_add(noise_stats->lambda_power + noise_stats->power[i],\n            noise_stats->comp_lambda_power + mfspec[i]);\n#endif\n    }\n\n    /* Noise estimation and vad decision */\n    fe_lower_envelope(noise_stats, noise_stats->power, noise_stats->noise, num_filts);\n\n    lrt = FLOAT2FIX(0.0);\n    for (i = 0; i < num_filts; i++) {\n#ifndef FIXED_POINT\n        signal[i] = noise_stats->power[i] - noise_stats->noise[i];\n        if (signal[i] < 1.0)\n            signal[i] = 1.0;\n        snr = log(noise_stats->power[i] / noise_stats->noise[i]);\n#else\n        signal[i] = fe_log_sub(noise_stats->power[i], noise_stats->noise[i]);\n        snr = noise_stats->power[i] - noise_stats->noise[i];\n#endif    \n        if (snr > lrt)\n            lrt = snr;\n    }\n    is_quiet = fe_is_frame_quiet(noise_stats, signal, num_filts);\n\n#ifdef VAD_DEBUG\n    if (lrt < fe->vad_threshold)\n        low_snr++;\n    else if (is_quiet)\n        low_volume++;\n#endif\n\n#ifndef FIXED_POINT\n    if (fe->remove_silence && (lrt < fe->vad_threshold || is_quiet)) {\n#else\n    if (fe->remove_silence && (lrt < FLOAT2FIX(fe->vad_threshold) || is_quiet)) {\n#endif\n        *in_speech = FALSE;\n    } else {\n        *in_speech = TRUE;\n    }\n\n#ifdef VAD_DEBUG\n#ifndef FIXED_POINT\n    fprintf(vad_stats, \"%.3f %d\\n\", lrt, *in_speech);\n#else\n    fprintf(vad_stats, \"%d %d\\n\", lrt, *in_speech);\n#endif\n#endif\n\n    fe_lower_envelope(noise_stats, signal, noise_stats->floor, num_filts);\n\n    fe_temp_masking(noise_stats, signal, noise_stats->peak, num_filts);\n\n    if (!fe->remove_noise) {\n        /* no need for further calculations if noise cancellation disabled */\n        ckd_free(signal);\n        return;\n    }\n\n    for (i = 0; i < num_filts; i++) {\n        if (signal[i] < noise_stats->floor[i])\n            signal[i] = noise_stats->floor[i];\n    }\n\n    gain = (powspec_t *) ckd_calloc(num_filts, sizeof(powspec_t));\n#ifndef FIXED_POINT\n    for (i = 0; i < num_filts; i++) {\n        if (signal[i] < noise_stats->max_gain * noise_stats->power[i])\n            gain[i] = signal[i] / noise_stats->power[i];\n        else\n            gain[i] = noise_stats->max_gain;\n        if (gain[i] < noise_stats->inv_max_gain)\n            gain[i] = noise_stats->inv_max_gain;\n    }\n#else\n    for (i = 0; i < num_filts; i++) {\n        gain[i] = signal[i] - noise_stats->power[i];\n        if (gain[i] > noise_stats->max_gain)\n            gain[i] = noise_stats->max_gain;\n        if (gain[i] < noise_stats->inv_max_gain)\n            gain[i] = noise_stats->inv_max_gain;\n    }\n#endif\n\n    /* Weight smoothing and time frequency normalization */\n    fe_weight_smooth(noise_stats, mfspec, gain, num_filts);\n\n    ckd_free(gain);\n    ckd_free(signal);\n}\n\nvoid\nfe_vad_hangover(fe_t * fe, mfcc_t * feat, int32 is_speech, int32 store_pcm)\n{\n    if (!fe->vad_data->in_speech) {\n        fe_prespch_write_cep(fe->vad_data->prespch_buf, feat);\n        if (store_pcm)\n            fe_prespch_write_pcm(fe->vad_data->prespch_buf, fe->spch);\n    }\n    \n    /* track vad state and deal with cepstrum prespeech buffer */\n    if (is_speech) {\n        fe->vad_data->post_speech_frames = 0;\n        if (!fe->vad_data->in_speech) {\n            fe->vad_data->pre_speech_frames++;\n            /* check for transition sil->speech */\n            if (fe->vad_data->pre_speech_frames >= fe->start_speech) {\n                fe->vad_data->pre_speech_frames = 0;\n                fe->vad_data->in_speech = 1;\n            }\n        }\n    } else {\n        fe->vad_data->pre_speech_frames = 0;\n        if (fe->vad_data->in_speech) {\n            fe->vad_data->post_speech_frames++;\n            /* check for transition speech->sil */\n            if (fe->vad_data->post_speech_frames >= fe->post_speech) {\n                fe->vad_data->post_speech_frames = 0;\n                fe->vad_data->in_speech = 0;\n    \t        fe_prespch_reset_cep(fe->vad_data->prespch_buf);\n        \tfe_prespch_reset_pcm(fe->vad_data->prespch_buf);\n            }\n        }\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n* Copyright (c) 2013 Carnegie Mellon University.  All rights \n* reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n*\n* 1. Redistributions of source code must retain the above copyright\n*    notice, this list of conditions and the following disclaimer. \n*\n* 2. Redistributions in binary form must reproduce the above copyright\n*    notice, this list of conditions and the following disclaimer in\n*    the documentation and/or other materials provided with the\n*    distribution.\n*\n* This work was supported in part by funding from the Defense Advanced \n* Research Projects Agency and the National Science Foundation of the \n* United States of America, and the CMU Sphinx Speech Consortium.\n*\n* THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n* ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n* PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n* NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*\n* ====================================================================\n*\n*/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/err.h\"\n\n#include \"fe_prespch_buf.h\"\n\nstruct prespch_buf_s {\n    /* saved mfcc frames */\n    mfcc_t **cep_buf;\n    /* saved pcm audio */\n    int16 *pcm_buf;\n\n    /* flag for pcm buffer initialization */\n    int16 cep_write_ptr;\n    /* read pointer for cep buffer */\n    int16 cep_read_ptr;\n    /* Count */\n    int16 ncep;\n    \n\n    /* flag for pcm buffer initialization */\n    int16 pcm_write_ptr;\n    /* read pointer for cep buffer */\n    int16 pcm_read_ptr;\n    /* Count */\n    int16 npcm;\n    \n    /* frames amount in cep buffer */\n    int16 num_frames_cep;\n    /* frames amount in pcm buffer */\n    int16 num_frames_pcm;\n    /* filters amount */\n    int16 num_cepstra;\n    /* amount of fresh samples in frame */\n    int16 num_samples;\n};\n\nprespch_buf_t *\nfe_prespch_init(int num_frames, int num_cepstra, int num_samples)\n{\n    prespch_buf_t *prespch_buf;\n\n    prespch_buf = (prespch_buf_t *) ckd_calloc(1, sizeof(prespch_buf_t));\n\n    prespch_buf->num_cepstra = num_cepstra;\n    prespch_buf->num_frames_cep = num_frames;\n    prespch_buf->num_samples = num_samples;\n    prespch_buf->num_frames_pcm = 0;\n\n    prespch_buf->cep_write_ptr = 0;\n    prespch_buf->cep_read_ptr = 0;\n    prespch_buf->ncep = 0;\n    \n    prespch_buf->pcm_write_ptr = 0;\n    prespch_buf->pcm_read_ptr = 0;\n    prespch_buf->npcm = 0;\n\n    prespch_buf->cep_buf = (mfcc_t **)\n        ckd_calloc_2d(num_frames, num_cepstra,\n                      sizeof(**prespch_buf->cep_buf));\n\n    prespch_buf->pcm_buf = (int16 *)\n        ckd_calloc(prespch_buf->num_frames_pcm * prespch_buf->num_samples,\n                   sizeof(int16));\n\n    return prespch_buf;\n}\n\n\nint\nfe_prespch_read_cep(prespch_buf_t * prespch_buf, mfcc_t * feat)\n{\n    if (prespch_buf->ncep == 0)\n        return 0;\n    memcpy(feat, prespch_buf->cep_buf[prespch_buf->cep_read_ptr],\n           sizeof(mfcc_t) * prespch_buf->num_cepstra);\n    prespch_buf->cep_read_ptr = (prespch_buf->cep_read_ptr + 1) % prespch_buf->num_frames_cep;\n    prespch_buf->ncep--;\n    return 1;\n}\n\nvoid\nfe_prespch_write_cep(prespch_buf_t * prespch_buf, mfcc_t * feat)\n{\n    memcpy(prespch_buf->cep_buf[prespch_buf->cep_write_ptr], feat,\n           sizeof(mfcc_t) * prespch_buf->num_cepstra);\n    prespch_buf->cep_write_ptr = (prespch_buf->cep_write_ptr + 1) % prespch_buf->num_frames_cep;\n    if (prespch_buf->ncep < prespch_buf->num_frames_cep) {\n        prespch_buf->ncep++;\t\n    } else {\n        prespch_buf->cep_read_ptr = (prespch_buf->cep_read_ptr + 1) % prespch_buf->num_frames_cep;\n    }\n}\n\nvoid\nfe_prespch_read_pcm(prespch_buf_t * prespch_buf, int16 *samples,\n                    int32 *samples_num)\n{\n    int i;\n    int16 *cursample = samples;\n    *samples_num = prespch_buf->npcm * prespch_buf->num_samples;\n    for (i = 0; i < prespch_buf->npcm; i++) {\n\tmemcpy(cursample, &prespch_buf->pcm_buf[prespch_buf->pcm_read_ptr * prespch_buf->num_samples],\n\t           prespch_buf->num_samples * sizeof(int16));\n\tprespch_buf->pcm_read_ptr = (prespch_buf->pcm_read_ptr + 1) % prespch_buf->num_frames_pcm;\n    }\n    prespch_buf->pcm_read_ptr = 0;\n    prespch_buf->pcm_write_ptr = 0;    \n    prespch_buf->npcm = 0;\n    return;\n}\n\nvoid\nfe_prespch_write_pcm(prespch_buf_t * prespch_buf, int16 * samples)\n{\n    int32 sample_ptr;\n\n    sample_ptr = prespch_buf->pcm_write_ptr * prespch_buf->num_samples;\n    memcpy(&prespch_buf->pcm_buf[sample_ptr], samples,\n           prespch_buf->num_samples * sizeof(int16));\n\n    prespch_buf->pcm_write_ptr = (prespch_buf->pcm_write_ptr + 1) % prespch_buf->num_frames_pcm;\n    if (prespch_buf->npcm < prespch_buf->num_frames_pcm) {\n        prespch_buf->npcm++;\t\n    } else {\n        prespch_buf->pcm_read_ptr = (prespch_buf->pcm_read_ptr + 1) % prespch_buf->num_frames_pcm;\n    }\n}\n\nvoid\nfe_prespch_reset_cep(prespch_buf_t * prespch_buf)\n{\n    prespch_buf->cep_read_ptr = 0;\n    prespch_buf->cep_write_ptr = 0;\n    prespch_buf->ncep = 0;\n}\n\nvoid\nfe_prespch_reset_pcm(prespch_buf_t * prespch_buf)\n{\n    prespch_buf->pcm_read_ptr = 0;\n    prespch_buf->pcm_write_ptr = 0;\n    prespch_buf->npcm = 0;\n}\n\nvoid\nfe_prespch_free(prespch_buf_t * prespch_buf)\n{\n    if (!prespch_buf)\n\treturn;\n    if (prespch_buf->cep_buf)\n        ckd_free_2d((void **) prespch_buf->cep_buf);\n    if (prespch_buf->pcm_buf)\n        ckd_free(prespch_buf->pcm_buf);\n    ckd_free(prespch_buf);\n}\n\nint32 \nfe_prespch_ncep(prespch_buf_t * prespch_buf)\n{\n    return prespch_buf->ncep;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * agc.c -- Various forms of automatic gain control (AGC)\n * \n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1996 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log$\n * Revision 1.5  2005/06/21  19:25:41  arthchan2003\n * 1, Fixed doxygen documentation. 2, Added $ keyword.\n * \n * Revision 1.3  2005/03/30 01:22:46  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 04-Nov-95\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tCreated.\n */\n\n#include <string.h>\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/agc.h\"\n\n/* NOTE!  These must match the enum in agc.h */\nconst char *agc_type_str[] = {\n    \"none\",\n    \"max\",\n    \"emax\",\n    \"noise\"\n};\nstatic const int n_agc_type_str = sizeof(agc_type_str)/sizeof(agc_type_str[0]);\n\nagc_type_t\nagc_type_from_str(const char *str)\n{\n    int i;\n\n    for (i = 0; i < n_agc_type_str; ++i) {\n        if (0 == strcmp(str, agc_type_str[i]))\n            return (agc_type_t)i;\n    }\n    E_FATAL(\"Unknown AGC type '%s'\\n\", str);\n    return AGC_NONE;\n}\n\nagc_t *agc_init(void)\n{\n    agc_t *agc;\n    agc = ckd_calloc(1, sizeof(*agc));\n    agc->noise_thresh = FLOAT2MFCC(2.0);\n    \n    return agc;\n}\n\nvoid agc_free(agc_t *agc)\n{\n    ckd_free(agc);\n}\n\n/**\n * Normalize c0 for all frames such that max(c0) = 0.\n */\nvoid\nagc_max(agc_t *agc, mfcc_t **mfc, int32 n_frame)\n{\n    int32 i;\n\n    if (n_frame <= 0)\n        return;\n    agc->obs_max = mfc[0][0];\n    for (i = 1; i < n_frame; i++) {\n        if (mfc[i][0] > agc->obs_max) {\n            agc->obs_max = mfc[i][0];\n            agc->obs_frame = 1;\n        }\n    }\n\n    E_INFO(\"AGCMax: obs=max= %.2f\\n\", agc->obs_max);\n    for (i = 0; i < n_frame; i++)\n        mfc[i][0] -= agc->obs_max;\n}\n\nvoid\nagc_emax_set(agc_t *agc, float32 m)\n{\n    agc->max = FLOAT2MFCC(m);\n    E_INFO(\"AGCEMax: max= %.2f\\n\", m);\n}\n\nfloat32\nagc_emax_get(agc_t *agc)\n{\n    return MFCC2FLOAT(agc->max);\n}\n\nvoid\nagc_emax(agc_t *agc, mfcc_t **mfc, int32 n_frame)\n{\n    int i;\n\n    if (n_frame <= 0)\n        return;\n    for (i = 0; i < n_frame; ++i) {\n        if (mfc[i][0] > agc->obs_max) {\n            agc->obs_max = mfc[i][0];\n            agc->obs_frame = 1;\n        }\n        mfc[i][0] -= agc->max;\n    }\n}\n\n/* Update estimated max for next utterance */\nvoid\nagc_emax_update(agc_t *agc)\n{\n    if (agc->obs_frame) {            /* Update only if some data observed */\n        agc->obs_max_sum += agc->obs_max;\n        agc->obs_utt++;\n\n        /* Re-estimate max over past history; decay the history */\n        agc->max = agc->obs_max_sum / agc->obs_utt;\n        if (agc->obs_utt == 16) {\n            agc->obs_max_sum /= 2;\n            agc->obs_utt = 8;\n        }\n    }\n    E_INFO(\"AGCEMax: obs= %.2f, new= %.2f\\n\", agc->obs_max, agc->max);\n\n    /* Reset the accumulators for the next utterance. */\n    agc->obs_frame = 0;\n    agc->obs_max = FLOAT2MFCC(-1000.0); /* Less than any real C0 value (hopefully!!) */\n}\n\nvoid\nagc_noise(agc_t *agc,\n          mfcc_t **cep,\n          int32 nfr)\n{\n    mfcc_t min_energy; /* Minimum log-energy */\n    mfcc_t noise_level;        /* Average noise_level */\n    int32 i;           /* frame index */\n    int32 noise_frames;        /* Number of noise frames */\n\n    /* Determine minimum log-energy in utterance */\n    min_energy = cep[0][0];\n    for (i = 0; i < nfr; ++i) {\n        if (cep[i][0] < min_energy)\n            min_energy = cep[i][0];\n    }\n\n    /* Average all frames between min_energy and min_energy + agc->noise_thresh */\n    noise_frames = 0;\n    noise_level = 0;\n    min_energy += agc->noise_thresh;\n    for (i = 0; i < nfr; ++i) {\n        if (cep[i][0] < min_energy) {\n            noise_level += cep[i][0];\n            noise_frames++;\n        }\n    }\n\n    if (noise_frames > 0) {\n        noise_level /= noise_frames;\n        E_INFO(\"AGC NOISE: max= %6.3f\\n\", MFCC2FLOAT(noise_level));\n        /* Subtract noise_level from all log_energy values */\n        for (i = 0; i < nfr; i++) {\n            cep[i][0] -= noise_level;\n        }\n    }\n}\n\nvoid\nagc_set_threshold(agc_t *agc, float32 threshold)\n{\n    agc->noise_thresh = FLOAT2MFCC(threshold);\n}\n\nfloat32\nagc_get_threshold(agc_t *agc)\n{\n    return FLOAT2MFCC(agc->noise_thresh);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * cmn.c -- Various forms of cepstral mean normalization\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <math.h>\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4244)\n#endif\n\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/cmn.h\"\n\n/* NOTE!  These must match the enum in cmn.h */\nconst char *cmn_type_str[] = {\n    \"none\",\n    \"batch\",\n    \"live\"\n};\nconst char *cmn_alt_type_str[] = {\n    \"none\",\n    \"current\",\n    \"prior\"\n};\nstatic const int n_cmn_type_str = sizeof(cmn_type_str)/sizeof(cmn_type_str[0]);\n\ncmn_type_t\ncmn_type_from_str(const char *str)\n{\n    int i;\n\n    for (i = 0; i < n_cmn_type_str; ++i) {\n        if (0 == strcmp(str, cmn_type_str[i]) || 0 == strcmp(str, cmn_alt_type_str[i]))\n            return (cmn_type_t)i;\n    }\n    E_FATAL(\"Unknown CMN type '%s'\\n\", str);\n    return CMN_NONE;\n}\n\ncmn_t *\ncmn_init(int32 veclen)\n{\n    cmn_t *cmn;\n    cmn = (cmn_t *) ckd_calloc(1, sizeof(cmn_t));\n    cmn->veclen = veclen;\n    cmn->cmn_mean = (mfcc_t *) ckd_calloc(veclen, sizeof(mfcc_t));\n    cmn->cmn_var = (mfcc_t *) ckd_calloc(veclen, sizeof(mfcc_t));\n    cmn->sum = (mfcc_t *) ckd_calloc(veclen, sizeof(mfcc_t));\n    cmn->nframe = 0;\n\n    return cmn;\n}\n\n\nvoid\ncmn(cmn_t *cmn, mfcc_t ** mfc, int32 varnorm, int32 n_frame)\n{\n    mfcc_t *mfcp;\n    mfcc_t t;\n    int32 i, f;\n    int32 n_pos_frame;\n\n    assert(mfc != NULL);\n\n    if (n_frame <= 0)\n        return;\n\n    /* If cmn->cmn_mean wasn't NULL, we need to zero the contents */\n    memset(cmn->cmn_mean, 0, cmn->veclen * sizeof(mfcc_t));\n\n    /* Find mean cep vector for this utterance */\n    for (f = 0, n_pos_frame = 0; f < n_frame; f++) {\n        mfcp = mfc[f];\n\n        /* Skip zero energy frames */\n        if (mfcp[0] < 0)\n    \t    continue;\n\n        for (i = 0; i < cmn->veclen; i++) {\n            cmn->cmn_mean[i] += mfcp[i];\n        }\n\n        n_pos_frame++;\n    }\n\n    for (i = 0; i < cmn->veclen; i++)\n        cmn->cmn_mean[i] /= n_pos_frame;\n\n    E_INFO(\"CMN: \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\"\\n\");\n    if (!varnorm) {\n        /* Subtract mean from each cep vector */\n        for (f = 0; f < n_frame; f++) {\n            mfcp = mfc[f];\n            for (i = 0; i < cmn->veclen; i++)\n                mfcp[i] -= cmn->cmn_mean[i];\n        }\n    }\n    else {\n        /* Scale cep vectors to have unit variance along each dimension, and subtract means */\n        /* If cmn->cmn_var wasn't NULL, we need to zero the contents */\n        memset(cmn->cmn_var, 0, cmn->veclen * sizeof(mfcc_t));\n\n        for (f = 0; f < n_frame; f++) {\n            mfcp = mfc[f];\n\n            for (i = 0; i < cmn->veclen; i++) {\n                t = mfcp[i] - cmn->cmn_mean[i];\n                cmn->cmn_var[i] += MFCCMUL(t, t);\n            }\n        }\n        for (i = 0; i < cmn->veclen; i++)\n            /* Inverse Std. Dev, RAH added type case from sqrt */\n            cmn->cmn_var[i] = FLOAT2MFCC(sqrt((float64)n_frame / MFCC2FLOAT(cmn->cmn_var[i])));\n\n        for (f = 0; f < n_frame; f++) {\n            mfcp = mfc[f];\n            for (i = 0; i < cmn->veclen; i++)\n                mfcp[i] = MFCCMUL((mfcp[i] - cmn->cmn_mean[i]), cmn->cmn_var[i]);\n        }\n    }\n}\n\n/* \n * RAH, free previously allocated memory\n */\nvoid\ncmn_free(cmn_t * cmn)\n{\n    if (cmn != NULL) {\n        if (cmn->cmn_var)\n            ckd_free((void *) cmn->cmn_var);\n\n        if (cmn->cmn_mean)\n            ckd_free((void *) cmn->cmn_mean);\n\n        if (cmn->sum)\n            ckd_free((void *) cmn->sum);\n\n        ckd_free((void *) cmn);\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4244)\n#endif\n\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/cmn.h\"\n\nvoid\ncmn_live_set(cmn_t *cmn, mfcc_t const * vec)\n{\n    int32 i;\n\n    E_INFO(\"Update from < \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\">\\n\");\n\n    for (i = 0; i < cmn->veclen; i++) {\n        cmn->cmn_mean[i] = vec[i];\n        cmn->sum[i] = vec[i] * CMN_WIN;\n    }\n    cmn->nframe = CMN_WIN;\n\n    E_INFO(\"Update to   < \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\">\\n\");\n}\n\nvoid\ncmn_live_get(cmn_t *cmn, mfcc_t * vec)\n{\n    int32 i;\n\n    for (i = 0; i < cmn->veclen; i++)\n        vec[i] = cmn->cmn_mean[i];\n\n}\n\nstatic void\ncmn_live_shiftwin(cmn_t *cmn)\n{\n    mfcc_t sf;\n    int32 i;\n\n    E_INFO(\"Update from < \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\">\\n\");\n\n    sf = FLOAT2MFCC(1.0) / cmn->nframe;\n    for (i = 0; i < cmn->veclen; i++)\n        cmn->cmn_mean[i] = cmn->sum[i] / cmn->nframe; /* sum[i] * sf */\n\n    /* Make the accumulation decay exponentially */\n    if (cmn->nframe >= CMN_WIN_HWM) {\n        sf = CMN_WIN * sf;\n        for (i = 0; i < cmn->veclen; i++)\n            cmn->sum[i] = MFCCMUL(cmn->sum[i], sf);\n        cmn->nframe = CMN_WIN;\n    }\n\n    E_INFO(\"Update to   < \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\">\\n\");\n}\n\nvoid\ncmn_live_update(cmn_t *cmn)\n{\n    mfcc_t sf;\n    int32 i;\n\n    if (cmn->nframe <= 0)\n        return;\n\n    E_INFO(\"Update from < \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\">\\n\");\n\n    /* Update mean buffer */\n    sf = FLOAT2MFCC(1.0) / cmn->nframe;\n    for (i = 0; i < cmn->veclen; i++)\n        cmn->cmn_mean[i] = cmn->sum[i] / cmn->nframe; /* sum[i] * sf; */\n\n    /* Make the accumulation decay exponentially */\n    if (cmn->nframe > CMN_WIN_HWM) {\n        sf = CMN_WIN * sf;\n        for (i = 0; i < cmn->veclen; i++)\n            cmn->sum[i] = MFCCMUL(cmn->sum[i], sf);\n        cmn->nframe = CMN_WIN;\n    }\n\n    E_INFO(\"Update to   < \");\n    for (i = 0; i < cmn->veclen; i++)\n        E_INFOCONT(\"%5.2f \", MFCC2FLOAT(cmn->cmn_mean[i]));\n    E_INFOCONT(\">\\n\");\n}\n\nvoid\ncmn_live(cmn_t *cmn, mfcc_t **incep, int32 varnorm, int32 nfr)\n{\n    int32 i, j;\n\n    if (nfr <= 0)\n        return;\n\n    if (varnorm)\n        E_FATAL\n            (\"Variance normalization not implemented in live mode decode\\n\");\n\n    for (i = 0; i < nfr; i++) {\n\n\t/* Skip zero energy frames */\n\tif (incep[i][0] < 0)\n\t    continue;\n\n        for (j = 0; j < cmn->veclen; j++) {\n            cmn->sum[j] += incep[i][j];\n            incep[i][j] -= cmn->cmn_mean[j];\n        }\n\n        ++cmn->nframe;\n    }\n\n    /* Shift buffer down if we have more than CMN_WIN_HWM frames */\n    if (cmn->nframe > CMN_WIN_HWM)\n        cmn_live_shiftwin(cmn);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * feat.c -- Feature vector description and cepstra->feature computation.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1996 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log$\n * Revision 1.22  2006/02/23  03:59:40  arthchan2003\n * Merged from branch SPHINX3_5_2_RCI_IRII_BRANCH: a, Free buffers correctly. b, Fixed dox-doc.\n * \n * Revision 1.21.4.3  2005/10/17 04:45:57  arthchan2003\n * Free stuffs in cmn and feat corectly.\n *\n * Revision 1.21.4.2  2005/09/26 02:19:57  arthchan2003\n * Add message to show the directory which the feature is searched for.\n *\n * Revision 1.21.4.1  2005/07/03 22:55:50  arthchan2003\n * More correct deallocation in feat.c. The cmn deallocation is still not correct at this point.\n *\n * Revision 1.21  2005/06/22 03:29:35  arthchan2003\n * Makefile.am s  for all subdirectory of libs3decoder/\n *\n * Revision 1.4  2005/04/21 23:50:26  archan\n * Some more refactoring on the how reporting of structures inside kbcore_t is done, it is now 50% nice. Also added class-based LM test case into test-decode.sh.in.  At this moment, everything in search mode 5 is already done.  It is time to test the idea whether the search can really be used.\n *\n * Revision 1.3  2005/03/30 01:22:46  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 20.Apr.2001  RAH (rhoughton@mediasite.com, ricky.houghton@cs.cmu.edu)\n *              Adding feat_free() to free allocated memory\n *\n * 02-Jan-2001\tRita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University\n *\t\tModified feat_s2mfc2feat_block() to handle empty buffers at\n *\t\tthe end of an utterance\n *\n * 30-Dec-2000\tRita Singh (rsingh@cs.cmu.edu) at Carnegie Mellon University\n *\t\tAdded feat_s2mfc2feat_block() to allow feature computation\n *\t\tfrom sequences of blocks of cepstral vectors\n *\n * 12-Jun-98\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tMajor changes to accommodate arbitrary feature input types.  Added\n * \t\tfeat_read(), moved various cep2feat functions from other files into\n *\t\tthis one.  Also, made this module object-oriented with the feat_t type.\n * \t\tChanged definition of s2mfc_read to let the caller manage MFC buffers.\n * \n * 03-Oct-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tAdded unistd.h include.\n * \n * 02-Oct-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tAdded check for sf argument to s2mfc_read being within file size.\n * \n * 18-Sep-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tAdded sf, ef parameters to s2mfc_read().\n * \n * 10-Jan-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tAdded feat_cepsize().\n * \t\tAdded different feature-handling (s2_4x, s3_1x39 at this point).\n * \t\tMoved feature-dependent functions to feature-dependent files.\n * \n * 09-Jan-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tMoved constant declarations from feat.h into here.\n * \n * 04-Nov-95\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tCreated.\n */\n\n\n/*\n * This module encapsulates different feature streams used by the Sphinx group.  New\n * stream types can be added by augmenting feat_init() and providing an accompanying\n * compute_feat function.  It also provides a \"generic\" feature vector definition for\n * handling \"arbitrary\" speech input feature types (see the last section in feat_init()).\n * In this case the speech input data should already be feature vectors; no computation,\n * such as MFC->feature conversion, is available or needed.\n */\n\n#include <assert.h>\n#include <string.h>\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4244 4996)\n#endif\n\n#include \"sphinxbase/fe.h\"\n#include \"sphinxbase/feat.h\"\n#include \"sphinxbase/bio.h\"\n#include \"sphinxbase/pio.h\"\n#include \"sphinxbase/cmn.h\"\n#include \"sphinxbase/agc.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/glist.h\"\n\n#define FEAT_VERSION\t\"1.0\"\n#define FEAT_DCEP_WIN\t\t2\n\n#ifdef DUMP_FEATURES\nstatic void\ncep_dump_dbg(feat_t *fcb, mfcc_t **mfc, int32 nfr, const char *text)\n{\n    int32 i, j;\n\n    E_INFO(\"%s\\n\", text);\n    for (i = 0; i < nfr; i++) {\n        for (j = 0; j < fcb->cepsize; j++) {\n            fprintf(stderr, \"%f \", MFCC2FLOAT(mfc[i][j]));\n        }\n        fprintf(stderr, \"\\n\");\n    }\n}\nstatic void\nfeat_print_dbg(feat_t *fcb, mfcc_t ***feat, int32 nfr, const char *text)\n{\n    E_INFO(\"%s\\n\", text);\n    feat_print(fcb, feat, nfr, stderr);\n}\n#else /* !DUMP_FEATURES */\n#define cep_dump_dbg(fcb,mfc,nfr,text)\n#define feat_print_dbg(fcb,mfc,nfr,text)\n#endif\n\nint32 **\nparse_subvecs(char const *str)\n{\n    char const *strp;\n    int32 n, n2, l;\n    glist_t dimlist;            /* List of dimensions in one subvector */\n    glist_t veclist;            /* List of dimlists (subvectors) */\n    int32 **subvec;\n    gnode_t *gn, *gn2;\n\n    veclist = NULL;\n\n    strp = str;\n    for (;;) {\n        dimlist = NULL;\n\n        for (;;) {\n            if (sscanf(strp, \"%d%n\", &n, &l) != 1)\n                E_FATAL(\"'%s': Couldn't read int32 @pos %d\\n\", str,\n                        strp - str);\n            strp += l;\n\n            if (*strp == '-') {\n                strp++;\n\n                if (sscanf(strp, \"%d%n\", &n2, &l) != 1)\n                    E_FATAL(\"'%s': Couldn't read int32 @pos %d\\n\", str,\n                            strp - str);\n                strp += l;\n            }\n            else\n                n2 = n;\n\n            if ((n < 0) || (n > n2))\n                E_FATAL(\"'%s': Bad subrange spec ending @pos %d\\n\", str,\n                        strp - str);\n\n            for (; n <= n2; n++) {\n\t\tgnode_t *gn;\n\t\tfor (gn = dimlist; gn; gn = gnode_next(gn))\n\t\t    if (gnode_int32(gn) == n)\n\t\t\tbreak;\n\t\tif (gn != NULL)\n                    E_FATAL(\"'%s': Duplicate dimension ending @pos %d\\n\",\n                            str, strp - str);\n\n                dimlist = glist_add_int32(dimlist, n);\n            }\n\n            if ((*strp == '\\0') || (*strp == '/'))\n                break;\n\n            if (*strp != ',')\n                E_FATAL(\"'%s': Bad delimiter @pos %d\\n\", str, strp - str);\n\n            strp++;\n        }\n\n        veclist = glist_add_ptr(veclist, (void *) dimlist);\n\n        if (*strp == '\\0')\n            break;\n\n        assert(*strp == '/');\n        strp++;\n    }\n\n    /* Convert the glists to arrays; remember the glists are in reverse order of the input! */\n    n = glist_count(veclist);   /* #Subvectors */\n    subvec = (int32 **) ckd_calloc(n + 1, sizeof(int32 *));     /* +1 for sentinel */\n    subvec[n] = NULL;           /* sentinel */\n\n    for (--n, gn = veclist; (n >= 0) && gn; gn = gnode_next(gn), --n) {\n        gn2 = (glist_t) gnode_ptr(gn);\n\n        n2 = glist_count(gn2);  /* Length of this subvector */\n        if (n2 <= 0)\n            E_FATAL(\"'%s': 0-length subvector\\n\", str);\n\n        subvec[n] = (int32 *) ckd_calloc(n2 + 1, sizeof(int32));        /* +1 for sentinel */\n        subvec[n][n2] = -1;     /* sentinel */\n\n        for (--n2; (n2 >= 0) && gn2; gn2 = gnode_next(gn2), --n2)\n            subvec[n][n2] = gnode_int32(gn2);\n        assert((n2 < 0) && (!gn2));\n    }\n    assert((n < 0) && (!gn));\n\n    /* Free the glists */\n    for (gn = veclist; gn; gn = gnode_next(gn)) {\n        gn2 = (glist_t) gnode_ptr(gn);\n        glist_free(gn2);\n    }\n    glist_free(veclist);\n\n    return subvec;\n}\n\nvoid\nsubvecs_free(int32 **subvecs)\n{\n    int32 **sv;\n\n    for (sv = subvecs; sv && *sv; ++sv)\n        ckd_free(*sv);\n    ckd_free(subvecs);\n}\n\nint\nfeat_set_subvecs(feat_t *fcb, int32 **subvecs)\n{\n    int32 **sv;\n    uint32 n_sv, n_dim, i;\n\n    if (subvecs == NULL) {\n        subvecs_free(fcb->subvecs);\n        ckd_free(fcb->sv_buf);\n        ckd_free(fcb->sv_len);\n        fcb->n_sv = 0;\n        fcb->subvecs = NULL;\n        fcb->sv_len = NULL;\n        fcb->sv_buf = NULL;\n        fcb->sv_dim = 0;\n        return 0;\n    }\n\n    if (fcb->n_stream != 1) {\n        E_ERROR(\"Subvector specifications require single-stream features!\");\n        return -1;\n    }\n\n    n_sv = 0;\n    n_dim = 0;\n    for (sv = subvecs; sv && *sv; ++sv) {\n        int32 *d;\n\n        for (d = *sv; d && *d != -1; ++d) {\n            ++n_dim;\n        }\n        ++n_sv;\n    }\n    if (n_dim > feat_dimension(fcb)) {\n        E_ERROR(\"Total dimensionality of subvector specification %d \"\n                \"> feature dimensionality %d\\n\", n_dim, feat_dimension(fcb));\n        return -1;\n    }\n\n    fcb->n_sv = n_sv;\n    fcb->subvecs = subvecs;\n    fcb->sv_len = (uint32 *)ckd_calloc(n_sv, sizeof(*fcb->sv_len));\n    fcb->sv_buf = (mfcc_t *)ckd_calloc(n_dim, sizeof(*fcb->sv_buf));\n    fcb->sv_dim = n_dim;\n    for (i = 0; i < n_sv; ++i) {\n        int32 *d;\n        for (d = subvecs[i]; d && *d != -1; ++d) {\n            ++fcb->sv_len[i];\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Project feature components to subvectors (if any).\n */\nstatic void\nfeat_subvec_project(feat_t *fcb, mfcc_t ***inout_feat, uint32 nfr)\n{\n    uint32 i;\n\n    if (fcb->subvecs == NULL)\n        return;\n    for (i = 0; i < nfr; ++i) {\n        mfcc_t *out;\n        int32 j;\n\n        out = fcb->sv_buf;\n        for (j = 0; j < fcb->n_sv; ++j) {\n            int32 *d;\n            for (d = fcb->subvecs[j]; d && *d != -1; ++d) {\n                *out++ = inout_feat[i][0][*d];\n            }\n        }\n        memcpy(inout_feat[i][0], fcb->sv_buf, fcb->sv_dim * sizeof(*fcb->sv_buf));\n    }\n}\n\nmfcc_t ***\nfeat_array_alloc(feat_t * fcb, int32 nfr)\n{\n    int32 i, j, k;\n    mfcc_t *data, *d, ***feat;\n\n    assert(fcb);\n    assert(nfr > 0);\n    assert(feat_dimension(fcb) > 0);\n\n    /* Make sure to use the dimensionality of the features *before*\n       LDA and subvector projection. */\n    k = 0;\n    for (i = 0; i < fcb->n_stream; ++i)\n        k += fcb->stream_len[i];\n    assert(k >= feat_dimension(fcb));\n    assert(k >= fcb->sv_dim);\n\n    feat =\n        (mfcc_t ***) ckd_calloc_2d(nfr, feat_dimension1(fcb), sizeof(mfcc_t *));\n    data = (mfcc_t *) ckd_calloc(nfr * k, sizeof(mfcc_t));\n\n    for (i = 0; i < nfr; i++) {\n        d = data + i * k;\n        for (j = 0; j < feat_dimension1(fcb); j++) {\n            feat[i][j] = d;\n            d += feat_dimension2(fcb, j);\n        }\n    }\n\n    return feat;\n}\n\nmfcc_t ***\nfeat_array_realloc(feat_t *fcb, mfcc_t ***old_feat, int32 ofr, int32 nfr)\n{\n    int32 i, k, cf;\n    mfcc_t*** new_feat;\n\n    assert(fcb);\n    assert(nfr > 0);\n    assert(ofr > 0);\n    assert(feat_dimension(fcb) > 0);\n\n    /* Make sure to use the dimensionality of the features *before*\n       LDA and subvector projection. */\n    k = 0;\n    for (i = 0; i < fcb->n_stream; ++i)\n        k += fcb->stream_len[i];\n    assert(k >= feat_dimension(fcb));\n    assert(k >= fcb->sv_dim);\n    \n    new_feat = feat_array_alloc(fcb, nfr);\n\n    cf = (nfr < ofr) ? nfr : ofr;\n    memcpy(new_feat[0][0], old_feat[0][0], cf * k * sizeof(mfcc_t));\n\n    feat_array_free(old_feat);\n    \n    return new_feat;\n}\n\nvoid\nfeat_array_free(mfcc_t ***feat)\n{\n    ckd_free(feat[0][0]);\n    ckd_free_2d((void **)feat);\n}\n\nstatic void\nfeat_s2_4x_cep2feat(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    mfcc_t *f;\n    mfcc_t *w, *_w;\n    mfcc_t *w1, *w_1, *_w1, *_w_1;\n    mfcc_t d1, d2;\n    int32 i, j;\n\n    assert(fcb);\n    assert(feat_cepsize(fcb) == 13);\n    assert(feat_n_stream(fcb) == 4);\n    assert(feat_stream_len(fcb, 0) == 12);\n    assert(feat_stream_len(fcb, 1) == 24);\n    assert(feat_stream_len(fcb, 2) == 3);\n    assert(feat_stream_len(fcb, 3) == 12);\n    assert(feat_window_size(fcb) == 4);\n\n    /* CEP; skip C0 */\n    memcpy(feat[0], mfc[0] + 1, (feat_cepsize(fcb) - 1) * sizeof(mfcc_t));\n\n    /*\n     * DCEP(SHORT): mfc[2] - mfc[-2]\n     * DCEP(LONG):  mfc[4] - mfc[-4]\n     */\n    w = mfc[2] + 1;             /* +1 to skip C0 */\n    _w = mfc[-2] + 1;\n\n    f = feat[1];\n    for (i = 0; i < feat_cepsize(fcb) - 1; i++) /* Short-term */\n        f[i] = w[i] - _w[i];\n\n    w = mfc[4] + 1;             /* +1 to skip C0 */\n    _w = mfc[-4] + 1;\n\n    for (j = 0; j < feat_cepsize(fcb) - 1; i++, j++)    /* Long-term */\n        f[i] = w[j] - _w[j];\n\n    /* D2CEP: (mfc[3] - mfc[-1]) - (mfc[1] - mfc[-3]) */\n    w1 = mfc[3] + 1;            /* Final +1 to skip C0 */\n    _w1 = mfc[-1] + 1;\n    w_1 = mfc[1] + 1;\n    _w_1 = mfc[-3] + 1;\n\n    f = feat[3];\n    for (i = 0; i < feat_cepsize(fcb) - 1; i++) {\n        d1 = w1[i] - _w1[i];\n        d2 = w_1[i] - _w_1[i];\n\n        f[i] = d1 - d2;\n    }\n\n    /* POW: C0, DC0, D2C0; differences computed as above for rest of cep */\n    f = feat[2];\n    f[0] = mfc[0][0];\n    f[1] = mfc[2][0] - mfc[-2][0];\n\n    d1 = mfc[3][0] - mfc[-1][0];\n    d2 = mfc[1][0] - mfc[-3][0];\n    f[2] = d1 - d2;\n}\n\n\nstatic void\nfeat_s3_1x39_cep2feat(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    mfcc_t *f;\n    mfcc_t *w, *_w;\n    mfcc_t *w1, *w_1, *_w1, *_w_1;\n    mfcc_t d1, d2;\n    int32 i;\n\n    assert(fcb);\n    assert(feat_cepsize(fcb) == 13);\n    assert(feat_n_stream(fcb) == 1);\n    assert(feat_stream_len(fcb, 0) == 39);\n    assert(feat_window_size(fcb) == 3);\n\n    /* CEP; skip C0 */\n    memcpy(feat[0], mfc[0] + 1, (feat_cepsize(fcb) - 1) * sizeof(mfcc_t));\n    /*\n     * DCEP: mfc[2] - mfc[-2];\n     */\n    f = feat[0] + feat_cepsize(fcb) - 1;\n    w = mfc[2] + 1;             /* +1 to skip C0 */\n    _w = mfc[-2] + 1;\n\n    for (i = 0; i < feat_cepsize(fcb) - 1; i++)\n        f[i] = w[i] - _w[i];\n\n    /* POW: C0, DC0, D2C0 */\n    f += feat_cepsize(fcb) - 1;\n\n    f[0] = mfc[0][0];\n    f[1] = mfc[2][0] - mfc[-2][0];\n\n    d1 = mfc[3][0] - mfc[-1][0];\n    d2 = mfc[1][0] - mfc[-3][0];\n    f[2] = d1 - d2;\n\n    /* D2CEP: (mfc[3] - mfc[-1]) - (mfc[1] - mfc[-3]) */\n    f += 3;\n\n    w1 = mfc[3] + 1;            /* Final +1 to skip C0 */\n    _w1 = mfc[-1] + 1;\n    w_1 = mfc[1] + 1;\n    _w_1 = mfc[-3] + 1;\n\n    for (i = 0; i < feat_cepsize(fcb) - 1; i++) {\n        d1 = w1[i] - _w1[i];\n        d2 = w_1[i] - _w_1[i];\n\n        f[i] = d1 - d2;\n    }\n}\n\n\nstatic void\nfeat_s3_cep(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    assert(fcb);\n    assert(feat_n_stream(fcb) == 1);\n    assert(feat_window_size(fcb) == 0);\n\n    /* CEP */\n    memcpy(feat[0], mfc[0], feat_cepsize(fcb) * sizeof(mfcc_t));\n}\n\nstatic void\nfeat_s3_cep_dcep(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    mfcc_t *f;\n    mfcc_t *w, *_w;\n    int32 i;\n\n    assert(fcb);\n    assert(feat_n_stream(fcb) == 1);\n    assert(feat_stream_len(fcb, 0) == feat_cepsize(fcb) * 2);\n    assert(feat_window_size(fcb) == 2);\n\n    /* CEP */\n    memcpy(feat[0], mfc[0], feat_cepsize(fcb) * sizeof(mfcc_t));\n\n    /*\n     * DCEP: mfc[2] - mfc[-2];\n     */\n    f = feat[0] + feat_cepsize(fcb);\n    w = mfc[2];\n    _w = mfc[-2];\n\n    for (i = 0; i < feat_cepsize(fcb); i++)\n        f[i] = w[i] - _w[i];\n}\n\nstatic void\nfeat_1s_c_d_dd_cep2feat(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    mfcc_t *f;\n    mfcc_t *w, *_w;\n    mfcc_t *w1, *w_1, *_w1, *_w_1;\n    mfcc_t d1, d2;\n    int32 i;\n\n    assert(fcb);\n    assert(feat_n_stream(fcb) == 1);\n    assert(feat_stream_len(fcb, 0) == feat_cepsize(fcb) * 3);\n    assert(feat_window_size(fcb) == FEAT_DCEP_WIN + 1);\n\n    /* CEP */\n    memcpy(feat[0], mfc[0], feat_cepsize(fcb) * sizeof(mfcc_t));\n\n    /*\n     * DCEP: mfc[w] - mfc[-w], where w = FEAT_DCEP_WIN;\n     */\n    f = feat[0] + feat_cepsize(fcb);\n    w = mfc[FEAT_DCEP_WIN];\n    _w = mfc[-FEAT_DCEP_WIN];\n\n    for (i = 0; i < feat_cepsize(fcb); i++)\n        f[i] = w[i] - _w[i];\n\n    /* \n     * D2CEP: (mfc[w+1] - mfc[-w+1]) - (mfc[w-1] - mfc[-w-1]), \n     * where w = FEAT_DCEP_WIN \n     */\n    f += feat_cepsize(fcb);\n\n    w1 = mfc[FEAT_DCEP_WIN + 1];\n    _w1 = mfc[-FEAT_DCEP_WIN + 1];\n    w_1 = mfc[FEAT_DCEP_WIN - 1];\n    _w_1 = mfc[-FEAT_DCEP_WIN - 1];\n\n    for (i = 0; i < feat_cepsize(fcb); i++) {\n        d1 = w1[i] - _w1[i];\n        d2 = w_1[i] - _w_1[i];\n\n        f[i] = d1 - d2;\n    }\n}\n\nstatic void\nfeat_1s_c_d_ld_dd_cep2feat(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    mfcc_t *f;\n    mfcc_t *w, *_w;\n    mfcc_t *w1, *w_1, *_w1, *_w_1;\n    mfcc_t d1, d2;\n    int32 i;\n\n    assert(fcb);\n    assert(feat_n_stream(fcb) == 1);\n    assert(feat_stream_len(fcb, 0) == feat_cepsize(fcb) * 4);\n    assert(feat_window_size(fcb) == FEAT_DCEP_WIN * 2);\n\n    /* CEP */\n    memcpy(feat[0], mfc[0], feat_cepsize(fcb) * sizeof(mfcc_t));\n\n    /*\n     * DCEP: mfc[w] - mfc[-w], where w = FEAT_DCEP_WIN;\n     */\n    f = feat[0] + feat_cepsize(fcb);\n    w = mfc[FEAT_DCEP_WIN];\n    _w = mfc[-FEAT_DCEP_WIN];\n\n    for (i = 0; i < feat_cepsize(fcb); i++)\n        f[i] = w[i] - _w[i];\n\n    /*\n     * LDCEP: mfc[w] - mfc[-w], where w = FEAT_DCEP_WIN * 2;\n     */\n    f += feat_cepsize(fcb);\n    w = mfc[FEAT_DCEP_WIN * 2];\n    _w = mfc[-FEAT_DCEP_WIN * 2];\n\n    for (i = 0; i < feat_cepsize(fcb); i++)\n        f[i] = w[i] - _w[i];\n\n    /* \n     * D2CEP: (mfc[w+1] - mfc[-w+1]) - (mfc[w-1] - mfc[-w-1]), \n     * where w = FEAT_DCEP_WIN \n     */\n    f += feat_cepsize(fcb);\n\n    w1 = mfc[FEAT_DCEP_WIN + 1];\n    _w1 = mfc[-FEAT_DCEP_WIN + 1];\n    w_1 = mfc[FEAT_DCEP_WIN - 1];\n    _w_1 = mfc[-FEAT_DCEP_WIN - 1];\n\n    for (i = 0; i < feat_cepsize(fcb); i++) {\n        d1 = w1[i] - _w1[i];\n        d2 = w_1[i] - _w_1[i];\n\n        f[i] = d1 - d2;\n    }\n}\n\nstatic void\nfeat_copy(feat_t * fcb, mfcc_t ** mfc, mfcc_t ** feat)\n{\n    int32 win, i, j;\n\n    win = feat_window_size(fcb);\n\n    /* Concatenate input features */\n    for (i = -win; i <= win; ++i) {\n        uint32 spos = 0;\n\n        for (j = 0; j < feat_n_stream(fcb); ++j) {\n            uint32 stream_len;\n\n            /* Unscale the stream length by the window. */\n            stream_len = feat_stream_len(fcb, j) / (2 * win + 1);\n            memcpy(feat[j] + ((i + win) * stream_len),\n                   mfc[i] + spos,\n                   stream_len * sizeof(mfcc_t));\n            spos += stream_len;\n        }\n    }\n}\n\nfeat_t *\nfeat_init(char const *type, cmn_type_t cmn, int32 varnorm,\n          agc_type_t agc, int32 breport, int32 cepsize)\n{\n    feat_t *fcb;\n\n    if (cepsize == 0)\n        cepsize = 13;\n    if (breport)\n        E_INFO\n            (\"Initializing feature stream to type: '%s', ceplen=%d, CMN='%s', VARNORM='%s', AGC='%s'\\n\",\n             type, cepsize, cmn_type_str[cmn], varnorm ? \"yes\" : \"no\", agc_type_str[agc]);\n\n    fcb = (feat_t *) ckd_calloc(1, sizeof(feat_t));\n    fcb->refcount = 1;\n    fcb->name = (char *) ckd_salloc(type);\n    if (strcmp(type, \"s2_4x\") == 0) {\n        /* Sphinx-II format 4-stream feature (Hack!! hardwired constants below) */\n        if (cepsize != 13) {\n            E_ERROR(\"s2_4x features require cepsize == 13\\n\");\n            ckd_free(fcb);\n            return NULL;\n        }\n        fcb->cepsize = 13;\n        fcb->n_stream = 4;\n        fcb->stream_len = (uint32 *) ckd_calloc(4, sizeof(uint32));\n        fcb->stream_len[0] = 12;\n        fcb->stream_len[1] = 24;\n        fcb->stream_len[2] = 3;\n        fcb->stream_len[3] = 12;\n        fcb->out_dim = 51;\n        fcb->window_size = 4;\n        fcb->compute_feat = feat_s2_4x_cep2feat;\n    }\n    else if ((strcmp(type, \"s3_1x39\") == 0) || (strcmp(type, \"1s_12c_12d_3p_12dd\") == 0)) {\n        /* 1-stream cep/dcep/pow/ddcep (Hack!! hardwired constants below) */\n        if (cepsize != 13) {\n            E_ERROR(\"s2_4x features require cepsize == 13\\n\");\n            ckd_free(fcb);\n            return NULL;\n        }\n        fcb->cepsize = 13;\n        fcb->n_stream = 1;\n        fcb->stream_len = (uint32 *) ckd_calloc(1, sizeof(uint32));\n        fcb->stream_len[0] = 39;\n        fcb->out_dim = 39;\n        fcb->window_size = 3;\n        fcb->compute_feat = feat_s3_1x39_cep2feat;\n    }\n    else if (strncmp(type, \"1s_c_d_dd\", 9) == 0) {\n        fcb->cepsize = cepsize;\n        fcb->n_stream = 1;\n        fcb->stream_len = (uint32 *) ckd_calloc(1, sizeof(uint32));\n        fcb->stream_len[0] = cepsize * 3;\n        fcb->out_dim = cepsize * 3;\n        fcb->window_size = FEAT_DCEP_WIN + 1; /* ddcep needs the extra 1 */\n        fcb->compute_feat = feat_1s_c_d_dd_cep2feat;\n    }\n    else if (strncmp(type, \"1s_c_d_ld_dd\", 12) == 0) {\n        fcb->cepsize = cepsize;\n        fcb->n_stream = 1;\n        fcb->stream_len = (uint32 *) ckd_calloc(1, sizeof(uint32));\n        fcb->stream_len[0] = cepsize * 4;\n        fcb->out_dim = cepsize * 4;\n        fcb->window_size = FEAT_DCEP_WIN * 2;\n        fcb->compute_feat = feat_1s_c_d_ld_dd_cep2feat;\n    }\n    else if (strncmp(type, \"cep_dcep\", 8) == 0 || strncmp(type, \"1s_c_d\", 6) == 0) {\n        /* 1-stream cep/dcep */\n        fcb->cepsize = cepsize;\n        fcb->n_stream = 1;\n        fcb->stream_len = (uint32 *) ckd_calloc(1, sizeof(uint32));\n        fcb->stream_len[0] = feat_cepsize(fcb) * 2;\n        fcb->out_dim = fcb->stream_len[0];\n        fcb->window_size = 2;\n        fcb->compute_feat = feat_s3_cep_dcep;\n    }\n    else if (strncmp(type, \"cep\", 3) == 0 || strncmp(type, \"1s_c\", 4) == 0) {\n        /* 1-stream cep */\n        fcb->cepsize = cepsize;\n        fcb->n_stream = 1;\n        fcb->stream_len = (uint32 *) ckd_calloc(1, sizeof(uint32));\n        fcb->stream_len[0] = feat_cepsize(fcb);\n        fcb->out_dim = fcb->stream_len[0];\n        fcb->window_size = 0;\n        fcb->compute_feat = feat_s3_cep;\n    }\n    else if (strncmp(type, \"1s_3c\", 5) == 0 || strncmp(type, \"1s_4c\", 5) == 0) {\n\t/* 1-stream cep with frames concatenated, so called cepwin features */\n        if (strncmp(type, \"1s_3c\", 5) == 0)\n            fcb->window_size = 3;\n        else\n    \t    fcb->window_size = 4;\n\n        fcb->cepsize = cepsize;\n        fcb->n_stream = 1;\n        fcb->stream_len = (uint32 *) ckd_calloc(1, sizeof(uint32));\n        fcb->stream_len[0] = feat_cepsize(fcb) * (2 * fcb->window_size + 1);\n        fcb->out_dim = fcb->stream_len[0];\n        fcb->compute_feat = feat_copy;\n    }\n    else {\n        int32 i, k, l;\n        size_t len;\n        char *strp;\n        char *mtype = ckd_salloc(type);\n        char *wd = ckd_salloc(type);\n        /*\n         * Generic definition: Format should be %d,%d,%d,...,%d (i.e.,\n         * comma separated list of feature stream widths; #items =\n         * #streams).  An optional window size (frames will be\n         * concatenated) is also allowed, which can be specified with\n         * a colon after the list of feature streams.\n         */\n        len = strlen(mtype);\n        k = 0;\n        for (i = 1; i < len - 1; i++) {\n            if (mtype[i] == ',') {\n                mtype[i] = ' ';\n                k++;\n            }\n            else if (mtype[i] == ':') {\n                mtype[i] = '\\0';\n                fcb->window_size = atoi(mtype + i + 1);\n                break;\n            }\n        }\n        k++;                    /* Presumably there are (#commas+1) streams */\n        fcb->n_stream = k;\n        fcb->stream_len = (uint32 *) ckd_calloc(k, sizeof(uint32));\n\n        /* Scan individual feature stream lengths */\n        strp = mtype;\n        i = 0;\n        fcb->out_dim = 0;\n        fcb->cepsize = 0;\n        while (sscanf(strp, \"%s%n\", wd, &l) == 1) {\n            strp += l;\n            if ((i >= fcb->n_stream)\n                || (sscanf(wd, \"%u\", &(fcb->stream_len[i])) != 1)\n                || (fcb->stream_len[i] <= 0))\n                E_FATAL(\"Bad feature type argument\\n\");\n            /* Input size before windowing */\n            fcb->cepsize += fcb->stream_len[i];\n            if (fcb->window_size > 0)\n                fcb->stream_len[i] *= (fcb->window_size * 2 + 1);\n            /* Output size after windowing */\n            fcb->out_dim += fcb->stream_len[i];\n            i++;\n        }\n        if (i != fcb->n_stream)\n            E_FATAL(\"Bad feature type argument\\n\");\n        if (fcb->cepsize != cepsize)\n    \t    E_FATAL(\"Bad feature type argument\\n\");\n\n        /* Input is already the feature stream */\n        fcb->compute_feat = feat_copy;\n        ckd_free(mtype);\n        ckd_free(wd);\n    }\n\n    if (cmn != CMN_NONE)\n        fcb->cmn_struct = cmn_init(feat_cepsize(fcb));\n    fcb->cmn = cmn;\n    fcb->varnorm = varnorm;\n    if (agc != AGC_NONE) {\n        fcb->agc_struct = agc_init();\n        /*\n         * No need to check if agc is set to EMAX; agc_emax_set() changes only emax related things\n         * Moreover, if agc is not NONE and block mode is used, feat_agc() SILENTLY\n         * switches to EMAX\n         */\n        /* HACK: hardwired initial estimates based on use of CMN (from Sphinx2) */\n        agc_emax_set(fcb->agc_struct, (cmn != CMN_NONE) ? 5.0 : 10.0);\n    }\n    fcb->agc = agc;\n    /*\n     * Make sure this buffer is large enough to be used in feat_s2mfc2feat_block_utt()\n     */\n    fcb->cepbuf = (mfcc_t **) ckd_calloc_2d((LIVEBUFBLOCKSIZE < feat_window_size(fcb) * 2) ? feat_window_size(fcb) * 2 : LIVEBUFBLOCKSIZE,\n                                            feat_cepsize(fcb),\n                                            sizeof(mfcc_t));\n    /* This one is actually just an array of pointers to \"flatten out\"\n     * wraparounds. */\n    fcb->tmpcepbuf = (mfcc_t** )ckd_calloc(2 * feat_window_size(fcb) + 1,\n                                sizeof(*fcb->tmpcepbuf));\n\n    return fcb;\n}\n\n\nvoid\nfeat_print(feat_t * fcb, mfcc_t *** feat, int32 nfr, FILE * fp)\n{\n    uint32 i, j, k;\n\n    for (i = 0; i < nfr; i++) {\n        fprintf(fp, \"%8d:\\n\", i);\n\n        for (j = 0; j < feat_dimension1(fcb); j++) {\n            fprintf(fp, \"\\t%2d:\", j);\n\n            for (k = 0; k < feat_dimension2(fcb, j); k++)\n                fprintf(fp, \" %8.4f\", MFCC2FLOAT(feat[i][j][k]));\n            fprintf(fp, \"\\n\");\n        }\n    }\n\n    fflush(fp);\n}\n\nstatic void\nfeat_cmn(feat_t *fcb, mfcc_t **mfc, int32 nfr, int32 beginutt, int32 endutt)\n{\n    cmn_type_t cmn_type = fcb->cmn;\n\n    if (!(beginutt && endutt)\n        && cmn_type != CMN_NONE) /* Only cmn_prior in block computation mode. */\n        fcb->cmn = cmn_type = CMN_LIVE;\n\n    switch (cmn_type) {\n    case CMN_BATCH:\n        cmn(fcb->cmn_struct, mfc, fcb->varnorm, nfr);\n        break;\n    case CMN_LIVE:\n        cmn_live(fcb->cmn_struct, mfc, fcb->varnorm, nfr);\n        if (endutt)\n            cmn_live_update(fcb->cmn_struct);\n        break;\n    default:\n        ;\n    }\n    cep_dump_dbg(fcb, mfc, nfr, \"After CMN\");\n}\n\nstatic void\nfeat_agc(feat_t *fcb, mfcc_t **mfc, int32 nfr, int32 beginutt, int32 endutt)\n{\n    agc_type_t agc_type = fcb->agc;\n\n    if (!(beginutt && endutt)\n        && agc_type != AGC_NONE) /* Only agc_emax in block computation mode. */\n        agc_type = AGC_EMAX;\n\n    switch (agc_type) {\n    case AGC_MAX:\n        agc_max(fcb->agc_struct, mfc, nfr);\n        break;\n    case AGC_EMAX:\n        agc_emax(fcb->agc_struct, mfc, nfr);\n        if (endutt)\n            agc_emax_update(fcb->agc_struct);\n        break;\n    case AGC_NOISE:\n        agc_noise(fcb->agc_struct, mfc, nfr);\n        break;\n    default:\n        ;\n    }\n    cep_dump_dbg(fcb, mfc, nfr, \"After AGC\");\n}\n\nstatic void\nfeat_compute_utt(feat_t *fcb, mfcc_t **mfc, int32 nfr, int32 win, mfcc_t ***feat)\n{\n    int32 i;\n\n    cep_dump_dbg(fcb, mfc, nfr, \"Incoming features (after padding)\");\n\n    /* Create feature vectors */\n    for (i = win; i < nfr - win; i++) {\n        fcb->compute_feat(fcb, mfc + i, feat[i - win]);\n    }\n\n    feat_print_dbg(fcb, feat, nfr - win * 2, \"After dynamic feature computation\");\n\n    if (fcb->lda) {\n        feat_lda_transform(fcb, feat, nfr - win * 2);\n        feat_print_dbg(fcb, feat, nfr - win * 2, \"After LDA\");\n    }\n\n    if (fcb->subvecs) {\n        feat_subvec_project(fcb, feat, nfr - win * 2);\n        feat_print_dbg(fcb, feat, nfr - win * 2, \"After subvector projection\");\n    }\n}\n\n\n/**\n * Read Sphinx-II format mfc file (s2mfc = Sphinx-II format MFC data).\n * If out_mfc is NULL, no actual reading will be done, and the number of \n * frames (plus padding) that would be read is returned.\n * \n * It's important that normalization is done before padding because\n * frames outside the data we are interested in shouldn't be taken\n * into normalization stats.\n *\n * @return # frames read (plus padding) if successful, -1 if\n * error (e.g., mfc array too small).  \n */\nstatic int32\nfeat_s2mfc_read_norm_pad(feat_t *fcb, char *file, int32 win,\n            \t\t int32 sf, int32 ef,\n            \t\t mfcc_t ***out_mfc,\n            \t\t int32 maxfr,\n            \t\t int32 cepsize)\n{\n    FILE *fp;\n    int32 n_float32;\n    float32 *float_feat;\n    struct stat statbuf;\n    int32 i, n, byterev;\n    int32 start_pad, end_pad;\n    mfcc_t **mfc;\n\n    /* Initialize the output pointer to NULL, so that any attempts to\n       free() it if we fail before allocating it will not segfault! */\n    if (out_mfc)\n        *out_mfc = NULL;\n    E_INFO(\"Reading mfc file: '%s'[%d..%d]\\n\", file, sf, ef);\n    if (ef >= 0 && ef <= sf) {\n        E_ERROR(\"%s: End frame (%d) <= Start frame (%d)\\n\", file, ef, sf);\n        return -1;\n    }\n\n    /* Find filesize; HACK!! To get around intermittent NFS failures, use stat_retry */\n    if ((stat_retry(file, &statbuf) < 0)\n        || ((fp = fopen(file, \"rb\")) == NULL)) {\n        E_ERROR_SYSTEM(\"Failed to open file '%s' for reading\", file);\n        return -1;\n    }\n\n    /* Read #floats in header */\n    if (fread_retry(&n_float32, sizeof(int32), 1, fp) != 1) {\n        E_ERROR(\"%s: fread(#floats) failed\\n\", file);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Check if n_float32 matches file size */\n    byterev = 0;\n    if ((int32) (n_float32 * sizeof(float32) + 4) != (int32) statbuf.st_size) { /* RAH, typecast both sides to remove compile warning */\n        n = n_float32;\n        SWAP_INT32(&n);\n\n        if ((int32) (n * sizeof(float32) + 4) != (int32) (statbuf.st_size)) {   /* RAH, typecast both sides to remove compile warning */\n            E_ERROR\n                (\"%s: Header size field: %d(%08x); filesize: %d(%08x)\\n\",\n                 file, n_float32, n_float32, statbuf.st_size,\n                 statbuf.st_size);\n            fclose(fp);\n            return -1;\n        }\n\n        n_float32 = n;\n        byterev = 1;\n    }\n    if (n_float32 <= 0) {\n        E_ERROR(\"%s: Header size field (#floats) = %d\\n\", file, n_float32);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Convert n to #frames of input */\n    n = n_float32 / cepsize;\n    if (n * cepsize != n_float32) {\n        E_ERROR(\"Header size field: %d; not multiple of %d\\n\", n_float32,\n                cepsize);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Check start and end frames */\n    if (sf > 0) {\n        if (sf >= n) {\n            E_ERROR(\"%s: Start frame (%d) beyond file size (%d)\\n\", file,\n                    sf, n);\n            fclose(fp);\n            return -1;\n        }\n    }\n    if (ef < 0)\n        ef = n-1;\n    else if (ef >= n) {\n        E_WARN(\"%s: End frame (%d) beyond file size (%d), will truncate\\n\",\n               file, ef, n);\n        ef = n-1;\n    }\n\n    /* Add window to start and end frames */\n    sf -= win;\n    ef += win;\n    if (sf < 0) {\n        start_pad = -sf;\n        sf = 0;\n    }\n    else\n        start_pad = 0;\n    if (ef >= n) {\n        end_pad = ef - n + 1;\n        ef = n - 1;\n    }\n    else\n        end_pad = 0;\n\n    /* Limit n if indicated by [sf..ef] */\n    if ((ef - sf + 1) < n)\n        n = (ef - sf + 1);\n    if (maxfr > 0 && n + start_pad + end_pad > maxfr) {\n        E_ERROR(\"%s: Maximum output size(%d frames) < actual #frames(%d)\\n\",\n                file, maxfr, n + start_pad + end_pad);\n        fclose(fp);\n        return -1;\n    }\n\n    /* If no output buffer was supplied, then skip the actual data reading. */\n    if (out_mfc != NULL) {\n        /* Position at desired start frame and read actual MFC data */\n        mfc = (mfcc_t **)ckd_calloc_2d(n + start_pad + end_pad, cepsize, sizeof(mfcc_t));\n        if (sf > 0)\n            fseek(fp, sf * cepsize * sizeof(float32), SEEK_CUR);\n        n_float32 = n * cepsize;\n#ifdef FIXED_POINT\n        float_feat = ckd_calloc(n_float32, sizeof(float32));\n#else\n        float_feat = mfc[start_pad];\n#endif\n        if (fread_retry(float_feat, sizeof(float32), n_float32, fp) != n_float32) {\n            E_ERROR(\"%s: fread(%dx%d) (MFC data) failed\\n\", file, n, cepsize);\n            ckd_free_2d(mfc);\n            fclose(fp);\n            return -1;\n        }\n        if (byterev) {\n            for (i = 0; i < n_float32; i++) {\n                SWAP_FLOAT32(&float_feat[i]);\n            }\n        }\n#ifdef FIXED_POINT\n        for (i = 0; i < n_float32; ++i) {\n            mfc[start_pad][i] = FLOAT2MFCC(float_feat[i]);\n        }\n        ckd_free(float_feat);\n#endif\n\n        /* Normalize */\n        feat_cmn(fcb, mfc + start_pad, n, 1, 1);\n        feat_agc(fcb, mfc + start_pad, n, 1, 1);\n\n        /* Replicate start and end frames if necessary. */\n        for (i = 0; i < start_pad; ++i)\n            memcpy(mfc[i], mfc[start_pad], cepsize * sizeof(mfcc_t));\n        for (i = 0; i < end_pad; ++i)\n            memcpy(mfc[start_pad + n + i], mfc[start_pad + n - 1],\n                   cepsize * sizeof(mfcc_t));\n\n        *out_mfc = mfc;\n    }\n\n    fclose(fp);\n    return n + start_pad + end_pad;\n}\n\n\n\nint32\nfeat_s2mfc2feat(feat_t * fcb, const char *file, const char *dir, const char *cepext,\n                int32 sf, int32 ef, mfcc_t *** feat, int32 maxfr)\n{\n    char *path;\n    char *ps = \"/\";\n    int32 win, nfr;\n    size_t file_length, cepext_length, path_length = 0;\n    mfcc_t **mfc;\n\n    if (fcb->cepsize <= 0) {\n        E_ERROR(\"Bad cepsize: %d\\n\", fcb->cepsize);\n        return -1;\n    }\n\n    if (cepext == NULL)\n        cepext = \"\";\n\n    /*\n     * Create mfc filename, combining file, dir and extension if\n     * necessary\n     */\n\n    /*\n     * First we decide about the path. If dir is defined, then use\n     * it. Otherwise assume the filename already contains the path.\n     */\n    if (dir == NULL) {\n        dir = \"\";\n        ps = \"\";\n        /*\n         * This is not true but some 3rd party apps\n         * may parse the output explicitly checking for this line\n         */\n        E_INFO(\"At directory . (current directory)\\n\");\n    }\n    else {\n        E_INFO(\"At directory %s\\n\", dir);\n        /*\n         * Do not forget the path separator!\n         */\n        path_length += strlen(dir) + 1;\n    }\n\n    /*\n     * Include cepext, if it's not already part of the filename.\n     */\n    file_length = strlen(file);\n    cepext_length = strlen(cepext);\n    if ((file_length > cepext_length)\n        && (strcmp(file + file_length - cepext_length, cepext) == 0)) {\n        cepext = \"\";\n        cepext_length = 0;\n    }\n\n    /*\n     * Do not forget the '\\0'\n     */\n    path_length += file_length + cepext_length + 1;\n    path = (char*) ckd_calloc(path_length, sizeof(char));\n\n#ifdef HAVE_SNPRINTF\n    /*\n     * Paranoia is our best friend...\n     */\n    while ((file_length = snprintf(path, path_length, \"%s%s%s%s\", dir, ps, file, cepext)) > path_length) {\n        path_length = file_length;\n        path = (char*) ckd_realloc(path, path_length * sizeof(char));\n    }\n#else\n    sprintf(path, \"%s%s%s%s\", dir, ps, file, cepext);\n#endif\n\n    win = feat_window_size(fcb);\n    /* Pad maxfr with win, so we read enough raw feature data to\n     * calculate the requisite number of dynamic features. */\n    if (maxfr >= 0)\n        maxfr += win * 2;\n\n    if (feat != NULL) {\n        /* Read mfc file including window or padding if necessary. */\n        nfr = feat_s2mfc_read_norm_pad(fcb, path, win, sf, ef, &mfc, maxfr, fcb->cepsize);\n        ckd_free(path);\n        if (nfr < 0) {\n            ckd_free_2d((void **) mfc);\n            return -1;\n        }\n\n        /* Actually compute the features */\n        feat_compute_utt(fcb, mfc, nfr, win, feat);\n        \n        ckd_free_2d((void **) mfc);\n    }\n    else {\n        /* Just calculate the number of frames we would need. */\n        nfr = feat_s2mfc_read_norm_pad(fcb, path, win, sf, ef, NULL, maxfr, fcb->cepsize);\n        ckd_free(path);\n        if (nfr < 0)\n            return nfr;\n    }\n\n\n    return (nfr - win * 2);\n}\n\nstatic int32\nfeat_s2mfc2feat_block_utt(feat_t * fcb, mfcc_t ** uttcep,\n\t\t\t  int32 nfr, mfcc_t *** ofeat)\n{\n    mfcc_t **cepbuf;\n    int32 i, win, cepsize;\n\n    win = feat_window_size(fcb);\n    cepsize = feat_cepsize(fcb);\n\n    /* Copy and pad out the utterance (this requires that the\n     * feature computation functions always access the buffer via\n     * the frame pointers, which they do)  */\n    cepbuf = (mfcc_t **)ckd_calloc(nfr + win * 2, sizeof(mfcc_t *));\n    memcpy(cepbuf + win, uttcep, nfr * sizeof(mfcc_t *));\n\n    /* Do normalization before we interpolate on the boundary */    \n    feat_cmn(fcb, cepbuf + win, nfr, 1, 1);\n    feat_agc(fcb, cepbuf + win, nfr, 1, 1);\n\n    /* Now interpolate */    \n    for (i = 0; i < win; ++i) {\n        cepbuf[i] = fcb->cepbuf[i];\n        memcpy(cepbuf[i], uttcep[0], cepsize * sizeof(mfcc_t));\n        cepbuf[nfr + win + i] = fcb->cepbuf[win + i];\n        memcpy(cepbuf[nfr + win + i], uttcep[nfr - 1], cepsize * sizeof(mfcc_t));\n    }\n    /* Compute as usual. */\n    feat_compute_utt(fcb, cepbuf, nfr + win * 2, win, ofeat);\n    ckd_free(cepbuf);\n    return nfr;\n}\n\nint32\nfeat_s2mfc2feat_live(feat_t * fcb, mfcc_t ** uttcep, int32 *inout_ncep,\n\t\t     int32 beginutt, int32 endutt, mfcc_t *** ofeat)\n{\n    int32 win, cepsize, nbufcep;\n    int32 i, j, nfeatvec;\n    int32 zero = 0;\n\n    /* Avoid having to check this everywhere. */\n    if (inout_ncep == NULL) inout_ncep = &zero;\n\n    /* Special case for entire utterances. */\n    if (beginutt && endutt && *inout_ncep > 0)\n        return feat_s2mfc2feat_block_utt(fcb, uttcep, *inout_ncep, ofeat);\n\n    win = feat_window_size(fcb);\n    cepsize = feat_cepsize(fcb);\n\n    /* Empty the input buffer on start of utterance. */\n    if (beginutt)\n        fcb->bufpos = fcb->curpos;\n\n    /* Calculate how much data is in the buffer already. */\n    nbufcep = fcb->bufpos - fcb->curpos;\n    if (nbufcep < 0)\n\tnbufcep = fcb->bufpos + LIVEBUFBLOCKSIZE - fcb->curpos;\n    /* Add any data that we have to replicate. */\n    if (beginutt && *inout_ncep > 0)\n        nbufcep += win;\n    if (endutt)\n        nbufcep += win;\n\n    /* Only consume as much input as will fit in the buffer. */\n    if (nbufcep + *inout_ncep > LIVEBUFBLOCKSIZE) {\n        /* We also can't overwrite the trailing window, hence the\n         * reason why win is subtracted here. */\n        *inout_ncep = LIVEBUFBLOCKSIZE - nbufcep - win;\n        /* Cancel end of utterance processing. */\n        endutt = FALSE;\n    }\n\n    /* FIXME: Don't modify the input! */\n    feat_cmn(fcb, uttcep, *inout_ncep, beginutt, endutt);\n    feat_agc(fcb, uttcep, *inout_ncep, beginutt, endutt);\n\n    /* Replicate first frame into the first win frames if we're at the\n     * beginning of the utterance and there was some actual input to\n     * deal with.  (FIXME: Not entirely sure why that condition) */\n    if (beginutt && *inout_ncep > 0) {\n        for (i = 0; i < win; i++) {\n            memcpy(fcb->cepbuf[fcb->bufpos++], uttcep[0],\n                   cepsize * sizeof(mfcc_t));\n            fcb->bufpos %= LIVEBUFBLOCKSIZE;\n        }\n        /* Move the current pointer past this data. */\n        fcb->curpos = fcb->bufpos;\n        nbufcep -= win;\n    }\n\n    /* Copy in frame data to the circular buffer. */\n    for (i = 0; i < *inout_ncep; ++i) {\n        memcpy(fcb->cepbuf[fcb->bufpos++], uttcep[i],\n               cepsize * sizeof(mfcc_t));\n        fcb->bufpos %= LIVEBUFBLOCKSIZE;\n\t++nbufcep;\n    }\n\n    /* Replicate last frame into the last win frames if we're at the\n     * end of the utterance (even if there was no input, so we can\n     * flush the output). */\n    if (endutt) {\n        int32 tpos; /* Index of last input frame. */\n        if (fcb->bufpos == 0)\n            tpos = LIVEBUFBLOCKSIZE - 1;\n        else\n            tpos = fcb->bufpos - 1;\n        for (i = 0; i < win; ++i) {\n            memcpy(fcb->cepbuf[fcb->bufpos++], fcb->cepbuf[tpos],\n                   cepsize * sizeof(mfcc_t));\n            fcb->bufpos %= LIVEBUFBLOCKSIZE;\n        }\n    }\n\n    /* We have to leave the trailing window of frames. */\n    nfeatvec = nbufcep - win;\n    if (nfeatvec <= 0)\n        return 0; /* Do nothing. */\n\n    for (i = 0; i < nfeatvec; ++i) {\n        /* Handle wraparound cases. */\n        if (fcb->curpos - win < 0 || fcb->curpos + win >= LIVEBUFBLOCKSIZE) {\n            /* Use tmpcepbuf for this case.  Actually, we just need the pointers. */\n            for (j = -win; j <= win; ++j) {\n                int32 tmppos =\n                    (fcb->curpos + j + LIVEBUFBLOCKSIZE) % LIVEBUFBLOCKSIZE;\n\t\tfcb->tmpcepbuf[win + j] = fcb->cepbuf[tmppos];\n            }\n            fcb->compute_feat(fcb, fcb->tmpcepbuf + win, ofeat[i]);\n        }\n        else {\n            fcb->compute_feat(fcb, fcb->cepbuf + fcb->curpos, ofeat[i]);\n        }\n\t/* Move the read pointer forward. */\n        ++fcb->curpos;\n        fcb->curpos %= LIVEBUFBLOCKSIZE;\n    }\n\n    if (fcb->lda)\n        feat_lda_transform(fcb, ofeat, nfeatvec);\n\n    if (fcb->subvecs)\n        feat_subvec_project(fcb, ofeat, nfeatvec);\n\n    return nfeatvec;\n}\n\nvoid \nfeat_update_stats(feat_t *fcb)\n{\n    if (fcb->cmn == CMN_LIVE) {\n        cmn_live_update(fcb->cmn_struct);\n    }\n    if (fcb->agc == AGC_EMAX || fcb->agc == AGC_MAX) {\n\tagc_emax_update(fcb->agc_struct);\t\n    }\n}\n\nfeat_t *\nfeat_retain(feat_t *f)\n{\n    ++f->refcount;\n    return f;\n}\n\nint\nfeat_free(feat_t * f)\n{\n    if (f == NULL)\n        return 0;\n    if (--f->refcount > 0)\n        return f->refcount;\n\n    if (f->cepbuf)\n        ckd_free_2d((void **) f->cepbuf);\n    ckd_free(f->tmpcepbuf);\n\n    if (f->name) {\n        ckd_free((void *) f->name);\n    }\n    if (f->lda)\n        ckd_free_3d((void ***) f->lda);\n\n    ckd_free(f->stream_len);\n    ckd_free(f->sv_len);\n    ckd_free(f->sv_buf);\n    subvecs_free(f->subvecs);\n\n    cmn_free(f->cmn_struct);\n    agc_free(f->agc_struct);\n\n    ckd_free(f);\n    return 0;\n}\n\n\nvoid\nfeat_report(feat_t * f)\n{\n    int i;\n    E_INFO_NOFN(\"Initialization of feat_t, report:\\n\");\n    E_INFO_NOFN(\"Feature type         = %s\\n\", f->name);\n    E_INFO_NOFN(\"Cepstral size        = %d\\n\", f->cepsize);\n    E_INFO_NOFN(\"Number of streams    = %d\\n\", f->n_stream);\n    for (i = 0; i < f->n_stream; i++) {\n        E_INFO_NOFN(\"Vector size of stream[%d]: %d\\n\", i,\n                    f->stream_len[i]);\n    }\n    E_INFO_NOFN(\"Number of subvectors = %d\\n\", f->n_sv);\n    for (i = 0; i < f->n_sv; i++) {\n        int32 *sv;\n\n        E_INFO_NOFN(\"Components of subvector[%d]:\", i);\n        for (sv = f->subvecs[i]; sv && *sv != -1; ++sv)\n            E_INFOCONT(\" %d\", *sv);\n        E_INFOCONT(\"\\n\");\n    }\n    E_INFO_NOFN(\"Whether CMN is used  = %d\\n\", f->cmn);\n    E_INFO_NOFN(\"Whether AGC is used  = %d\\n\", f->agc);\n    E_INFO_NOFN(\"Whether variance is normalized = %d\\n\", f->varnorm);\n    E_INFO_NOFN(\"\\n\");\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2006 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * lda.c -- Read and apply LDA matrices to features.\n *\n * Author: David Huggins-Daines <dhuggins@cs.cmu.edu>\n */\n\n#include <assert.h>\n#include <string.h>\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4018)\n#endif\n\n#include \"sphinxbase/feat.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/bio.h\"\n#include \"sphinxbase/err.h\"\n\n#define MATRIX_FILE_VERSION \"0.1\"\n\nint32\nfeat_read_lda(feat_t *feat, const char *ldafile, int32 dim)\n{\n    FILE *fh;\n    int32 byteswap;\n    uint32 chksum, i, m, n;\n    char **argname, **argval;\n\n    assert(feat);\n    if (feat->n_stream != 1) {\n        E_ERROR(\"LDA incompatible with multi-stream features (n_stream = %d)\\n\",\n                feat->n_stream);\n        return -1;\n    }\n\n    if ((fh = fopen(ldafile, \"rb\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open transform file '%s' for reading\", ldafile);\n        return -1;\n    }\n\n    if (bio_readhdr(fh, &argname, &argval, &byteswap) < 0) {\n        E_ERROR(\"Failed to read header from transform file '%s'\\n\", ldafile);\n        fclose(fh);\n        return -1;\n    }\n\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n            if (strcmp(argval[i], MATRIX_FILE_VERSION) != 0)\n                E_WARN(\"%s: Version mismatch: %s, expecting %s\\n\",\n                       ldafile, argval[i], MATRIX_FILE_VERSION);\n        }\n    }\n\n    bio_hdrarg_free(argname, argval);\n    argname = argval = NULL;\n\n    chksum = 0;\n\n    if (feat->lda)\n        ckd_free_3d((void ***)feat->lda);\n\n    {\n        /* Use a temporary variable to avoid strict-aliasing problems. */\n        void ***outlda;\n\n        if (bio_fread_3d(&outlda, sizeof(float32),\n                         &feat->n_lda, &m, &n,\n                         fh, byteswap, &chksum) < 0) {\n            E_ERROR_SYSTEM(\"%s: bio_fread_3d(lda) failed\\n\", ldafile);\n            fclose(fh);\n            return -1;\n        }\n        feat->lda = (void *)outlda;\n    }\n    fclose(fh);\n    \n#ifdef FIXED_POINT\n    /* FIXME: This is a fragile hack that depends on mfcc_t and\n     * float32 being the same size (which they are, but...) */\n    for (i = 0; i < feat->n_lda * m * n; ++i) {\n        feat->lda[0][0][i] = FLOAT2MFCC(((float *)feat->lda[0][0])[i]);\n    }\n#endif\n\n    /* Note that SphinxTrain stores the eigenvectors as row vectors. */\n    if (n != feat->stream_len[0])\n\tE_FATAL(\"LDA matrix dimension %d doesn't match feature stream size %d\\n\", n, feat->stream_len[0]);\n    \n    /* Override dim from file if it is 0 or greater than m. */\n    if (dim > m || dim <= 0) {\n        dim = m;\n    }\n    feat->out_dim = dim;\n\n    return 0;\n}\n\nvoid\nfeat_lda_transform(feat_t *fcb, mfcc_t ***inout_feat, uint32 nfr)\n{\n    mfcc_t *tmp;\n    uint32 i, j, k;\n\n    tmp = ckd_calloc(fcb->stream_len[0], sizeof(mfcc_t));\n    for (i = 0; i < nfr; ++i) {\n        /* Do the matrix multiplication inline here since fcb->lda\n         * is transposed (eigenvectors in rows not columns). */\n        /* FIXME: In the future we ought to use the BLAS. */\n        memset(tmp, 0, sizeof(mfcc_t) * fcb->stream_len[0]);\n        for (j = 0; j < feat_dimension(fcb); ++j) {\n            for (k = 0; k < fcb->stream_len[0]; ++k) {\n                tmp[j] += MFCCMUL(inout_feat[i][0][k], fcb->lda[0][j][k]);\n            }\n        }\n        memcpy(inout_feat[i][0], tmp, fcb->stream_len[0] * sizeof(mfcc_t));\n    }\n    ckd_free(tmp);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n/* SphinxBase headers. */\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/pio.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/hash_table.h\"\n#include \"sphinxbase/fsg_model.h\"\n#include \"sphinxbase/bitvec.h\"\n\n/**\n * Adjacency list (opaque) for a state in an FSG.\n *\n * Actually we use hash tables so that random access is a bit faster.\n * Plus it allows us to make the lookup code a bit less ugly.\n */\n\nstruct trans_list_s {\n    hash_table_t *null_trans;   /* Null transitions keyed by state. */\n    hash_table_t *trans;        /* Lists of non-null transitions keyed by state. */\n};\n\n/**\n * Implementation of arc iterator.\n */\nstruct fsg_arciter_s {\n    hash_iter_t *itor, *null_itor;\n    gnode_t *gn;\n};\n\n#define FSG_MODEL_BEGIN_DECL\t\t\"FSG_BEGIN\"\n#define FSG_MODEL_END_DECL\t\t\"FSG_END\"\n#define FSG_MODEL_N_DECL\t\t\t\"N\"\n#define FSG_MODEL_NUM_STATES_DECL\t\"NUM_STATES\"\n#define FSG_MODEL_S_DECL\t\t\t\"S\"\n#define FSG_MODEL_START_STATE_DECL\t\"START_STATE\"\n#define FSG_MODEL_F_DECL\t\t\t\"F\"\n#define FSG_MODEL_FINAL_STATE_DECL\t\"FINAL_STATE\"\n#define FSG_MODEL_T_DECL\t\t\t\"T\"\n#define FSG_MODEL_TRANSITION_DECL\t\"TRANSITION\"\n#define FSG_MODEL_COMMENT_CHAR\t\t'#'\n\n\nstatic int32\nnextline_str2words(FILE * fp, int32 * lineno,\n                   char **lineptr, char ***wordptr)\n{\n    for (;;) {\n        size_t len;\n        int32 n;\n\n        ckd_free(*lineptr);\n        if ((*lineptr = fread_line(fp, &len)) == NULL)\n            return -1;\n\n        (*lineno)++;\n\n        if ((*lineptr)[0] == FSG_MODEL_COMMENT_CHAR)\n            continue;           /* Skip comment lines */\n\n        n = str2words(*lineptr, NULL, 0);\n        if (n == 0)\n            continue;           /* Skip blank lines */\n\n        /* Abuse of realloc(), but this doesn't have to be fast. */\n        if (*wordptr == NULL)\n            *wordptr = ckd_calloc(n, sizeof(**wordptr));\n        else\n            *wordptr = ckd_realloc(*wordptr, n * sizeof(**wordptr));\n        return str2words(*lineptr, *wordptr, n);\n    }\n}\n\nvoid\nfsg_model_trans_add(fsg_model_t * fsg,\n                    int32 from, int32 to, int32 logp, int32 wid)\n{\n    fsg_link_t *link;\n    glist_t gl;\n    gnode_t *gn;\n\n    if (fsg->trans[from].trans == NULL)\n        fsg->trans[from].trans = hash_table_new(5, HASH_CASE_YES);\n\n    /* Check for duplicate link (i.e., link already exists with label=wid) */\n    for (gn = gl = fsg_model_trans(fsg, from, to); gn; gn = gnode_next(gn)) {\n        link = (fsg_link_t *) gnode_ptr(gn);\n        if (link->wid == wid) {\n            if (link->logs2prob < logp)\n                link->logs2prob = logp;\n            return;\n        }\n    }\n\n    /* Create transition object */\n    link = listelem_malloc(fsg->link_alloc);\n    link->from_state = from;\n    link->to_state = to;\n    link->logs2prob = logp;\n    link->wid = wid;\n\n    /* Add it to the list of transitions and update the hash table */\n    gl = glist_add_ptr(gl, (void *) link);\n    hash_table_replace_bkey(fsg->trans[from].trans,\n                            (char const *) &link->to_state,\n                            sizeof(link->to_state), gl);\n}\n\nint32\nfsg_model_tag_trans_add(fsg_model_t * fsg, int32 from, int32 to,\n                        int32 logp, int32 wid)\n{\n    fsg_link_t *link, *link2;\n\n    /* Check for transition probability */\n    if (logp > 0) {\n        E_FATAL(\"Null transition prob must be <= 1.0 (state %d -> %d)\\n\",\n                from, to);\n    }\n\n    /* Self-loop null transitions (with prob <= 1.0) are redundant */\n    if (from == to)\n        return -1;\n\n    if (fsg->trans[from].null_trans == NULL)\n        fsg->trans[from].null_trans = hash_table_new(5, HASH_CASE_YES);\n\n    /* Check for a duplicate link; if found, keep the higher prob */\n    link = fsg_model_null_trans(fsg, from, to);\n    if (link) {\n        if (link->logs2prob < logp) {\n            link->logs2prob = logp;\n            return 0;\n        }\n        else\n            return -1;\n    }\n\n    /* Create null transition object */\n    link = listelem_malloc(fsg->link_alloc);\n    link->from_state = from;\n    link->to_state = to;\n    link->logs2prob = logp;\n    link->wid = -1;\n\n    link2 = (fsg_link_t *)\n        hash_table_enter_bkey(fsg->trans[from].null_trans,\n                              (char const *) &link->to_state,\n                              sizeof(link->to_state), link);\n    assert(link == link2);\n\n    return 1;\n}\n\nint32\nfsg_model_null_trans_add(fsg_model_t * fsg, int32 from, int32 to,\n                         int32 logp)\n{\n    return fsg_model_tag_trans_add(fsg, from, to, logp, -1);\n}\n\nglist_t\nfsg_model_null_trans_closure(fsg_model_t * fsg, glist_t nulls)\n{\n    gnode_t *gn1;\n    int updated;\n    fsg_link_t *tl1, *tl2;\n    int32 k, n;\n\n    E_INFO(\"Computing transitive closure for null transitions\\n\");\n\n    /* If our caller didn't give us a list of null-transitions,\n       make such a list. Just loop through all the FSG states, \n       and all the null-transitions in that state (which are kept in\n       their own hash table). */\n    if (nulls == NULL) {\n        int i;\n        for (i = 0; i < fsg->n_state; ++i) {\n            hash_iter_t *itor;\n            hash_table_t *null_trans = fsg->trans[i].null_trans;\n            if (null_trans == NULL)\n                continue;\n            for (itor = hash_table_iter(null_trans);\n                 itor != NULL; itor = hash_table_iter_next(itor)) {\n                nulls = glist_add_ptr(nulls, hash_entry_val(itor->ent));\n            }\n        }\n    }\n\n    /*\n     * Probably not the most efficient closure implementation, in general, but\n     * probably reasonably efficient for a sparse null transition matrix.\n     */\n    n = 0;\n    do {\n        updated = FALSE;\n\n        for (gn1 = nulls; gn1; gn1 = gnode_next(gn1)) {\n            hash_iter_t *itor;\n\n            tl1 = (fsg_link_t *) gnode_ptr(gn1);\n            assert(tl1->wid < 0);\n\n            if (fsg->trans[tl1->to_state].null_trans == NULL)\n                continue;\n\n            for (itor =\n                 hash_table_iter(fsg->trans[tl1->to_state].null_trans);\n                 itor; itor = hash_table_iter_next(itor)) {\n\n                tl2 = (fsg_link_t *) hash_entry_val(itor->ent);\n\n                k = fsg_model_null_trans_add(fsg,\n                                             tl1->from_state,\n                                             tl2->to_state,\n                                             tl1->logs2prob +\n                                             tl2->logs2prob);\n                if (k >= 0) {\n                    updated = TRUE;\n                    if (k > 0) {\n                        nulls = glist_add_ptr(nulls, (void *)\n                                              fsg_model_null_trans\n                                              (fsg, tl1->from_state,\n                                               tl2->to_state));\n                        n++;\n                    }\n                }\n            }\n        }\n    } while (updated);\n\n    E_INFO(\"%d null transitions added\\n\", n);\n\n    return nulls;\n}\n\nglist_t\nfsg_model_trans(fsg_model_t * fsg, int32 i, int32 j)\n{\n    void *val;\n\n    if (fsg->trans[i].trans == NULL)\n        return NULL;\n    if (hash_table_lookup_bkey(fsg->trans[i].trans, (char const *) &j,\n                               sizeof(j), &val) < 0)\n        return NULL;\n    return (glist_t) val;\n}\n\nfsg_link_t *\nfsg_model_null_trans(fsg_model_t * fsg, int32 i, int32 j)\n{\n    void *val;\n\n    if (fsg->trans[i].null_trans == NULL)\n        return NULL;\n    if (hash_table_lookup_bkey(fsg->trans[i].null_trans, (char const *) &j,\n                               sizeof(j), &val) < 0)\n        return NULL;\n    return (fsg_link_t *) val;\n}\n\nfsg_arciter_t *\nfsg_model_arcs(fsg_model_t * fsg, int32 i)\n{\n    fsg_arciter_t *itor;\n\n    if (fsg->trans[i].trans == NULL && fsg->trans[i].null_trans == NULL)\n        return NULL;\n    itor = ckd_calloc(1, sizeof(*itor));\n    if (fsg->trans[i].null_trans)\n        itor->null_itor = hash_table_iter(fsg->trans[i].null_trans);\n    if (fsg->trans[i].trans)\n        itor->itor = hash_table_iter(fsg->trans[i].trans);\n    if (itor->itor != NULL)\n        itor->gn = hash_entry_val(itor->itor->ent);\n    return itor;\n}\n\nfsg_link_t *\nfsg_arciter_get(fsg_arciter_t * itor)\n{\n    /* Iterate over non-null arcs first. */\n    if (itor->gn)\n        return (fsg_link_t *) gnode_ptr(itor->gn);\n    else if (itor->null_itor)\n        return (fsg_link_t *) hash_entry_val(itor->null_itor->ent);\n    else\n        return NULL;\n}\n\nfsg_arciter_t *\nfsg_arciter_next(fsg_arciter_t * itor)\n{\n    /* Iterate over non-null arcs first. */\n    if (itor->gn) {\n        itor->gn = gnode_next(itor->gn);\n        /* Move to the next destination arc. */\n        if (itor->gn == NULL) {\n            itor->itor = hash_table_iter_next(itor->itor);\n            if (itor->itor != NULL)\n                itor->gn = hash_entry_val(itor->itor->ent);\n            else if (itor->null_itor == NULL)\n                goto stop_iteration;\n        }\n    }\n    else {\n        if (itor->null_itor == NULL)\n            goto stop_iteration;\n        itor->null_itor = hash_table_iter_next(itor->null_itor);\n        if (itor->null_itor == NULL)\n            goto stop_iteration;\n    }\n    return itor;\n  stop_iteration:\n    fsg_arciter_free(itor);\n    return NULL;\n\n}\n\nvoid\nfsg_arciter_free(fsg_arciter_t * itor)\n{\n    if (itor == NULL)\n        return;\n    hash_table_iter_free(itor->null_itor);\n    hash_table_iter_free(itor->itor);\n    ckd_free(itor);\n}\n\nint\nfsg_model_word_id(fsg_model_t * fsg, char const *word)\n{\n    int wid;\n\n    /* Search for an existing word matching this. */\n    for (wid = 0; wid < fsg->n_word; ++wid) {\n        if (0 == strcmp(fsg->vocab[wid], word))\n            break;\n    }\n    /* If not found, add this to the vocab. */\n    if (wid == fsg->n_word)\n        return -1;\n    return wid;\n}\n\nint\nfsg_model_word_add(fsg_model_t * fsg, char const *word)\n{\n    int wid, old_size;\n\n    /* Search for an existing word matching this. */\n    wid = fsg_model_word_id(fsg, word);\n    /* If not found, add this to the vocab. */\n    if (wid == -1) {\n        wid = fsg->n_word;\n        if (fsg->n_word == fsg->n_word_alloc) {\n            old_size = fsg->n_word_alloc;\n            fsg->n_word_alloc += 10;\n            fsg->vocab = ckd_realloc(fsg->vocab,\n                                     fsg->n_word_alloc *\n                                     sizeof(*fsg->vocab));\n            if (fsg->silwords)\n                fsg->silwords =\n                    bitvec_realloc(fsg->silwords, old_size,\n                                   fsg->n_word_alloc);\n            if (fsg->altwords)\n                fsg->altwords =\n                    bitvec_realloc(fsg->altwords, old_size,\n                                   fsg->n_word_alloc);\n        }\n        ++fsg->n_word;\n        fsg->vocab[wid] = ckd_salloc(word);\n    }\n    return wid;\n}\n\nint\nfsg_model_add_silence(fsg_model_t * fsg, char const *silword,\n                      int state, float32 silprob)\n{\n    int32 logsilp;\n    int n_trans, silwid, src;\n\n    E_INFO(\"Adding silence transitions for %s to FSG\\n\", silword);\n\n    silwid = fsg_model_word_add(fsg, silword);\n    logsilp = (int32) (logmath_log(fsg->lmath, silprob) * fsg->lw);\n    if (fsg->silwords == NULL)\n        fsg->silwords = bitvec_alloc(fsg->n_word_alloc);\n    bitvec_set(fsg->silwords, silwid);\n\n    n_trans = 0;\n    if (state == -1) {\n        for (src = 0; src < fsg->n_state; src++) {\n            fsg_model_trans_add(fsg, src, src, logsilp, silwid);\n            ++n_trans;\n        }\n    }\n    else {\n        fsg_model_trans_add(fsg, state, state, logsilp, silwid);\n        ++n_trans;\n    }\n\n    E_INFO(\"Added %d silence word transitions\\n\", n_trans);\n    return n_trans;\n}\n\nint\nfsg_model_add_alt(fsg_model_t * fsg, char const *baseword,\n                  char const *altword)\n{\n    int i, basewid, altwid;\n    int ntrans;\n\n    /* FIXME: This will get slow, eventually... */\n    for (basewid = 0; basewid < fsg->n_word; ++basewid)\n        if (0 == strcmp(fsg->vocab[basewid], baseword))\n            break;\n    if (basewid == fsg->n_word) {\n        E_ERROR(\"Base word %s not present in FSG vocabulary!\\n\", baseword);\n        return -1;\n    }\n    altwid = fsg_model_word_add(fsg, altword);\n    if (fsg->altwords == NULL)\n        fsg->altwords = bitvec_alloc(fsg->n_word_alloc);\n    bitvec_set(fsg->altwords, altwid);\n    if (fsg_model_is_filler(fsg, basewid)) {\n        if (fsg->silwords == NULL)\n            fsg->silwords = bitvec_alloc(fsg->n_word_alloc);\n        bitvec_set(fsg->silwords, altwid);\n    }\n\n    E_DEBUG(\"Adding alternate word transitions (%s,%s) to FSG\\n\",\n            baseword, altword);\n\n    /* Look for all transitions involving baseword and duplicate them. */\n    /* FIXME: This will also get slow, eventually... */\n    ntrans = 0;\n    for (i = 0; i < fsg->n_state; ++i) {\n        hash_iter_t *itor;\n        if (fsg->trans[i].trans == NULL)\n            continue;\n        for (itor = hash_table_iter(fsg->trans[i].trans); itor;\n             itor = hash_table_iter_next(itor)) {\n            glist_t trans;\n            gnode_t *gn;\n\n            trans = hash_entry_val(itor->ent);\n            for (gn = trans; gn; gn = gnode_next(gn)) {\n                fsg_link_t *fl = gnode_ptr(gn);\n                if (fl->wid == basewid) {\n                    fsg_link_t *link;\n\n                    /* Create transition object */\n                    link = listelem_malloc(fsg->link_alloc);\n                    link->from_state = fl->from_state;\n                    link->to_state = fl->to_state;\n                    link->logs2prob = fl->logs2prob;    /* FIXME!!!??? */\n                    link->wid = altwid;\n\n                    trans = glist_add_ptr(trans, (void *) link);\n                    ++ntrans;\n                }\n            }\n            hash_entry_val(itor->ent) = trans;\n        }\n    }\n\n    E_DEBUG(\"Added %d alternate word transitions\\n\", ntrans);\n    return ntrans;\n}\n\n\nfsg_model_t *\nfsg_model_init(char const *name, logmath_t * lmath, float32 lw,\n               int32 n_state)\n{\n    fsg_model_t *fsg;\n\n    /* Allocate basic stuff. */\n    fsg = ckd_calloc(1, sizeof(*fsg));\n    fsg->refcount = 1;\n    fsg->link_alloc = listelem_alloc_init(sizeof(fsg_link_t));\n    fsg->lmath = lmath;\n    fsg->name = name ? ckd_salloc(name) : NULL;\n    fsg->n_state = n_state;\n    fsg->lw = lw;\n\n    fsg->trans = ckd_calloc(fsg->n_state, sizeof(*fsg->trans));\n\n    return fsg;\n}\n\nfsg_model_t *\nfsg_model_read(FILE * fp, logmath_t * lmath, float32 lw)\n{\n    fsg_model_t *fsg;\n    hash_table_t *vocab;\n    hash_iter_t *itor;\n    int32 lastwid;\n    char **wordptr;\n    char *lineptr;\n    char *fsgname;\n    int32 lineno;\n    int32 n, i, j;\n    int n_state, n_trans, n_null_trans;\n    glist_t nulls;\n    float32 p;\n\n    lineno = 0;\n    vocab = hash_table_new(32, FALSE);\n    wordptr = NULL;\n    lineptr = NULL;\n    nulls = NULL;\n    fsgname = NULL;\n    fsg = NULL;\n\n    /* Scan upto FSG_BEGIN header */\n    for (;;) {\n        n = nextline_str2words(fp, &lineno, &lineptr, &wordptr);\n        if (n < 0) {\n            E_ERROR(\"%s declaration missing\\n\", FSG_MODEL_BEGIN_DECL);\n            goto parse_error;\n        }\n\n        if ((strcmp(wordptr[0], FSG_MODEL_BEGIN_DECL) == 0)) {\n            if (n > 2) {\n                E_ERROR(\"Line[%d]: malformed FSG_BEGIN declaration\\n\",\n                        lineno);\n                goto parse_error;\n            }\n            break;\n        }\n    }\n    /* Save FSG name, or it will get clobbered below :(.\n     * If name is missing, try the default.\n     */\n    if (n == 2) {\n        fsgname = ckd_salloc(wordptr[1]);\n    }\n    else {\n        E_WARN(\"FSG name is missing\\n\");\n        fsgname = ckd_salloc(\"unknown\");\n    }\n\n    /* Read #states */\n    n = nextline_str2words(fp, &lineno, &lineptr, &wordptr);\n    if ((n != 2)\n        || ((strcmp(wordptr[0], FSG_MODEL_N_DECL) != 0)\n            && (strcmp(wordptr[0], FSG_MODEL_NUM_STATES_DECL) != 0))\n        || (sscanf(wordptr[1], \"%d\", &n_state) != 1)\n        || (n_state <= 0)) {\n        E_ERROR\n            (\"Line[%d]: #states declaration line missing or malformed\\n\",\n             lineno);\n        goto parse_error;\n    }\n\n    /* Now create the FSG. */\n    fsg = fsg_model_init(fsgname, lmath, lw, n_state);\n    ckd_free(fsgname);\n    fsgname = NULL;\n\n    /* Read start state */\n    n = nextline_str2words(fp, &lineno, &lineptr, &wordptr);\n    if ((n != 2)\n        || ((strcmp(wordptr[0], FSG_MODEL_S_DECL) != 0)\n            && (strcmp(wordptr[0], FSG_MODEL_START_STATE_DECL) != 0))\n        || (sscanf(wordptr[1], \"%d\", &(fsg->start_state)) != 1)\n        || (fsg->start_state < 0)\n        || (fsg->start_state >= fsg->n_state)) {\n        E_ERROR\n            (\"Line[%d]: start state declaration line missing or malformed\\n\",\n             lineno);\n        goto parse_error;\n    }\n\n    /* Read final state */\n    n = nextline_str2words(fp, &lineno, &lineptr, &wordptr);\n    if ((n != 2)\n        || ((strcmp(wordptr[0], FSG_MODEL_F_DECL) != 0)\n            && (strcmp(wordptr[0], FSG_MODEL_FINAL_STATE_DECL) != 0))\n        || (sscanf(wordptr[1], \"%d\", &(fsg->final_state)) != 1)\n        || (fsg->final_state < 0)\n        || (fsg->final_state >= fsg->n_state)) {\n        E_ERROR\n            (\"Line[%d]: final state declaration line missing or malformed\\n\",\n             lineno);\n        goto parse_error;\n    }\n\n    /* Read transitions */\n    lastwid = 0;\n    n_trans = n_null_trans = 0;\n    for (;;) {\n        int32 wid, tprob;\n\n        n = nextline_str2words(fp, &lineno, &lineptr, &wordptr);\n        if (n <= 0) {\n            E_ERROR(\"Line[%d]: transition or FSG_END statement expected\\n\",\n                    lineno);\n            goto parse_error;\n        }\n\n        if ((strcmp(wordptr[0], FSG_MODEL_END_DECL) == 0)) {\n            break;\n        }\n\n        if ((strcmp(wordptr[0], FSG_MODEL_T_DECL) == 0)\n            || (strcmp(wordptr[0], FSG_MODEL_TRANSITION_DECL) == 0)) {\n\n\n            if (((n != 4) && (n != 5))\n                || (sscanf(wordptr[1], \"%d\", &i) != 1)\n                || (sscanf(wordptr[2], \"%d\", &j) != 1)\n                || (i < 0) || (i >= fsg->n_state)\n                || (j < 0) || (j >= fsg->n_state)) {\n                E_ERROR\n                    (\"Line[%d]: transition spec malformed; Expecting: from-state to-state trans-prob [word]\\n\",\n                     lineno);\n                goto parse_error;\n            }\n\n            p = atof_c(wordptr[3]);\n            if ((p <= 0.0) || (p > 1.0)) {\n                E_ERROR\n                    (\"Line[%d]: transition spec malformed; Expecting float as transition probability\\n\",\n                     lineno);\n                goto parse_error;\n            }\n        }\n        else {\n            E_ERROR(\"Line[%d]: transition or FSG_END statement expected\\n\",\n                    lineno);\n            goto parse_error;\n        }\n\n        tprob = (int32) (logmath_log(lmath, p) * fsg->lw);\n        /* Add word to \"dictionary\". */\n        if (n > 4) {\n            if (hash_table_lookup_int32(vocab, wordptr[4], &wid) < 0) {\n                (void) hash_table_enter_int32(vocab,\n                                              ckd_salloc(wordptr[4]),\n                                              lastwid);\n                wid = lastwid;\n                ++lastwid;\n            }\n            fsg_model_trans_add(fsg, i, j, tprob, wid);\n            ++n_trans;\n        }\n        else {\n            if (fsg_model_null_trans_add(fsg, i, j, tprob) == 1) {\n                ++n_null_trans;\n                nulls =\n                    glist_add_ptr(nulls, fsg_model_null_trans(fsg, i, j));\n            }\n        }\n    }\n\n    E_INFO(\"FSG: %d states, %d unique words, %d transitions (%d null)\\n\",\n           fsg->n_state, hash_table_inuse(vocab), n_trans, n_null_trans);\n\n\n    /* Now create a string table from the \"dictionary\" */\n    fsg->n_word = hash_table_inuse(vocab);\n    fsg->n_word_alloc = fsg->n_word + 10;       /* Pad it a bit. */\n    fsg->vocab = ckd_calloc(fsg->n_word_alloc, sizeof(*fsg->vocab));\n    for (itor = hash_table_iter(vocab); itor;\n         itor = hash_table_iter_next(itor)) {\n        char const *word = hash_entry_key(itor->ent);\n        int32 wid = (int32) (long) hash_entry_val(itor->ent);\n        fsg->vocab[wid] = (char *) word;\n    }\n    hash_table_free(vocab);\n\n    /* Do transitive closure on null transitions */\n    nulls = fsg_model_null_trans_closure(fsg, nulls);\n    glist_free(nulls);\n\n    ckd_free(lineptr);\n    ckd_free(wordptr);\n\n    return fsg;\n\n  parse_error:\n    for (itor = hash_table_iter(vocab); itor;\n         itor = hash_table_iter_next(itor))\n        ckd_free((char *) hash_entry_key(itor->ent));\n    glist_free(nulls);\n    hash_table_free(vocab);\n    ckd_free(fsgname);\n    ckd_free(lineptr);\n    ckd_free(wordptr);\n    fsg_model_free(fsg);\n    return NULL;\n}\n\n\nfsg_model_t *\nfsg_model_readfile(const char *file, logmath_t * lmath, float32 lw)\n{\n    FILE *fp;\n    fsg_model_t *fsg;\n\n    if ((fp = fopen(file, \"r\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open FSG file '%s' for reading\", file);\n        return NULL;\n    }\n    fsg = fsg_model_read(fp, lmath, lw);\n    fclose(fp);\n    return fsg;\n}\n\nfsg_model_t *\nfsg_model_retain(fsg_model_t * fsg)\n{\n    ++fsg->refcount;\n    return fsg;\n}\n\nstatic void\ntrans_list_free(fsg_model_t * fsg, int32 i)\n{\n    hash_iter_t *itor;\n\n    /* FIXME (maybe): FSG links will all get freed when we call\n     * listelem_alloc_free() so don't bother freeing them explicitly\n     * here. */\n    if (fsg->trans[i].trans) {\n        for (itor = hash_table_iter(fsg->trans[i].trans);\n             itor; itor = hash_table_iter_next(itor)) {\n            glist_t gl = (glist_t) hash_entry_val(itor->ent);\n            glist_free(gl);\n        }\n    }\n    hash_table_free(fsg->trans[i].trans);\n    hash_table_free(fsg->trans[i].null_trans);\n}\n\nint\nfsg_model_free(fsg_model_t * fsg)\n{\n    int i;\n\n    if (fsg == NULL)\n        return 0;\n\n    if (--fsg->refcount > 0)\n        return fsg->refcount;\n\n    for (i = 0; i < fsg->n_word; ++i)\n        ckd_free(fsg->vocab[i]);\n    for (i = 0; i < fsg->n_state; ++i)\n        trans_list_free(fsg, i);\n    ckd_free(fsg->trans);\n    ckd_free(fsg->vocab);\n    listelem_alloc_free(fsg->link_alloc);\n    bitvec_free(fsg->silwords);\n    bitvec_free(fsg->altwords);\n    ckd_free(fsg->name);\n    ckd_free(fsg);\n    return 0;\n}\n\n\nvoid\nfsg_model_write(fsg_model_t * fsg, FILE * fp)\n{\n    int32 i;\n\n    fprintf(fp, \"%s %s\\n\", FSG_MODEL_BEGIN_DECL,\n            fsg->name ? fsg->name : \"\");\n    fprintf(fp, \"%s %d\\n\", FSG_MODEL_NUM_STATES_DECL, fsg->n_state);\n    fprintf(fp, \"%s %d\\n\", FSG_MODEL_START_STATE_DECL, fsg->start_state);\n    fprintf(fp, \"%s %d\\n\", FSG_MODEL_FINAL_STATE_DECL, fsg->final_state);\n\n    for (i = 0; i < fsg->n_state; i++) {\n        fsg_arciter_t *itor;\n\n        for (itor = fsg_model_arcs(fsg, i); itor;\n             itor = fsg_arciter_next(itor)) {\n            fsg_link_t *tl = fsg_arciter_get(itor);\n\n            fprintf(fp, \"%s %d %d %f %s\\n\", FSG_MODEL_TRANSITION_DECL,\n                    tl->from_state, tl->to_state,\n                    logmath_exp(fsg->lmath,\n                                (int32) (tl->logs2prob / fsg->lw)),\n                    (tl->wid < 0) ? \"\" : fsg_model_word_str(fsg, tl->wid));\n        }\n    }\n\n    fprintf(fp, \"%s\\n\", FSG_MODEL_END_DECL);\n\n    fflush(fp);\n}\n\nvoid\nfsg_model_writefile(fsg_model_t * fsg, char const *file)\n{\n    FILE *fp;\n\n    assert(fsg);\n\n    E_INFO(\"Writing FSG file '%s'\\n\", file);\n\n    if ((fp = fopen(file, \"w\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open FSG file '%s' for reading\", file);\n        return;\n    }\n\n    fsg_model_write(fsg, fp);\n\n    fclose(fp);\n}\n\nstatic void\nfsg_model_write_fsm_trans(fsg_model_t * fsg, int i, FILE * fp)\n{\n    fsg_arciter_t *itor;\n\n    for (itor = fsg_model_arcs(fsg, i); itor;\n         itor = fsg_arciter_next(itor)) {\n        fsg_link_t *tl = fsg_arciter_get(itor);\n        fprintf(fp, \"%d %d %s %f\\n\",\n                tl->from_state, tl->to_state,\n                (tl->wid < 0) ? \"<eps>\" : fsg_model_word_str(fsg, tl->wid),\n                -logmath_log_to_ln(fsg->lmath, tl->logs2prob / fsg->lw));\n    }\n}\n\nvoid\nfsg_model_write_fsm(fsg_model_t * fsg, FILE * fp)\n{\n    int i;\n\n    /* Write transitions from initial state first. */\n    fsg_model_write_fsm_trans(fsg, fsg_model_start_state(fsg), fp);\n\n    /* Other states. */\n    for (i = 0; i < fsg->n_state; i++) {\n        if (i == fsg_model_start_state(fsg))\n            continue;\n        fsg_model_write_fsm_trans(fsg, i, fp);\n    }\n\n    /* Final state. */\n    fprintf(fp, \"%d 0\\n\", fsg_model_final_state(fsg));\n\n    fflush(fp);\n}\n\nvoid\nfsg_model_writefile_fsm(fsg_model_t * fsg, char const *file)\n{\n    FILE *fp;\n\n    assert(fsg);\n\n    E_INFO(\"Writing FSM file '%s'\\n\", file);\n\n    if ((fp = fopen(file, \"w\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open fsm file '%s' for writing\", file);\n        return;\n    }\n\n    fsg_model_write_fsm(fsg, fp);\n\n    fclose(fp);\n}\n\nvoid\nfsg_model_write_symtab(fsg_model_t * fsg, FILE * file)\n{\n    int i;\n\n    fprintf(file, \"<eps> 0\\n\");\n    for (i = 0; i < fsg_model_n_word(fsg); ++i) {\n        fprintf(file, \"%s %d\\n\", fsg_model_word_str(fsg, i), i + 1);\n    }\n    fflush(file);\n}\n\nvoid\nfsg_model_writefile_symtab(fsg_model_t * fsg, char const *file)\n{\n    FILE *fp;\n\n    assert(fsg);\n\n    E_INFO(\"Writing FSM symbol table '%s'\\n\", file);\n\n    if ((fp = fopen(file, \"w\")) == NULL) {\n        E_ERROR(\"Failed to open symbol table '%s' for writing\", file);\n        return;\n    }\n\n    fsg_model_write_symtab(fsg, fp);\n\n    fclose(fp);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2007 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <string.h>\n#include <assert.h>\n\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/hash_table.h\"\n#include \"sphinxbase/filename.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/jsgf.h\"\n\n#include \"jsgf_internal.h\"\n#include \"jsgf_parser.h\"\n#include \"jsgf_scanner.h\"\n\nextern int yyparse(void *scanner, jsgf_t * jsgf);\n\n/**\n * \\file jsgf.c\n *\n * This file implements the data structures for parsing JSGF grammars\n * into Sphinx finite-state grammars.\n **/\n\nstatic int expand_rule(jsgf_t * grammar, jsgf_rule_t * rule,\n                       int rule_entry, int rule_exit);\n\njsgf_atom_t *\njsgf_atom_new(char *name, float weight)\n{\n    jsgf_atom_t *atom;\n\n    atom = ckd_calloc(1, sizeof(*atom));\n    atom->name = ckd_salloc(name);\n    atom->weight = weight;\n    return atom;\n}\n\nint\njsgf_atom_free(jsgf_atom_t * atom)\n{\n    if (atom == NULL)\n        return 0;\n    ckd_free(atom->name);\n    ckd_free(atom);\n    return 0;\n}\n\njsgf_t *\njsgf_grammar_new(jsgf_t * parent)\n{\n    jsgf_t *grammar;\n\n    grammar = ckd_calloc(1, sizeof(*grammar));\n    /* If this is an imported/subgrammar, then we will share a global\n     * namespace with the parent grammar. */\n    if (parent) {\n        grammar->rules = parent->rules;\n        grammar->imports = parent->imports;\n        grammar->searchpath = parent->searchpath;\n        grammar->parent = parent;\n    }\n    else {\n        grammar->rules = hash_table_new(64, 0);\n        grammar->imports = hash_table_new(16, 0);\n    }\n\n    return grammar;\n}\n\nvoid\njsgf_grammar_free(jsgf_t * jsgf)\n{\n    /* FIXME: Probably should just use refcounting instead. */\n    if (jsgf->parent == NULL) {\n        hash_iter_t *itor;\n        gnode_t *gn;\n\n        for (itor = hash_table_iter(jsgf->rules); itor;\n             itor = hash_table_iter_next(itor)) {\n            ckd_free((char *) itor->ent->key);\n            jsgf_rule_free((jsgf_rule_t *) itor->ent->val);\n        }\n        hash_table_free(jsgf->rules);\n        for (itor = hash_table_iter(jsgf->imports); itor;\n             itor = hash_table_iter_next(itor)) {\n            ckd_free((char *) itor->ent->key);\n            jsgf_grammar_free((jsgf_t *) itor->ent->val);\n        }\n        hash_table_free(jsgf->imports);\n        for (gn = jsgf->searchpath; gn; gn = gnode_next(gn))\n            ckd_free(gnode_ptr(gn));\n        glist_free(jsgf->searchpath);\n        for (gn = jsgf->links; gn; gn = gnode_next(gn))\n            ckd_free(gnode_ptr(gn));\n        glist_free(jsgf->links);\n    }\n    ckd_free(jsgf->name);\n    ckd_free(jsgf->version);\n    ckd_free(jsgf->charset);\n    ckd_free(jsgf->locale);\n    ckd_free(jsgf);\n}\n\nstatic void\njsgf_rhs_free(jsgf_rhs_t * rhs)\n{\n    gnode_t *gn;\n\n    if (rhs == NULL)\n        return;\n\n    jsgf_rhs_free(rhs->alt);\n    for (gn = rhs->atoms; gn; gn = gnode_next(gn))\n        jsgf_atom_free(gnode_ptr(gn));\n    glist_free(rhs->atoms);\n    ckd_free(rhs);\n}\n\njsgf_atom_t *\njsgf_kleene_new(jsgf_t * jsgf, jsgf_atom_t * atom, int plus)\n{\n    jsgf_rule_t *rule;\n    jsgf_atom_t *rule_atom;\n    jsgf_rhs_t *rhs;\n\n    /* Generate an \"internal\" rule of the form (<NULL> | <name> <g0006>) */\n    /* Or if plus is true, (<name> | <name> <g0006>) */\n    rhs = ckd_calloc(1, sizeof(*rhs));\n    if (plus)\n        rhs->atoms = glist_add_ptr(NULL, jsgf_atom_new(atom->name, 1.0));\n    else\n        rhs->atoms = glist_add_ptr(NULL, jsgf_atom_new(\"<NULL>\", 1.0));\n    rule = jsgf_define_rule(jsgf, NULL, rhs, 0);\n    rule_atom = jsgf_atom_new(rule->name, 1.0);\n    rhs = ckd_calloc(1, sizeof(*rhs));\n    rhs->atoms = glist_add_ptr(NULL, rule_atom);\n    rhs->atoms = glist_add_ptr(rhs->atoms, atom);\n    rule->rhs->alt = rhs;\n\n    return jsgf_atom_new(rule->name, 1.0);\n}\n\njsgf_rule_t *\njsgf_optional_new(jsgf_t * jsgf, jsgf_rhs_t * exp)\n{\n    jsgf_rhs_t *rhs = ckd_calloc(1, sizeof(*rhs));\n    jsgf_atom_t *atom = jsgf_atom_new(\"<NULL>\", 1.0);\n    rhs->alt = exp;\n    rhs->atoms = glist_add_ptr(NULL, atom);\n    return jsgf_define_rule(jsgf, NULL, rhs, 0);\n}\n\nvoid\njsgf_add_link(jsgf_t * grammar, jsgf_atom_t * atom, int from, int to)\n{\n    jsgf_link_t *link;\n\n    link = ckd_calloc(1, sizeof(*link));\n    link->from = from;\n    link->to = to;\n    link->atom = atom;\n    grammar->links = glist_add_ptr(grammar->links, link);\n}\n\nstatic char *\nextract_grammar_name(char *rule_name)\n{\n    char *dot_pos;\n    char *grammar_name = ckd_salloc(rule_name + 1);\n    if ((dot_pos = strrchr(grammar_name + 1, '.')) == NULL) {\n        ckd_free(grammar_name);\n        return NULL;\n    }\n    *dot_pos = '\\0';\n    return grammar_name;\n}\n\nchar const *\njsgf_grammar_name(jsgf_t * jsgf)\n{\n    return jsgf->name;\n}\n\nstatic char *\njsgf_fullname(jsgf_t * jsgf, const char *name)\n{\n    char *fullname;\n\n    /* Check if it is already qualified */\n    if (strchr(name + 1, '.'))\n        return ckd_salloc(name);\n\n    /* Skip leading < in name */\n    fullname = ckd_malloc(strlen(jsgf->name) + strlen(name) + 4);\n    sprintf(fullname, \"<%s.%s\", jsgf->name, name + 1);\n    return fullname;\n}\n\nstatic char *\njsgf_fullname_from_rule(jsgf_rule_t * rule, const char *name)\n{\n    char *fullname, *grammar_name;\n\n    /* Check if it is already qualified */\n    if (strchr(name + 1, '.'))\n        return ckd_salloc(name);\n\n    /* Skip leading < in name */\n    if ((grammar_name = extract_grammar_name(rule->name)) == NULL)\n        return ckd_salloc(name);\n    fullname = ckd_malloc(strlen(grammar_name) + strlen(name) + 4);\n    sprintf(fullname, \"<%s.%s\", grammar_name, name + 1);\n    ckd_free(grammar_name);\n\n    return fullname;\n}\n\n/* Extract as rulename everything after the secondlast dot, if existent. \n * Because everything before the secondlast dot is the path-specification. */\nstatic char *\nimportname2rulename(char *importname)\n{\n    char *rulename = ckd_salloc(importname);\n    char *last_dotpos;\n    char *secondlast_dotpos;\n\n    if ((last_dotpos = strrchr(rulename + 1, '.')) != NULL) {\n        *last_dotpos = '\\0';\n        if ((secondlast_dotpos = strrchr(rulename + 1, '.')) != NULL) {\n            *last_dotpos = '.';\n            *secondlast_dotpos = '<';\n            secondlast_dotpos = ckd_salloc(secondlast_dotpos);\n            ckd_free(rulename);\n            return secondlast_dotpos;\n        }\n        else {\n            *last_dotpos = '.';\n            return rulename;\n        }\n    }\n    else {\n        return rulename;\n    }\n}\n\n#define NO_NODE -1\n#define RECURSIVE_NODE -2\n\n/**\n *\n * Expand a right-hand-side of a rule (i.e. a single alternate).\n *\n * @returns the FSG state at the end of this rule, NO_NODE if there's an\n * error, and RECURSIVE_NODE if the right-hand-side ended in right-recursion (i.e.\n * a link to an earlier FSG state).\n */\nstatic int\nexpand_rhs(jsgf_t * grammar, jsgf_rule_t * rule, jsgf_rhs_t * rhs,\n           int rule_entry, int rule_exit)\n{\n    gnode_t *gn;\n    int lastnode;\n\n    /* Last node expanded in this sequence. */\n    lastnode = rule_entry;\n\n    /* Iterate over atoms in rhs and generate links/nodes */\n    for (gn = rhs->atoms; gn; gn = gnode_next(gn)) {\n        jsgf_atom_t *atom = gnode_ptr(gn);\n\n        if (jsgf_atom_is_rule(atom)) {\n            jsgf_rule_t *subrule;\n            char *fullname;\n            gnode_t *subnode;\n            jsgf_rule_stack_t *rule_stack_entry = NULL;\n\n            /* Special case for <NULL> and <VOID> pseudo-rules             \n               If this is the only atom in the rhs, and it's the \n               first rhs in the rule, then emit a null transition, \n               creating an exit state if needed. */\n            if (0 == strcmp(atom->name, \"<NULL>\")) {\n                if (gn == rhs->atoms && gnode_next(gn) == NULL) {\n                    if (rule_exit == NO_NODE) {\n                        jsgf_add_link(grammar, atom,\n                                      lastnode, grammar->nstate);\n                        rule_exit = lastnode = grammar->nstate;\n                        ++grammar->nstate;\n                    }\n                    else {\n                        jsgf_add_link(grammar, atom, lastnode, rule_exit);\n                    }\n                }\n                continue;\n            }\n            else if (0 == strcmp(atom->name, \"<VOID>\")) {\n                /* Make this entire RHS unspeakable */\n                return NO_NODE;\n            }\n\n            fullname = jsgf_fullname_from_rule(rule, atom->name);\n            if (hash_table_lookup\n                (grammar->rules, fullname, (void **) &subrule) == -1) {\n                E_ERROR(\"Undefined rule in RHS: %s\\n\", fullname);\n                ckd_free(fullname);\n                return NO_NODE;\n            }\n            ckd_free(fullname);\n\n            /* Look for this subrule in the stack of expanded rules */\n            for (subnode = grammar->rulestack; subnode;\n                 subnode = gnode_next(subnode)) {\n                rule_stack_entry =\n                    (jsgf_rule_stack_t *) gnode_ptr(subnode);\n                if (rule_stack_entry->rule == subrule)\n                    break;\n            }\n\n            if (subnode != NULL) {\n                /* Allow right-recursion only. */\n                if (gnode_next(gn) != NULL) {\n                    E_ERROR\n                        (\"Only right-recursion is permitted (in %s.%s)\\n\",\n                         grammar->name, rule->name);\n                    return NO_NODE;\n                }\n                /* Add a link back to the beginning of this rule instance */\n                E_INFO(\"Right recursion %s %d => %d\\n\", atom->name,\n                       lastnode, rule_stack_entry->entry);\n                jsgf_add_link(grammar, atom, lastnode,\n                              rule_stack_entry->entry);\n\n                /* Let our caller know that this rhs didn't reach an\n                   end state. */\n                lastnode = RECURSIVE_NODE;\n            }\n            else {\n                /* If this is the last atom in this rhs, link its\n                   expansion to the parent rule's exit state.\n                   Otherwise, create a new exit state for it. */\n                int subruleexit = NO_NODE;\n                if (gnode_next(gn) == NULL && rule_exit >= 0)\n                    subruleexit = rule_exit;\n\n                /* Expand the subrule */\n                lastnode =\n                    expand_rule(grammar, subrule, lastnode, subruleexit);\n\n                if (lastnode == NO_NODE)\n                    return NO_NODE;\n            }\n        }\n        else {\n            /* An exit-state is created if this isn't the last atom\n               in the rhs, or if the containing rule doesn't have an\n               exit state yet.\n               Otherwise, the rhs's exit state becomes the containing\n               rule's exit state. */\n            int exitstate;\n            if (gnode_next(gn) == NULL && rule_exit >= 0) {\n                exitstate = rule_exit;\n            }\n            else {\n                exitstate = grammar->nstate;\n                ++grammar->nstate;\n            }\n\n            /* Add a link for this token */\n            jsgf_add_link(grammar, atom, lastnode, exitstate);\n            lastnode = exitstate;\n        }\n    }\n\n    return lastnode;\n}\n\nstatic int\nexpand_rule(jsgf_t * grammar, jsgf_rule_t * rule, int rule_entry,\n            int rule_exit)\n{\n    jsgf_rule_stack_t *rule_stack_entry;\n    jsgf_rhs_t *rhs;\n\n    /* Push this rule onto the stack */\n    rule_stack_entry =\n        (jsgf_rule_stack_t *) ckd_calloc(1, sizeof(jsgf_rule_stack_t));\n    rule_stack_entry->rule = rule;\n    rule_stack_entry->entry = rule_entry;\n    grammar->rulestack = glist_add_ptr(grammar->rulestack,\n                                       rule_stack_entry);\n\n    for (rhs = rule->rhs; rhs; rhs = rhs->alt) {\n        int lastnode;\n\n        lastnode = expand_rhs(grammar, rule, rhs, rule_entry, rule_exit);\n\n        if (lastnode == NO_NODE) {\n            return NO_NODE;\n        }\n        else if (lastnode == RECURSIVE_NODE) {\n            /* The rhs ended with right-recursion, i.e. a transition to\n               an earlier state. Nothing needs to happen at this level. */\n            ;\n        }\n        else if (rule_exit == NO_NODE) {\n            /* If this rule doesn't have an exit state yet, use the exit\n               state of its first right-hand-side.\n               All other right-hand-sides will use this exit state. */\n            assert(lastnode >= 0);\n            rule_exit = lastnode;\n        }\n    }\n\n    /* If no exit-state was created, use the entry-state. */\n    if (rule_exit == NO_NODE) {\n        rule_exit = rule_entry;\n    }\n\n    /* Pop this rule from the rule stack */\n    ckd_free(gnode_ptr(grammar->rulestack));\n    grammar->rulestack = gnode_free(grammar->rulestack, NULL);\n\n    return rule_exit;\n}\n\njsgf_rule_iter_t *\njsgf_rule_iter(jsgf_t * grammar)\n{\n    return hash_table_iter(grammar->rules);\n}\n\njsgf_rule_t *\njsgf_get_rule(jsgf_t * grammar, char const *name)\n{\n    void *val;\n    char *fullname;\n\n    fullname = string_join(\"<\", name, \">\", NULL);\n    if (hash_table_lookup(grammar->rules, fullname, &val) < 0) {\n        ckd_free(fullname);\n        return NULL;\n    }\n    ckd_free(fullname);\n    return (jsgf_rule_t *) val;\n}\n\njsgf_rule_t *\njsgf_get_public_rule(jsgf_t * grammar)\n{\n    jsgf_rule_iter_t *itor;\n    jsgf_rule_t *public_rule = NULL;\n\n    for (itor = jsgf_rule_iter(grammar); itor;\n         itor = jsgf_rule_iter_next(itor)) {\n        jsgf_rule_t *rule = jsgf_rule_iter_rule(itor);\n        if (jsgf_rule_public(rule)) {\n            const char *rule_name = jsgf_rule_name(rule);\n            char *dot_pos;\n            if ((dot_pos = strrchr(rule_name + 1, '.')) == NULL) {\n                public_rule = rule;\n                jsgf_rule_iter_free(itor);\n                break;\n            }\n            if (0 ==\n                strncmp(rule_name + 1, jsgf_grammar_name(grammar),\n                        dot_pos - rule_name - 1)) {\n                public_rule = rule;\n                jsgf_rule_iter_free(itor);\n                break;\n            }\n        }\n    }\n    return public_rule;\n}\n\nchar const *\njsgf_rule_name(jsgf_rule_t * rule)\n{\n    return rule->name;\n}\n\nint\njsgf_rule_public(jsgf_rule_t * rule)\n{\n    return rule->is_public;\n}\n\nstatic fsg_model_t *\njsgf_build_fsg_internal(jsgf_t * grammar, jsgf_rule_t * rule,\n                        logmath_t * lmath, float32 lw, int do_closure)\n{\n    fsg_model_t *fsg;\n    glist_t nulls;\n    gnode_t *gn;\n    int rule_entry, rule_exit;\n\n    /* Clear previous links */\n    for (gn = grammar->links; gn; gn = gnode_next(gn)) {\n        ckd_free(gnode_ptr(gn));\n    }\n    glist_free(grammar->links);\n    grammar->links = NULL;\n    grammar->nstate = 0;\n\n    /* Create the top-level entry state, and expand the\n       top-level rule. */\n    rule_entry = grammar->nstate++;\n    rule_exit = expand_rule(grammar, rule, rule_entry, NO_NODE);\n\n    /* If no exit-state was created, create one. */\n    if (rule_exit == NO_NODE) {\n        rule_exit = grammar->nstate++;\n        jsgf_add_link(grammar, NULL, rule_entry, rule_exit);\n    }\n\n    fsg = fsg_model_init(rule->name, lmath, lw, grammar->nstate);\n    fsg->start_state = rule_entry;\n    fsg->final_state = rule_exit;\n    grammar->links = glist_reverse(grammar->links);\n    for (gn = grammar->links; gn; gn = gnode_next(gn)) {\n        jsgf_link_t *link = gnode_ptr(gn);\n\n        if (link->atom) {\n            if (jsgf_atom_is_rule(link->atom)) {\n                fsg_model_null_trans_add(fsg, link->from, link->to,\n                                         logmath_log(lmath,\n                                                     link->atom->weight));\n            }\n            else {\n                int wid = fsg_model_word_add(fsg, link->atom->name);\n                fsg_model_trans_add(fsg, link->from, link->to,\n                                    logmath_log(lmath, link->atom->weight),\n                                    wid);\n            }\n        }\n        else {\n            fsg_model_null_trans_add(fsg, link->from, link->to, 0);\n        }\n    }\n    if (do_closure) {\n        nulls = fsg_model_null_trans_closure(fsg, NULL);\n        glist_free(nulls);\n    }\n\n    return fsg;\n}\n\nfsg_model_t *\njsgf_build_fsg(jsgf_t * grammar, jsgf_rule_t * rule,\n               logmath_t * lmath, float32 lw)\n{\n    return jsgf_build_fsg_internal(grammar, rule, lmath, lw, TRUE);\n}\n\nfsg_model_t *\njsgf_build_fsg_raw(jsgf_t * grammar, jsgf_rule_t * rule,\n                   logmath_t * lmath, float32 lw)\n{\n    return jsgf_build_fsg_internal(grammar, rule, lmath, lw, FALSE);\n}\n\nfsg_model_t *\njsgf_read_file(const char *file, logmath_t * lmath, float32 lw)\n{\n    fsg_model_t *fsg;\n    jsgf_rule_t *rule;\n    jsgf_t *jsgf;\n    jsgf_rule_iter_t *itor;\n\n    if ((jsgf = jsgf_parse_file(file, NULL)) == NULL) {\n        E_ERROR(\"Error parsing file: %s\\n\", file);\n        return NULL;\n    }\n\n    rule = NULL;\n    for (itor = jsgf_rule_iter(jsgf); itor;\n         itor = jsgf_rule_iter_next(itor)) {\n        rule = jsgf_rule_iter_rule(itor);\n        if (jsgf_rule_public(rule)) {\n            jsgf_rule_iter_free(itor);\n            break;\n        }\n    }\n    if (rule == NULL) {\n        E_ERROR(\"No public rules found in %s\\n\", file);\n        return NULL;\n    }\n    fsg = jsgf_build_fsg(jsgf, rule, lmath, lw);\n    jsgf_grammar_free(jsgf);\n    return fsg;\n}\n\nfsg_model_t *\njsgf_read_string(const char *string, logmath_t * lmath, float32 lw)\n{\n    fsg_model_t *fsg;\n    jsgf_rule_t *rule;\n    jsgf_t *jsgf;\n    jsgf_rule_iter_t *itor;\n\n    if ((jsgf = jsgf_parse_string(string, NULL)) == NULL) {\n        E_ERROR(\"Error parsing input string\\n\");\n        return NULL;\n    }\n\n    rule = NULL;\n    for (itor = jsgf_rule_iter(jsgf); itor;\n         itor = jsgf_rule_iter_next(itor)) {\n        rule = jsgf_rule_iter_rule(itor);\n        if (jsgf_rule_public(rule)) {\n            jsgf_rule_iter_free(itor);\n            break;\n        }\n    }\n    if (rule == NULL) {\n        jsgf_grammar_free(jsgf);\n        E_ERROR(\"No public rules found in input string\\n\");\n        return NULL;\n    }\n    fsg = jsgf_build_fsg(jsgf, rule, lmath, lw);\n    jsgf_grammar_free(jsgf);\n    return fsg;\n}\n\n\nint\njsgf_write_fsg(jsgf_t * grammar, jsgf_rule_t * rule, FILE * outfh)\n{\n    fsg_model_t *fsg;\n    logmath_t *lmath = logmath_init(1.0001, 0, 0);\n\n    if ((fsg = jsgf_build_fsg_raw(grammar, rule, lmath, 1.0)) == NULL)\n        goto error_out;\n\n    fsg_model_write(fsg, outfh);\n    logmath_free(lmath);\n    return 0;\n\n  error_out:\n    logmath_free(lmath);\n    return -1;\n}\n\njsgf_rule_t *\njsgf_define_rule(jsgf_t * jsgf, char *name, jsgf_rhs_t * rhs,\n                 int is_public)\n{\n    jsgf_rule_t *rule;\n    void *val;\n\n    if (name == NULL) {\n        name = ckd_malloc(strlen(jsgf->name) + 16);\n        sprintf(name, \"<%s.g%05d>\", jsgf->name,\n                hash_table_inuse(jsgf->rules));\n    }\n    else {\n        char *newname;\n\n        newname = jsgf_fullname(jsgf, name);\n        name = newname;\n    }\n\n    rule = ckd_calloc(1, sizeof(*rule));\n    rule->refcnt = 1;\n    rule->name = ckd_salloc(name);\n    rule->rhs = rhs;\n    rule->is_public = is_public;\n\n    E_INFO(\"Defined rule: %s%s\\n\",\n           rule->is_public ? \"PUBLIC \" : \"\", rule->name);\n    val = hash_table_enter(jsgf->rules, name, rule);\n    if (val != (void *) rule) {\n        E_WARN(\"Multiply defined symbol: %s\\n\", name);\n    }\n    return rule;\n}\n\njsgf_rule_t *\njsgf_rule_retain(jsgf_rule_t * rule)\n{\n    ++rule->refcnt;\n    return rule;\n}\n\nint\njsgf_rule_free(jsgf_rule_t * rule)\n{\n    if (rule == NULL)\n        return 0;\n    if (--rule->refcnt > 0)\n        return rule->refcnt;\n    jsgf_rhs_free(rule->rhs);\n    ckd_free(rule->name);\n    ckd_free(rule);\n    return 0;\n}\n\n\n/* FIXME: This should go in libsphinxutil */\nstatic char *\npath_list_search(glist_t paths, char *path)\n{\n    gnode_t *gn;\n\n    for (gn = paths; gn; gn = gnode_next(gn)) {\n        char *fullpath;\n        FILE *tmp;\n\n        fullpath = string_join(gnode_ptr(gn), \"/\", path, NULL);\n        tmp = fopen(fullpath, \"r\");\n        if (tmp != NULL) {\n            fclose(tmp);\n            return fullpath;\n        }\n        else {\n            ckd_free(fullpath);\n        }\n    }\n    return NULL;\n}\n\njsgf_rule_t *\njsgf_import_rule(jsgf_t * jsgf, char *name)\n{\n    char *c, *path, *newpath;\n    size_t namelen, packlen;\n    void *val;\n    jsgf_t *imp;\n    int import_all;\n\n    /* Trim the leading and trailing <> */\n    namelen = strlen(name);\n    path = ckd_malloc(namelen - 2 + 6); /* room for a trailing .gram */\n    strcpy(path, name + 1);\n    /* Split off the first part of the name */\n    c = strrchr(path, '.');\n    if (c == NULL) {\n        E_ERROR(\"Imported rule is not qualified: %s\\n\", name);\n        ckd_free(path);\n        return NULL;\n    }\n    packlen = c - path;\n    *c = '\\0';\n\n    /* Look for import foo.* */\n    import_all = (strlen(name) > 2\n                  && 0 == strcmp(name + namelen - 3, \".*>\"));\n\n    /* Construct a filename. */\n    for (c = path; *c; ++c)\n        if (*c == '.')\n            *c = '/';\n    strcat(path, \".gram\");\n    newpath = path_list_search(jsgf->searchpath, path);\n    if (newpath == NULL) {\n        E_ERROR(\"Failed to find grammar %s\\n\", path);\n        ckd_free(path);\n        return NULL;\n    }\n    ckd_free(path);\n\n    path = newpath;\n    E_INFO(\"Importing %s from %s to %s\\n\", name, path, jsgf->name);\n\n    /* FIXME: Also, we need to make sure that path is fully qualified\n     * here, by adding any prefixes from jsgf->name to it. */\n    /* See if we have parsed it already */\n    if (hash_table_lookup(jsgf->imports, path, &val) == 0) {\n        E_INFO(\"Already imported %s\\n\", path);\n        imp = val;\n        ckd_free(path);\n    }\n    else {\n        /* If not, parse it. */\n        imp = jsgf_parse_file(path, jsgf);\n        val = hash_table_enter(jsgf->imports, path, imp);\n        if (val != (void *) imp) {\n            E_WARN(\"Multiply imported file: %s\\n\", path);\n        }\n    }\n    if (imp != NULL) {\n        hash_iter_t *itor;\n        /* Look for public rules matching rulename. */\n        for (itor = hash_table_iter(imp->rules); itor;\n             itor = hash_table_iter_next(itor)) {\n            hash_entry_t *he = itor->ent;\n            jsgf_rule_t *rule = hash_entry_val(he);\n            int rule_matches;\n            char *rule_name = importname2rulename(name);\n\n            if (import_all) {\n                /* Match package name (symbol table is shared) */\n                rule_matches =\n                    !strncmp(rule_name, rule->name, packlen + 1);\n            }\n            else {\n                /* Exact match */\n                rule_matches = !strcmp(rule_name, rule->name);\n            }\n            ckd_free(rule_name);\n            if (rule->is_public && rule_matches) {\n                void *val;\n                char *newname;\n\n                /* Link this rule into the current namespace. */\n                c = strrchr(rule->name, '.');\n                assert(c != NULL);\n                newname = jsgf_fullname(jsgf, c);\n\n                E_INFO(\"Imported %s\\n\", newname);\n                val = hash_table_enter(jsgf->rules, newname,\n                                       jsgf_rule_retain(rule));\n                if (val != (void *) rule) {\n                    E_WARN(\"Multiply defined symbol: %s\\n\", newname);\n                }\n                if (!import_all) {\n                    hash_table_iter_free(itor);\n                    return rule;\n                }\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic void\njsgf_set_search_path(jsgf_t * jsgf, const char *filename)\n{\n    char *jsgf_path;\n\n#if !defined(_WIN32_WCE)\n    if ((jsgf_path = getenv(\"JSGF_PATH\")) != NULL) {\n        char *word, *c;\n        /* FIXME: This should be a function in libsphinxbase. */\n        word = jsgf_path = ckd_salloc(jsgf_path);\n        while ((c = strchr(word, ':'))) {\n            *c = '\\0';\n            jsgf->searchpath = glist_add_ptr(jsgf->searchpath, word);\n            word = c + 1;\n        }\n        jsgf->searchpath = glist_add_ptr(jsgf->searchpath, word);\n        jsgf->searchpath = glist_reverse(jsgf->searchpath);\n        return;\n    }\n#endif\n\n    if (!filename) {\n        jsgf->searchpath =\n            glist_add_ptr(jsgf->searchpath, ckd_salloc(\".\"));\n        return;\n    }\n\n    jsgf_path = ckd_salloc(filename);\n    path2dirname(filename, jsgf_path);\n    jsgf->searchpath = glist_add_ptr(jsgf->searchpath, jsgf_path);\n}\n\njsgf_t *\njsgf_parse_file(const char *filename, jsgf_t * parent)\n{\n    yyscan_t yyscanner;\n    jsgf_t *jsgf;\n    int yyrv;\n    FILE *in = NULL;\n\n    yylex_init(&yyscanner);\n    if (filename == NULL) {\n        yyset_in(stdin, yyscanner);\n    }\n    else {\n        in = fopen(filename, \"r\");\n        if (in == NULL) {\n            E_ERROR_SYSTEM(\"Failed to open %s for parsing\", filename);\n            return NULL;\n        }\n        yyset_in(in, yyscanner);\n    }\n\n    jsgf = jsgf_grammar_new(parent);\n\n    if (!parent)\n        jsgf_set_search_path(jsgf, filename);\n\n    yyrv = yyparse(yyscanner, jsgf);\n    if (yyrv != 0) {\n        E_ERROR(\"Failed to parse JSGF grammar from '%s'\\n\",\n                filename ? filename : \"(stdin)\");\n        jsgf_grammar_free(jsgf);\n        yylex_destroy(yyscanner);\n        return NULL;\n    }\n    if (in)\n        fclose(in);\n    yylex_destroy(yyscanner);\n\n    return jsgf;\n}\n\njsgf_t *\njsgf_parse_string(const char *string, jsgf_t * parent)\n{\n    yyscan_t yyscanner;\n    jsgf_t *jsgf;\n    int yyrv;\n    YY_BUFFER_STATE buf;\n\n    yylex_init(&yyscanner);\n    buf = yy_scan_string(string, yyscanner);\n\n    jsgf = jsgf_grammar_new(parent);\n    if (!parent)\n        jsgf_set_search_path(jsgf, NULL);\n\n    yyrv = yyparse(yyscanner, jsgf);\n    if (yyrv != 0) {\n        E_ERROR(\"Failed to parse JSGF grammar from input string\\n\");\n        jsgf_grammar_free(jsgf);\n        yy_delete_buffer(buf, yyscanner);\n        yylex_destroy(yyscanner);\n        return NULL;\n    }\n    yy_delete_buffer(buf, yyscanner);\n    yylex_destroy(yyscanner);\n\n    return jsgf;\n}\n",null,null,null,null,"/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2015 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <string.h>\n\n#include <sphinxbase/err.h>\n#include <sphinxbase/pio.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/byteorder.h>\n\n#include \"ngram_model_internal.h\"\n#include \"ngrams_raw.h\"\n\nint\nngram_ord_comparator(const void *a_raw, const void *b_raw)\n{\n    ngram_raw_t *a = (ngram_raw_t *) a_raw;\n    ngram_raw_t *b = (ngram_raw_t *) b_raw;\n    int a_w_ptr = 0;\n    int b_w_ptr = 0;\n    while (a_w_ptr < a->order && b_w_ptr < b->order) {\n        if (a->words[a_w_ptr] == b->words[b_w_ptr]) {\n            a_w_ptr++;\n            b_w_ptr++;\n            continue;\n        }\n        if (a->words[a_w_ptr] < b->words[b_w_ptr])\n            return -1;\n        else\n            return 1;\n    }\n    return a->order - b->order;\n}\n\nstatic int\nread_ngram_instance(lineiter_t ** li, hash_table_t * wid,\n                    logmath_t * lmath, int order, int order_max,\n                    ngram_raw_t * raw_ngram)\n{\n    int n;\n    int words_expected;\n    int i;\n    char *wptr[NGRAM_MAX_ORDER + 1];\n    uint32 *word_out;\n\n    if (*li) \n        *li = lineiter_next(*li);\n    if (*li == NULL) {\n        E_ERROR(\"Unexpected end of ARPA file. Failed to read %d-gram\\n\",\n                order);\n        return -1;\n    }\n    words_expected = order + 1;\n    if ((n =\n         str2words((*li)->buf, wptr,\n                   NGRAM_MAX_ORDER + 1)) < words_expected) {\n        E_ERROR(\"Format error; %d-gram ignored: %s\\n\", order, (*li)->buf);\n        return -1;\n    }\n\n    raw_ngram->order = order;\n\n    if (order == order_max) {\n        raw_ngram->prob = atof_c(wptr[0]);\n        if (raw_ngram->prob > 0) {\n            E_WARN(\"%d-gram '%s' has positive probability\\n\", order, wptr[1]);\n            raw_ngram->prob = 0.0f;\n        }\n        raw_ngram->prob =\n            logmath_log10_to_log_float(lmath, raw_ngram->prob);\n    }\n    else {\n        float weight, backoff;\n\n        weight = atof_c(wptr[0]);\n        if (weight > 0) {\n            E_WARN(\"%d-gram '%s' has positive probability\\n\", order, wptr[1]);\n            raw_ngram->prob = 0.0f;\n        }\n        else {\n            raw_ngram->prob =\n                logmath_log10_to_log_float(lmath, weight);\n        }\n\n        if (n == order + 1) {\n            raw_ngram->backoff = 0.0f;\n        }\n        else {\n            backoff = atof_c(wptr[order + 1]);\n            raw_ngram->backoff =\n                logmath_log10_to_log_float(lmath, backoff);\n        }\n    }\n    raw_ngram->words =\n        (uint32 *) ckd_calloc(order, sizeof(*raw_ngram->words));\n    for (word_out = raw_ngram->words + order - 1, i = 1;\n         word_out >= raw_ngram->words; --word_out, i++) {\n        hash_table_lookup_int32(wid, wptr[i], (int32 *) word_out);\n    }\n    return 0;\n}\n\nstatic int\nngrams_raw_read_order(ngram_raw_t ** raw_ngrams, lineiter_t ** li,\n                      hash_table_t * wid, logmath_t * lmath, uint32 count,\n                      int order, int order_max)\n{\n    char expected_header[20];\n    uint32 i;\n\n    sprintf(expected_header, \"\\\\%d-grams:\", order);\n    while (*li && strcmp((*li)->buf, expected_header) != 0) {\n\t*li = lineiter_next(*li);\n    }\n    \n    if (*li == NULL) {\n\tE_ERROR(\"Failed to find '%s', language model file truncated\\n\", expected_header);\n\treturn -1;\n    }\n    \n    *raw_ngrams = (ngram_raw_t *) ckd_calloc(count, sizeof(ngram_raw_t));\n    for (i = 0; i < count; i++) {\n        if (read_ngram_instance(li, wid, lmath, order, order_max,\n                            &((*raw_ngrams)[i])) < 0)\n            break;\n    }\n\n    qsort(*raw_ngrams, count, sizeof(ngram_raw_t), &ngram_ord_comparator);\n    return 0;\n}\n\nngram_raw_t **\nngrams_raw_read_arpa(lineiter_t ** li, logmath_t * lmath, uint32 * counts,\n                     int order, hash_table_t * wid)\n{\n    ngram_raw_t **raw_ngrams;\n    int order_it;\n\n    raw_ngrams =\n        (ngram_raw_t **) ckd_calloc(order - 1, sizeof(*raw_ngrams));\n\n    for (order_it = 2; order_it <= order; order_it++) {\n        if (ngrams_raw_read_order(&raw_ngrams[order_it - 2], li, wid, lmath,\n                              counts[order_it - 1], order_it, order) < 0)\n        break;\n    }\n\n    /* Check if we found ARPA end-mark */\n    if (*li == NULL) {\n        E_ERROR(\"ARPA file ends without end-mark\\n\");\n\tngrams_raw_free(raw_ngrams, counts, order);\n        return NULL;\n    } else {\n        *li = lineiter_next(*li);\n\tif (strcmp((*li)->buf, \"\\\\end\\\\\") != 0) {\n    \t    E_WARN\n        \t(\"Finished reading ARPA file. Expecting end mark but found '%s'\\n\",\n        \t (*li)->buf);\n        }\n    }\n\n    return raw_ngrams;\n}\n\nstatic void\nread_dmp_weight_array(FILE * fp, logmath_t * lmath, uint8 do_swap,\n                      int32 counts, ngram_raw_t * raw_ngrams,\n                      int weight_idx)\n{\n    int32 i, k;\n    dmp_weight_t *tmp_weight_arr;\n\n    fread(&k, sizeof(k), 1, fp);\n    if (do_swap)\n        SWAP_INT32(&k);\n    tmp_weight_arr =\n        (dmp_weight_t *) ckd_calloc(k, sizeof(*tmp_weight_arr));\n    fread(tmp_weight_arr, sizeof(*tmp_weight_arr), k, fp);\n    for (i = 0; i < k; i++) {\n        if (do_swap)\n            SWAP_INT32(&tmp_weight_arr[i].l);\n        /* Convert values to log. */\n        tmp_weight_arr[i].f =\n            logmath_log10_to_log_float(lmath, tmp_weight_arr[i].f);\n    }\n    /* replace indexes with real probs in raw bigrams */\n    for (i = 0; i < counts; i++) {\n\tif (weight_idx == 0) {\n\t    raw_ngrams[i].prob =\n                tmp_weight_arr[(int) raw_ngrams[i].prob].f;\n        } else {\n\t    raw_ngrams[i].backoff =\n                tmp_weight_arr[(int) raw_ngrams[i].backoff].f;\n        }\n    }\n    ckd_free(tmp_weight_arr);\n}\n\n#define BIGRAM_SEGMENT_SIZE 9\n\nngram_raw_t **\nngrams_raw_read_dmp(FILE * fp, logmath_t * lmath, uint32 * counts,\n                    int order, uint32 * unigram_next, uint8 do_swap)\n{\n    uint32 j, ngram_idx;\n    uint16 *bigrams_next;\n    ngram_raw_t **raw_ngrams =\n        (ngram_raw_t **) ckd_calloc(order - 1, sizeof(*raw_ngrams));\n\n    /* read bigrams */\n    raw_ngrams[0] =\n        (ngram_raw_t *) ckd_calloc((size_t) (counts[1] + 1),\n                                   sizeof(*raw_ngrams[0]));\n    bigrams_next =\n        (uint16 *) ckd_calloc((size_t) (counts[1] + 1),\n                              sizeof(*bigrams_next));\n    ngram_idx = 1;\n    for (j = 0; j <= (int32) counts[1]; j++) {\n        uint16 wid, prob_idx, bo_idx;\n        ngram_raw_t *raw_ngram = &raw_ngrams[0][j];\n\n        fread(&wid, sizeof(wid), 1, fp);\n        if (do_swap)\n            SWAP_INT16(&wid);\n        raw_ngram->order = 2;\n        while (ngram_idx < counts[0] && j == unigram_next[ngram_idx]) {\n            ngram_idx++;\n        }\n\t\n\tif (j != counts[1]) {\n            raw_ngram->words =\n    \t\t(uint32 *) ckd_calloc(2, sizeof(*raw_ngram->words));\n    \t    raw_ngram->words[0] = (uint32) wid;\n\t    raw_ngram->words[1] = (uint32) ngram_idx - 1;\n\t}\n\n        fread(&prob_idx, sizeof(prob_idx), 1, fp);\n        fread(&bo_idx, sizeof(bo_idx), 1, fp);\n        fread(&bigrams_next[j], sizeof(bigrams_next[j]), 1, fp);\n        if (do_swap) {\n            SWAP_INT16(&prob_idx);\n            SWAP_INT16(&bo_idx);\n            SWAP_INT16(&bigrams_next[j]);\n        }\n\n\tif (j != counts[1]) {\n            raw_ngram->prob = prob_idx + 0.5f; /* keep index in float. ugly but avoiding using extra memory */\n\t    raw_ngram->backoff = bo_idx + 0.5f;\n\t}\n    }\n\n    if (ngram_idx < counts[0]) {\n        E_ERROR(\"Corrupted model, not enough unigrams %d %d\\n\", ngram_idx, counts[0]);\n        ckd_free(bigrams_next);\n        ngrams_raw_free(raw_ngrams, counts, order);\n        return NULL;\n    }\n\n    /* read trigrams */\n    if (order > 2) {\n        raw_ngrams[1] =\n            (ngram_raw_t *) ckd_calloc((size_t) counts[2],\n                                       sizeof(*raw_ngrams[1]));\n        for (j = 0; j < (int32) counts[2]; j++) {\n            uint16 wid, prob_idx;\n            ngram_raw_t *raw_ngram = &raw_ngrams[1][j];\n\n            fread(&wid, sizeof(wid), 1, fp);\n            fread(&prob_idx, sizeof(prob_idx), 1, fp);\n            if (do_swap) {\n                SWAP_INT16(&wid);\n                SWAP_INT16(&prob_idx);\n            }\n            \n    \t    raw_ngram->order = 3;\n            raw_ngram->words =\n                (uint32 *) ckd_calloc(3, sizeof(*raw_ngram->words));\n            raw_ngram->words[0] = (uint32) wid;\n            raw_ngram->prob = prob_idx + 0.5f; /* keep index in float. ugly but avoiding using extra memory */\n        }\n    }\n\n    /* read prob2 */\n    read_dmp_weight_array(fp, lmath, do_swap, (int32) counts[1],\n                          raw_ngrams[0], 0);\n    /* read bo2 */\n    if (order > 2) {\n        int32 k;\n        int32 *tseg_base;\n        read_dmp_weight_array(fp, lmath, do_swap, (int32) counts[1],\n                              raw_ngrams[0], 1);\n        /* read prob3 */\n        read_dmp_weight_array(fp, lmath, do_swap, (int32) counts[2],\n                              raw_ngrams[1], 0);\n        /* Read tseg_base size and tseg_base to fill trigram's first words */\n        fread(&k, sizeof(k), 1, fp);\n        if (do_swap)\n            SWAP_INT32(&k);\n        tseg_base = (int32 *) ckd_calloc(k, sizeof(int32));\n        fread(tseg_base, sizeof(int32), k, fp);\n        if (do_swap) {\n            for (j = 0; j < (uint32) k; j++) {\n                SWAP_INT32(&tseg_base[j]);\n            }\n        }\n        ngram_idx = 0;\n        for (j = 1; j <= counts[1]; j++) {\n            uint32 next_ngram_idx =\n                (uint32) (tseg_base[j >> BIGRAM_SEGMENT_SIZE] +\n                          bigrams_next[j]);\n            while (ngram_idx < next_ngram_idx) {\n                raw_ngrams[1][ngram_idx].words[1] =\n                    raw_ngrams[0][j - 1].words[0];\n                raw_ngrams[1][ngram_idx].words[2] =\n                    raw_ngrams[0][j - 1].words[1];\n                ngram_idx++;\n            }\n        }\n        ckd_free(tseg_base);\n        \n        if (ngram_idx < counts[2]) {\n      \t    E_ERROR(\"Corrupted model, some trigrams have no corresponding bigram\\n\");\n    \t    ckd_free(bigrams_next);\n    \t    ngrams_raw_free(raw_ngrams, counts, order);\n    \t    return NULL;\n        }\n    }\n    ckd_free(bigrams_next);\n\n    /* sort raw ngrams for reverse trie */\n    qsort(raw_ngrams[0], (size_t) counts[1], sizeof(*raw_ngrams[0]),\n          &ngram_ord_comparator);\n    if (order > 2) {\n        qsort(raw_ngrams[1], (size_t) counts[2], sizeof(*raw_ngrams[1]),\n              &ngram_ord_comparator);\n    }\n    return raw_ngrams;\n}\n\nvoid\nngrams_raw_free(ngram_raw_t ** raw_ngrams, uint32 * counts, int order)\n{\n    uint32 num;\n    int order_it;\n\n    for (order_it = 0; order_it < order - 1; order_it++) {\n        for (num = 0; num < counts[order_it + 1]; num++) {\n            ckd_free(raw_ngrams[order_it][num].words);\n        }\n        ckd_free(raw_ngrams[order_it]);\n    }\n    ckd_free(raw_ngrams);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2015 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n\n#include <sphinxbase/prim_type.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/err.h>\n#include <sphinxbase/priority_queue.h>\n\n#include \"lm_trie.h\"\n#include \"lm_trie_quant.h\"\n\nstatic void lm_trie_alloc_ngram(lm_trie_t * trie, uint32 * counts, int order);\n\nstatic uint32\nbase_size(uint32 entries, uint32 max_vocab, uint8 remaining_bits)\n{\n    uint8 total_bits = bitarr_required_bits(max_vocab) + remaining_bits;\n    /* Extra entry for next pointer at the end.  \n     * +7 then / 8 to round up bits and convert to bytes\n     * +sizeof(uint64) so that ReadInt57 etc don't go segfault.  \n     * Note that this waste is O(order), not O(number of ngrams).*/\n    return ((1 + entries) * total_bits + 7) / 8 + sizeof(uint64);\n}\n\nuint32\nmiddle_size(uint8 quant_bits, uint32 entries, uint32 max_vocab,\n            uint32 max_ptr)\n{\n    return base_size(entries, max_vocab,\n                     quant_bits + bitarr_required_bits(max_ptr));\n}\n\nuint32\nlongest_size(uint8 quant_bits, uint32 entries, uint32 max_vocab)\n{\n    return base_size(entries, max_vocab, quant_bits);\n}\n\nstatic void\nbase_init(base_t * base, void *base_mem, uint32 max_vocab,\n          uint8 remaining_bits)\n{\n    base->word_bits = bitarr_required_bits(max_vocab);\n    base->word_mask = (1U << base->word_bits) - 1U;\n    if (base->word_bits > 25)\n        E_ERROR\n            (\"Sorry, word indices more than %d are not implemented.  Edit util/bit_packing.hh and fix the bit packing functions\\n\",\n             (1U << 25));\n    base->total_bits = base->word_bits + remaining_bits;\n\n    base->base = (uint8 *) base_mem;\n    base->insert_index = 0;\n    base->max_vocab = max_vocab;\n}\n\nvoid\nmiddle_init(middle_t * middle, void *base_mem, uint8 quant_bits,\n            uint32 entries, uint32 max_vocab, uint32 max_next,\n            void *next_source)\n{\n    middle->quant_bits = quant_bits;\n    bitarr_mask_from_max(&middle->next_mask, max_next);\n    middle->next_source = next_source;\n    if (entries + 1 >= (1U << 25) || (max_next >= (1U << 25)))\n        E_ERROR\n            (\"Sorry, this does not support more than %d n-grams of a particular order.  Edit util/bit_packing.hh and fix the bit packing functions\\n\",\n             (1U << 25));\n    base_init(&middle->base, base_mem, max_vocab,\n              quant_bits + middle->next_mask.bits);\n}\n\nvoid\nlongest_init(longest_t * longest, void *base_mem, uint8 quant_bits,\n             uint32 max_vocab)\n{\n    base_init(&longest->base, base_mem, max_vocab, quant_bits);\n}\n\nstatic bitarr_address_t\nmiddle_insert(middle_t * middle, uint32 word, int order, int max_order)\n{\n    uint32 at_pointer;\n    uint32 next;\n    bitarr_address_t address;\n    assert(word <= middle->base.word_mask);\n    address.base = middle->base.base;\n    address.offset = middle->base.insert_index * middle->base.total_bits;\n    bitarr_write_int25(address, middle->base.word_bits, word);\n    address.offset += middle->base.word_bits;\n    at_pointer = address.offset;\n    address.offset += middle->quant_bits;\n    if (order == max_order - 1) {\n        next = ((longest_t *) middle->next_source)->base.insert_index;\n    }\n    else {\n        next = ((middle_t *) middle->next_source)->base.insert_index;\n    }\n\n    bitarr_write_int25(address, middle->next_mask.bits, next);\n    middle->base.insert_index++;\n    address.offset = at_pointer;\n    return address;\n}\n\nstatic bitarr_address_t\nlongest_insert(longest_t * longest, uint32 index)\n{\n    bitarr_address_t address;\n    assert(index <= longest->base.word_mask);\n    address.base = longest->base.base;\n    address.offset = longest->base.insert_index * longest->base.total_bits;\n    bitarr_write_int25(address, longest->base.word_bits, index);\n    address.offset += longest->base.word_bits;\n    longest->base.insert_index++;\n    return address;\n}\n\nstatic void\nmiddle_finish_loading(middle_t * middle, uint32 next_end)\n{\n    bitarr_address_t address;\n    address.base = middle->base.base;\n    address.offset =\n        (middle->base.insert_index + 1) * middle->base.total_bits -\n        middle->next_mask.bits;\n    bitarr_write_int25(address, middle->next_mask.bits, next_end);\n}\n\nstatic uint32\nunigram_next(lm_trie_t * trie, int order)\n{\n    return order ==\n        2 ? trie->longest->base.insert_index : trie->middle_begin->base.\n        insert_index;\n}\n\nvoid\nlm_trie_fix_counts(ngram_raw_t ** raw_ngrams, uint32 * counts,\n                   uint32 * fixed_counts, int order)\n{\n    priority_queue_t *ngrams =\n        priority_queue_create(order - 1, &ngram_ord_comparator);\n    uint32 raw_ngram_ptrs[NGRAM_MAX_ORDER - 1];\n    uint32 words[NGRAM_MAX_ORDER];\n    int i;\n\n    memset(words, -1, sizeof(words));\n    memcpy(fixed_counts, counts, order * sizeof(*fixed_counts));\n    for (i = 2; i <= order; i++) {\n        ngram_raw_t *tmp_ngram;\n        \n        if (counts[i - 1] <= 0)\n            continue;\n\n        raw_ngram_ptrs[i - 2] = 0;\n\n        tmp_ngram =\n            (ngram_raw_t *) ckd_calloc(1, sizeof(*tmp_ngram));\n        *tmp_ngram = raw_ngrams[i - 2][0];\n        tmp_ngram->order = i;\n        priority_queue_add(ngrams, tmp_ngram);\n    }\n\n    for (;;) {\n        int32 to_increment = TRUE;\n        ngram_raw_t *top;\n        if (priority_queue_size(ngrams) == 0) {\n            break;\n        }\n        top = (ngram_raw_t *) priority_queue_poll(ngrams);\n        if (top->order == 2) {\n            memcpy(words, top->words, 2 * sizeof(*words));\n        }\n        else {\n            for (i = 0; i < top->order - 1; i++) {\n                if (words[i] != top->words[i]) {\n                    int num;\n                    num = (i == 0) ? 1 : i;\n                    memcpy(words, top->words,\n                           (num + 1) * sizeof(*words));\n                    fixed_counts[num]++;\n                    to_increment = FALSE;\n                    break;\n                }\n            }\n            words[top->order - 1] = top->words[top->order - 1];\n        }\n        if (to_increment) {\n            raw_ngram_ptrs[top->order - 2]++;\n        }\n        if (raw_ngram_ptrs[top->order - 2] < counts[top->order - 1]) {\n            *top = raw_ngrams[top->order - 2][raw_ngram_ptrs[top->order - 2]];\n            priority_queue_add(ngrams, top);\n        }\n        else {\n            ckd_free(top);\n        }\n    }\n\n    assert(priority_queue_size(ngrams) == 0);\n    priority_queue_free(ngrams, NULL);\n}\n\n\nstatic void\nrecursive_insert(lm_trie_t * trie, ngram_raw_t ** raw_ngrams,\n                 uint32 * counts, int order)\n{\n    uint32 unigram_idx = 0;\n    uint32 *words;\n    float *probs;\n    const uint32 unigram_count = (uint32) counts[0];\n    priority_queue_t *ngrams =\n        priority_queue_create(order, &ngram_ord_comparator);\n    ngram_raw_t *ngram;\n    uint32 *raw_ngrams_ptr;\n    int i;\n\n    words = (uint32 *) ckd_calloc(order, sizeof(*words));\n    probs = (float *) ckd_calloc(order - 1, sizeof(*probs));\n    ngram = (ngram_raw_t *) ckd_calloc(1, sizeof(*ngram));\n    ngram->order = 1;\n    ngram->words = &unigram_idx;\n    priority_queue_add(ngrams, ngram);\n    raw_ngrams_ptr =\n        (uint32 *) ckd_calloc(order - 1, sizeof(*raw_ngrams_ptr));\n    for (i = 2; i <= order; ++i) {\n        ngram_raw_t *tmp_ngram;\n        \n        if (counts[i - 1] <= 0)\n            continue;\n\n        raw_ngrams_ptr[i - 2] = 0;\n        tmp_ngram =\n            (ngram_raw_t *) ckd_calloc(1, sizeof(*tmp_ngram));\n        *tmp_ngram = raw_ngrams[i - 2][0];\n        tmp_ngram->order = i;\n\n        priority_queue_add(ngrams, tmp_ngram);\n    }\n\n    for (;;) {\n        ngram_raw_t *top =\n            (ngram_raw_t *) priority_queue_poll(ngrams);\n\n        if (top->order == 1) {\n            trie->unigrams[unigram_idx].next = unigram_next(trie, order);\n            words[0] = unigram_idx;\n            probs[0] = trie->unigrams[unigram_idx].prob;\n            if (++unigram_idx == unigram_count + 1) {\n                ckd_free(top);\n                break;\n            }\n            priority_queue_add(ngrams, top);\n        }\n        else {\n            for (i = 0; i < top->order - 1; i++) {\n                if (words[i] != top->words[i]) {\n                    /* need to insert dummy suffixes to make ngram of higher order reachable */\n                    int j;\n                    assert(i > 0);  /* unigrams are not pruned without removing ngrams that contains them */\n                    for (j = i; j < top->order - 1; j++) {\n                        middle_t *middle = &trie->middle_begin[j - 1];\n                        bitarr_address_t address =\n                            middle_insert(middle, top->words[j],\n                                          j + 1, order);\n                        /* calculate prob for blank */\n                        float calc_prob =\n                            probs[j - 1] +\n                            trie->unigrams[top->words[j]].bo;\n                        probs[j] = calc_prob;\n                        lm_trie_quant_mwrite(trie->quant, address, j - 1,\n                                             calc_prob, 0.0f);\n                    }\n                }\n            }\n            memcpy(words, top->words,\n                   top->order * sizeof(*words));\n            if (top->order == order) {\n                bitarr_address_t address =\n                    longest_insert(trie->longest,\n                                   top->words[top->order - 1]);\n                lm_trie_quant_lwrite(trie->quant, address, top->prob);\n            }\n            else {\n                middle_t *middle = &trie->middle_begin[top->order - 2];\n                bitarr_address_t address =\n                    middle_insert(middle,\n                                  top->words[top->order - 1],\n                                  top->order, order);\n                /* write prob and backoff */\n                probs[top->order - 1] = top->prob;\n                lm_trie_quant_mwrite(trie->quant, address, top->order - 2,\n                                     top->prob, top->backoff);\n            }\n            raw_ngrams_ptr[top->order - 2]++;\n            if (raw_ngrams_ptr[top->order - 2] < counts[top->order - 1]) {\n        \t*top = raw_ngrams[top->order -\n                               2][raw_ngrams_ptr[top->order - 2]];\n\n                priority_queue_add(ngrams, top);\n            }\n            else {\n                ckd_free(top);\n            }\n        }\n    }\n    assert(priority_queue_size(ngrams) == 0);\n    priority_queue_free(ngrams, NULL);\n    ckd_free(raw_ngrams_ptr);\n    ckd_free(words);\n    ckd_free(probs);\n}\n\nstatic lm_trie_t *\nlm_trie_init(uint32 unigram_count)\n{\n    lm_trie_t *trie;\n\n    trie = (lm_trie_t *) ckd_calloc(1, sizeof(*trie));\n    memset(trie->hist_cache, -1, sizeof(trie->hist_cache)); /* prepare request history */\n    memset(trie->backoff_cache, 0, sizeof(trie->backoff_cache));\n    trie->unigrams =\n        (unigram_t *) ckd_calloc((unigram_count + 1),\n                                 sizeof(*trie->unigrams));\n    trie->ngram_mem = NULL;\n    return trie;\n}\n\nlm_trie_t *\nlm_trie_create(uint32 unigram_count, int order)\n{\n    lm_trie_t *trie = lm_trie_init(unigram_count);\n    trie->quant =\n        (order > 1) ? lm_trie_quant_create(order) : 0;\n    return trie;\n}\n\nlm_trie_t *\nlm_trie_read_bin(uint32 * counts, int order, FILE * fp)\n{\n    lm_trie_t *trie = lm_trie_init(counts[0]);\n    trie->quant = (order > 1) ? lm_trie_quant_read_bin(fp, order) : NULL;\n    fread(trie->unigrams, sizeof(*trie->unigrams), (counts[0] + 1), fp);\n    if (order > 1) {\n        lm_trie_alloc_ngram(trie, counts, order);\n        fread(trie->ngram_mem, 1, trie->ngram_mem_size, fp);\n    }\n    return trie;\n}\n\nvoid\nlm_trie_write_bin(lm_trie_t * trie, uint32 unigram_count, FILE * fp)\n{\n\n    if (trie->quant)\n        lm_trie_quant_write_bin(trie->quant, fp);\n    fwrite(trie->unigrams, sizeof(*trie->unigrams), (unigram_count + 1),\n           fp);\n    if (trie->ngram_mem)\n        fwrite(trie->ngram_mem, 1, trie->ngram_mem_size, fp);\n}\n\nvoid\nlm_trie_free(lm_trie_t * trie)\n{\n    if (trie->ngram_mem) {\n        ckd_free(trie->ngram_mem);\n        ckd_free(trie->middle_begin);\n        ckd_free(trie->longest);\n    }\n    if (trie->quant)\n        lm_trie_quant_free(trie->quant);\n    ckd_free(trie->unigrams);\n    ckd_free(trie);\n}\n\nstatic void\nlm_trie_alloc_ngram(lm_trie_t * trie, uint32 * counts, int order)\n{\n    int i;\n    uint8 *mem_ptr;\n    uint8 **middle_starts;\n\n    trie->ngram_mem_size = 0;\n    for (i = 1; i < order - 1; i++) {\n        trie->ngram_mem_size +=\n            middle_size(lm_trie_quant_msize(trie->quant), counts[i],\n                        counts[0], counts[i + 1]);\n    }\n    trie->ngram_mem_size +=\n        longest_size(lm_trie_quant_lsize(trie->quant), counts[order - 1],\n                     counts[0]);\n    trie->ngram_mem =\n        (uint8 *) ckd_calloc(trie->ngram_mem_size,\n                             sizeof(*trie->ngram_mem));\n    mem_ptr = trie->ngram_mem;\n    trie->middle_begin =\n        (middle_t *) ckd_calloc(order - 2, sizeof(*trie->middle_begin));\n    trie->middle_end = trie->middle_begin + (order - 2);\n    middle_starts =\n        (uint8 **) ckd_calloc(order - 2, sizeof(*middle_starts));\n    for (i = 2; i < order; i++) {\n        middle_starts[i - 2] = mem_ptr;\n        mem_ptr +=\n            middle_size(lm_trie_quant_msize(trie->quant), counts[i - 1],\n                        counts[0], counts[i]);\n    }\n    trie->longest = (longest_t *) ckd_calloc(1, sizeof(*trie->longest));\n    /* Crazy backwards thing so we initialize using pointers to ones that have already been initialized */\n    for (i = order - 1; i >= 2; --i) {\n        middle_t *middle_ptr = &trie->middle_begin[i - 2];\n        middle_init(middle_ptr, middle_starts[i - 2],\n                    lm_trie_quant_msize(trie->quant), counts[i - 1],\n                    counts[0], counts[i],\n                    (i ==\n                     order -\n                     1) ? (void *) trie->longest : (void *) &trie->\n                    middle_begin[i - 1]);\n    }\n    ckd_free(middle_starts);\n    longest_init(trie->longest, mem_ptr, lm_trie_quant_lsize(trie->quant),\n                 counts[0]);\n}\n\nvoid\nlm_trie_build(lm_trie_t * trie, ngram_raw_t ** raw_ngrams, uint32 * counts, uint32 *out_counts,\n              int order)\n{\n    int i;\n\n    lm_trie_fix_counts(raw_ngrams, counts, out_counts, order);\n    lm_trie_alloc_ngram(trie, out_counts, order);\n    \n    if (order > 1)\n        E_INFO(\"Training quantizer\\n\");\n    for (i = 2; i < order; i++) {\n        lm_trie_quant_train(trie->quant, i, counts[i - 1],\n                            raw_ngrams[i - 2]);\n    }\n    lm_trie_quant_train_prob(trie->quant, order, counts[order - 1],\n                             raw_ngrams[order - 2]);\n\n    E_INFO(\"Building LM trie\\n\");\n    recursive_insert(trie, raw_ngrams, counts, order);\n    /* Set ending offsets so the last entry will be sized properly */\n    /* Last entry for unigrams was already set. */\n    if (trie->middle_begin != trie->middle_end) {\n        middle_t *middle_ptr;\n        for (middle_ptr = trie->middle_begin;\n             middle_ptr != trie->middle_end - 1; ++middle_ptr) {\n            middle_t *next_middle_ptr = middle_ptr + 1;\n            middle_finish_loading(middle_ptr,\n                                  next_middle_ptr->base.insert_index);\n        }\n        middle_ptr = trie->middle_end - 1;\n        middle_finish_loading(middle_ptr,\n                              trie->longest->base.insert_index);\n    }\n}\n\nunigram_t *\nunigram_find(unigram_t * u, uint32 word, node_range_t * next)\n{\n    unigram_t *ptr = &u[word];\n    next->begin = ptr->next;\n    next->end = (ptr + 1)->next;\n    return ptr;\n}\n\nstatic size_t\ncalc_pivot(uint32 off, uint32 range, uint32 width)\n{\n    return (size_t) ((off * width) / (range + 1));\n}\n\nstatic uint8\nuniform_find(void *base, uint8 total_bits, uint8 key_bits, uint32 key_mask,\n             uint32 before_it, uint32 before_v,\n             uint32 after_it, uint32 after_v, uint32 key, uint32 * out)\n{\n    bitarr_address_t address;\n    address.base = base;\n\n    /* If we look for unigram added later */\n    if (key > after_v)\n\treturn FALSE;\n\n    while (after_it - before_it > 1) {\n        uint32 mid;\n        uint32 pivot =\n            before_it + (1 +\n                         calc_pivot(key - before_v, after_v - before_v,\n                                    after_it - before_it - 1));\n        /* access by pivot */\n        address.offset = pivot * (uint32) total_bits;\n        mid = bitarr_read_int25(address, key_bits, key_mask);\n        if (mid < key) {\n            before_it = pivot;\n            before_v = mid;\n        }\n        else if (mid > key) {\n            after_it = pivot;\n            after_v = mid;\n        }\n        else {\n            *out = pivot;\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nstatic bitarr_address_t\nmiddle_find(middle_t * middle, uint32 word, node_range_t * range)\n{\n    uint32 at_pointer;\n    bitarr_address_t address;\n\n    /* finding BitPacked with uniform find */\n    if (!uniform_find\n        ((void *) middle->base.base, middle->base.total_bits,\n         middle->base.word_bits, middle->base.word_mask, range->begin - 1,\n         0, range->end, middle->base.max_vocab, word, &at_pointer)) {\n        address.base = NULL;\n        address.offset = 0;\n        return address;\n    }\n\n    address.base = middle->base.base;\n    at_pointer *= middle->base.total_bits;\n    at_pointer += middle->base.word_bits;\n    address.offset = at_pointer + middle->quant_bits;\n    range->begin =\n        bitarr_read_int25(address, middle->next_mask.bits,\n                          middle->next_mask.mask);\n    address.offset += middle->base.total_bits;\n    range->end =\n        bitarr_read_int25(address, middle->next_mask.bits,\n                          middle->next_mask.mask);\n    address.offset = at_pointer;\n\n    return address;\n}\n\nstatic bitarr_address_t\nlongest_find(longest_t * longest, uint32 word, node_range_t * range)\n{\n    uint32 at_pointer;\n    bitarr_address_t address;\n\n    /* finding BitPacked with uniform find */\n    if (!uniform_find\n        ((void *) longest->base.base, longest->base.total_bits,\n         longest->base.word_bits, longest->base.word_mask,\n         range->begin - 1, 0, range->end, longest->base.max_vocab, word,\n         &at_pointer)) {\n        address.base = NULL;\n        address.offset = 0;\n        return address;\n    }\n    address.base = longest->base.base;\n    address.offset =\n        at_pointer * longest->base.total_bits + longest->base.word_bits;\n    return address;\n}\n\nstatic float\nget_available_prob(lm_trie_t * trie, int32 wid, int32 * hist,\n                   int max_order, int32 n_hist, int32 * n_used)\n{\n    float prob;\n    node_range_t node;\n    bitarr_address_t address;\n    int order_minus_2;\n    uint8 independent_left;\n    int32 *hist_iter, *hist_end;\n\n    *n_used = 1;\n    prob = unigram_find(trie->unigrams, wid, &node)->prob;\n    if (n_hist == 0) {\n        return prob;\n    }\n\n    /* find ngrams of higher order if any */\n    order_minus_2 = 0;\n    independent_left = (node.begin == node.end);\n    hist_iter = hist;\n    hist_end = hist + n_hist;\n    for (;; order_minus_2++, hist_iter++) {\n        if (hist_iter == hist_end)\n            return prob;\n        if (independent_left)\n            return prob;\n        if (order_minus_2 == max_order - 2)\n            break;\n\n        address =\n            middle_find(&trie->middle_begin[order_minus_2], *hist_iter,\n                        &node);\n        independent_left = (address.base == NULL)\n            || (node.begin == node.end);\n\n        /* didn't find entry */\n        if (address.base == NULL)\n            return prob;\n        prob = lm_trie_quant_mpread(trie->quant, address, order_minus_2);\n        *n_used = order_minus_2 + 2;\n    }\n\n    address = longest_find(trie->longest, *hist_iter, &node);\n    if (address.base != NULL) {\n        prob = lm_trie_quant_lpread(trie->quant, address);\n        *n_used = max_order;\n    }\n    return prob;\n}\n\nstatic float\nget_available_backoff(lm_trie_t * trie, int32 start, int32 * hist,\n                      int32 n_hist)\n{\n    float backoff = 0.0f;\n    int order_minus_2;\n    int32 *hist_iter;\n    node_range_t node;\n    unigram_t *first_hist = unigram_find(trie->unigrams, hist[0], &node);\n    if (start <= 1) {\n        backoff += first_hist->bo;\n        start = 2;\n    }\n    order_minus_2 = start - 2;\n    for (hist_iter = hist + start - 1; hist_iter < hist + n_hist;\n         hist_iter++, order_minus_2++) {\n        bitarr_address_t address =\n            middle_find(&trie->middle_begin[order_minus_2], *hist_iter,\n                        &node);\n        if (address.base == NULL)\n            break;\n        backoff +=\n            lm_trie_quant_mboread(trie->quant, address, order_minus_2);\n    }\n    return backoff;\n}\n\nstatic float\nlm_trie_nobo_score(lm_trie_t * trie, int32 wid, int32 * hist,\n                   int max_order, int32 n_hist, int32 * n_used)\n{\n    float prob =\n        get_available_prob(trie, wid, hist, max_order, n_hist, n_used);\n    if (n_hist < *n_used)\n        return prob;\n    return prob + get_available_backoff(trie, *n_used, hist, n_hist);\n}\n\nstatic float\nlm_trie_hist_score(lm_trie_t * trie, int32 wid, int32 * hist, int32 n_hist,\n                   int32 * n_used)\n{\n    float prob;\n    int i, j;\n    node_range_t node;\n    bitarr_address_t address;\n\n    *n_used = 1;\n    prob = unigram_find(trie->unigrams, wid, &node)->prob;\n    if (n_hist == 0)\n        return prob;\n    for (i = 0; i < n_hist - 1; i++) {\n        address = middle_find(&trie->middle_begin[i], hist[i], &node);\n        if (address.base == NULL) {\n            for (j = i; j < n_hist; j++) {\n                prob += trie->backoff_cache[j];\n            }\n            return prob;\n        }\n        else {\n            (*n_used)++;\n            prob = lm_trie_quant_mpread(trie->quant, address, i);\n        }\n    }\n    address = longest_find(trie->longest, hist[n_hist - 1], &node);\n    if (address.base == NULL) {\n        return prob + trie->backoff_cache[n_hist - 1];\n    }\n    else {\n        (*n_used)++;\n        return lm_trie_quant_lpread(trie->quant, address);\n    }\n}\n\nstatic uint8\nhistory_matches(int32 * hist, int32 * prev_hist, int32 n_hist)\n{\n    int i;\n    for (i = 0; i < n_hist; i++) {\n        if (hist[i] != prev_hist[i]) {\n            return FALSE;\n        }\n    }\n    return TRUE;\n}\n\nstatic void\nupdate_backoff(lm_trie_t * trie, int32 * hist, int32 n_hist)\n{\n    int i;\n    node_range_t node;\n    bitarr_address_t address;\n\n    memset(trie->backoff_cache, 0, sizeof(trie->backoff_cache));\n    trie->backoff_cache[0] = unigram_find(trie->unigrams, hist[0], &node)->bo;\n    for (i = 1; i < n_hist; i++) {\n        address = middle_find(&trie->middle_begin[i - 1], hist[i], &node);\n        if (address.base == NULL) {\n            break;\n        }\n        trie->backoff_cache[i] =\n            lm_trie_quant_mboread(trie->quant, address, i - 1);\n    }\n    memcpy(trie->hist_cache, hist, n_hist * sizeof(*hist));\n}\n\nfloat\nlm_trie_score(lm_trie_t * trie, int order, int32 wid, int32 * hist,\n              int32 n_hist, int32 * n_used)\n{\n    if (n_hist < order - 1) {\n        return lm_trie_nobo_score(trie, wid, hist, order, n_hist, n_used);\n    }\n    else {\n        assert(n_hist == order - 1);\n        if (!history_matches(hist, (int32 *) trie->hist_cache, n_hist)) {\n            update_backoff(trie, hist, n_hist);\n        }\n        return lm_trie_hist_score(trie, wid, hist, n_hist, n_used);\n    }\n}\n\nvoid\nlm_trie_fill_raw_ngram(lm_trie_t * trie,\n    \t\t       ngram_raw_t * raw_ngrams, uint32 * raw_ngram_idx,\n            \t       uint32 * counts, node_range_t range, uint32 * hist,\n    \t               int n_hist, int order, int max_order)\n{\n    if (n_hist > 0 && range.begin == range.end) {\n        return;\n    }\n    if (n_hist == 0) {\n        uint32 i;\n        for (i = 0; i < counts[0]; i++) {\n            node_range_t node;\n            unigram_find(trie->unigrams, i, &node);\n            hist[0] = i;\n            lm_trie_fill_raw_ngram(trie, raw_ngrams, raw_ngram_idx, counts,\n                           node, hist, 1, order, max_order);\n        }\n    }\n    else if (n_hist < order - 1) {\n        uint32 ptr;\n        node_range_t node;\n        bitarr_address_t address;\n        uint32 new_word;\n        middle_t *middle = &trie->middle_begin[n_hist - 1];\n        for (ptr = range.begin; ptr < range.end; ptr++) {\n            address.base = middle->base.base;\n            address.offset = ptr * middle->base.total_bits;\n            new_word =\n                bitarr_read_int25(address, middle->base.word_bits,\n                                  middle->base.word_mask);\n            hist[n_hist] = new_word;\n            address.offset += middle->base.word_bits + middle->quant_bits;\n            node.begin =\n                bitarr_read_int25(address, middle->next_mask.bits,\n                                  middle->next_mask.mask);\n            address.offset =\n                (ptr + 1) * middle->base.total_bits +\n                middle->base.word_bits + middle->quant_bits;\n            node.end =\n                bitarr_read_int25(address, middle->next_mask.bits,\n                                  middle->next_mask.mask);\n            lm_trie_fill_raw_ngram(trie, raw_ngrams, raw_ngram_idx, counts,\n                           node, hist, n_hist + 1, order, max_order);\n        }\n    }\n    else {\n        bitarr_address_t address;\n        uint32 ptr;\n        float prob, backoff;\n        int i;\n        assert(n_hist == order - 1);\n        for (ptr = range.begin; ptr < range.end; ptr++) {\n            ngram_raw_t *raw_ngram = &raw_ngrams[*raw_ngram_idx];\n            if (order == max_order) {\n                longest_t *longest = trie->longest;\n                address.base = longest->base.base;\n                address.offset = ptr * longest->base.total_bits;\n                hist[n_hist] =\n                    bitarr_read_int25(address, longest->base.word_bits,\n                                      longest->base.word_mask);\n                address.offset += longest->base.word_bits;\n                prob = lm_trie_quant_lpread(trie->quant, address);\n            }\n            else {\n                middle_t *middle = &trie->middle_begin[n_hist - 1];\n                address.base = middle->base.base;\n                address.offset = ptr * middle->base.total_bits;\n                hist[n_hist] =\n                    bitarr_read_int25(address, middle->base.word_bits,\n                                      middle->base.word_mask);\n                address.offset += middle->base.word_bits;\n                prob =\n                    lm_trie_quant_mpread(trie->quant, address, n_hist - 1);\n                backoff =\n                    lm_trie_quant_mboread(trie->quant, address,\n                                          n_hist - 1);\n                raw_ngram->backoff = backoff;\n            }\n            raw_ngram->prob = prob;\n            raw_ngram->words =\n                (uint32 *) ckd_calloc(order, sizeof(*raw_ngram->words));\n            for (i = 0; i <= n_hist; i++) {\n                raw_ngram->words[i] = hist[n_hist - i];\n            }\n            (*raw_ngram_idx)++;\n        }\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2015 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <math.h>\n\n#include <sphinxbase/prim_type.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/err.h>\n\n#include \"ngram_model_internal.h\"\n#include \"lm_trie_quant.h\"\n\n#define FLOAT_INF (0x7f800000)\n\ntypedef struct bins_s {\n    float *begin;\n    const float *end;\n} bins_t;\n\nstruct lm_trie_quant_s {\n    bins_t tables[NGRAM_MAX_ORDER - 1][2];\n    bins_t *longest;\n    uint8 *mem;\n    size_t mem_size;\n    uint8 prob_bits;\n    uint8 bo_bits;\n    uint32 prob_mask;\n    uint32 bo_mask;\n};\n\nstatic void\nbins_create(bins_t * bins, uint8 bits, float *begin)\n{\n    bins->begin = begin;\n    bins->end = bins->begin + (1ULL << bits);\n}\n\nstatic float *\nlower_bound(float *first, const float *last, float val)\n{\n    int count, step;\n    float *it;\n\n    count = last - first;\n    while (count > 0) {\n        it = first;\n        step = count / 2;\n        it += step;\n        if (*it < val) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n\nstatic uint64\nbins_encode(bins_t * bins, float value)\n{\n    float *above = lower_bound(bins->begin, bins->end, value);\n    if (above == bins->begin)\n        return 0;\n    if (above == bins->end)\n        return bins->end - bins->begin - 1;\n    return above - bins->begin - (value - *(above - 1) < *above - value);\n}\n\nstatic float\nbins_decode(bins_t * bins, size_t off)\n{\n    return bins->begin[off];\n}\n\nstatic size_t\nquant_size(int order)\n{\n    int prob_bits = 16;\n    int bo_bits = 16;\n    size_t longest_table = (1U << prob_bits) * sizeof(float);\n    size_t middle_table = (1U << bo_bits) * sizeof(float) + longest_table;\n    /* unigrams are currently not quantized so no need for a table. */\n    return (order - 2) * middle_table + longest_table;\n}\n\nlm_trie_quant_t *\nlm_trie_quant_create(int order)\n{\n    float *start;\n    int i;\n    lm_trie_quant_t *quant =\n        (lm_trie_quant_t *) ckd_calloc(1, sizeof(*quant));\n    quant->mem_size = quant_size(order);\n    quant->mem =\n        (uint8 *) ckd_calloc(quant->mem_size, sizeof(*quant->mem));\n\n    quant->prob_bits = 16;\n    quant->bo_bits = 16;\n    quant->prob_mask = (1U << quant->prob_bits) - 1;\n    quant->bo_mask = (1U << quant->bo_bits) - 1;\n\n    start = (float *) (quant->mem);\n    for (i = 0; i < order - 2; i++) {\n        bins_create(&quant->tables[i][0], quant->prob_bits, start);\n        start += (1ULL << quant->prob_bits);\n        bins_create(&quant->tables[i][1], quant->bo_bits, start);\n        start += (1ULL << quant->bo_bits);\n    }\n    bins_create(&quant->tables[order - 2][0], quant->prob_bits, start);\n    quant->longest = &quant->tables[order - 2][0];\n    return quant;\n}\n\n\nlm_trie_quant_t *\nlm_trie_quant_read_bin(FILE * fp, int order)\n{\n    int dummy;\n    lm_trie_quant_t *quant;\n\n    fread(&dummy, sizeof(dummy), 1, fp);\n    quant = lm_trie_quant_create(order);\n    fread(quant->mem, sizeof(*quant->mem), quant->mem_size, fp);\n\n    return quant;\n}\n\nvoid\nlm_trie_quant_write_bin(lm_trie_quant_t * quant, FILE * fp)\n{\n    /* Before it was quantization type */\n    int dummy = 1;\n    fwrite(&dummy, sizeof(dummy), 1, fp);\n    fwrite(quant->mem, sizeof(*quant->mem), quant->mem_size, fp);\n}\n\nvoid\nlm_trie_quant_free(lm_trie_quant_t * quant)\n{\n    if (quant->mem)\n        ckd_free(quant->mem);\n    ckd_free(quant);\n}\n\nuint8\nlm_trie_quant_msize(lm_trie_quant_t * quant)\n{\n    return 32;\n}\n\nuint8\nlm_trie_quant_lsize(lm_trie_quant_t * quant)\n{\n    return 16;\n}\n\nstatic int\nweights_comparator(const void *a, const void *b)\n{\n    return (int) (*(float *) a - *(float *) b);\n}\n\nstatic void\nmake_bins(float *values, uint32 values_num, float *centers, uint32 bins)\n{\n    float *finish, *start;\n    uint32 i;\n\n    qsort(values, values_num, sizeof(*values), &weights_comparator);\n    start = values;\n    for (i = 0; i < bins; i++, centers++, start = finish) {\n        finish = values + (size_t) ((uint64) values_num * (i + 1) / bins);\n        if (finish == start) {\n            /* zero length bucket. */\n            *centers = i ? *(centers - 1) : -FLOAT_INF;\n        }\n        else {\n            float sum = 0.0f;\n            float *ptr;\n            for (ptr = start; ptr != finish; ptr++) {\n                sum += *ptr;\n            }\n            *centers = sum / (float) (finish - start);\n        }\n    }\n}\n\nvoid\nlm_trie_quant_train(lm_trie_quant_t * quant, int order, uint32 counts,\n                    ngram_raw_t * raw_ngrams)\n{\n    float *probs;\n    float *backoffs;\n    float *centers;\n    uint32 backoff_num;\n    uint32 prob_num;\n    ngram_raw_t *raw_ngrams_end;\n\n    probs = (float *) ckd_calloc(counts, sizeof(*probs));\n    backoffs = (float *) ckd_calloc(counts, sizeof(*backoffs));\n    raw_ngrams_end = raw_ngrams + counts;\n\n    for (backoff_num = 0, prob_num = 0; raw_ngrams != raw_ngrams_end;\n         raw_ngrams++) {\n        probs[prob_num++] = raw_ngrams->prob;\n        backoffs[backoff_num++] = raw_ngrams->backoff;\n    }\n\n    make_bins(probs, prob_num, quant->tables[order - 2][0].begin,\n              1ULL << quant->prob_bits);\n    centers = quant->tables[order - 2][1].begin;\n    make_bins(backoffs, backoff_num, centers, (1ULL << quant->bo_bits));\n    ckd_free(probs);\n    ckd_free(backoffs);\n}\n\nvoid\nlm_trie_quant_train_prob(lm_trie_quant_t * quant, int order, uint32 counts,\n                         ngram_raw_t * raw_ngrams)\n{\n    float *probs;\n    uint32 prob_num;\n    ngram_raw_t *raw_ngrams_end;\n\n    probs = (float *) ckd_calloc(counts, sizeof(*probs));\n    raw_ngrams_end = raw_ngrams + counts;\n\n    for (prob_num = 0; raw_ngrams != raw_ngrams_end; raw_ngrams++) {\n        probs[prob_num++] = raw_ngrams->prob;\n    }\n\n    make_bins(probs, prob_num, quant->tables[order - 2][0].begin,\n              1ULL << quant->prob_bits);\n    ckd_free(probs);\n}\n\nvoid\nlm_trie_quant_mwrite(lm_trie_quant_t * quant, bitarr_address_t address,\n                     int order_minus_2, float prob, float backoff)\n{\n    bitarr_write_int57(address, quant->prob_bits + quant->bo_bits,\n                       (uint64) ((bins_encode\n                                  (&quant->tables[order_minus_2][0],\n                                   prob) << quant->\n                                  bo_bits) | bins_encode(&quant->\n                                                         tables\n                                                         [order_minus_2]\n                                                         [1],\n                                                         backoff)));\n}\n\nvoid\nlm_trie_quant_lwrite(lm_trie_quant_t * quant, bitarr_address_t address,\n                     float prob)\n{\n    bitarr_write_int25(address, quant->prob_bits,\n                       (uint32) bins_encode(quant->longest, prob));\n}\n\nfloat\nlm_trie_quant_mboread(lm_trie_quant_t * quant, bitarr_address_t address,\n                      int order_minus_2)\n{\n    return bins_decode(&quant->tables[order_minus_2][1],\n                       bitarr_read_int25(address, quant->bo_bits,\n                                         quant->bo_mask));\n}\n\nfloat\nlm_trie_quant_mpread(lm_trie_quant_t * quant, bitarr_address_t address,\n                     int order_minus_2)\n{\n    address.offset += quant->bo_bits;\n    return bins_decode(&quant->tables[order_minus_2][0],\n                       bitarr_read_int25(address, quant->prob_bits,\n                                         quant->prob_mask));\n}\n\nfloat\nlm_trie_quant_lpread(lm_trie_quant_t * quant, bitarr_address_t address)\n{\n    return bins_decode(quant->longest,\n                       bitarr_read_int25(address, quant->prob_bits,\n                                         quant->prob_mask));\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2008 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/**\n * @file ngram_model_set.c Set of language models.\n * @author David Huggins-Daines <dhuggins@cs.cmu.edu>\n */\n\n#include <string.h>\n#include <stdlib.h>\n\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/filename.h\"\n\n#include \"ngram_model_set.h\"\n\nstatic ngram_funcs_t ngram_model_set_funcs;\n\nstatic int\nmy_compare(const void *a, const void *b)\n{\n    /* Make sure <UNK> floats to the beginning. */\n    if (strcmp(*(char *const *) a, \"<UNK>\") == 0)\n        return -1;\n    else if (strcmp(*(char *const *) b, \"<UNK>\") == 0)\n        return 1;\n    else\n        return strcmp(*(char *const *) a, *(char *const *) b);\n}\n\nstatic void\nbuild_widmap(ngram_model_t * base, logmath_t * lmath, int32 n)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    ngram_model_t **models = set->lms;\n    hash_table_t *vocab;\n    glist_t hlist;\n    gnode_t *gn;\n    int32 i;\n\n    /* Construct a merged vocabulary and a set of word-ID mappings. */\n    vocab = hash_table_new(models[0]->n_words, FALSE);\n    /* Create the set of merged words. */\n    for (i = 0; i < set->n_models; ++i) {\n        int32 j;\n        for (j = 0; j < models[i]->n_words; ++j) {\n            /* Ignore collisions. */\n            (void) hash_table_enter_int32(vocab, models[i]->word_str[j],\n                                          j);\n        }\n    }\n    /* Create the array of words, then sort it. */\n    if (hash_table_lookup(vocab, \"<UNK>\", NULL) != 0)\n        (void) hash_table_enter_int32(vocab, \"<UNK>\", 0);\n    /* Now we know the number of unigrams, initialize the base model. */\n    ngram_model_init(base, &ngram_model_set_funcs, lmath, n,\n                     hash_table_inuse(vocab));\n    base->writable = FALSE;     /* We will reuse the pointers from the submodels. */\n    i = 0;\n    hlist = hash_table_tolist(vocab, NULL);\n    for (gn = hlist; gn; gn = gnode_next(gn)) {\n        hash_entry_t *ent = gnode_ptr(gn);\n        base->word_str[i++] = (char *) ent->key;\n    }\n    glist_free(hlist);\n    qsort(base->word_str, base->n_words, sizeof(*base->word_str),\n          my_compare);\n\n    /* Now create the word ID mappings. */\n    if (set->widmap)\n        ckd_free_2d((void **) set->widmap);\n    set->widmap = (int32 **) ckd_calloc_2d(base->n_words, set->n_models,\n                                           sizeof(**set->widmap));\n    for (i = 0; i < base->n_words; ++i) {\n        int32 j;\n        /* Also create the master wid mapping. */\n        (void) hash_table_enter_int32(base->wid, base->word_str[i], i);\n        /* printf(\"%s: %d => \", base->word_str[i], i); */\n        for (j = 0; j < set->n_models; ++j) {\n            set->widmap[i][j] = ngram_wid(models[j], base->word_str[i]);\n            /* printf(\"%d \", set->widmap[i][j]); */\n        }\n        /* printf(\"\\n\"); */\n    }\n    hash_table_free(vocab);\n}\n\nngram_model_t *\nngram_model_set_init(cmd_ln_t * config,\n                     ngram_model_t ** models,\n                     char **names, const float32 * weights, int32 n_models)\n{\n    ngram_model_set_t *model;\n    ngram_model_t *base;\n    logmath_t *lmath;\n    int32 i, n;\n\n    if (n_models == 0)          /* WTF */\n        return NULL;\n\n    /* Do consistency checking on the models.  They must all use the\n     * same logbase and shift. */\n    lmath = models[0]->lmath;\n    for (i = 1; i < n_models; ++i) {\n        if (logmath_get_base(models[i]->lmath) != logmath_get_base(lmath)\n            || logmath_get_shift(models[i]->lmath) !=\n            logmath_get_shift(lmath)) {\n            E_ERROR\n                (\"Log-math parameters don't match, will not create LM set\\n\");\n            return NULL;\n        }\n    }\n\n    /* Allocate the combined model, initialize it. */\n    model = ckd_calloc(1, sizeof(*model));\n    base = &model->base;\n    model->n_models = n_models;\n    model->lms = ckd_calloc(n_models, sizeof(*model->lms));\n    model->names = ckd_calloc(n_models, sizeof(*model->names));\n    /* Initialize weights to a uniform distribution */\n    model->lweights = ckd_calloc(n_models, sizeof(*model->lweights));\n    {\n        int32 uniform = logmath_log(lmath, 1.0 / n_models);\n        for (i = 0; i < n_models; ++i)\n            model->lweights[i] = uniform;\n    }\n    /* Default to interpolate if weights were given. */\n    if (weights)\n        model->cur = -1;\n\n    n = 0;\n    for (i = 0; i < n_models; ++i) {\n        model->lms[i] = ngram_model_retain(models[i]);\n        model->names[i] = ckd_salloc(names[i]);\n        if (weights)\n            model->lweights[i] = logmath_log(lmath, weights[i]);\n        /* N is the maximum of all merged models. */\n        if (models[i]->n > n)\n            n = models[i]->n;\n    }\n    /* Allocate the history mapping table. */\n    model->maphist = ckd_calloc(n - 1, sizeof(*model->maphist));\n\n    /* Now build the word-ID mapping and merged vocabulary. */\n    build_widmap(base, lmath, n);\n    return base;\n}\n\nngram_model_t *\nngram_model_set_read(cmd_ln_t * config,\n                     const char *lmctlfile, logmath_t * lmath)\n{\n    FILE *ctlfp;\n    glist_t lms = NULL;\n    glist_t lmnames = NULL;\n    __BIGSTACKVARIABLE__ char str[1024];\n    ngram_model_t *set = NULL;\n    hash_table_t *classes;\n    char *basedir, *c;\n\n    /* Read all the class definition files to accumulate a mapping of\n     * classnames to definitions. */\n    classes = hash_table_new(0, FALSE);\n    if ((ctlfp = fopen(lmctlfile, \"r\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open %s\", lmctlfile);\n        return NULL;\n    }\n\n    /* Try to find the base directory to append to relative paths in\n     * the lmctl file. */\n    if ((c = strrchr(lmctlfile, '/')) || (c = strrchr(lmctlfile, '\\\\'))) {\n        /* Include the trailing slash. */\n        basedir = ckd_calloc(c - lmctlfile + 2, 1);\n        memcpy(basedir, lmctlfile, c - lmctlfile + 1);\n    }\n    else {\n        basedir = NULL;\n    }\n    E_INFO(\"Reading LM control file '%s'\\n\", lmctlfile);\n    if (basedir)\n        E_INFO(\"Will prepend '%s' to unqualified paths\\n\", basedir);\n\n    if (fscanf(ctlfp, \"%1023s\", str) == 1) {\n        if (strcmp(str, \"{\") == 0) {\n            /* Load LMclass files */\n            while ((fscanf(ctlfp, \"%1023s\", str) == 1)\n                   && (strcmp(str, \"}\") != 0)) {\n                char *deffile;\n                if (basedir && !path_is_absolute(str))\n                    deffile = string_join(basedir, str, NULL);\n                else\n                    deffile = ckd_salloc(str);\n                E_INFO(\"Reading classdef from '%s'\\n\", deffile);\n                if (read_classdef_file(classes, deffile) < 0) {\n                    ckd_free(deffile);\n                    goto error_out;\n                }\n                ckd_free(deffile);\n            }\n\n            if (strcmp(str, \"}\") != 0) {\n                E_ERROR(\"Unexpected EOF in %s\\n\", lmctlfile);\n                goto error_out;\n            }\n\n            /* This might be the first LM name. */\n            if (fscanf(ctlfp, \"%1023s\", str) != 1)\n                str[0] = '\\0';\n        }\n    }\n    else\n        str[0] = '\\0';\n\n    /* Read in one LM at a time and add classes to them as necessary. */\n    while (str[0] != '\\0') {\n        char *lmfile;\n        ngram_model_t *lm;\n\n        if (basedir && str[0] != '/' && str[0] != '\\\\')\n            lmfile = string_join(basedir, str, NULL);\n        else\n            lmfile = ckd_salloc(str);\n        E_INFO(\"Reading lm from '%s'\\n\", lmfile);\n        lm = ngram_model_read(config, lmfile, NGRAM_AUTO, lmath);\n        if (lm == NULL) {\n            ckd_free(lmfile);\n            goto error_out;\n        }\n        if (fscanf(ctlfp, \"%1023s\", str) != 1) {\n            E_ERROR(\"LMname missing after LMFileName '%s'\\n\", lmfile);\n            ckd_free(lmfile);\n            goto error_out;\n        }\n        ckd_free(lmfile);\n        lms = glist_add_ptr(lms, lm);\n        lmnames = glist_add_ptr(lmnames, ckd_salloc(str));\n\n        if (fscanf(ctlfp, \"%1023s\", str) == 1) {\n            if (strcmp(str, \"{\") == 0) {\n                /* LM uses classes; read their names */\n                while ((fscanf(ctlfp, \"%1023s\", str) == 1) &&\n                       (strcmp(str, \"}\") != 0)) {\n                    void *val;\n                    classdef_t *classdef;\n\n                    if (hash_table_lookup(classes, str, &val) == -1) {\n                        E_ERROR(\"Unknown class %s in control file\\n\", str);\n                        goto error_out;\n                    }\n                    classdef = val;\n                    if (ngram_model_add_class(lm, str, 1.0,\n                                              classdef->words,\n                                              classdef->weights,\n                                              classdef->n_words) < 0) {\n                        goto error_out;\n                    }\n                    E_INFO(\"Added class %s containing %d words\\n\",\n                           str, classdef->n_words);\n                }\n                if (strcmp(str, \"}\") != 0) {\n                    E_ERROR(\"Unexpected EOF in %s\\n\", lmctlfile);\n                    goto error_out;\n                }\n                if (fscanf(ctlfp, \"%1023s\", str) != 1)\n                    str[0] = '\\0';\n            }\n        }\n        else\n            str[0] = '\\0';\n    }\n    fclose(ctlfp);\n\n    /* Now construct arrays out of lms and lmnames, and build an\n     * ngram_model_set. */\n    lms = glist_reverse(lms);\n    lmnames = glist_reverse(lmnames);\n    {\n        int32 n_models;\n        ngram_model_t **lm_array;\n        char **name_array;\n        gnode_t *lm_node, *name_node;\n        int32 i;\n\n        n_models = glist_count(lms);\n        lm_array = ckd_calloc(n_models, sizeof(*lm_array));\n        name_array = ckd_calloc(n_models, sizeof(*name_array));\n        lm_node = lms;\n        name_node = lmnames;\n        for (i = 0; i < n_models; ++i) {\n            lm_array[i] = gnode_ptr(lm_node);\n            name_array[i] = gnode_ptr(name_node);\n            lm_node = gnode_next(lm_node);\n            name_node = gnode_next(name_node);\n        }\n        set = ngram_model_set_init(config, lm_array, name_array,\n                                   NULL, n_models);\n\n        for (i = 0; i < n_models; ++i) {\n            ngram_model_free(lm_array[i]);\n        }\n        ckd_free(lm_array);\n        ckd_free(name_array);\n    }\n  error_out:\n    {\n        gnode_t *gn;\n        glist_t hlist;\n\n        if (set == NULL) {\n            for (gn = lms; gn; gn = gnode_next(gn)) {\n                ngram_model_free(gnode_ptr(gn));\n            }\n        }\n        glist_free(lms);\n        for (gn = lmnames; gn; gn = gnode_next(gn)) {\n            ckd_free(gnode_ptr(gn));\n        }\n        glist_free(lmnames);\n        hlist = hash_table_tolist(classes, NULL);\n        for (gn = hlist; gn; gn = gnode_next(gn)) {\n            hash_entry_t *he = gnode_ptr(gn);\n            ckd_free((char *) he->key);\n            classdef_free(he->val);\n        }\n        glist_free(hlist);\n        hash_table_free(classes);\n        ckd_free(basedir);\n    }\n    return set;\n}\n\nint32\nngram_model_set_count(ngram_model_t * base)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    return set->n_models;\n}\n\nngram_model_set_iter_t *\nngram_model_set_iter(ngram_model_t * base)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    ngram_model_set_iter_t *itor;\n\n    if (set == NULL || set->n_models == 0)\n        return NULL;\n    itor = ckd_calloc(1, sizeof(*itor));\n    itor->set = set;\n    return itor;\n}\n\nngram_model_set_iter_t *\nngram_model_set_iter_next(ngram_model_set_iter_t * itor)\n{\n    if (++itor->cur == itor->set->n_models) {\n        ngram_model_set_iter_free(itor);\n        return NULL;\n    }\n    return itor;\n}\n\nvoid\nngram_model_set_iter_free(ngram_model_set_iter_t * itor)\n{\n    ckd_free(itor);\n}\n\nngram_model_t *\nngram_model_set_iter_model(ngram_model_set_iter_t * itor,\n                           char const **lmname)\n{\n    if (lmname)\n        *lmname = itor->set->names[itor->cur];\n    return itor->set->lms[itor->cur];\n}\n\nngram_model_t *\nngram_model_set_lookup(ngram_model_t * base, const char *name)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 i;\n\n    if (name == NULL) {\n        if (set->cur == -1)\n            return NULL;\n        else\n            return set->lms[set->cur];\n    }\n\n    /* There probably won't be very many submodels. */\n    for (i = 0; i < set->n_models; ++i)\n        if (0 == strcmp(set->names[i], name))\n            break;\n    if (i == set->n_models)\n        return NULL;\n    return set->lms[i];\n}\n\nngram_model_t *\nngram_model_set_select(ngram_model_t * base, const char *name)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 i;\n\n    /* There probably won't be very many submodels. */\n    for (i = 0; i < set->n_models; ++i)\n        if (0 == strcmp(set->names[i], name))\n            break;\n    if (i == set->n_models)\n        return NULL;\n    set->cur = i;\n    return set->lms[set->cur];\n}\n\nconst char *\nngram_model_set_current(ngram_model_t * base)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n\n    if (set->cur == -1)\n        return NULL;\n    else\n        return set->names[set->cur];\n}\n\nint32\nngram_model_set_current_wid(ngram_model_t * base, int32 set_wid)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n\n    if (set->cur == -1 || set_wid >= base->n_words)\n        return NGRAM_INVALID_WID;\n    else\n        return set->widmap[set_wid][set->cur];\n}\n\nint32\nngram_model_set_known_wid(ngram_model_t * base, int32 set_wid)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n\n    if (set_wid >= base->n_words)\n        return FALSE;\n    else if (set->cur == -1) {\n        int32 i;\n        for (i = 0; i < set->n_models; ++i) {\n            if (set->widmap[set_wid][i] != ngram_unknown_wid(set->lms[i]))\n                return TRUE;\n        }\n        return FALSE;\n    }\n    else\n        return (set->widmap[set_wid][set->cur]\n                != ngram_unknown_wid(set->lms[set->cur]));\n}\n\nngram_model_t *\nngram_model_set_interp(ngram_model_t * base,\n                       const char **names, const float32 * weights)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n\n    /* If we have a set of weights here, then set them. */\n    if (names && weights) {\n        int32 i, j;\n\n        /* We hope there aren't many models. */\n        for (i = 0; i < set->n_models; ++i) {\n            for (j = 0; j < set->n_models; ++j)\n                if (0 == strcmp(names[i], set->names[j]))\n                    break;\n            if (j == set->n_models) {\n                E_ERROR(\"Unknown LM name %s\\n\", names[i]);\n                return NULL;\n            }\n            set->lweights[j] = logmath_log(base->lmath, weights[i]);\n        }\n    }\n    else if (weights) {\n        memcpy(set->lweights, weights,\n               set->n_models * sizeof(*set->lweights));\n    }\n    /* Otherwise just enable existing weights. */\n    set->cur = -1;\n    return base;\n}\n\nngram_model_t *\nngram_model_set_add(ngram_model_t * base,\n                    ngram_model_t * model,\n                    const char *name, float32 weight, int reuse_widmap)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    float32 fprob;\n    int32 scale, i;\n\n    /* Add it to the array of lms. */\n    ++set->n_models;\n    set->lms = ckd_realloc(set->lms, set->n_models * sizeof(*set->lms));\n    set->lms[set->n_models - 1] = model;\n    set->names =\n        ckd_realloc(set->names, set->n_models * sizeof(*set->names));\n    set->names[set->n_models - 1] = ckd_salloc(name);\n    /* Expand the history mapping table if necessary. */\n    if (model->n > base->n) {\n        base->n = model->n;\n        set->maphist = ckd_realloc(set->maphist,\n                                   (model->n - 1) * sizeof(*set->maphist));\n    }\n\n    /* Renormalize the interpolation weights. */\n    fprob = weight * 1.0f / set->n_models;\n    set->lweights = ckd_realloc(set->lweights,\n                                set->n_models * sizeof(*set->lweights));\n    set->lweights[set->n_models - 1] = logmath_log(base->lmath, fprob);\n    /* Now normalize everything else to fit it in.  This is\n     * accomplished by simply scaling all the other probabilities\n     * by (1-fprob). */\n    scale = logmath_log(base->lmath, 1.0 - fprob);\n    for (i = 0; i < set->n_models - 1; ++i)\n        set->lweights[i] += scale;\n\n    /* Reuse the old word ID mapping if requested. */\n    if (reuse_widmap) {\n        int32 **new_widmap;\n\n        /* Tack another column onto the widmap array. */\n        new_widmap = (int32 **) ckd_calloc_2d(base->n_words, set->n_models,\n                                              sizeof(**new_widmap));\n        for (i = 0; i < base->n_words; ++i) {\n            /* Copy all the existing mappings. */\n            memcpy(new_widmap[i], set->widmap[i],\n                   (set->n_models - 1) * sizeof(**new_widmap));\n            /* Create the new mapping. */\n            new_widmap[i][set->n_models - 1] =\n                ngram_wid(model, base->word_str[i]);\n        }\n        ckd_free_2d((void **) set->widmap);\n        set->widmap = new_widmap;\n    }\n    else {\n        build_widmap(base, base->lmath, base->n);\n    }\n    return model;\n}\n\nngram_model_t *\nngram_model_set_remove(ngram_model_t * base,\n                       const char *name, int reuse_widmap)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    ngram_model_t *submodel;\n    int32 lmidx, scale, n, i;\n    float32 fprob;\n\n    for (lmidx = 0; lmidx < set->n_models; ++lmidx)\n        if (0 == strcmp(name, set->names[lmidx]))\n            break;\n    if (lmidx == set->n_models)\n        return NULL;\n    submodel = set->lms[lmidx];\n\n    /* Renormalize the interpolation weights by scaling them by\n     * 1/(1-fprob) */\n    fprob = (float32) logmath_exp(base->lmath, set->lweights[lmidx]);\n    scale = logmath_log(base->lmath, 1.0 - fprob);\n\n    /* Remove it from the array of lms, renormalize remaining weights,\n     * and recalcluate n. */\n    --set->n_models;\n    n = 0;\n    ckd_free(set->names[lmidx]);\n    set->names[lmidx] = NULL;\n    for (i = 0; i < set->n_models; ++i) {\n        if (i >= lmidx) {\n            set->lms[i] = set->lms[i + 1];\n            set->names[i] = set->names[i + 1];\n            set->lweights[i] = set->lweights[i + 1];\n        }\n        set->lweights[i] -= scale;\n        if (set->lms[i]->n > n)\n            n = set->lms[i]->n;\n    }\n    /* There's no need to shrink these arrays. */\n    set->lms[set->n_models] = NULL;\n    set->lweights[set->n_models] = base->log_zero;\n    /* No need to shrink maphist either. */\n\n    /* Reuse the existing word ID mapping if requested. */\n    if (reuse_widmap) {\n        /* Just go through and shrink each row. */\n        for (i = 0; i < base->n_words; ++i) {\n            memmove(set->widmap[i] + lmidx, set->widmap[i] + lmidx + 1,\n                    (set->n_models - lmidx) * sizeof(**set->widmap));\n        }\n    }\n    else {\n        build_widmap(base, base->lmath, n);\n    }\n    return submodel;\n}\n\nvoid\nngram_model_set_map_words(ngram_model_t * base,\n                          const char **words, int32 n_words)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 i;\n\n    /* Recreate the word mapping. */\n    if (base->writable) {\n        for (i = 0; i < base->n_words; ++i) {\n            ckd_free(base->word_str[i]);\n        }\n    }\n    ckd_free(base->word_str);\n    ckd_free_2d((void **) set->widmap);\n    base->writable = TRUE;\n    base->n_words = base->n_1g_alloc = n_words;\n    base->word_str = ckd_calloc(n_words, sizeof(*base->word_str));\n    set->widmap =\n        (int32 **) ckd_calloc_2d(n_words, set->n_models,\n                                 sizeof(**set->widmap));\n    hash_table_empty(base->wid);\n    for (i = 0; i < n_words; ++i) {\n        int32 j;\n        base->word_str[i] = ckd_salloc(words[i]);\n        (void) hash_table_enter_int32(base->wid, base->word_str[i], i);\n        for (j = 0; j < set->n_models; ++j) {\n            set->widmap[i][j] = ngram_wid(set->lms[j], base->word_str[i]);\n        }\n    }\n}\n\nstatic int\nngram_model_set_apply_weights(ngram_model_t * base, float32 lw,\n                              float32 wip)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 i;\n\n    /* Apply weights to each sub-model. */\n    for (i = 0; i < set->n_models; ++i)\n        ngram_model_apply_weights(set->lms[i], lw, wip);\n    return 0;\n}\n\nstatic int32\nngram_model_set_score(ngram_model_t * base, int32 wid,\n                      int32 * history, int32 n_hist, int32 * n_used)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 mapwid;\n    int32 score;\n    int32 i;\n\n    /* Truncate the history. */\n    if (n_hist > base->n - 1)\n        n_hist = base->n - 1;\n\n    /* Interpolate if there is no current. */\n    if (set->cur == -1) {\n        score = base->log_zero;\n        for (i = 0; i < set->n_models; ++i) {\n            int32 j;\n            /* Map word and history IDs for each model. */\n            mapwid = set->widmap[wid][i];\n            for (j = 0; j < n_hist; ++j) {\n                if (history[j] == NGRAM_INVALID_WID)\n                    set->maphist[j] = NGRAM_INVALID_WID;\n                else\n                    set->maphist[j] = set->widmap[history[j]][i];\n            }\n            score = logmath_add(base->lmath, score,\n                                set->lweights[i] +\n                                ngram_ng_score(set->lms[i],\n                                               mapwid, set->maphist,\n                                               n_hist, n_used));\n        }\n    }\n    else {\n        int32 j;\n        /* Map word and history IDs (FIXME: do this in a function?) */\n        mapwid = set->widmap[wid][set->cur];\n        for (j = 0; j < n_hist; ++j) {\n            if (history[j] == NGRAM_INVALID_WID)\n                set->maphist[j] = NGRAM_INVALID_WID;\n            else\n                set->maphist[j] = set->widmap[history[j]][set->cur];\n        }\n        score = ngram_ng_score(set->lms[set->cur],\n                               mapwid, set->maphist, n_hist, n_used);\n    }\n\n    return score;\n}\n\nstatic int32\nngram_model_set_raw_score(ngram_model_t * base, int32 wid,\n                          int32 * history, int32 n_hist, int32 * n_used)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 mapwid;\n    int32 score;\n    int32 i;\n\n    /* Truncate the history. */\n    if (n_hist > base->n - 1)\n        n_hist = base->n - 1;\n\n    /* Interpolate if there is no current. */\n    if (set->cur == -1) {\n        score = base->log_zero;\n        for (i = 0; i < set->n_models; ++i) {\n            int32 j;\n            /* Map word and history IDs for each model. */\n            mapwid = set->widmap[wid][i];\n            for (j = 0; j < n_hist; ++j) {\n                if (history[j] == NGRAM_INVALID_WID)\n                    set->maphist[j] = NGRAM_INVALID_WID;\n                else\n                    set->maphist[j] = set->widmap[history[j]][i];\n            }\n            score = logmath_add(base->lmath, score,\n                                set->lweights[i] +\n                                ngram_ng_prob(set->lms[i],\n                                              mapwid, set->maphist, n_hist,\n                                              n_used));\n        }\n    }\n    else {\n        int32 j;\n        /* Map word and history IDs (FIXME: do this in a function?) */\n        mapwid = set->widmap[wid][set->cur];\n        for (j = 0; j < n_hist; ++j) {\n            if (history[j] == NGRAM_INVALID_WID)\n                set->maphist[j] = NGRAM_INVALID_WID;\n            else\n                set->maphist[j] = set->widmap[history[j]][set->cur];\n        }\n        score = ngram_ng_prob(set->lms[set->cur],\n                              mapwid, set->maphist, n_hist, n_used);\n    }\n\n    return score;\n}\n\nstatic int32\nngram_model_set_add_ug(ngram_model_t * base, int32 wid, int32 lweight)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 *newwid;\n    int32 i, prob;\n\n    /* At this point the word has already been added to the master\n       model and we have a new word ID for it.  Add it to active\n       submodels and track the word IDs. */\n    newwid = ckd_calloc(set->n_models, sizeof(*newwid));\n    prob = base->log_zero;\n    for (i = 0; i < set->n_models; ++i) {\n        int32 wprob, n_hist;\n\n        /* Only add to active models. */\n        if (set->cur == -1 || set->cur == i) {\n            /* Did this word already exist? */\n            newwid[i] = ngram_wid(set->lms[i], base->word_str[wid]);\n            if (newwid[i] == NGRAM_INVALID_WID) {\n                /* Add it to the submodel. */\n                newwid[i] =\n                    ngram_model_add_word(set->lms[i], base->word_str[wid],\n                                         (float32) logmath_exp(base->lmath,\n                                                               lweight));\n                if (newwid[i] == NGRAM_INVALID_WID) {\n                    ckd_free(newwid);\n                    return base->log_zero;\n                }\n            }\n            /* Now get the unigram probability for the new word and either\n             * interpolate it or use it (if this is the current model). */\n            wprob =\n                ngram_ng_prob(set->lms[i], newwid[i], NULL, 0, &n_hist);\n            if (set->cur == i)\n                prob = wprob;\n            else if (set->cur == -1)\n                prob =\n                    logmath_add(base->lmath, prob,\n                                set->lweights[i] + wprob);\n        }\n        else {\n            newwid[i] = NGRAM_INVALID_WID;\n        }\n    }\n    /* Okay we have the word IDs for this in all the submodels.  Now\n       do some complicated memory mangling to add this to the\n       widmap. */\n    set->widmap =\n        ckd_realloc(set->widmap, base->n_words * sizeof(*set->widmap));\n    set->widmap[0] =\n        ckd_realloc(set->widmap[0],\n                    base->n_words * set->n_models * sizeof(**set->widmap));\n    for (i = 0; i < base->n_words; ++i)\n        set->widmap[i] = set->widmap[0] + i * set->n_models;\n    memcpy(set->widmap[wid], newwid, set->n_models * sizeof(*newwid));\n    ckd_free(newwid);\n    return prob;\n}\n\nstatic void\nngram_model_set_free(ngram_model_t * base)\n{\n    ngram_model_set_t *set = (ngram_model_set_t *) base;\n    int32 i;\n\n    for (i = 0; i < set->n_models; ++i)\n        ngram_model_free(set->lms[i]);\n    ckd_free(set->lms);\n    for (i = 0; i < set->n_models; ++i)\n        ckd_free(set->names[i]);\n    ckd_free(set->names);\n    ckd_free(set->lweights);\n    ckd_free(set->maphist);\n    ckd_free_2d((void **) set->widmap);\n}\n\nstatic ngram_funcs_t ngram_model_set_funcs = {\n    ngram_model_set_free,       /* free */\n    ngram_model_set_apply_weights,      /* apply_weights */\n    ngram_model_set_score,      /* score */\n    ngram_model_set_raw_score,  /* raw_score */\n    ngram_model_set_add_ug,     /* add_ug */\n};\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2015 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <string.h>\n#include <assert.h>\n\n#include <sphinxbase/err.h>\n#include <sphinxbase/pio.h>\n#include <sphinxbase/strfuncs.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/byteorder.h>\n\n#include \"ngram_model_trie.h\"\n\nstatic const char trie_hdr[] = \"Trie Language Model\";\nstatic const char dmp_hdr[] = \"Darpa Trigram LM\";\nstatic ngram_funcs_t ngram_model_trie_funcs;\n\n/*\n * Read and return #unigrams, #bigrams, #trigrams as stated in input file.\n */\nstatic int\nread_counts_arpa(lineiter_t ** li, uint32 * counts, int *order)\n{\n    int32 ngram, prev_ngram;\n    uint32 ngram_cnt;\n\n    /* skip file until past the '\\data\\' marker */\n    while (*li) {\n        if (strcmp((*li)->buf, \"\\\\data\\\\\") == 0)\n            break;\n        *li = lineiter_next(*li);\n    }\n\n    if (*li == NULL || strcmp((*li)->buf, \"\\\\data\\\\\") != 0) {\n        E_INFO(\"No \\\\data\\\\ mark in LM file\\n\");\n        return -1;\n    }\n\n    prev_ngram = 0;\n    *order = 0;\n    while ((*li = lineiter_next(*li))) {\n        if (sscanf((*li)->buf, \"ngram %d=%d\", &ngram, &ngram_cnt) != 2)\n            break;\n        if (ngram != prev_ngram + 1) {\n            E_ERROR\n                (\"Ngram counts in LM file is not in order. %d goes after %d\\n\",\n                 ngram, prev_ngram);\n            return -1;\n        }\n        prev_ngram = ngram;\n        counts[*order] = ngram_cnt;\n        (*order)++;\n    }\n\n    if (*li == NULL) {\n        E_ERROR(\"EOF while reading ngram counts\\n\");\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nread_1grams_arpa(lineiter_t ** li, uint32 count, ngram_model_t * base,\n                 unigram_t * unigrams)\n{\n    uint32 i;\n    int n;\n    int n_parts;\n    char *wptr[3];\n\n    while (*li && strcmp((*li)->buf, \"\\\\1-grams:\") != 0) {\n\t*li = lineiter_next(*li);\n    }\n    if (*li == NULL) {\n        E_ERROR_SYSTEM(\"Failed to read \\\\1-grams: mark\");\n        return -1;\n    }\n\n    n_parts = 2;\n    for (i = 0; i < count; i++) {\n        unigram_t *unigram;\n        \n        *li = lineiter_next(*li);\n        if (*li == NULL) {\n            E_ERROR\n                (\"Unexpected end of ARPA file. Failed to read %dth unigram\\n\",\n                 i + 1);\n            return -1;\n        }\n        if ((n = str2words((*li)->buf, wptr, 3)) < n_parts) {\n            E_ERROR(\"Format error at line %s, Failed to read unigrams\\n\", (*li)->buf);\n            return -1;\n        }\n\n        unigram = &unigrams[i];\n        unigram->prob =\n            logmath_log10_to_log_float(base->lmath, atof_c(wptr[0]));\n        if (unigram->prob > 0) {\n            E_WARN(\"Unigram '%s' has positive probability\\n\", wptr[1]);\n            unigram->prob = 0;\n        }\n        if (n == n_parts + 1) {\n            unigram->bo =\n                logmath_log10_to_log_float(base->lmath,\n                                           atof_c(wptr[2]));\n        }\n        else {\n            unigram->bo = 0.0f;\n        }\n\n        /* TODO: classify float with fpclassify and warn if bad value occurred */\n        base->word_str[i] = ckd_salloc(wptr[1]);\n    }\n\n    /* fill hash-table that maps unigram names to their word ids */\n    for (i = 0; i < count; i++) {\n        if ((hash_table_enter\n             (base->wid, base->word_str[i],\n              (void *) (long) i)) != (void *) (long) i) {\n            E_WARN(\"Duplicate word in dictionary: %s\\n\",\n                   base->word_str[i]);\n        }\n    }\n    return 0;\n}\n\nngram_model_t *\nngram_model_trie_read_arpa(cmd_ln_t * config,\n                           const char *path, logmath_t * lmath)\n{\n    FILE *fp;\n    lineiter_t *li;\n    ngram_model_trie_t *model;\n    ngram_model_t *base;\n    ngram_raw_t **raw_ngrams;\n    int32 is_pipe;\n    uint32 counts[NGRAM_MAX_ORDER];\n    int order;\n    int i;\n\n    E_INFO(\"Trying to read LM in arpa format\\n\");\n    if ((fp = fopen_comp(path, \"r\", &is_pipe)) == NULL) {\n        E_ERROR(\"File %s not found\\n\", path);\n        return NULL;\n    }\n\n    model = (ngram_model_trie_t *) ckd_calloc(1, sizeof(*model));\n    li = lineiter_start_clean(fp);\n    /* Read n-gram counts from file */\n    if (read_counts_arpa(&li, counts, &order) == -1) {\n        ckd_free(model);\n        lineiter_free(li);\n        fclose_comp(fp, is_pipe);\n        return NULL;\n    }\n\n    E_INFO(\"LM of order %d\\n\", order);\n    for (i = 0; i < order; i++) {\n        E_INFO(\"#%d-grams: %d\\n\", i + 1, counts[i]);\n    }\n\n    base = &model->base;\n    ngram_model_init(base, &ngram_model_trie_funcs, lmath, order,\n                     (int32) counts[0]);\n    base->writable = TRUE;\n\n    model->trie = lm_trie_create(counts[0], order);\n    if (read_1grams_arpa(&li, counts[0], base, model->trie->unigrams) < 0) {\n\tngram_model_free(base);\n        lineiter_free(li);\n        fclose_comp(fp, is_pipe);\n        return NULL;\n    }\n\n    if (order > 1) {\n        raw_ngrams =\n            ngrams_raw_read_arpa(&li, base->lmath, counts, order,\n                                 base->wid);\n        if (raw_ngrams == NULL) {\n            ngram_model_free(base);\n            lineiter_free(li);\n            fclose_comp(fp, is_pipe);\n            return NULL;\n        }\n        lm_trie_build(model->trie, raw_ngrams, counts, base->n_counts, order);\n        ngrams_raw_free(raw_ngrams, counts, order);\n    }\n\n    lineiter_free(li);\n    fclose_comp(fp, is_pipe);\n\n    return base;\n}\n\nint\nngram_model_trie_write_arpa(ngram_model_t * base, const char *path)\n{\n    int i;\n    uint32 j;\n    ngram_model_trie_t *model = (ngram_model_trie_t *) base;\n    FILE *fp = fopen(path, \"w\");\n    if (!fp) {\n        E_ERROR(\"Unable to open %s to write arpa LM from trie\\n\", path);\n        return -1;\n    }\n    fprintf(fp,\n            \"This is an ARPA-format language model file, generated by CMU Sphinx\\n\");\n    /* Write N-gram counts. */\n    fprintf(fp, \"\\\\data\\\\\\n\");\n    for (i = 0; i < base->n; ++i) {\n        fprintf(fp, \"ngram %d=%d\\n\", i + 1, base->n_counts[i]);\n    }\n    /* Write 1-grams */\n    fprintf(fp, \"\\n\\\\1-grams:\\n\");\n    for (j = 0; j < base->n_counts[0]; j++) {\n        unigram_t *unigram = &model->trie->unigrams[j];\n        fprintf(fp, \"%.4f\\t%s\",\n                logmath_log_float_to_log10(base->lmath, unigram->prob),\n                base->word_str[j]);\n        if (base->n > 1) {\n            fprintf(fp, \"\\t%.4f\",\n                    logmath_log_float_to_log10(base->lmath, unigram->bo));\n        }\n        fprintf(fp, \"\\n\");\n    }\n    /* Write ngrams */\n    if (base->n > 1) {\n        for (i = 2; i <= base->n; ++i) {\n            ngram_raw_t *raw_ngrams =\n                (ngram_raw_t *) ckd_calloc((size_t) base->n_counts[i - 1],\n                                           sizeof(*raw_ngrams));\n            uint32 raw_ngram_idx;\n            uint32 j;\n            uint32 hist[NGRAM_MAX_ORDER];\n            node_range_t range;\n            raw_ngram_idx = 0;\n            range.begin = range.end = 0;  \n\n            /* we need to iterate over a trie here. recursion should do the job */\n            lm_trie_fill_raw_ngram(model->trie, raw_ngrams,\n                           &raw_ngram_idx, base->n_counts, range, hist, 0,\n                           i, base->n);\n            assert(raw_ngram_idx == base->n_counts[i - 1]);\n            qsort(raw_ngrams, (size_t) base->n_counts[i - 1],\n                  sizeof(ngram_raw_t), &ngram_ord_comparator);\n\n            fprintf(fp, \"\\n\\\\%d-grams:\\n\", i);\n            for (j = 0; j < base->n_counts[i - 1]; j++) {\n                int k;\n                fprintf(fp, \"%.4f\", logmath_log_float_to_log10(base->lmath, raw_ngrams[j].prob));\n                for (k = 0; k < i; k++) {\n                    fprintf(fp, \"\\t%s\",\n                            base->word_str[raw_ngrams[j].words[k]]);\n                }\n                ckd_free(raw_ngrams[j].words);\n                if (i < base->n) {\n                    fprintf(fp, \"\\t%.4f\", logmath_log_float_to_log10(base->lmath, raw_ngrams[j].backoff));\n                }\n                fprintf(fp, \"\\n\");\n            }\n            ckd_free(raw_ngrams);\n        }\n    }\n    fprintf(fp, \"\\n\\\\end\\\\\\n\");\n    return fclose(fp);\n}\n\nstatic void\nread_word_str(ngram_model_t * base, FILE * fp)\n{\n    int32 k;\n    uint32 i, j;\n    char *tmp_word_str;\n    /* read ascii word strings */\n    base->writable = TRUE;\n    fread(&k, sizeof(k), 1, fp);\n    tmp_word_str = (char *) ckd_calloc((size_t) k, 1);\n    fread(tmp_word_str, 1, (size_t) k, fp);\n\n    /* First make sure string just read contains n_counts[0] words (PARANOIA!!) */\n    for (i = 0, j = 0; i < (uint32) k; i++)\n        if (tmp_word_str[i] == '\\0')\n            j++;\n    if (j != base->n_counts[0]) {\n        E_ERROR\n            (\"Error reading word strings (%d doesn't match n_unigrams %d)\\n\",\n             j, base->n_counts[0]);\n    }\n\n    /* Break up string just read into words */\n    j = 0;\n    for (i = 0; i < base->n_counts[0]; i++) {\n        base->word_str[i] = ckd_salloc(tmp_word_str + j);\n        if (hash_table_enter(base->wid, base->word_str[i],\n                             (void *) (long) i) != (void *) (long) i) {\n            E_WARN(\"Duplicate word in dictionary: %s\\n\",\n                   base->word_str[i]);\n        }\n        j += strlen(base->word_str[i]) + 1;\n    }\n    free(tmp_word_str);\n}\n\nngram_model_t *\nngram_model_trie_read_bin(cmd_ln_t * config,\n                          const char *path, logmath_t * lmath)\n{\n    int32 is_pipe;\n    FILE *fp;\n    size_t hdr_size;\n    char *hdr;\n    int cmp_res;\n    uint8 i, order;\n    uint32 counts[NGRAM_MAX_ORDER];\n    ngram_model_trie_t *model;\n    ngram_model_t *base;\n\n    E_INFO(\"Trying to read LM in trie binary format\\n\");\n    if ((fp = fopen_comp(path, \"rb\", &is_pipe)) == NULL) {\n        E_ERROR(\"File %s not found\\n\", path);\n        return NULL;\n    }\n    hdr_size = strlen(trie_hdr);\n    hdr = (char *) ckd_calloc(hdr_size + 1, sizeof(*hdr));\n    fread(hdr, sizeof(*hdr), hdr_size, fp);\n    cmp_res = strcmp(hdr, trie_hdr);\n    ckd_free(hdr);\n    if (cmp_res) {\n        E_INFO(\"Header doesn't match\\n\");\n        fclose_comp(fp, is_pipe);\n        return NULL;\n    }\n    model = (ngram_model_trie_t *) ckd_calloc(1, sizeof(*model));\n    base = &model->base;\n    fread(&order, sizeof(order), 1, fp);\n    for (i = 0; i < order; i++) {\n        fread(&counts[i], sizeof(counts[i]), 1, fp);\n    }\n    ngram_model_init(base, &ngram_model_trie_funcs, lmath, order,\n                     (int32) counts[0]);\n    for (i = 0; i < order; i++) {\n        base->n_counts[i] = counts[i];\n    }\n\n    model->trie = lm_trie_read_bin(counts, order, fp);\n    read_word_str(base, fp);\n    fclose_comp(fp, is_pipe);\n\n    return base;\n}\n\nstatic void\nwrite_word_str(FILE * fp, ngram_model_t * model)\n{\n    int32 k;\n    uint32 i;\n\n    k = 0;\n    for (i = 0; i < model->n_counts[0]; i++)\n        k += strlen(model->word_str[i]) + 1;\n    fwrite(&k, sizeof(k), 1, fp);\n    for (i = 0; i < model->n_counts[0]; i++)\n        fwrite(model->word_str[i], 1, strlen(model->word_str[i]) + 1, fp);\n}\n\nint\nngram_model_trie_write_bin(ngram_model_t * base, const char *path)\n{\n    int i;\n    int32 is_pipe;\n    ngram_model_trie_t *model = (ngram_model_trie_t *) base;\n    FILE *fp = fopen_comp(path, \"wb\", &is_pipe);\n    if (!fp) {\n        E_ERROR(\"Unable to open %s to write binary trie LM\\n\", path);\n        return -1;\n    }\n\n    fwrite(trie_hdr, sizeof(*trie_hdr), strlen(trie_hdr), fp);\n    fwrite(&model->base.n, sizeof(model->base.n), 1, fp);\n    for (i = 0; i < model->base.n; i++) {\n        fwrite(&model->base.n_counts[i], sizeof(model->base.n_counts[i]),\n               1, fp);\n    }\n    lm_trie_write_bin(model->trie, base->n_counts[0], fp);\n    write_word_str(fp, base);\n    fclose_comp(fp, is_pipe);\n    return 0;\n}\n\nngram_model_t *\nngram_model_trie_read_dmp(cmd_ln_t * config,\n                          const char *file_name, logmath_t * lmath)\n{\n    uint8 do_swap;\n    int32 is_pipe;\n    int32 k;\n    uint32 j;\n    int32 vn, ts;\n    int32 count;\n    uint32 counts[3];\n    uint32 *unigram_next;\n    int order;\n    char str[1024];\n    FILE *fp;\n    ngram_model_trie_t *model;\n    ngram_model_t *base;\n    ngram_raw_t **raw_ngrams;\n\n    E_INFO(\"Trying to read LM in dmp format\\n\");\n    if ((fp = fopen_comp(file_name, \"rb\", &is_pipe)) == NULL) {\n        E_ERROR(\"Dump file %s not found\\n\", file_name);\n        return NULL;\n    }\n\n    do_swap = FALSE;\n    fread(&k, sizeof(k), 1, fp);\n    if (k != strlen(dmp_hdr) + 1) {\n        SWAP_INT32(&k);\n        if (k != strlen(dmp_hdr) + 1) {\n            E_ERROR\n                (\"Wrong magic header size number %x: %s is not a dump file\\n\",\n                 k, file_name);\n            return NULL;\n        }\n        do_swap = 1;\n    }\n    if (fread(str, 1, k, fp) != (size_t) k) {\n        E_ERROR(\"Cannot read header\\n\");\n        return NULL;\n    }\n    if (strncmp(str, dmp_hdr, k) != 0) {\n        E_ERROR(\"Wrong header %s: %s is not a dump file\\n\", dmp_hdr);\n        return NULL;\n    }\n\n    if (fread(&k, sizeof(k), 1, fp) != 1)\n        return NULL;\n    if (do_swap)\n        SWAP_INT32(&k);\n    if (fread(str, 1, k, fp) != (size_t) k) {\n        E_ERROR(\"Cannot read LM filename in header\\n\");\n        return NULL;\n    }\n\n    /* read version#, if present (must be <= 0) */\n    if (fread(&vn, sizeof(vn), 1, fp) != 1)\n        return NULL;\n    if (do_swap)\n        SWAP_INT32(&vn);\n    if (vn <= 0) {\n        /* read and don't compare timestamps (we don't care) */\n        if (fread(&ts, sizeof(ts), 1, fp) != 1)\n            return NULL;\n        if (do_swap)\n            SWAP_INT32(&ts);\n\n        /* read and skip format description */\n        for (;;) {\n            if (fread(&k, sizeof(k), 1, fp) != 1)\n                return NULL;\n            if (do_swap)\n                SWAP_INT32(&k);\n            if (k == 0)\n                break;\n            if (fread(str, 1, k, fp) != (size_t) k) {\n                E_ERROR(\"Failed to read word\\n\");\n                return NULL;\n            }\n        }\n        /* read model->ucount */\n        if (fread(&count, sizeof(count), 1, fp) != 1)\n            return NULL;\n        if (do_swap)\n            SWAP_INT32(&count);\n        counts[0] = count;\n    }\n    else {\n        counts[0] = vn;\n    }\n    /* read model->bcount, tcount */\n    if (fread(&count, sizeof(count), 1, fp) != 1)\n        return NULL;\n    if (do_swap)\n        SWAP_INT32(&count);\n    counts[1] = count;\n    if (fread(&count, sizeof(count), 1, fp) != 1)\n        return NULL;\n    if (do_swap)\n        SWAP_INT32(&count);\n    counts[2] = count;\n    E_INFO(\"ngrams 1=%d, 2=%d, 3=%d\\n\", counts[0], counts[1], counts[2]);\n\n    model = (ngram_model_trie_t *) ckd_calloc(1, sizeof(*model));\n    base = &model->base;\n    if (counts[2] > 0)\n        order = 3;\n    else if (counts[1] > 0)\n        order = 2;\n    else\n        order = 1;\n    ngram_model_init(base, &ngram_model_trie_funcs, lmath, order,\n                     (int32) counts[0]);\n\n    model->trie = lm_trie_create(counts[0], order);\n\n    unigram_next =\n        (uint32 *) ckd_calloc((int32) counts[0] + 1, sizeof(unigram_next));\n    for (j = 0; j <= (int32) counts[0]; j++) {\n        int32 bigrams;\n        int32 mapid;\n        dmp_weight_t weightp;\n        dmp_weight_t weightb;\n\n        /* Skip over the mapping ID, we don't care about it. */\n        /* Read the weights from actual unigram structure. */\n        fread(&mapid, sizeof(int32), 1, fp);\n        fread(&weightp, sizeof(weightp), 1, fp);\n        fread(&weightb, sizeof(weightb), 1, fp);\n        fread(&bigrams, sizeof(int32), 1, fp);\n        if (do_swap) {\n            SWAP_INT32(&weightp.l);\n            SWAP_INT32(&weightb.l);\n            SWAP_INT32(&bigrams);\n        }\n        model->trie->unigrams[j].prob = logmath_log10_to_log_float(lmath, weightp.f);\n        model->trie->unigrams[j].bo = logmath_log10_to_log_float(lmath, weightb.f);\n        model->trie->unigrams[j].next = bigrams;\n        unigram_next[j] = bigrams;\n    }\n\n    if (order > 1) {\n        raw_ngrams =\n            ngrams_raw_read_dmp(fp, lmath, counts, order, unigram_next,\n                                do_swap);\n        if (raw_ngrams == NULL) {\n            ngram_model_free(base);\n            ckd_free(unigram_next);\n            fclose_comp(fp, is_pipe);\n            return NULL;\n        }\n        lm_trie_build(model->trie, raw_ngrams, counts, base->n_counts, order);        \n        ngrams_raw_free(raw_ngrams, counts, order);\n    }\n    \n    /* Sentinel unigram and bigrams read before */\n    ckd_free(unigram_next);\n\n    /* read ascii word strings */\n    read_word_str(base, fp);\n\n    fclose_comp(fp, is_pipe);\n    return base;\n}\n\nstatic void\nngram_model_trie_free(ngram_model_t * base)\n{\n    ngram_model_trie_t *model = (ngram_model_trie_t *) base;\n    lm_trie_free(model->trie);\n}\n\nstatic int\ntrie_apply_weights(ngram_model_t * base, float32 lw, float32 wip)\n{\n    /* just update weights that are going to be used on score calculation */\n    base->lw = lw;\n    base->log_wip = logmath_log(base->lmath, wip);\n    return 0;\n}\n\nstatic int32\nweight_score(ngram_model_t * base, int32 score)\n{\n    return (int32) (score * base->lw + base->log_wip);\n}\n\nstatic int32\nngram_model_trie_raw_score(ngram_model_t * base, int32 wid, int32 * hist,\n                           int32 n_hist, int32 * n_used)\n{\n    int32 i;\n    ngram_model_trie_t *model = (ngram_model_trie_t *) base;\n\n    if (n_hist > model->base.n - 1)\n        n_hist = model->base.n - 1;\n    for (i = 0; i < n_hist; i++) {\n        if (hist[i] < 0) {\n            n_hist = i;\n            break;\n        }\n    }\n\n    return (int32) lm_trie_score(model->trie, model->base.n, wid, hist,\n                                 n_hist, n_used);\n}\n\nstatic int32\nngram_model_trie_score(ngram_model_t * base, int32 wid, int32 * hist,\n                       int32 n_hist, int32 * n_used)\n{\n    return weight_score(base,\n                        ngram_model_trie_raw_score(base, wid, hist, n_hist,\n                                                   n_used));\n}\n\nstatic int32\nlm_trie_add_ug(ngram_model_t * base, int32 wid, int32 lweight)\n{\n    ngram_model_trie_t *model = (ngram_model_trie_t *) base;\n\n    /* This would be very bad if this happened! */\n    assert(!NGRAM_IS_CLASSWID(wid));\n\n    /* Reallocate unigram array. */\n    model->trie->unigrams =\n        (unigram_t *) ckd_realloc(model->trie->unigrams,\n                                  sizeof(*model->trie->unigrams) *\n                                  (base->n_1g_alloc + 1));\n    memset(model->trie->unigrams + (base->n_counts[0] + 1), 0,\n           (size_t) (base->n_1g_alloc -\n                     base->n_counts[0]) * sizeof(*model->trie->unigrams));\n    ++base->n_counts[0];\n    lweight += logmath_log(base->lmath, 1.0 / base->n_counts[0]);\n    model->trie->unigrams[wid + 1].next = model->trie->unigrams[wid].next;\n    model->trie->unigrams[wid].prob = (float) lweight;\n    /* This unigram by definition doesn't participate in any bigrams,\n     * so its backoff weight is undefined and next pointer same as in finish unigram*/\n    model->trie->unigrams[wid].bo = 0;\n    /* Finally, increase the unigram count */\n    /* FIXME: Note that this can actually be quite bogus due to the\n     * presence of class words.  If wid falls outside the unigram\n     * count, increase it to compensate, at the cost of no longer\n     * really knowing how many unigrams we have :( */\n    if ((uint32) wid >= base->n_counts[0])\n        base->n_counts[0] = wid + 1;\n\n    return (int32) weight_score(base, lweight);\n}\n\nstatic void\nlm_trie_flush(ngram_model_t * base)\n{\n    ngram_model_trie_t *model = (ngram_model_trie_t *) base;\n    lm_trie_t *trie = model->trie;\n    memset(trie->hist_cache, -1, sizeof(trie->hist_cache));\n    memset(trie->backoff_cache, 0, sizeof(trie->backoff_cache));\n    return;\n}\n\nstatic ngram_funcs_t ngram_model_trie_funcs = {\n    ngram_model_trie_free,      /* free */\n    trie_apply_weights,         /* apply_weights */\n    ngram_model_trie_score,     /* score */\n    ngram_model_trie_raw_score, /* raw_score */\n    lm_trie_add_ug,             /* add_ug */\n    lm_trie_flush               /* flush */\n};\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2007 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * \\file ngram_model.c N-Gram language models.\n *\n * Author: David Huggins-Daines, much code taken from sphinx3/src/libs3decoder/liblm\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <string.h>\n#include <assert.h>\n\n#include \"sphinxbase/ngram_model.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/filename.h\"\n#include \"sphinxbase/pio.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/logmath.h\"\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/case.h\"\n\n#include \"ngram_model_internal.h\"\n#include \"ngram_model_trie.h\"\n\nngram_file_type_t\nngram_file_name_to_type(const char *file_name)\n{\n    const char *ext;\n\n    ext = strrchr(file_name, '.');\n    if (ext == NULL) {\n        return NGRAM_INVALID;\n    }\n    if (0 == strcmp_nocase(ext, \".gz\")) {\n        while (--ext >= file_name) {\n            if (*ext == '.')\n                break;\n        }\n        if (ext < file_name) {\n            return NGRAM_INVALID;\n        }\n    }\n    else if (0 == strcmp_nocase(ext, \".bz2\")) {\n        while (--ext >= file_name) {\n            if (*ext == '.')\n                break;\n        }\n        if (ext < file_name) {\n            return NGRAM_INVALID;\n        }\n    }\n    /* We use strncmp because there might be a .gz on the end. */\n    if (0 == strncmp_nocase(ext, \".ARPA\", 5))\n        return NGRAM_ARPA;\n    if (0 == strncmp_nocase(ext, \".DMP\", 4)\n        || 0 == strncmp_nocase(ext, \".BIN\", 4))\n        return NGRAM_BIN;\n    return NGRAM_INVALID;\n}\n\nngram_file_type_t\nngram_str_to_type(const char *str_name)\n{\n    if (0 == strcmp_nocase(str_name, \"arpa\"))\n        return NGRAM_ARPA;\n    if (0 == strcmp_nocase(str_name, \"dmp\")\n        || 0 == strcmp_nocase(str_name, \"bin\"))\n        return NGRAM_BIN;\n    return NGRAM_INVALID;\n}\n\nchar const *\nngram_type_to_str(int type)\n{\n    switch (type) {\n    case NGRAM_ARPA:\n        return \"arpa\";\n    case NGRAM_BIN:\n        return \"dmp/bin\";\n    default:\n        return NULL;\n    }\n}\n\n\nngram_model_t *\nngram_model_read(cmd_ln_t * config,\n                 const char *file_name,\n                 ngram_file_type_t file_type, logmath_t * lmath)\n{\n    ngram_model_t *model = NULL;\n    switch (file_type) {\n    case NGRAM_AUTO:{\n            if ((model =\n                 ngram_model_trie_read_bin(config, file_name,\n                                           lmath)) != NULL)\n                break;\n            if ((model =\n                 ngram_model_trie_read_arpa(config, file_name,\n                                            lmath)) != NULL)\n                break;\n            if ((model =\n                 ngram_model_trie_read_dmp(config, file_name,\n                                           lmath)) != NULL)\n                break;\n            return NULL;\n        }\n    case NGRAM_ARPA:\n        model = ngram_model_trie_read_arpa(config, file_name, lmath);\n        break;\n    case NGRAM_BIN:\n        if ((model =\n             ngram_model_trie_read_bin(config, file_name, lmath)) != NULL)\n            break;\n        if ((model =\n             ngram_model_trie_read_dmp(config, file_name, lmath)) != NULL)\n            break;\n        return NULL;\n    default:\n        E_ERROR(\"language model file type not supported\\n\");\n        return NULL;\n    }\n\n    /* Now set weights based on config if present. */\n    if (config) {\n        float32 lw = 1.0;\n        float32 wip = 1.0;\n\n        if (cmd_ln_exists_r(config, \"-lw\"))\n            lw = cmd_ln_float32_r(config, \"-lw\");\n        if (cmd_ln_exists_r(config, \"-wip\"))\n            wip = cmd_ln_float32_r(config, \"-wip\");\n\n        ngram_model_apply_weights(model, lw, wip);\n    }\n\n    return model;\n}\n\nint\nngram_model_write(ngram_model_t * model, const char *file_name,\n                  ngram_file_type_t file_type)\n{\n    switch (file_type) {\n    case NGRAM_AUTO:{\n            file_type = ngram_file_name_to_type(file_name);\n            /* Default to ARPA (catches .lm and other things) */\n            if (file_type == NGRAM_INVALID)\n                file_type = NGRAM_ARPA;\n            return ngram_model_write(model, file_name, file_type);\n        }\n    case NGRAM_ARPA:\n        return ngram_model_trie_write_arpa(model, file_name);\n    case NGRAM_BIN:\n        return ngram_model_trie_write_bin(model, file_name);\n    default:\n        E_ERROR(\"language model file type not supported\\n\");\n        return -1;\n    }\n    E_ERROR(\"language model file type not supported\\n\");\n    return -1;\n}\n\nint32\nngram_model_init(ngram_model_t * base,\n                 ngram_funcs_t * funcs,\n                 logmath_t * lmath, int32 n, int32 n_unigram)\n{\n    base->refcount = 1;\n    base->funcs = funcs;\n    base->n = n;\n    /* If this was previously initialized... */\n    if (base->n_counts == NULL)\n        base->n_counts = (uint32 *) ckd_calloc(n, sizeof(*base->n_counts));\n    /* Don't reset weights if logmath object hasn't changed. */\n    if (base->lmath != lmath) {\n        /* Set default values for weights. */\n        base->lw = 1.0;\n        base->log_wip = 0;      /* i.e. 1.0 */\n        base->log_zero = logmath_get_zero(lmath);\n        base->lmath = lmath;\n    }\n    /* Allocate or reallocate space for word strings. */\n    if (base->word_str) {\n        /* Free all previous word strings if they were allocated. */\n        if (base->writable) {\n            int32 i;\n            for (i = 0; i < base->n_words; ++i) {\n                ckd_free(base->word_str[i]);\n                base->word_str[i] = NULL;\n            }\n        }\n        base->word_str =\n            (char **) ckd_realloc(base->word_str,\n                                  n_unigram * sizeof(char *));\n    }\n    else {\n        base->word_str = (char **) ckd_calloc(n_unigram, sizeof(char *));\n    }\n    /* NOTE: They are no longer case-insensitive since we are allowing\n     * other encodings for word strings.  Beware. */\n    if (base->wid)\n        hash_table_empty(base->wid);\n    else\n        base->wid = hash_table_new(n_unigram, FALSE);\n    base->n_counts[0] = base->n_1g_alloc = base->n_words = n_unigram;\n\n    return 0;\n}\n\nngram_model_t *\nngram_model_retain(ngram_model_t * model)\n{\n    ++model->refcount;\n    return model;\n}\n\nvoid\nngram_model_flush(ngram_model_t * model)\n{\n    if (model->funcs && model->funcs->flush)\n        (*model->funcs->flush) (model);\n}\n\nint\nngram_model_free(ngram_model_t * model)\n{\n    int i;\n\n    if (model == NULL)\n        return 0;\n    if (--model->refcount > 0)\n        return model->refcount;\n    if (model->funcs && model->funcs->free)\n        (*model->funcs->free) (model);\n    if (model->writable) {\n        /* Free all words. */\n        for (i = 0; i < model->n_words; ++i) {\n            ckd_free(model->word_str[i]);\n        }\n    }\n    else {\n        /* Free all class words. */\n        for (i = 0; i < model->n_classes; ++i) {\n            ngram_class_t *lmclass;\n            int32 j;\n\n            lmclass = model->classes[i];\n            for (j = 0; j < lmclass->n_words; ++j) {\n                ckd_free(model->word_str[lmclass->start_wid + j]);\n            }\n            for (j = 0; j < lmclass->n_hash; ++j) {\n                if (lmclass->nword_hash[j].wid != -1) {\n                    ckd_free(model->word_str[lmclass->nword_hash[j].wid]);\n                }\n            }\n        }\n    }\n    for (i = 0; i < model->n_classes; ++i) {\n        ngram_class_free(model->classes[i]);\n    }\n    ckd_free(model->classes);\n    hash_table_free(model->wid);\n    ckd_free(model->word_str);\n    ckd_free(model->n_counts);\n    ckd_free(model);\n    return 0;\n}\n\nint\nngram_model_casefold(ngram_model_t * model, int kase)\n{\n    int writable, i;\n    hash_table_t *new_wid;\n\n    /* Were word strings already allocated? */\n    writable = model->writable;\n    /* Either way, we are going to allocate some word strings. */\n    model->writable = TRUE;\n\n    /* And, don't forget, we need to rebuild the word to unigram ID\n     * mapping. */\n    new_wid = hash_table_new(model->n_words, FALSE);\n    for (i = 0; i < model->n_words; ++i) {\n        char *outstr;\n        if (writable) {\n            outstr = model->word_str[i];\n        }\n        else {\n            outstr = ckd_salloc(model->word_str[i]);\n        }\n        /* Don't case-fold <tags> or [classes] */\n        if (outstr[0] == '<' || outstr[0] == '[') {\n        }\n        else {\n            switch (kase) {\n            case NGRAM_UPPER:\n                ucase(outstr);\n                break;\n            case NGRAM_LOWER:\n                lcase(outstr);\n                break;\n            default:\n                ;\n            }\n        }\n        model->word_str[i] = outstr;\n\n        /* Now update the hash table.  We might have terrible\n         * collisions here, so warn about them. */\n        if (hash_table_enter_int32(new_wid, model->word_str[i], i) != i) {\n            E_WARN(\"Duplicate word in dictionary after conversion: %s\\n\",\n                   model->word_str[i]);\n        }\n    }\n    /* Swap out the hash table. */\n    hash_table_free(model->wid);\n    model->wid = new_wid;\n    return 0;\n}\n\nint\nngram_model_apply_weights(ngram_model_t * model, float32 lw, float32 wip)\n{\n    return (*model->funcs->apply_weights) (model, lw, wip);\n}\n\nfloat32\nngram_model_get_weights(ngram_model_t * model, int32 * out_log_wip)\n{\n    if (out_log_wip)\n        *out_log_wip = model->log_wip;\n    return model->lw;\n}\n\n\nint32\nngram_ng_score(ngram_model_t * model, int32 wid, int32 * history,\n               int32 n_hist, int32 * n_used)\n{\n    int32 score, class_weight = 0;\n    int i;\n\n    /* Closed vocabulary, OOV word probability is zero */\n    if (wid == NGRAM_INVALID_WID)\n        return model->log_zero;\n\n    /* \"Declassify\" wid and history */\n    if (NGRAM_IS_CLASSWID(wid)) {\n        ngram_class_t *lmclass = model->classes[NGRAM_CLASSID(wid)];\n\n        class_weight = ngram_class_prob(lmclass, wid);\n        if (class_weight == 1)  /* Meaning, not found in class. */\n            return model->log_zero;\n        wid = lmclass->tag_wid;\n    }\n    for (i = 0; i < n_hist; ++i) {\n        if (history[i] != NGRAM_INVALID_WID\n            && NGRAM_IS_CLASSWID(history[i]))\n            history[i] =\n                model->classes[NGRAM_CLASSID(history[i])]->tag_wid;\n    }\n    score = (*model->funcs->score) (model, wid, history, n_hist, n_used);\n\n    /* Multiply by unigram in-class weight. */\n    return score + class_weight;\n}\n\nint32\nngram_score(ngram_model_t * model, const char *word, ...)\n{\n    va_list history;\n    const char *hword;\n    int32 *histid;\n    int32 n_hist;\n    int32 n_used;\n    int32 prob;\n\n    va_start(history, word);\n    n_hist = 0;\n    while ((hword = va_arg(history, const char *)) != NULL)\n        ++n_hist;\n    va_end(history);\n\n    histid = ckd_calloc(n_hist, sizeof(*histid));\n    va_start(history, word);\n    n_hist = 0;\n    while ((hword = va_arg(history, const char *)) != NULL) {\n        histid[n_hist] = ngram_wid(model, hword);\n        ++n_hist;\n    }\n    va_end(history);\n\n    prob = ngram_ng_score(model, ngram_wid(model, word),\n                          histid, n_hist, &n_used);\n    ckd_free(histid);\n    return prob;\n}\n\nint32\nngram_tg_score(ngram_model_t * model, int32 w3, int32 w2, int32 w1,\n               int32 * n_used)\n{\n    int32 hist[2];\n    hist[0] = w2;\n    hist[1] = w1;\n    return ngram_ng_score(model, w3, hist, 2, n_used);\n}\n\nint32\nngram_bg_score(ngram_model_t * model, int32 w2, int32 w1, int32 * n_used)\n{\n    return ngram_ng_score(model, w2, &w1, 1, n_used);\n}\n\nint32\nngram_ng_prob(ngram_model_t * model, int32 wid, int32 * history,\n              int32 n_hist, int32 * n_used)\n{\n    int32 prob, class_weight = 0;\n    int i;\n\n    /* Closed vocabulary, OOV word probability is zero */\n    if (wid == NGRAM_INVALID_WID)\n        return model->log_zero;\n\n    /* \"Declassify\" wid and history */\n    if (NGRAM_IS_CLASSWID(wid)) {\n        ngram_class_t *lmclass = model->classes[NGRAM_CLASSID(wid)];\n\n        class_weight = ngram_class_prob(lmclass, wid);\n        if (class_weight == 1)  /* Meaning, not found in class. */\n            return class_weight;\n        wid = lmclass->tag_wid;\n    }\n    for (i = 0; i < n_hist; ++i) {\n        if (history[i] != NGRAM_INVALID_WID\n            && NGRAM_IS_CLASSWID(history[i]))\n            history[i] =\n                model->classes[NGRAM_CLASSID(history[i])]->tag_wid;\n    }\n    prob = (*model->funcs->raw_score) (model, wid, history,\n                                       n_hist, n_used);\n    /* Multiply by unigram in-class weight. */\n    return prob + class_weight;\n}\n\nint32\nngram_probv(ngram_model_t * model, const char *word, ...)\n{\n    va_list history;\n    const char *hword;\n    int32 *histid;\n    int32 n_hist;\n    int32 n_used;\n    int32 prob;\n\n    va_start(history, word);\n    n_hist = 0;\n    while ((hword = va_arg(history, const char *)) != NULL)\n        ++n_hist;\n    va_end(history);\n\n    histid = ckd_calloc(n_hist, sizeof(*histid));\n    va_start(history, word);\n    n_hist = 0;\n    while ((hword = va_arg(history, const char *)) != NULL) {\n        histid[n_hist] = ngram_wid(model, hword);\n        ++n_hist;\n    }\n    va_end(history);\n\n    prob = ngram_ng_prob(model, ngram_wid(model, word),\n                         histid, n_hist, &n_used);\n    ckd_free(histid);\n    return prob;\n}\n\nint32\nngram_prob(ngram_model_t * model, const char* const *words, int32 n)\n{\n    int32 *ctx_id;\n    int32 nused;\n    int32 prob;\n    int32 wid;\n    uint32 i;\n\n    ctx_id = (int32 *) ckd_calloc(n - 1, sizeof(*ctx_id));\n    for (i = 1; i < (uint32) n; ++i)\n        ctx_id[i - 1] = ngram_wid(model, words[i]);\n\n    wid = ngram_wid(model, *words);\n    prob = ngram_ng_prob(model, wid, ctx_id, n - 1, &nused);\n    ckd_free(ctx_id);\n\n    return prob;\n}\n\nint32\nngram_score_to_prob(ngram_model_t * base, int32 score)\n{\n    int32 prob;\n\n    /* Undo insertion penalty. */\n    prob = score - base->log_wip;\n    /* Undo language weight. */\n    prob = (int32) (prob / base->lw);\n\n    return prob;\n}\n\nint32\nngram_unknown_wid(ngram_model_t * model)\n{\n    int32 val;\n\n    /* FIXME: This could be memoized for speed if necessary. */\n    /* Look up <UNK>, if not found return NGRAM_INVALID_WID. */\n    if (hash_table_lookup_int32(model->wid, \"<UNK>\", &val) == -1)\n        return NGRAM_INVALID_WID;\n    else\n        return val;\n}\n\nint32\nngram_zero(ngram_model_t * model)\n{\n    return model->log_zero;\n}\n\nint32\nngram_model_get_size(ngram_model_t * model)\n{\n    if (model != NULL)\n        return model->n;\n    return 0;\n}\n\nuint32 const *\nngram_model_get_counts(ngram_model_t * model)\n{\n    if (model != NULL)\n        return model->n_counts;\n    return NULL;\n}\n\nint32\nngram_wid(ngram_model_t * model, const char *word)\n{\n    int32 val;\n\n    if (hash_table_lookup_int32(model->wid, word, &val) == -1)\n        return ngram_unknown_wid(model);\n    else\n        return val;\n}\n\nconst char *\nngram_word(ngram_model_t * model, int32 wid)\n{\n    /* Remove any class tag */\n    wid = NGRAM_BASEWID(wid);\n    if (wid >= model->n_words)\n        return NULL;\n    return model->word_str[wid];\n}\n\n/**\n * Add a word to the word string and ID mapping.\n */\nint32\nngram_add_word_internal(ngram_model_t * model,\n                        const char *word, int32 classid)\n{\n\n    /* Check for hash collisions. */\n    int32 wid;\n    if (hash_table_lookup_int32(model->wid, word, &wid) == 0) {\n        E_WARN(\"Omit duplicate word '%s'\\n\", word);\n        return wid;\n    }\n\n    /* Take the next available word ID */\n    wid = model->n_words;\n    if (classid >= 0) {\n        wid = NGRAM_CLASSWID(wid, classid);\n    }\n\n    /* Reallocate word_str if necessary. */\n    if (model->n_words >= model->n_1g_alloc) {\n        model->n_1g_alloc += UG_ALLOC_STEP;\n        model->word_str = ckd_realloc(model->word_str,\n                                      sizeof(*model->word_str) *\n                                      model->n_1g_alloc);\n    }\n    /* Add the word string in the appropriate manner. */\n    /* Class words are always dynamically allocated. */\n    model->word_str[model->n_words] = ckd_salloc(word);\n    /* Now enter it into the hash table. */\n    if (hash_table_enter_int32\n        (model->wid, model->word_str[model->n_words], wid) != wid) {\n        E_ERROR\n            (\"Hash insertion failed for word %s => %p (should not happen)\\n\",\n             model->word_str[model->n_words], (void *) (long) (wid));\n    }\n    /* Increment number of words. */\n    ++model->n_words;\n    return wid;\n}\n\nint32\nngram_model_add_word(ngram_model_t * model,\n                     const char *word, float32 weight)\n{\n    int32 wid, prob = model->log_zero;\n\n    /* If we add word to unwritable model, we need to make it writable */\n    if (!model->writable) {\n        E_WARN(\"Can't add word '%s' to read-only language model. \"\n               \"Disable mmap with '-mmap no' to make it writable\\n\", word);\n        return -1;\n    }\n\n    wid = ngram_add_word_internal(model, word, -1);\n    if (wid == NGRAM_INVALID_WID)\n        return wid;\n\n    /* Do what needs to be done to add the word to the unigram. */\n    if (model->funcs && model->funcs->add_ug)\n        prob =\n            (*model->funcs->add_ug) (model, wid,\n                                     logmath_log(model->lmath, weight));\n    if (prob == 0)\n        return -1;\n\n    return wid;\n}\n\nngram_class_t *\nngram_class_new(ngram_model_t * model, int32 tag_wid, int32 start_wid,\n                glist_t classwords)\n{\n    ngram_class_t *lmclass;\n    gnode_t *gn;\n    float32 tprob;\n    int i;\n\n    lmclass = ckd_calloc(1, sizeof(*lmclass));\n    lmclass->tag_wid = tag_wid;\n    /* wid_base is the wid (minus class tag) of the first word in the list. */\n    lmclass->start_wid = start_wid;\n    lmclass->n_words = glist_count(classwords);\n    lmclass->prob1 = ckd_calloc(lmclass->n_words, sizeof(*lmclass->prob1));\n    lmclass->nword_hash = NULL;\n    lmclass->n_hash = 0;\n    tprob = 0.0;\n    for (gn = classwords; gn; gn = gnode_next(gn)) {\n        tprob += gnode_float32(gn);\n    }\n    if (tprob > 1.1 || tprob < 0.9) {\n        E_INFO(\"Total class probability is %f, will normalize\\n\", tprob);\n        for (gn = classwords; gn; gn = gnode_next(gn)) {\n            gn->data.fl /= tprob;\n        }\n    }\n    for (i = 0, gn = classwords; gn; ++i, gn = gnode_next(gn)) {\n        lmclass->prob1[i] = logmath_log(model->lmath, gnode_float32(gn));\n    }\n\n    return lmclass;\n}\n\nint32\nngram_class_add_word(ngram_class_t * lmclass, int32 wid, int32 lweight)\n{\n    int32 hash;\n\n    if (lmclass->nword_hash == NULL) {\n        /* Initialize everything in it to -1 */\n        lmclass->nword_hash =\n            ckd_malloc(NGRAM_HASH_SIZE * sizeof(*lmclass->nword_hash));\n        memset(lmclass->nword_hash, 0xff,\n               NGRAM_HASH_SIZE * sizeof(*lmclass->nword_hash));\n        lmclass->n_hash = NGRAM_HASH_SIZE;\n        lmclass->n_hash_inuse = 0;\n    }\n    /* Stupidest possible hash function.  This will work pretty well\n     * when this function is called repeatedly with contiguous word\n     * IDs, though... */\n    hash = wid & (lmclass->n_hash - 1);\n    if (lmclass->nword_hash[hash].wid == -1) {\n        /* Good, no collision. */\n        lmclass->nword_hash[hash].wid = wid;\n        lmclass->nword_hash[hash].prob1 = lweight;\n        ++lmclass->n_hash_inuse;\n        return hash;\n    }\n    else {\n        int32 next; /**< Next available bucket. */\n        /* Collision... Find the end of the hash chain. */\n        while (lmclass->nword_hash[hash].next != -1)\n            hash = lmclass->nword_hash[hash].next;\n        assert(hash != -1);\n        /* Does we has any more bukkit? */\n        if (lmclass->n_hash_inuse == lmclass->n_hash) {\n            /* Oh noes!  Ok, we makes more. */\n            lmclass->nword_hash = ckd_realloc(lmclass->nword_hash,\n                                              lmclass->n_hash * 2 *\n                                              sizeof(*lmclass->\n                                                     nword_hash));\n            memset(lmclass->nword_hash + lmclass->n_hash, 0xff,\n                   lmclass->n_hash * sizeof(*lmclass->nword_hash));\n            /* Just use the next allocated one (easy) */\n            next = lmclass->n_hash;\n            lmclass->n_hash *= 2;\n        }\n        else {\n            /* Look for any available bucket.  We hope this doesn't happen. */\n            for (next = 0; next < lmclass->n_hash; ++next)\n                if (lmclass->nword_hash[next].wid == -1)\n                    break;\n            /* This should absolutely not happen. */\n            assert(next != lmclass->n_hash);\n        }\n        lmclass->nword_hash[next].wid = wid;\n        lmclass->nword_hash[next].prob1 = lweight;\n        lmclass->nword_hash[hash].next = next;\n        ++lmclass->n_hash_inuse;\n        return next;\n    }\n}\n\nvoid\nngram_class_free(ngram_class_t * lmclass)\n{\n    ckd_free(lmclass->nword_hash);\n    ckd_free(lmclass->prob1);\n    ckd_free(lmclass);\n}\n\nint32\nngram_model_add_class_word(ngram_model_t * model,\n                           const char *classname,\n                           const char *word, float32 weight)\n{\n    ngram_class_t *lmclass;\n    int32 classid, tag_wid, wid, i, scale;\n    float32 fprob;\n\n    /* Find the class corresponding to classname.  Linear search\n     * probably okay here since there won't be very many classes, and\n     * this doesn't have to be fast. */\n    tag_wid = ngram_wid(model, classname);\n    if (tag_wid == NGRAM_INVALID_WID) {\n        E_ERROR(\"No such word or class tag: %s\\n\", classname);\n        return tag_wid;\n    }\n    for (classid = 0; classid < model->n_classes; ++classid) {\n        if (model->classes[classid]->tag_wid == tag_wid)\n            break;\n    }\n    /* Hmm, no such class.  It's probably not a good idea to create one. */\n    if (classid == model->n_classes) {\n        E_ERROR\n            (\"Word %s is not a class tag (call ngram_model_add_class() first)\\n\",\n             classname);\n        return NGRAM_INVALID_WID;\n    }\n    lmclass = model->classes[classid];\n\n    /* Add this word to the model's set of words. */\n    wid = ngram_add_word_internal(model, word, classid);\n    if (wid == NGRAM_INVALID_WID)\n        return wid;\n\n    /* This is the fixed probability of the new word. */\n    fprob = weight * 1.0f / (lmclass->n_words + lmclass->n_hash_inuse + 1);\n    /* Now normalize everything else to fit it in.  This is\n     * accomplished by simply scaling all the other probabilities\n     * by (1-fprob). */\n    scale = logmath_log(model->lmath, 1.0 - fprob);\n    for (i = 0; i < lmclass->n_words; ++i)\n        lmclass->prob1[i] += scale;\n    for (i = 0; i < lmclass->n_hash; ++i)\n        if (lmclass->nword_hash[i].wid != -1)\n            lmclass->nword_hash[i].prob1 += scale;\n\n    /* Now add it to the class hash table. */\n    return ngram_class_add_word(lmclass, wid,\n                                logmath_log(model->lmath, fprob));\n}\n\nint32\nngram_model_add_class(ngram_model_t * model,\n                      const char *classname,\n                      float32 classweight,\n                      char **words, const float32 * weights, int32 n_words)\n{\n    ngram_class_t *lmclass;\n    glist_t classwords = NULL;\n    int32 i, start_wid = -1;\n    int32 classid, tag_wid;\n\n    /* Check if classname already exists in model.  If not, add it. */\n    if ((tag_wid =\n         ngram_wid(model, classname)) == ngram_unknown_wid(model)) {\n        tag_wid = ngram_model_add_word(model, classname, classweight);\n        if (tag_wid == NGRAM_INVALID_WID)\n            return -1;\n    }\n\n    if (model->n_classes == 128) {\n        E_ERROR(\"Number of classes cannot exceed 128 (sorry)\\n\");\n        return -1;\n    }\n    classid = model->n_classes;\n    for (i = 0; i < n_words; ++i) {\n        int32 wid;\n\n        wid = ngram_add_word_internal(model, words[i], classid);\n        if (wid == NGRAM_INVALID_WID)\n            return -1;\n        if (start_wid == -1)\n            start_wid = NGRAM_BASEWID(wid);\n        classwords = glist_add_float32(classwords, weights[i]);\n    }\n    classwords = glist_reverse(classwords);\n    lmclass = ngram_class_new(model, tag_wid, start_wid, classwords);\n    glist_free(classwords);\n    if (lmclass == NULL)\n        return -1;\n\n    ++model->n_classes;\n    if (model->classes == NULL)\n        model->classes = ckd_calloc(1, sizeof(*model->classes));\n    else\n        model->classes = ckd_realloc(model->classes,\n                                     model->n_classes *\n                                     sizeof(*model->classes));\n    model->classes[classid] = lmclass;\n    return classid;\n}\n\nint32\nngram_class_prob(ngram_class_t * lmclass, int32 wid)\n{\n    int32 base_wid = NGRAM_BASEWID(wid);\n\n    if (base_wid < lmclass->start_wid\n        || base_wid > lmclass->start_wid + lmclass->n_words) {\n        int32 hash;\n\n        /* Look it up in the hash table. */\n        hash = wid & (lmclass->n_hash - 1);\n        while (hash != -1 && lmclass->nword_hash[hash].wid != wid)\n            hash = lmclass->nword_hash[hash].next;\n        if (hash == -1)\n            return 1;\n        return lmclass->nword_hash[hash].prob1;\n    }\n    else {\n        return lmclass->prob1[base_wid - lmclass->start_wid];\n    }\n}\n\nint32\nread_classdef_file(hash_table_t * classes, const char *file_name)\n{\n    FILE *fp;\n    int32 is_pipe;\n    int inclass;  /**< Are we currently reading a list of class words? */\n    int32 rv = -1;\n    gnode_t *gn;\n    glist_t classwords = NULL;\n    glist_t classprobs = NULL;\n    char *classname = NULL;\n\n    if ((fp = fopen_comp(file_name, \"r\", &is_pipe)) == NULL) {\n        E_ERROR(\"File %s not found\\n\", file_name);\n        return -1;\n    }\n\n    inclass = FALSE;\n    while (!feof(fp)) {\n        char line[512];\n        char *wptr[2];\n        int n_words;\n\n        if (fgets(line, sizeof(line), fp) == NULL)\n            break;\n\n        n_words = str2words(line, wptr, 2);\n        if (n_words <= 0)\n            continue;\n\n        if (inclass) {\n            /* Look for an end of class marker. */\n            if (n_words == 2 && 0 == strcmp(wptr[0], \"END\")) {\n                classdef_t *classdef;\n                gnode_t *word, *weight;\n                int32 i;\n\n                if (classname == NULL || 0 != strcmp(wptr[1], classname))\n                    goto error_out;\n                inclass = FALSE;\n\n                /* Construct a class from the list of words collected. */\n                classdef = ckd_calloc(1, sizeof(*classdef));\n                classwords = glist_reverse(classwords);\n                classprobs = glist_reverse(classprobs);\n                classdef->n_words = glist_count(classwords);\n                classdef->words = ckd_calloc(classdef->n_words,\n                                             sizeof(*classdef->words));\n                classdef->weights = ckd_calloc(classdef->n_words,\n                                               sizeof(*classdef->weights));\n                word = classwords;\n                weight = classprobs;\n                for (i = 0; i < classdef->n_words; ++i) {\n                    classdef->words[i] = gnode_ptr(word);\n                    classdef->weights[i] = gnode_float32(weight);\n                    word = gnode_next(word);\n                    weight = gnode_next(weight);\n                }\n\n                /* Add this class to the hash table. */\n                if (hash_table_enter(classes, classname, classdef) !=\n                    classdef) {\n                    classdef_free(classdef);\n                    goto error_out;\n                }\n\n                /* Reset everything. */\n                glist_free(classwords);\n                glist_free(classprobs);\n                classwords = NULL;\n                classprobs = NULL;\n                classname = NULL;\n            }\n            else {\n                float32 fprob;\n\n                if (n_words == 2)\n                    fprob = atof_c(wptr[1]);\n                else\n                    fprob = 1.0f;\n                /* Add it to the list of words for this class. */\n                classwords =\n                    glist_add_ptr(classwords, ckd_salloc(wptr[0]));\n                classprobs = glist_add_float32(classprobs, fprob);\n            }\n        }\n        else {\n            /* Start a new LM class if the LMCLASS marker is seen */\n            if (n_words == 2 && 0 == strcmp(wptr[0], \"LMCLASS\")) {\n                if (inclass)\n                    goto error_out;\n                inclass = TRUE;\n                classname = ckd_salloc(wptr[1]);\n            }\n            /* Otherwise, just ignore whatever junk we got */\n        }\n    }\n    rv = 0;                     /* Success. */\n\n  error_out:\n    /* Free all the stuff we might have allocated. */\n    fclose_comp(fp, is_pipe);\n    for (gn = classwords; gn; gn = gnode_next(gn))\n        ckd_free(gnode_ptr(gn));\n    glist_free(classwords);\n    glist_free(classprobs);\n    ckd_free(classname);\n\n    return rv;\n}\n\nvoid\nclassdef_free(classdef_t * classdef)\n{\n    int32 i;\n    for (i = 0; i < classdef->n_words; ++i)\n        ckd_free(classdef->words[i]);\n    ckd_free(classdef->words);\n    ckd_free(classdef->weights);\n    ckd_free(classdef);\n}\n\n\nint32\nngram_model_read_classdef(ngram_model_t * model, const char *file_name)\n{\n    hash_table_t *classes;\n    glist_t hl = NULL;\n    gnode_t *gn;\n    int32 rv = -1;\n\n    classes = hash_table_new(0, FALSE);\n    if (read_classdef_file(classes, file_name) < 0) {\n        hash_table_free(classes);\n        return -1;\n    }\n\n    /* Create a new class in the language model for each classdef. */\n    hl = hash_table_tolist(classes, NULL);\n    for (gn = hl; gn; gn = gnode_next(gn)) {\n        hash_entry_t *he = gnode_ptr(gn);\n        classdef_t *classdef = he->val;\n\n        if (ngram_model_add_class(model, he->key, 1.0,\n                                  classdef->words,\n                                  classdef->weights,\n                                  classdef->n_words) < 0)\n            goto error_out;\n    }\n    rv = 0;\n\n  error_out:\n    for (gn = hl; gn; gn = gnode_next(gn)) {\n        hash_entry_t *he = gnode_ptr(gn);\n        ckd_free((char *) he->key);\n        classdef_free(he->val);\n    }\n    glist_free(hl);\n    hash_table_free(classes);\n    return rv;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * bio.c -- Sphinx-3 binary file I/O functions.\n * \n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1996 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log$\n * Revision 1.4  2005/06/21  20:40:46  arthchan2003\n * 1, Fixed doxygen documentation, 2, Add the $ keyword.\n * \n * Revision 1.3  2005/03/30 01:22:46  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 02-Jul-1997\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tBugfix: Added byteswapping in bio_verify_chksum().\n * \n * 18-Dec-1996\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tCreated.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\n#include \"sphinxbase/bio.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\n\n#define BIO_HDRARG_MAX\t32\n#define END_COMMENT\t\"*end_comment*\\n\"\n\n\nstatic void\nbcomment_read(FILE * fp)\n{\n    __BIGSTACKVARIABLE__ char iline[16384];\n\n    while (fgets(iline, sizeof(iline), fp) != NULL) {\n        if (strcmp(iline, END_COMMENT) == 0)\n            return;\n    }\n    E_FATAL(\"Missing %s marker\\n\", END_COMMENT);\n}\n\n\nstatic int32\nswap_check(FILE * fp)\n{\n    uint32 magic;\n\n    if (fread(&magic, sizeof(uint32), 1, fp) != 1) {\n        E_ERROR(\"Cannot read BYTEORDER MAGIC NO.\\n\");\n        return -1;\n    }\n\n    if (magic != BYTE_ORDER_MAGIC) {\n        /* either need to swap or got bogus magic number */\n        SWAP_INT32(&magic);\n\n        if (magic == BYTE_ORDER_MAGIC)\n            return 1;\n\n        SWAP_INT32(&magic);\n        E_ERROR(\"Bad BYTEORDER MAGIC NO: %08x, expecting %08x\\n\",\n                magic, BYTE_ORDER_MAGIC);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nvoid\nbio_hdrarg_free(char **argname, char **argval)\n{\n    int32 i;\n\n    if (argname == NULL)\n        return;\n    for (i = 0; argname[i]; i++) {\n        ckd_free(argname[i]);\n        ckd_free(argval[i]);\n    }\n    ckd_free(argname);\n    ckd_free(argval);\n}\n\n\nint32\nbio_writehdr_version(FILE * fp, char *version)\n{\n    uint32 b;\n\n    fprintf(fp, \"s3\\n\");\n    fprintf(fp, \"version %s\\n\", version);\n    fprintf(fp, \"endhdr\\n\");\n    fflush(fp);\n\n    b = (uint32) BYTE_ORDER_MAGIC;\n    fwrite(&b, sizeof(uint32), 1, fp);\n    fflush(fp);\n\n    return 0;\n}\n\n\nint32\nbio_writehdr(FILE *fp, ...)\n{\n    char const *key;\n    va_list args;\n    uint32 b;\n\n    fprintf(fp, \"s3\\n\");\n    va_start(args, fp);\n    while ((key = va_arg(args, char const *)) != NULL) {\n        char const *val = va_arg(args, char const *);\n        if (val == NULL) {\n            E_ERROR(\"Wrong number of arguments\\n\");\n            va_end(args);\n            return -1;\n        }\n        fprintf(fp, \"%s %s\\n\", key, val);\n    }\n    va_end(args);\n\n    fprintf(fp, \"endhdr\\n\");\n    fflush(fp);\n\n    b = (uint32) BYTE_ORDER_MAGIC;\n    if (fwrite(&b, sizeof(uint32), 1, fp) != 1)\n        return -1;\n    fflush(fp);\n\n    return 0;\n}\n\n\nint32\nbio_readhdr(FILE * fp, char ***argname, char ***argval, int32 * swap)\n{\n    __BIGSTACKVARIABLE__ char line[16384], word[4096];\n    int32 i, l;\n    int32 lineno;\n\n    *argname = (char **) ckd_calloc(BIO_HDRARG_MAX + 1, sizeof(char *));\n    *argval = (char **) ckd_calloc(BIO_HDRARG_MAX, sizeof(char *));\n\n    lineno = 0;\n    if (fgets(line, sizeof(line), fp) == NULL){\n        E_ERROR(\"Premature EOF, line %d\\n\", lineno);\n        goto error_out;\n    }\n    lineno++;\n\n    if ((line[0] == 's') && (line[1] == '3') && (line[2] == '\\n')) {\n        /* New format (post Dec-1996, including checksums); read argument-value pairs */\n        for (i = 0;;) {\n            if (fgets(line, sizeof(line), fp) == NULL) {\n                E_ERROR(\"Premature EOF, line %d\\n\", lineno);\n                goto error_out;\n            }\n            lineno++;\n\n            if (sscanf(line, \"%s%n\", word, &l) != 1) {\n                E_ERROR(\"Header format error, line %d\\n\", lineno);\n                goto error_out;\n            }\n            if (strcmp(word, \"endhdr\") == 0)\n                break;\n            if (word[0] == '#') /* Skip comments */\n                continue;\n\n            if (i >= BIO_HDRARG_MAX) {\n                E_ERROR\n                    (\"Max arg-value limit(%d) exceeded; increase BIO_HDRARG_MAX\\n\",\n                     BIO_HDRARG_MAX);\n                goto error_out;\n            }\n\n            (*argname)[i] = ckd_salloc(word);\n            if (sscanf(line + l, \"%s\", word) != 1) {      /* Multi-word values not allowed */\n                E_ERROR(\"Header format error, line %d\\n\", lineno);\n                goto error_out;\n            }\n            (*argval)[i] = ckd_salloc(word);\n            i++;\n        }\n    }\n    else {\n        /* Old format (without checksums); the first entry must be the version# */\n        if (sscanf(line, \"%s\", word) != 1) {\n            E_ERROR(\"Header format error, line %d\\n\", lineno);\n            goto error_out;\n        }\n\n        (*argname)[0] = ckd_salloc(\"version\");\n        (*argval)[0] = ckd_salloc(word);\n        i = 1;\n\n        bcomment_read(fp);\n    }\n    (*argname)[i] = NULL;\n\n    if ((*swap = swap_check(fp)) < 0) {\n        E_ERROR(\"swap_check failed\\n\");\n        goto error_out;\n    }\n\n    return 0;\nerror_out:\n    bio_hdrarg_free(*argname, *argval);\n    *argname = *argval = NULL;\n    return -1;\n}\n\n\nstatic uint32\nchksum_accum(const void *buf, int32 el_sz, int32 n_el, uint32 sum)\n{\n    int32 i;\n    uint8 *i8;\n    uint16 *i16;\n    uint32 *i32;\n\n    switch (el_sz) {\n    case 1:\n        i8 = (uint8 *) buf;\n        for (i = 0; i < n_el; i++)\n            sum = (sum << 5 | sum >> 27) + i8[i];\n        break;\n    case 2:\n        i16 = (uint16 *) buf;\n        for (i = 0; i < n_el; i++)\n            sum = (sum << 10 | sum >> 22) + i16[i];\n        break;\n    case 4:\n        i32 = (uint32 *) buf;\n        for (i = 0; i < n_el; i++)\n            sum = (sum << 20 | sum >> 12) + i32[i];\n        break;\n    default:\n        E_FATAL(\"Unsupported elemsize for checksum: %d\\n\", el_sz);\n        break;\n    }\n\n    return sum;\n}\n\n\nstatic void\nswap_buf(void *buf, int32 el_sz, int32 n_el)\n{\n    int32 i;\n    uint16 *buf16;\n    uint32 *buf32;\n\n    switch (el_sz) {\n    case 1:\n        break;\n    case 2:\n        buf16 = (uint16 *) buf;\n        for (i = 0; i < n_el; i++)\n            SWAP_INT16(buf16 + i);\n        break;\n    case 4:\n        buf32 = (uint32 *) buf;\n        for (i = 0; i < n_el; i++)\n            SWAP_INT32(buf32 + i);\n        break;\n    default:\n        E_FATAL(\"Unsupported elemsize for byteswapping: %d\\n\", el_sz);\n        break;\n    }\n}\n\n\nint32\nbio_fread(void *buf, int32 el_sz, int32 n_el, FILE * fp, int32 swap,\n          uint32 * chksum)\n{\n    if (fread(buf, el_sz, n_el, fp) != (size_t) n_el)\n        return -1;\n\n    if (swap)\n        swap_buf(buf, el_sz, n_el);\n\n    if (chksum)\n        *chksum = chksum_accum(buf, el_sz, n_el, *chksum);\n\n    return n_el;\n}\n\nint32\nbio_fwrite(const void *buf, int32 el_sz, int32 n_el, FILE *fp,\n           int32 swap, uint32 *chksum)\n{\n    if (chksum)\n        *chksum = chksum_accum(buf, el_sz, n_el, *chksum);\n    if (swap) {\n        void *nbuf;\n        int rv;\n\n        nbuf = ckd_calloc(n_el, el_sz);\n        memcpy(nbuf, buf, n_el * el_sz);\n        swap_buf(nbuf, el_sz, n_el);\n        rv = fwrite(nbuf, el_sz, n_el, fp);\n        ckd_free(nbuf);\n        return rv;\n    }\n    else {\n        return fwrite(buf, el_sz, n_el, fp);\n    }\n}\n\nint32\nbio_fread_1d(void **buf, size_t el_sz, uint32 * n_el, FILE * fp,\n             int32 sw, uint32 * ck)\n{\n    /* Read 1-d array size */\n    if (bio_fread(n_el, sizeof(int32), 1, fp, sw, ck) != 1)\n        E_FATAL(\"fread(arraysize) failed\\n\");\n    if (*n_el <= 0)\n        E_FATAL(\"Bad arraysize: %d\\n\", *n_el);\n\n    /* Allocate memory for array data */\n    *buf = (void *) ckd_calloc(*n_el, el_sz);\n\n    /* Read array data */\n    if (bio_fread(*buf, el_sz, *n_el, fp, sw, ck) != *n_el)\n        E_FATAL(\"fread(arraydata) failed\\n\");\n\n    return *n_el;\n}\n\nint32\nbio_fread_2d(void ***arr,\n             size_t e_sz,\n             uint32 *d1,\n             uint32 *d2,\n             FILE *fp,\n             uint32 swap,\n             uint32 *chksum)\n{\n    uint32 l_d1, l_d2;\n    uint32 n;\n    size_t ret;\n    void *raw;\n    \n    ret = bio_fread(&l_d1, sizeof(uint32), 1, fp, swap, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to read complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fread_2d\");\n\t}\n\treturn -1;\n    }\n    ret = bio_fread(&l_d2, sizeof(uint32), 1, fp, swap, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to read complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fread_2d\");\n\t}\n\treturn -1;\n    }\n    if (bio_fread_1d(&raw, e_sz, &n, fp, swap, chksum) != n)\n\treturn -1;\n\n    assert(n == l_d1*l_d2);\n\n    *d1 = l_d1;\n    *d2 = l_d2;\n    *arr = ckd_alloc_2d_ptr(l_d1, l_d2, raw, e_sz);\n\n    return n;\n}\n\nint32\nbio_fread_3d(void ****arr,\n             size_t e_sz,\n             uint32 *d1,\n             uint32 *d2,\n             uint32 *d3,\n             FILE *fp,\n             uint32 swap,\n             uint32 *chksum)\n{\n    uint32 l_d1;\n    uint32 l_d2;\n    uint32 l_d3;\n    uint32 n;\n    void *raw;\n    size_t ret;\n\n    ret = bio_fread(&l_d1, sizeof(uint32), 1, fp, swap, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to read complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fread_3d\");\n\t}\n\treturn -1;\n    }\n    ret = bio_fread(&l_d2, sizeof(uint32), 1, fp, swap, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to read complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fread_3d\");\n\t}\n\treturn -1;\n    }\n    ret = bio_fread(&l_d3, sizeof(uint32), 1, fp, swap, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to read complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fread_3d\");\n\t}\n\treturn -1;\n    }\n\n    if (bio_fread_1d(&raw, e_sz, &n, fp, swap, chksum) != n) {\n\treturn -1;\n    }\n\n    assert(n == l_d1 * l_d2 * l_d3);\n\n    *arr = ckd_alloc_3d_ptr(l_d1, l_d2, l_d3, raw, e_sz);\n    *d1 = l_d1;\n    *d2 = l_d2;\n    *d3 = l_d3;\n    \n    return n;\n}\n\nvoid\nbio_verify_chksum(FILE * fp, int32 byteswap, uint32 chksum)\n{\n    uint32 file_chksum;\n\n    if (fread(&file_chksum, sizeof(uint32), 1, fp) != 1)\n        E_FATAL(\"fread(chksum) failed\\n\");\n    if (byteswap)\n        SWAP_INT32(&file_chksum);\n    if (file_chksum != chksum)\n        E_FATAL\n            (\"Checksum error; file-checksum %08x, computed %08x\\n\",\n             file_chksum, chksum);\n}\n\nint\nbio_fwrite_3d(void ***arr,\n\t   size_t e_sz,\n\t   uint32 d1,\n\t   uint32 d2,\n\t   uint32 d3,\n\t   FILE *fp,\n\t   uint32 *chksum)\n{\n    size_t ret;\n\n    /* write out first dimension 1 */\n    ret = bio_fwrite(&d1, sizeof(uint32), 1, fp, 0, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to write complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fwrite_3d\");\n\t}\n\treturn -1;\n    }\n\n    /* write out first dimension 2 */\n    ret = bio_fwrite(&d2, sizeof(uint32), 1, fp, 0, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to write complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fwrite_3d\");\n\t}\n\treturn -1;\n    }\n\n    /* write out first dimension 3 */\n    ret = bio_fwrite(&d3, sizeof(uint32), 1, fp, 0, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to write complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fwrite_3d\");\n\t}\n\treturn -1;\n    }\n\n    /* write out the data in the array as one big block */\n    return bio_fwrite_1d(arr[0][0], e_sz, d1 * d2 * d3, fp, chksum);\n}\n\nint\nbio_fwrite_1d(void *arr,\n\t   size_t e_sz,\n\t   uint32 d1,\n\t   FILE *fp,\n\t   uint32 *chksum)\n{\n    size_t ret;\n    ret = bio_fwrite(&d1, sizeof(uint32), 1, fp, 0, chksum);\n    if (ret != 1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to write complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fwrite_1d\");\n\t}\n\treturn -1;\n    }\n\n    ret = bio_fwrite(arr, e_sz, d1, fp, 0, chksum);\n    if (ret != d1) {\n\tif (ret == 0) {\n\t    E_ERROR_SYSTEM(\"Unable to write complete data\");\n\t}\n\telse {\n\t    E_ERROR_SYSTEM(\"OS error in bio_fwrite_1d\");\n\t}\n\n\treturn -1;\n    }\n\n    return ret;\n}\n\nint16*\nbio_read_wavfile(char const *directory,\n\t\t char const *filename,\n\t\t char const *extension,\n\t\t int32 header,\n\t\t int32 endian,\n\t\t size_t *nsamps)\n{\n    FILE *uttfp;\n    char *inputfile;\n    size_t n, l;\n    int16 *data;\n\n    n = strlen(extension);\n    l = strlen(filename);\n    if ((n <= l) && (0 == strcmp(filename + l - n, extension)))\n        extension = \"\";\n    inputfile = ckd_calloc(strlen(directory) + l + n + 2, 1);\n    if (directory) {\n        sprintf(inputfile, \"%s/%s%s\", directory, filename, extension);\n    } else {\n        sprintf(inputfile, \"%s%s\", filename, extension);\n    }\n\n    if ((uttfp = fopen(inputfile, \"rb\")) == NULL) {\n        E_FATAL_SYSTEM(\"Failed to open file '%s' for reading\", inputfile);\n    }\n    fseek(uttfp, 0, SEEK_END);\n    n = ftell(uttfp);\n    fseek(uttfp, 0, SEEK_SET);\n    if (header > 0) {\n        if (fseek(uttfp, header, SEEK_SET) < 0) {\n            E_ERROR_SYSTEM(\"Failed to move to an offset %d in a file '%s'\", header, inputfile);\n            fclose(uttfp);\n            ckd_free(inputfile);\n            return NULL;\n        }\n        n -= header;\n    }\n    n /= sizeof(int16);\n    data = ckd_calloc(n, sizeof(*data));\n    if ((l = fread(data, sizeof(int16), n, uttfp)) < n) {\n        E_ERROR_SYSTEM(\"Failed to read %d samples from %s: %d\", n, inputfile, l);\n        ckd_free(data);\n        ckd_free(inputfile);\n        fclose(uttfp);\n        return NULL;\n    }\n    ckd_free(inputfile);\n    fclose(uttfp);\n    if (nsamps) *nsamps = n;\n\n    return data;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * bitvec.c -- Bit vector type.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log: bitvec.c,v $\n * Revision 1.4  2005/06/22 02:58:22  arthchan2003\n * Added  keyword\n *\n * Revision 1.3  2005/03/30 01:22:48  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 05-Mar-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tStarted.\n */\n\n\n#include \"sphinxbase/bitvec.h\"\n\nbitvec_t *\nbitvec_realloc(bitvec_t *vec,\n\t       size_t old_len,\n               size_t new_len)\n{\n    bitvec_t *new_vec;\n    size_t old_size = bitvec_size(old_len);\n    size_t new_size = bitvec_size(new_len);\n    \n    new_vec = ckd_realloc(vec, new_size * sizeof(bitvec_t));\n    if (new_size > old_size)\n\tmemset(new_vec + old_size, 0, (new_size - old_size) * sizeof(bitvec_t));\n\n    return new_vec;\n}\n\nsize_t\nbitvec_count_set(bitvec_t *vec, size_t len)\n{\n    size_t words, bits, w, b, n;\n    bitvec_t *v;\n\n    words = len / BITVEC_BITS;\n    bits = len % BITVEC_BITS;\n    v = vec;\n    n = 0;\n    for (w = 0; w < words; ++w, ++v) {\n        if (*v == 0)\n            continue;\n        for (b = 0; b < BITVEC_BITS; ++b)\n            if (*v & (1<<b))\n                ++n;\n    }\n    for (b = 0; b < bits; ++b)\n        if (*v & (1<<b))\n            ++n;\n\n    return n;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * case.c -- Upper/lower case conversion routines\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log: case.c,v $\n * Revision 1.7  2005/06/22 02:58:54  arthchan2003\n * Added  keyword\n *\n * Revision 1.3  2005/03/30 01:22:48  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 18-Jun-97\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tAdded strcmp_nocase.  Moved UPPER_CASE and LOWER_CASE definitions to .h.\n * \n * 16-Feb-97\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tCreated.\n */\n\n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"sphinxbase/case.h\"\n#include \"sphinxbase/err.h\"\n\n\nvoid\nlcase(register char *cp)\n{\n    if (cp) {\n        while (*cp) {\n            *cp = LOWER_CASE(*cp);\n            cp++;\n        }\n    }\n}\n\nvoid\nucase(register char *cp)\n{\n    if (cp) {\n        while (*cp) {\n            *cp = UPPER_CASE(*cp);\n            cp++;\n        }\n    }\n}\n\nint32\nstrcmp_nocase(const char *str1, const char *str2)\n{\n    char c1, c2;\n\n    if (str1 == str2)\n        return 0;\n    if (str1 && str2) {\n        for (;;) {\n            c1 = *(str1++);\n            c1 = UPPER_CASE(c1);\n            c2 = *(str2++);\n            c2 = UPPER_CASE(c2);\n            if (c1 != c2)\n                return (c1 - c2);\n            if (c1 == '\\0')\n                return 0;\n        }\n    }\n    else\n        return (str1 == NULL) ? -1 : 1;\n\n    return 0;\n}\n\nint32\nstrncmp_nocase(const char *str1, const char *str2, size_t len)\n{\n    char c1, c2;\n\n    if (str1 && str2) {\n        size_t n;\n\n        for (n = 0; n < len; ++n) {\n            c1 = *(str1++);\n            c1 = UPPER_CASE(c1);\n            c2 = *(str2++);\n            c2 = UPPER_CASE(c2);\n            if (c1 != c2)\n                return (c1 - c2);\n            if (c1 == '\\0')\n                return 0;\n        }\n    }\n    else\n        return (str1 == NULL) ? -1 : 1;\n\n    return 0;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced\n * Research Projects Agency and the National Science Foundation of the\n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * ckd_alloc.c -- Memory allocation package.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n *\n * HISTORY\n * $Log: ckd_alloc.c,v $\n * Revision 1.6  2005/06/22 02:59:25  arthchan2003\n * Added  keyword\n *\n * Revision 1.3  2005/03/30 01:22:48  archan\n * Fixed mistakes in last updates. Add\n *\n *\n * 19-Jun-97\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tRemoved file,line arguments from free functions.\n * \t\tRemoved debugging stuff.\n *\n * 01-Jan-96\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tCreated.\n */\n\n\n/*********************************************************************\n *\n * $Header: /cvsroot/cmusphinx/sphinx3/src/libutil/ckd_alloc.c,v 1.6 2005/06/22 02:59:25 arthchan2003 Exp $\n *\n * Carnegie Mellon ARPA Speech Group\n *\n * Copyright (c) 1994 Carnegie Mellon University.\n * All rights reserved.\n *\n *********************************************************************\n *\n * file: ckd_alloc.c\n *\n * traceability:\n *\n * description:\n *\n * author:\n *\n *********************************************************************/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdarg.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/err.h\"\n\n/**\n * Target for longjmp() on failure.\n *\n * FIXME: This should be in thread-local storage.\n */\nstatic jmp_buf *ckd_target;\nstatic int jmp_abort;\n\njmp_buf *\nckd_set_jump(jmp_buf *env, int abort)\n{\n    jmp_buf *old;\n\n    if (abort)\n        jmp_abort = 1;\n\n    old = ckd_target;\n    ckd_target = env;\n    return old;\n}\n\nvoid\nckd_fail(char *format, ...)\n{\n    va_list args;\n\n    va_start(args, format);\n    vfprintf(stderr, format, args);\n    va_end(args);\n\n    if (jmp_abort)\n        /* abort() doesn't exist in Windows CE */\n        #if defined(_WIN32_WCE)\n        exit(-1);\n        #else\n        abort();\n        #endif\n    else if (ckd_target)\n        longjmp(*ckd_target, 1);\n    else\n        exit(-1);\n}\n\nvoid *\n__ckd_calloc__(size_t n_elem, size_t elem_size,\n               const char *caller_file, int caller_line)\n{\n    void *mem;\n\n#if defined(__ADSPBLACKFIN__) && !defined(__linux__)\n    if ((mem = heap_calloc(heap_lookup(1),n_elem, elem_size)) == NULL)\n    \tif ((mem = heap_calloc(heap_lookup(0),n_elem, elem_size)) == NULL)\n    \t{\n        \tckd_fail(\"calloc(%d,%d) failed from %s(%d), free space: %d\\n\", n_elem,\n                elem_size, caller_file, caller_line,space_unused());\n    \t}\n#else\n    if ((mem = calloc(n_elem, elem_size)) == NULL) {\n        ckd_fail(\"calloc(%d,%d) failed from %s(%d)\\n\", n_elem,\n                elem_size, caller_file, caller_line);\n\t}\n#endif\n\n\n    return mem;\n}\n\n\nvoid *\n__ckd_malloc__(size_t size, const char *caller_file, int caller_line)\n{\n    void *mem;\n\n#if defined(__ADSPBLACKFIN__) && !defined(__linux__)\n    if ((mem = heap_malloc(heap_lookup(0),size)) == NULL)\n       \tif ((mem = heap_malloc(heap_lookup(1),size)) == NULL)\n#else\n    if ((mem = malloc(size)) == NULL)\n#endif\n\t        ckd_fail(\"malloc(%d) failed from %s(%d)\\n\", size,\n                caller_file, caller_line);\n\n    return mem;\n}\n\n\nvoid *\n__ckd_realloc__(void *ptr, size_t new_size,\n                const char *caller_file, int caller_line)\n{\n    void *mem;\n#if defined(__ADSPBLACKFIN__) && !defined(__linux__)\n    if ((mem = heap_realloc(heap_lookup(0),ptr, new_size)) == NULL) {\n#else\n    if ((mem = realloc(ptr, new_size)) == NULL) {\n#endif\n        ckd_fail(\"malloc(%d) failed from %s(%d)\\n\", new_size,\n                caller_file, caller_line);\n    }\n\n    return mem;\n}\n\n\nchar *\n__ckd_salloc__(const char *orig, const char *caller_file,\n               int caller_line)\n{\n    size_t len;\n    char *buf;\n\n    if (!orig)\n        return NULL;\n\n    len = strlen(orig) + 1;\n    buf = (char *) __ckd_malloc__(len, caller_file, caller_line);\n\n    strcpy(buf, orig);\n    return (buf);\n}\n\n\nvoid *\n__ckd_calloc_2d__(size_t d1, size_t d2, size_t elemsize,\n                  const char *caller_file, int caller_line)\n{\n    char **ref, *mem;\n    size_t i, offset;\n\n    mem =\n        (char *) __ckd_calloc__(d1 * d2, elemsize, caller_file,\n                                caller_line);\n    ref =\n        (char **) __ckd_malloc__(d1 * sizeof(void *), caller_file,\n                                 caller_line);\n\n    for (i = 0, offset = 0; i < d1; i++, offset += d2 * elemsize)\n        ref[i] = mem + offset;\n\n    return ref;\n}\n\n\nvoid\nckd_free(void *ptr)\n{\n#if defined(__ADSPBLACKFIN__) && !defined(__linux__)\n    if (ptr)\n        heap_free(0,ptr);\n#else\n    free(ptr);\n#endif\n}\n\nvoid\nckd_free_2d(void *tmpptr)\n{\n    void **ptr = (void **)tmpptr;\n    if (ptr)\n        ckd_free(ptr[0]);\n    ckd_free(ptr);\n}\n\n\nvoid *\n__ckd_calloc_3d__(size_t d1, size_t d2, size_t d3, size_t elemsize,\n                  const char *caller_file, int caller_line)\n{\n    char ***ref1, **ref2, *mem;\n    size_t i, j, offset;\n\n    mem =\n        (char *) __ckd_calloc__(d1 * d2 * d3, elemsize, caller_file,\n                                caller_line);\n    ref1 =\n        (char ***) __ckd_malloc__(d1 * sizeof(void **), caller_file,\n                                  caller_line);\n    ref2 =\n        (char **) __ckd_malloc__(d1 * d2 * sizeof(void *), caller_file,\n                                 caller_line);\n\n    for (i = 0, offset = 0; i < d1; i++, offset += d2)\n        ref1[i] = ref2 + offset;\n\n    offset = 0;\n    for (i = 0; i < d1; i++) {\n        for (j = 0; j < d2; j++) {\n            ref1[i][j] = mem + offset;\n            offset += d3 * elemsize;\n        }\n    }\n\n    return ref1;\n}\n\n\nvoid\nckd_free_3d(void *inptr)\n{\n    void ***ptr = (void ***)inptr;\n\n    if (ptr && ptr[0])\n        ckd_free(ptr[0][0]);\n    if (ptr)\n        ckd_free(ptr[0]);\n    ckd_free(ptr);\n}\n\n\nvoid ****\n__ckd_calloc_4d__(size_t d1,\n\t\t  size_t d2,\n\t\t  size_t d3,\n\t\t  size_t d4,\n\t\t  size_t elem_size,\n\t\t  char *file,\n\t\t  int line)\n{\n    void *store;\n    void **tmp1;\n    void ***tmp2;\n    void ****out;\n    size_t i, j;\n\n    store = calloc(d1 * d2 * d3 * d4, elem_size);\n    if (store == NULL) {\n\tE_FATAL(\"ckd_calloc_4d failed for caller at %s(%d) at %s(%d)\\n\",\n\t\tfile, line, __FILE__, __LINE__);\n    }\n\n    tmp1 = calloc(d1 * d2 * d3, sizeof(void *));\n    if (tmp1 == NULL) {\n\tE_FATAL(\"ckd_calloc_4d failed for caller at %s(%d) at %s(%d)\\n\",\n\t\tfile, line, __FILE__, __LINE__);\n    }\n\n    tmp2 = ckd_calloc(d1 * d2, sizeof(void **));\n    if (tmp2 == NULL) {\n\tE_FATAL(\"ckd_calloc_4d failed for caller at %s(%d) at %s(%d)\\n\",\n\t\tfile, line, __FILE__, __LINE__);\n    }\n\n    out = ckd_calloc(d1, sizeof(void ***));\n    if (out == NULL) {\n\tE_FATAL(\"ckd_calloc_4d failed for caller at %s(%d) at %s(%d)\\n\",\n\t\tfile, line, __FILE__, __LINE__);\n    }\n\n    for (i = 0, j = 0; i < d1*d2*d3; i++, j += d4) {\n\ttmp1[i] = &((char *)store)[j*elem_size];\n    }\n\n    for (i = 0, j = 0; i < d1*d2; i++, j += d3) {\n\ttmp2[i] = &tmp1[j];\n    }\n\n    for (i = 0, j = 0; i < d1; i++, j += d2) {\n\tout[i] = &tmp2[j];\n    }\n\n    return out;\n}\n\nvoid\nckd_free_4d(void *inptr)\n{\n    void ****ptr = (void ****)inptr;\n    if (ptr == NULL)\n\treturn;\n    /* free the underlying store */\n    ckd_free(ptr[0][0][0]);\n\n    /* free the access overhead */\n    ckd_free(ptr[0][0]);\n    ckd_free(ptr[0]);\n    ckd_free(ptr);\n}\n\n/* Layers a 3d array access structure over a preallocated storage area */\nvoid *\n__ckd_alloc_3d_ptr(size_t d1,\n\t\t   size_t d2,\n\t\t   size_t d3,\n\t\t   void *store,\n\t\t   size_t elem_size,\n\t\t   char *file,\n\t\t   int line)\n{\n    void **tmp1;\n    void ***out;\n    size_t i, j;\n\n    tmp1 = __ckd_calloc__(d1 * d2, sizeof(void *), file, line);\n\n    out  = __ckd_calloc__(d1, sizeof(void **), file, line);\n\n    for (i = 0, j = 0; i < d1*d2; i++, j += d3) {\n\ttmp1[i] = &((char *)store)[j*elem_size];\n    }\n\n    for (i = 0, j = 0; i < d1; i++, j += d2) {\n\tout[i] = &tmp1[j];\n    }\n\n    return out;\n}\n\nvoid *\n__ckd_alloc_2d_ptr(size_t d1,\n\t\t   size_t d2,\n\t\t   void *store,\n\t\t   size_t elem_size,\n\t\t   char *file,\n\t\t   int line)\n{\n    void **out;\n    size_t i, j;\n\n    out = __ckd_calloc__(d1, sizeof(void *), file, line);\n\n    for (i = 0, j = 0; i < d1; i++, j += d2) {\n\tout[i] = &((char *)store)[j*elem_size];\n    }\n\n    return out;\n}\n\n/* vim: set ts=4 sw=4: */\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced\n * Research Projects Agency and the National Science Foundation of the\n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * cmd_ln.c -- Command line argument parsing.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n *\n * HISTORY\n *\n * 10-Sep-1998 M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n *             Changed strcasecmp() call in cmp_name() to strcmp_nocase() call.\n *\n * 15-Jul-1997    M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n *         Added required arguments handling.\n *\n * 07-Dec-96    M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n *         Created, based on Eric's implementation.  Basically, combined several\n *        functions into one, eliminated validation, and simplified the interface.\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996 4018)\n#endif\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"sphinxbase/cmd_ln.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/hash_table.h\"\n#include \"sphinxbase/case.h\"\n#include \"sphinxbase/strfuncs.h\"\n\ntypedef struct cmd_ln_val_s {\n    anytype_t val;\n    int type;\n    char *name;\n} cmd_ln_val_t;\n\nstruct cmd_ln_s {\n    int refcount;\n    hash_table_t *ht;\n    char **f_argv;\n    uint32 f_argc;\n};\n\n/** Global command-line, for non-reentrant API. */\ncmd_ln_t *global_cmdln;\n\nstatic void\narg_dump_r(cmd_ln_t *, FILE *, arg_t const *, int32);\n\nstatic cmd_ln_t *\nparse_options(cmd_ln_t *, const arg_t *, int32, char* [], int32);\n\n/*\n * Find max length of name and default fields in the given defn array.\n * Return #items in defn array.\n */\nstatic int32\narg_strlen(const arg_t * defn, int32 * namelen, int32 * deflen)\n{\n    int32 i, l;\n\n    *namelen = *deflen = 0;\n    for (i = 0; defn[i].name; i++) {\n        l = strlen(defn[i].name);\n        if (*namelen < l)\n            *namelen = l;\n\n        if (defn[i].deflt)\n            l = strlen(defn[i].deflt);\n        else\n            l = strlen(\"(null)\");\n        /*      E_INFO(\"string default, %s , name %s, length %d\\n\",defn[i].deflt,defn[i].name,l); */\n        if (*deflen < l)\n            *deflen = l;\n    }\n\n    return i;\n}\n\n\nstatic int32\ncmp_name(const void *a, const void *b)\n{\n    return (strcmp_nocase\n            ((* (arg_t**) a)->name,\n             (* (arg_t**) b)->name));\n}\n\nstatic arg_t const **\narg_sort(const arg_t * defn, int32 n)\n{\n    const arg_t ** pos;\n    int32 i;\n\n    pos = (arg_t const **) ckd_calloc(n, sizeof(arg_t *));\n    for (i = 0; i < n; ++i)\n        pos[i] = &defn[i];\n    qsort(pos, n, sizeof(arg_t *), cmp_name);\n\n    return pos;\n}\n\nstatic size_t\nstrnappend(char **dest, size_t *dest_allocation,\n       const char *source, size_t n)\n{\n    size_t source_len, required_allocation;\n\n    if (dest == NULL || dest_allocation == NULL)\n        return -1;\n    if (*dest == NULL && *dest_allocation != 0)\n        return -1;\n    if (source == NULL)\n        return *dest_allocation;\n\n    source_len = strlen(source);\n    if (n && n < source_len)\n        source_len = n;\n\n    required_allocation = (*dest ? strlen(*dest) : 0) + source_len + 1;\n    if (*dest_allocation < required_allocation) {\n        if (*dest_allocation == 0) {\n            *dest = (char *)ckd_calloc(required_allocation * 2, 1);\n        } else {\n            *dest = (char *)ckd_realloc(*dest, required_allocation * 2);\n        }\n        *dest_allocation = required_allocation * 2;\n    }\n\n    strncat(*dest, source, source_len);\n\n    return *dest_allocation;\n}\n\nstatic size_t\nstrappend(char **dest, size_t *dest_allocation,\n       const char *source)\n{\n    return strnappend(dest, dest_allocation, source, 0);\n}\n\nstatic char*\narg_resolve_env(const char *str)\n{\n    char *resolved_str = NULL;\n    char env_name[100];\n    const char *env_val;\n    size_t alloced = 0;\n    const char *i = str, *j;\n\n    /* calculate required resolved_str size */\n    do {\n        j = strstr(i, \"$(\");\n        if (j != NULL) {\n            if (j != i) {\n                strnappend(&resolved_str, &alloced, i, j - i);\n                i = j;\n            }\n            j = strchr(i + 2, ')');\n            if (j != NULL) {\n                if (j - (i + 2) < 100) {\n                    strncpy(env_name, i + 2, j - (i + 2));\n                    env_name[j - (i + 2)] = '\\0';\n                    #if !defined(_WIN32_WCE)\n                    env_val = getenv(env_name);\n                    if (env_val)\n                        strappend(&resolved_str, &alloced, env_val);\n                    #else\n                    env_val = 0;\n                    #endif\n                }\n                i = j + 1;\n            } else {\n                /* unclosed, copy and skip */\n                j = i + 2;\n                strnappend(&resolved_str, &alloced, i, j - i);\n                i = j;\n            }\n        } else {\n            strappend(&resolved_str, &alloced, i);\n        }\n    } while(j != NULL);\n\n    return resolved_str;\n}\n\nstatic void\narg_dump_r(cmd_ln_t *cmdln, FILE *fp, const arg_t * defn, int32 doc)\n{\n    arg_t const **pos;\n    int32 i, n;\n    size_t l;\n    int32 namelen, deflen;\n    anytype_t *vp;\n    char const **array;\n\n    /* No definitions, do nothing. */\n    if (defn == NULL || fp == NULL)\n        return;\n\n    /* Find max lengths of name and default value fields, and #entries in defn */\n    n = arg_strlen(defn, &namelen, &deflen);\n    /*    E_INFO(\"String length %d. Name length %d, Default Length %d\\n\",n, namelen, deflen); */\n    namelen = namelen & 0xfffffff8;     /* Previous tab position */\n    deflen = deflen & 0xfffffff8;       /* Previous tab position */\n\n    fprintf(fp, \"[NAME]\");\n    for (l = strlen(\"[NAME]\"); l < namelen; l += 8)\n        fprintf(fp, \"\\t\");\n    fprintf(fp, \"\\t[DEFLT]\");\n    for (l = strlen(\"[DEFLT]\"); l < deflen; l += 8)\n        fprintf(fp, \"\\t\");\n\n    if (doc) {\n        fprintf(fp, \"\\t[DESCR]\\n\");\n    }\n    else {\n        fprintf(fp, \"\\t[VALUE]\\n\");\n    }\n\n    /* Print current configuration, sorted by name */\n    pos = arg_sort(defn, n);\n    for (i = 0; i < n; i++) {\n        fprintf(fp, \"%s\", pos[i]->name);\n        for (l = strlen(pos[i]->name); l < namelen; l += 8)\n            fprintf(fp, \"\\t\");\n\n        fprintf(fp, \"\\t\");\n        if (pos[i]->deflt) {\n            fprintf(fp, \"%s\", pos[i]->deflt);\n            l = strlen(pos[i]->deflt);\n        }\n        else\n            l = 0;\n        for (; l < deflen; l += 8)\n            fprintf(fp, \"\\t\");\n\n        fprintf(fp, \"\\t\");\n        if (doc) {\n            if (pos[i]->doc)\n                fprintf(fp, \"%s\", pos[i]->doc);\n        }\n        else {\n            vp = cmd_ln_access_r(cmdln, pos[i]->name);\n            if (vp) {\n                switch (pos[i]->type) {\n                case ARG_INTEGER:\n                case REQARG_INTEGER:\n                    fprintf(fp, \"%ld\", vp->i);\n                    break;\n                case ARG_FLOATING:\n                case REQARG_FLOATING:\n                    fprintf(fp, \"%e\", vp->fl);\n                    break;\n                case ARG_STRING:\n                case REQARG_STRING:\n                    if (vp->ptr)\n                        fprintf(fp, \"%s\", (char *)vp->ptr);\n                    break;\n                case ARG_STRING_LIST:\n                    array = (char const**)vp->ptr;\n                    if (array)\n                        for (l = 0; array[l] != 0; l++) {\n                            fprintf(fp, \"%s,\", array[l]);\n                        }\n                    break;\n                case ARG_BOOLEAN:\n                case REQARG_BOOLEAN:\n                    fprintf(fp, \"%s\", vp->i ? \"yes\" : \"no\");\n                    break;\n                default:\n                    E_ERROR(\"Unknown argument type: %d\\n\", pos[i]->type);\n                }\n            }\n        }\n\n        fprintf(fp, \"\\n\");\n    }\n    ckd_free(pos);\n\n    fprintf(fp, \"\\n\");\n}\n\nstatic char **\nparse_string_list(const char *str)\n{\n    int count, i, j;\n    const char *p;\n    char **result;\n\n    p = str;\n    count = 1;\n    while (*p) {\n\tif (*p == ',')\n    \t    count++;\n        p++;\n    }\n    /* Should end with NULL */\n    result = (char **) ckd_calloc(count + 1, sizeof(char *));\n    p = str;\n    for (i = 0; i < count; i++) {\n\tfor (j = 0; p[j] != ',' && p[j] != 0; j++);\n\tresult[i] = (char *)ckd_calloc(j + 1, sizeof(char));\n        strncpy( result[i], p, j);\n        p = p + j + 1;\n    }\n    return result;\n}\n\nstatic cmd_ln_val_t *\ncmd_ln_val_init(int t, const char *name, const char *str)\n{\n    cmd_ln_val_t *v;\n    anytype_t val;\n    char *e_str;\n\n    if (!str) {\n        /* For lack of a better default value. */\n        memset(&val, 0, sizeof(val));\n    }\n    else {\n        int valid = 1;\n        e_str = arg_resolve_env(str);\n\n        switch (t) {\n        case ARG_INTEGER:\n        case REQARG_INTEGER:\n            if (sscanf(e_str, \"%ld\", &val.i) != 1)\n                valid = 0;\n            break;\n        case ARG_FLOATING:\n        case REQARG_FLOATING:\n            if (e_str == NULL || e_str[0] == 0)\n            valid = 0;\n            val.fl = atof_c(e_str);\n            break;\n        case ARG_BOOLEAN:\n        case REQARG_BOOLEAN:\n            if ((e_str[0] == 'y') || (e_str[0] == 't') ||\n                (e_str[0] == 'Y') || (e_str[0] == 'T') || (e_str[0] == '1')) {\n                val.i = TRUE;\n            }\n            else if ((e_str[0] == 'n') || (e_str[0] == 'f') ||\n                     (e_str[0] == 'N') || (e_str[0] == 'F') |\n                     (e_str[0] == '0')) {\n                val.i = FALSE;\n            }\n            else {\n                E_ERROR(\"Unparsed boolean value '%s'\\n\", str);\n                valid = 0;\n            }\n            break;\n        case ARG_STRING:\n        case REQARG_STRING:\n            val.ptr = ckd_salloc(e_str);\n            break;\n        case ARG_STRING_LIST:\n            val.ptr = parse_string_list(e_str);\n            break;\n        default:\n            E_ERROR(\"Unknown argument type: %d\\n\", t);\n            valid = 0;\n        }\n\n        ckd_free(e_str);\n        if (valid == 0)\n            return NULL;\n    }\n\n    v = (cmd_ln_val_t *)ckd_calloc(1, sizeof(*v));\n    memcpy(v, &val, sizeof(val));\n    v->type = t;\n    v->name = ckd_salloc(name);\n\n    return v;\n}\n\n/*\n * Handles option parsing for cmd_ln_parse_file_r() and cmd_ln_init()\n * also takes care of storing argv.\n * DO NOT call it from cmd_ln_parse_r()\n */\nstatic cmd_ln_t *\nparse_options(cmd_ln_t *cmdln, const arg_t *defn, int32 argc, char* argv[], int32 strict)\n{\n    cmd_ln_t *new_cmdln;\n\n    new_cmdln = cmd_ln_parse_r(cmdln, defn, argc, argv, strict);\n    /* If this failed then clean up and return NULL. */\n    if (new_cmdln == NULL) {\n        int32 i;\n        for (i = 0; i < argc; ++i)\n            ckd_free(argv[i]);\n        ckd_free(argv);\n        return NULL;\n    }\n\n    /* Otherwise, we need to add the contents of f_argv to the new object. */\n    if (new_cmdln == cmdln) {\n        /* If we are adding to a previously passed-in cmdln, then\n         * store our allocated strings in its f_argv. */\n        new_cmdln->f_argv = (char **)ckd_realloc(new_cmdln->f_argv,\n                                        (new_cmdln->f_argc + argc)\n                                        * sizeof(*new_cmdln->f_argv));\n        memcpy(new_cmdln->f_argv + new_cmdln->f_argc, argv,\n               argc * sizeof(*argv));\n        ckd_free(argv);\n        new_cmdln->f_argc += argc;\n    }\n    else {\n        /* Otherwise, store f_argc and f_argv. */\n        new_cmdln->f_argc = argc;\n        new_cmdln->f_argv = argv;\n    }\n\n    return new_cmdln;\n}\n\nvoid\ncmd_ln_val_free(cmd_ln_val_t *val)\n{\n    int i;\n    if (val->type & ARG_STRING_LIST) {\n        char ** array = (char **)val->val.ptr;\n        if (array) {\n            for (i = 0; array[i] != NULL; i++) {\n                ckd_free(array[i]);\n            }\n            ckd_free(array);\n        }\n    }\n    if (val->type & ARG_STRING)\n        ckd_free(val->val.ptr);\n    ckd_free(val->name);\n    ckd_free(val);\n}\n\ncmd_ln_t *\ncmd_ln_get(void)\n{\n    return global_cmdln;\n}\n\nvoid\ncmd_ln_appl_enter(int argc, char *argv[],\n                  const char *default_argfn,\n                  const arg_t * defn)\n{\n    /* Look for default or specified arguments file */\n    const char *str;\n\n    str = NULL;\n\n    if ((argc == 2) && (strcmp(argv[1], \"help\") == 0)) {\n        cmd_ln_print_help(stderr, defn);\n        exit(1);\n    }\n\n    if ((argc == 2) && (argv[1][0] != '-'))\n        str = argv[1];\n    else if (argc == 1) {\n        FILE *fp;\n        E_INFO(\"Looking for default argument file: %s\\n\", default_argfn);\n\n        if ((fp = fopen(default_argfn, \"r\")) == NULL) {\n            E_INFO(\"Can't find default argument file %s.\\n\",\n                   default_argfn);\n        }\n        else {\n            str = default_argfn;\n        }\n        if (fp != NULL)\n            fclose(fp);\n    }\n\n\n    if (str) {\n        /* Build command line argument list from file */\n        E_INFO(\"Parsing command lines from file %s\\n\", str);\n        if (cmd_ln_parse_file(defn, str, TRUE)) {\n            E_INFOCONT(\"Usage:\\n\");\n            E_INFOCONT(\"\\t%s argument-list, or\\n\", argv[0]);\n            E_INFOCONT(\"\\t%s [argument-file] (default file: . %s)\\n\\n\",\n                    argv[0], default_argfn);\n            cmd_ln_print_help(stderr, defn);\n            exit(1);\n        }\n    }\n    else {\n        cmd_ln_parse(defn, argc, argv, TRUE);\n    }\n}\n\nvoid\ncmd_ln_appl_exit()\n{\n    cmd_ln_free();\n}\n\n\ncmd_ln_t *\ncmd_ln_parse_r(cmd_ln_t *inout_cmdln, const arg_t * defn, int32 argc, char *argv[], int strict)\n{\n    int32 i, j, n, argstart;\n    hash_table_t *defidx = NULL;\n    cmd_ln_t *cmdln;\n\n    /* Construct command-line object */\n    if (inout_cmdln == NULL) {\n        cmdln = (cmd_ln_t*)ckd_calloc(1, sizeof(*cmdln));\n        cmdln->refcount = 1;\n    }\n    else\n        cmdln = inout_cmdln;\n\n    /* Build a hash table for argument definitions */\n    defidx = hash_table_new(50, 0);\n    if (defn) {\n        for (n = 0; defn[n].name; n++) {\n            void *v;\n\n            v = hash_table_enter(defidx, defn[n].name, (void *)&defn[n]);\n            if (strict && (v != &defn[n])) {\n                E_ERROR(\"Duplicate argument name in definition: %s\\n\", defn[n].name);\n                goto error;\n            }\n        }\n    }\n    else {\n        /* No definitions. */\n        n = 0;\n    }\n\n    /* Allocate memory for argument values */\n    if (cmdln->ht == NULL)\n        cmdln->ht = hash_table_new(n, 0 /* argument names are case-sensitive */ );\n\n\n    /* skip argv[0] if it doesn't start with dash */\n    argstart = 0;\n    if (argc > 0 && argv[0][0] != '-') {\n        argstart = 1;\n    }\n\n    /* Parse command line arguments (name-value pairs) */\n    for (j = argstart; j < argc; j += 2) {\n        arg_t *argdef;\n        cmd_ln_val_t *val;\n        void *v;\n\n        if (hash_table_lookup(defidx, argv[j], &v) < 0) {\n            if (strict) {\n                E_ERROR(\"Unknown argument name '%s'\\n\", argv[j]);\n                goto error;\n            }\n            else if (defn == NULL)\n                v = NULL;\n            else\n                continue;\n        }\n        argdef = (arg_t *)v;\n\n        /* Enter argument value */\n        if (j + 1 >= argc) {\n            cmd_ln_print_help_r(cmdln, stderr, defn);\n            E_ERROR(\"Argument value for '%s' missing\\n\", argv[j]);\n            goto error;\n        }\n\n        if (argdef == NULL)\n            val = cmd_ln_val_init(ARG_STRING, argv[j], argv[j + 1]);\n        else {\n            if ((val = cmd_ln_val_init(argdef->type, argv[j], argv[j + 1])) == NULL) {\n                cmd_ln_print_help_r(cmdln, stderr, defn);\n                E_ERROR(\"Bad argument value for %s: %s\\n\", argv[j],\n                        argv[j + 1]);\n                goto error;\n            }\n        }\n\n        if ((v = hash_table_enter(cmdln->ht, val->name, (void *)val)) !=\n            (void *)val)\n        {\n            if (strict) {\n                cmd_ln_val_free(val);\n                E_ERROR(\"Duplicate argument name in arguments: %s\\n\",\n                        argdef->name);\n                goto error;\n            }\n            else {\n                v = hash_table_replace(cmdln->ht, val->name, (void *)val);\n                cmd_ln_val_free((cmd_ln_val_t *)v);\n            }\n        }\n    }\n\n    /* Fill in default values, if any, for unspecified arguments */\n    for (i = 0; i < n; i++) {\n        cmd_ln_val_t *val;\n        void *v;\n\n        if (hash_table_lookup(cmdln->ht, defn[i].name, &v) < 0) {\n            if ((val = cmd_ln_val_init(defn[i].type, defn[i].name, defn[i].deflt)) == NULL) {\n                E_ERROR\n                    (\"Bad default argument value for %s: %s\\n\",\n                     defn[i].name, defn[i].deflt);\n                goto error;\n            }\n            hash_table_enter(cmdln->ht, val->name, (void *)val);\n        }\n    }\n\n    /* Check for required arguments; exit if any missing */\n    j = 0;\n    for (i = 0; i < n; i++) {\n        if (defn[i].type & ARG_REQUIRED) {\n            void *v;\n            if (hash_table_lookup(cmdln->ht, defn[i].name, &v) != 0)\n                E_ERROR(\"Missing required argument %s\\n\", defn[i].name);\n        }\n    }\n    if (j > 0) {\n        cmd_ln_print_help_r(cmdln, stderr, defn);\n        goto error;\n    }\n\n    if (strict && argc == 1) {\n        E_ERROR(\"No arguments given, available options are:\\n\");\n        cmd_ln_print_help_r(cmdln, stderr, defn);\n        if (defidx)\n            hash_table_free(defidx);\n        if (inout_cmdln == NULL)\n            cmd_ln_free_r(cmdln);\n        return NULL;\n    }\n\n    /* If we use it from something except pocketsphinx, print current values */\n    if (!cmd_ln_exists_r(cmdln, \"-logfn\") && err_get_logfp()) {\n\tcmd_ln_print_values_r(cmdln, err_get_logfp(), defn);\n    }\n\n    hash_table_free(defidx);\n    return cmdln;\n\n  error:\n    if (defidx)\n        hash_table_free(defidx);\n    if (inout_cmdln == NULL)\n        cmd_ln_free_r(cmdln);\n    E_ERROR(\"Failed to parse arguments list\\n\");\n    return NULL;\n}\n\ncmd_ln_t *\ncmd_ln_init(cmd_ln_t *inout_cmdln, const arg_t *defn, int32 strict, ...)\n{\n    va_list args;\n    const char *arg, *val;\n    char **f_argv;\n    int32 f_argc;\n\n    va_start(args, strict);\n    f_argc = 0;\n    while ((arg = va_arg(args, const char *))) {\n        ++f_argc;\n        val = va_arg(args, const char*);\n        if (val == NULL) {\n            E_ERROR(\"Number of arguments must be even!\\n\");\n            return NULL;\n        }\n        ++f_argc;\n    }\n    va_end(args);\n\n    /* Now allocate f_argv */\n    f_argv = (char**)ckd_calloc(f_argc, sizeof(*f_argv));\n    va_start(args, strict);\n    f_argc = 0;\n    while ((arg = va_arg(args, const char *))) {\n        f_argv[f_argc] = ckd_salloc(arg);\n        ++f_argc;\n        val = va_arg(args, const char*);\n        f_argv[f_argc] = ckd_salloc(val);\n        ++f_argc;\n    }\n    va_end(args);\n\n    return parse_options(inout_cmdln, defn, f_argc, f_argv, strict);\n}\n\nint\ncmd_ln_parse(const arg_t * defn, int32 argc, char *argv[], int strict)\n{\n    cmd_ln_t *cmdln;\n\n    cmdln = cmd_ln_parse_r(global_cmdln, defn, argc, argv, strict);\n    if (cmdln == NULL) {\n        /* Old, bogus behaviour... */\n        E_ERROR(\"Failed to parse arguments list, forced exit\\n\");\n        exit(-1);\n    }\n    /* Initialize global_cmdln if not present. */\n    if (global_cmdln == NULL) {\n        global_cmdln = cmdln;\n    }\n    return 0;\n}\n\ncmd_ln_t *\ncmd_ln_parse_file_r(cmd_ln_t *inout_cmdln, const arg_t * defn, const char *filename, int32 strict)\n{\n    FILE *file;\n    int argc;\n    int argv_size;\n    char *str;\n    int arg_max_length = 512;\n    int len = 0;\n    int quoting, ch;\n    char **f_argv;\n    int rv = 0;\n    const char separator[] = \" \\t\\r\\n\";\n\n    if ((file = fopen(filename, \"r\")) == NULL) {\n        E_ERROR(\"Cannot open configuration file %s for reading\\n\",\n                filename);\n        return NULL;\n    }\n\n    ch = fgetc(file);\n    /* Skip to the next interesting character */\n    for (; ch != EOF && strchr(separator, ch); ch = fgetc(file)) ;\n\n    if (ch == EOF) {\n        fclose(file);\n        return NULL;\n    }\n\n    /*\n     * Initialize default argv, argc, and argv_size.\n     */\n    argv_size = 30;\n    argc = 0;\n    f_argv = (char **)ckd_calloc(argv_size, sizeof(char *));\n    /* Silently make room for \\0 */\n    str = (char* )ckd_calloc(arg_max_length + 1, sizeof(char));\n    quoting = 0;\n\n    do {\n        /* Handle arguments that are commented out */\n        if (len == 0 && argc % 2 == 0) {\n            while (ch == '#') {\n                /* Skip everything until newline */\n                for (ch = fgetc(file); ch != EOF && ch != '\\n'; ch = fgetc(file)) ;\n                /* Skip to the next interesting character */\n                for (ch = fgetc(file); ch != EOF && strchr(separator, ch); ch = fgetc(file)) ;\n            }\n\n            /* Check if we are at the last line (without anything interesting in it) */\n            if (ch == EOF)\n                break;\n        }\n\n        /* Handle quoted arguments */\n        if (ch == '\"' || ch == '\\'') {\n            if (quoting == ch) /* End a quoted section with the same type */\n                quoting = 0;\n            else if (quoting) {\n                E_ERROR(\"Nesting quotations is not supported!\\n\");\n                rv = 1;\n                break;\n            }\n            else\n                quoting = ch; /* Start a quoted section */\n        }\n        else if (ch == EOF || (!quoting && strchr(separator, ch))) {\n            /* Reallocate argv so it is big enough to contain all the arguments */\n            if (argc >= argv_size) {\n                char **tmp_argv;\n                if (!(tmp_argv =\n                       (char **)ckd_realloc(f_argv, argv_size * 2 * sizeof(char *)))) {\n                    rv = 1;\n                    break;\n                }\n                f_argv = tmp_argv;\n                argv_size *= 2;\n            }\n\n            /* Add the string to the list of arguments */\n            f_argv[argc] = ckd_salloc(str);\n            len = 0;\n            str[0] = '\\0';\n            argc++;\n\n            if (quoting)\n                E_WARN(\"Unclosed quotation, having EOF close it...\\n\");\n\n            /* Skip to the next interesting character */\n            for (; ch != EOF && strchr(separator, ch); ch = fgetc(file)) ;\n\n            if (ch == EOF)\n                break;\n\n            /* We already have the next character */\n            continue;\n        }\n        else {\n            if (len >= arg_max_length) {\n                /* Make room for more chars (including the \\0 !) */\n                char *tmp_str = str;\n                if ((tmp_str = (char *)ckd_realloc(str, (1 + arg_max_length * 2) * sizeof(char))) == NULL) {\n                    rv = 1;\n                    break;\n                }\n                str = tmp_str;\n                arg_max_length *= 2;\n            }\n            /* Add the char to the argument string */\n            str[len++] = ch;\n            /* Always null terminate */\n            str[len] = '\\0';\n        }\n\n        ch = fgetc(file);\n    } while (1);\n\n    fclose(file);\n\n    ckd_free(str);\n\n    if (rv) {\n        for (ch = 0; ch < argc; ++ch)\n            ckd_free(f_argv[ch]);\n        ckd_free(f_argv);\n        return NULL;\n    }\n\n    return parse_options(inout_cmdln, defn, argc, f_argv, strict);\n}\n\nint\ncmd_ln_parse_file(const arg_t * defn, const char *filename, int32 strict)\n{\n    cmd_ln_t *cmdln;\n\n    cmdln = cmd_ln_parse_file_r(global_cmdln, defn, filename, strict);\n    if (cmdln == NULL) {\n        return -1;\n    }\n    /* Initialize global_cmdln if not present. */\n    if (global_cmdln == NULL) {\n        global_cmdln = cmdln;\n    }\n    return 0;\n}\n\nvoid\ncmd_ln_print_help_r(cmd_ln_t *cmdln, FILE *fp, arg_t const* defn)\n{\n    if (defn == NULL)\n        return;\n    fprintf(fp, \"Arguments list definition:\\n\");\n    arg_dump_r(cmdln, fp, defn, TRUE);\n}\n\nvoid\ncmd_ln_print_values_r(cmd_ln_t *cmdln, FILE *fp, arg_t const* defn)\n{\n    if (defn == NULL)\n        return;\n    fprintf(fp, \"Current configuration:\\n\");\n    arg_dump_r(cmdln, fp, defn, FALSE);\n}\n\nint\ncmd_ln_exists_r(cmd_ln_t *cmdln, const char *name)\n{\n    void *val;\n    if (cmdln == NULL)\n        return FALSE;\n    return (hash_table_lookup(cmdln->ht, name, &val) == 0);\n}\n\nanytype_t *\ncmd_ln_access_r(cmd_ln_t *cmdln, const char *name)\n{\n    void *val;\n    if (hash_table_lookup(cmdln->ht, name, &val) < 0) {\n        E_ERROR(\"Unknown argument: %s\\n\", name);\n        return NULL;\n    }\n    return (anytype_t *)val;\n}\n\nchar const *\ncmd_ln_str_r(cmd_ln_t *cmdln, char const *name)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL)\n        return NULL;\n    return (char const *)val->ptr;\n}\n\nchar const **\ncmd_ln_str_list_r(cmd_ln_t *cmdln, char const *name)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL)\n        return NULL;\n    return (char const **)val->ptr;\n}\n\nlong\ncmd_ln_int_r(cmd_ln_t *cmdln, char const *name)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL)\n        return 0L;\n    return val->i;\n}\n\ndouble\ncmd_ln_float_r(cmd_ln_t *cmdln, char const *name)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL)\n        return 0.0;\n    return val->fl;\n}\n\nvoid\ncmd_ln_set_str_r(cmd_ln_t *cmdln, char const *name, char const *str)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL) {\n        E_ERROR(\"Unknown argument: %s\\n\", name);\n        return;\n    }\n    ckd_free(val->ptr);\n    val->ptr = ckd_salloc(str);\n}\n\nvoid\ncmd_ln_set_str_extra_r(cmd_ln_t *cmdln, char const *name, char const *str)\n{\n    cmd_ln_val_t *val;\n    if (hash_table_lookup(cmdln->ht, name, (void **)&val) < 0) {\n\tval = cmd_ln_val_init(ARG_STRING, name, str);\n\thash_table_enter(cmdln->ht, val->name, (void *)val);\n    } else {\n        ckd_free(val->val.ptr);\n        val->val.ptr = ckd_salloc(str);\n    }\n}\n\nvoid\ncmd_ln_set_int_r(cmd_ln_t *cmdln, char const *name, long iv)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL) {\n        E_ERROR(\"Unknown argument: %s\\n\", name);\n        return;\n    }\n    val->i = iv;\n}\n\nvoid\ncmd_ln_set_float_r(cmd_ln_t *cmdln, char const *name, double fv)\n{\n    anytype_t *val;\n    val = cmd_ln_access_r(cmdln, name);\n    if (val == NULL) {\n        E_ERROR(\"Unknown argument: %s\\n\", name);\n        return;\n    }\n    val->fl = fv;\n}\n\ncmd_ln_t *\ncmd_ln_retain(cmd_ln_t *cmdln)\n{\n    ++cmdln->refcount;\n    return cmdln;\n}\n\nint\ncmd_ln_free_r(cmd_ln_t *cmdln)\n{\n    if (cmdln == NULL)\n        return 0;\n    if (--cmdln->refcount > 0)\n        return cmdln->refcount;\n\n    if (cmdln->ht) {\n        glist_t entries;\n        gnode_t *gn;\n        int32 n;\n\n        entries = hash_table_tolist(cmdln->ht, &n);\n        for (gn = entries; gn; gn = gnode_next(gn)) {\n            hash_entry_t *e = (hash_entry_t *)gnode_ptr(gn);\n            cmd_ln_val_free((cmd_ln_val_t *)e->val);\n        }\n        glist_free(entries);\n        hash_table_free(cmdln->ht);\n        cmdln->ht = NULL;\n    }\n\n    if (cmdln->f_argv) {\n        int32 i;\n        for (i = 0; i < cmdln->f_argc; ++i) {\n            ckd_free(cmdln->f_argv[i]);\n        }\n        ckd_free(cmdln->f_argv);\n        cmdln->f_argv = NULL;\n        cmdln->f_argc = 0;\n    }\n    ckd_free(cmdln);\n    return 0;\n}\n\nvoid\ncmd_ln_free(void)\n{\n    cmd_ln_free_r(global_cmdln);\n    global_cmdln = NULL;\n}\n\n/* vim: set ts=4 sw=4: */\n","/****************************************************************\n *\n * The author of this software is David M. Gay.\n *\n * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose without fee is hereby granted, provided that this entire notice\n * is included in all copies of any software which is or includes a copy\n * or modification of this software and in all copies of the supporting\n * documentation for such software.\n *\n * THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY\n * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n *\n ***************************************************************/\n\n/****************************************************************\n * This is dtoa.c by David M. Gay, downloaded from\n * http://www.netlib.org/fp/dtoa.c on April 15, 2009 and modified for\n * inclusion into the Python core by Mark E. T. Dickinson and Eric V. Smith.\n * It was taken from Python distribution then and imported into sphinxbase.\n * Python version is preferred due to cleanups, though original\n * version at netlib is still maintained.\n *\n * Please remember to check http://www.netlib.org/fp regularly for bugfixes and updates.\n *\n * The major modifications from Gay's original code are as follows:\n *\n *  0. The original code has been specialized to Sphinxbase's needs by removing\n *     many of the #ifdef'd sections.  In particular, code to support VAX and\n *     IBM floating-point formats, hex NaNs, hex floats, locale-aware\n *     treatment of the decimal point, and setting of the inexact flag have\n *     been removed.\n *\n *  1. We use cdk_calloc and ckd_free in place of malloc and free.\n *\n *  2. The public functions strtod, dtoa and freedtoa all now have\n *     a sb_ prefix.\n *\n *  3. Instead of assuming that malloc always succeeds, we thread\n *     malloc failures through the code.  The functions\n *\n *     Balloc, multadd, s2b, i2b, mult, pow5mult, lshift, diff, d2b\n *\n *     of return type *Bigint all return NULL to indicate a malloc failure.\n *     Similarly, rv_alloc and nrv_alloc (return type char *) return NULL on\n *     failure.  bigcomp now has return type int (it used to be void) and\n *     returns -1 on failure and 0 otherwise.  sb_dtoa returns NULL\n *     on failure.  sb_strtod indicates failure due to malloc failure\n *     by returning -1.0, setting errno=ENOMEM and *se to s00.\n *\n *  4. The static variable dtoa_result has been removed.  Callers of\n *     sb_dtoa are expected to call sb_freedtoa to free the memory allocated \n *     by sb_dtoa.\n *\n *  5. The code has been reformatted to better fit with C style.\n *\n *  6. A bug in the memory allocation has been fixed: to avoid FREEing memory\n *     that hasn't been MALLOC'ed, private_mem should only be used when k <=\n *     Kmax.\n *\n *  7. sb_strtod has been modified so that it doesn't accept strings with\n *     leading whitespace.\n *\n *  8. Global static variables are not used due to memory access issues. Fixes\n *     usage from multiple threads.\n *\n ***************************************************************/\n\n/* Please send bug reports for the original dtoa.c code to David M. Gay (dmg\n * at acm dot org, with \" at \" changed at \"@\" and \" dot \" changed to \".\").\n */\n\n/* On a machine with IEEE extended-precision registers, it is\n * necessary to specify double-precision (53-bit) rounding precision\n * before invoking strtod or dtoa.  If the machine uses (the equivalent\n * of) Intel 80x87 arithmetic, the call\n *      _control87(PC_53, MCW_PC);\n * does this with many compilers.  Whether this or another call is\n * appropriate depends on the compiler; for this to work, it may be\n * necessary to #include \"float.h\" or another system-dependent header\n * file.\n */\n\n/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.\n *\n * This strtod returns a nearest machine number to the input decimal\n * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are\n * broken by the IEEE round-even rule.  Otherwise ties are broken by\n * biased rounding (add half and chop).\n *\n * Inspired loosely by William D. Clinger's paper \"How to Read Floating\n * Point Numbers Accurately\" [Proc. ACM SIGPLAN '90, pp. 92-101].\n *\n * Modifications:\n *\n *      1. We only require IEEE, IBM, or VAX double-precision\n *              arithmetic (not IEEE double-extended).\n *      2. We get by with floating-point arithmetic in a case that\n *              Clinger missed -- when we're computing d * 10^n\n *              for a small integer d and the integer n is not too\n *              much larger than 22 (the maximum integer k for which\n *              we can represent 10^k exactly), we may be able to\n *              compute (d*10^k) * 10^(e-k) with just one roundoff.\n *      3. Rather than a bit-at-a-time adjustment of the binary\n *              result in the hard case, we use floating-point\n *              arithmetic to determine the adjustment to within\n *              one bit; only in really hard cases do we need to\n *              compute a second residual.\n *      4. Because of 3., we don't need a large table of powers of 10\n *              for ten-to-e (just some small tables, e.g. of 10^k\n *              for 0 <= k <= 22).\n */\n\n/* Linking of sphinxbase's #defines to Gay's #defines starts here. */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/prim_type.h>\n\n#ifdef WORDS_BIGENDIAN\n#define IEEE_MC68k\n#else\n#define IEEE_8087\n#endif\n\n#define Long int32              /* ZOMG */\n#define ULong uint32            /* WTF */\n#ifdef HAVE_LONG_LONG\n#define ULLong uint64\n#endif\n\n#define MALLOC ckd_malloc\n#define FREE ckd_free\n\n#define DBL_DIG 15\n#define DBL_MAX_10_EXP 308\n#define DBL_MAX_EXP 1024\n#define FLT_RADIX 2\n\n/* maximum permitted exponent value for strtod; exponents larger than\n   MAX_ABS_EXP in absolute value get truncated to +-MAX_ABS_EXP.  MAX_ABS_EXP\n   should fit into an int. */\n#ifndef MAX_ABS_EXP\n#define MAX_ABS_EXP 1100000000U\n#endif\n/* Bound on length of pieces of input strings in sb_strtod; specifically,\n this is used to bound the total number of digits ignoring leading zeros and\n the number of digits that follow the decimal point.  Ideally, MAX_DIGITS\n should satisfy MAX_DIGITS + 400 < MAX_ABS_EXP; that ensures that the\n exponent clipping in sb_strtod can't affect the value of the output. */\n#ifndef MAX_DIGITS\n#define MAX_DIGITS 1000000000U\n#endif\n\n/* End sphinxbase #define linking */\n\n#ifdef DEBUG\n#define Bug(x) {fprintf(stderr, \"%s\\n\", x); exit(1);}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef union { double d; ULong L[2]; } U;\n\n#ifdef IEEE_8087\n#define word0(x) (x)->L[1]\n#define word1(x) (x)->L[0]\n#else\n#define word0(x) (x)->L[0]\n#define word1(x) (x)->L[1]\n#endif\n#define dval(x) (x)->d\n\n#ifndef STRTOD_DIGLIM\n#define STRTOD_DIGLIM 40\n#endif\n\n/* maximum permitted exponent value for strtod; exponents larger than\n   MAX_ABS_EXP in absolute value get truncated to +-MAX_ABS_EXP.  MAX_ABS_EXP\n   should fit into an int. */\n#ifndef MAX_ABS_EXP\n#define MAX_ABS_EXP 1100000000U\n#endif\n/* Bound on length of pieces of input strings in sb_strtod; specifically,\n   this is used to bound the total number of digits ignoring leading zeros and\n   the number of digits that follow the decimal point.  Ideally, MAX_DIGITS\n   should satisfy MAX_DIGITS + 400 < MAX_ABS_EXP; that ensures that the\n   exponent clipping in sb_strtod can't affect the value of the output. */\n#ifndef MAX_DIGITS\n#define MAX_DIGITS 1000000000U\n#endif\n\n/* Guard against trying to use the above values on unusual platforms with ints\n * of width less than 32 bits. */\n#if MAX_ABS_EXP > 0x7fffffff\n#error \"MAX_ABS_EXP should fit in an int\"\n#endif\n#if MAX_DIGITS > 0x7fffffff\n#error \"MAX_DIGITS should fit in an int\"\n#endif\n\n/* The following definition of Storeinc is appropriate for MIPS processors.\n * An alternative that might be better on some machines is\n * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)\n */\n#if defined(IEEE_8087)\n#define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b,  \\\n                         ((unsigned short *)a)[0] = (unsigned short)c, a++)\n#else\n#define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b,  \\\n                         ((unsigned short *)a)[1] = (unsigned short)c, a++)\n#endif\n\n/* #define P DBL_MANT_DIG */\n/* Ten_pmax = floor(P*log(2)/log(5)) */\n/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */\n/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */\n/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */\n\n#define Exp_shift  20\n#define Exp_shift1 20\n#define Exp_msk1    0x100000\n#define Exp_msk11   0x100000\n#define Exp_mask  0x7ff00000\n#define P 53\n#define Nbits 53\n#define Bias 1023\n#define Emax 1023\n#define Emin (-1022)\n#define Etiny (-1074)  /* smallest denormal is 2**Etiny */\n#define Exp_1  0x3ff00000\n#define Exp_11 0x3ff00000\n#define Ebits 11\n#define Frac_mask  0xfffff\n#define Frac_mask1 0xfffff\n#define Ten_pmax 22\n#define Bletch 0x10\n#define Bndry_mask  0xfffff\n#define Bndry_mask1 0xfffff\n#define Sign_bit 0x80000000\n#define Log2P 1\n#define Tiny0 0\n#define Tiny1 1\n#define Quick_max 14\n#define Int_max 14\n\n#ifndef Flt_Rounds\n#ifdef FLT_ROUNDS\n#define Flt_Rounds FLT_ROUNDS\n#else\n#define Flt_Rounds 1\n#endif\n#endif /*Flt_Rounds*/\n\n#define Rounding Flt_Rounds\n\n#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))\n#define Big1 0xffffffff\n\n/* Standard NaN used by sb_stdnan. */\n\n#define NAN_WORD0 0x7ff80000\n#define NAN_WORD1 0\n\n/* Bits of the representation of positive infinity. */\n\n#define POSINF_WORD0 0x7ff00000\n#define POSINF_WORD1 0\n\n/* struct BCinfo is used to pass information from sb_strtod to bigcomp */\n\ntypedef struct BCinfo BCinfo;\nstruct\nBCinfo {\n    int e0, nd, nd0, scale;\n};\n\n#define FFFFFFFF 0xffffffffUL\n\n#define Kmax 7\n\n/* struct Bigint is used to represent arbitrary-precision integers.  These\n   integers are stored in sign-magnitude format, with the magnitude stored as\n   an array of base 2**32 digits.  Bigints are always normalized: if x is a\n   Bigint then x->wds >= 1, and either x->wds == 1 or x[wds-1] is nonzero.\n\n   The Bigint fields are as follows:\n\n     - next is a header used by Balloc and Bfree to keep track of lists\n         of freed Bigints;  it's also used for the linked list of\n         powers of 5 of the form 5**2**i used by pow5mult.\n     - k indicates which pool this Bigint was allocated from\n     - maxwds is the maximum number of words space was allocated for\n       (usually maxwds == 2**k)\n     - sign is 1 for negative Bigints, 0 for positive.  The sign is unused\n       (ignored on inputs, set to 0 on outputs) in almost all operations\n       involving Bigints: a notable exception is the diff function, which\n       ignores signs on inputs but sets the sign of the output correctly.\n     - wds is the actual number of significant words\n     - x contains the vector of words (digits) for this Bigint, from least\n       significant (x[0]) to most significant (x[wds-1]).\n*/\n\nstruct\nBigint {\n    struct Bigint *next;\n    int k, maxwds, sign, wds;\n    ULong x[1];\n};\n\ntypedef struct Bigint Bigint;\n\n#define SPHINXBASE_USING_MEMORY_DEBUGGER 1\n\n#ifndef SPHINXBASE_USING_MEMORY_DEBUGGER\n\n#ifndef PRIVATE_MEM\n#define PRIVATE_MEM 2304\n#endif\n#define PRIVATE_mem ((PRIVATE_MEM+sizeof(double)-1)/sizeof(double))\nstatic double private_mem[PRIVATE_mem], *pmem_next = private_mem;\n\n/* Memory management: memory is allocated from, and returned to, Kmax+1 pools\n   of memory, where pool k (0 <= k <= Kmax) is for Bigints b with b->maxwds ==\n   1 << k.  These pools are maintained as linked lists, with freelist[k]\n   pointing to the head of the list for pool k.\n\n   On allocation, if there's no free slot in the appropriate pool, MALLOC is\n   called to get more memory.  This memory is not returned to the system until\n   Python quits.  There's also a private memory pool that's allocated from\n   in preference to using MALLOC.\n\n   For Bigints with more than (1 << Kmax) digits (which implies at least 1233\n   decimal digits), memory is directly allocated using MALLOC, and freed using\n   FREE.\n\n   XXX: it would be easy to bypass this memory-management system and\n   translate each call to Balloc into a call to PyMem_Malloc, and each\n   Bfree to PyMem_Free.  Investigate whether this has any significant\n   performance on impact. */\n\nstatic Bigint *freelist[Kmax+1];\n\n/* Allocate space for a Bigint with up to 1<<k digits */\n\nstatic Bigint *\nBalloc(int k)\n{\n    int x;\n    Bigint *rv;\n    unsigned int len;\n\n    if (k <= Kmax && (rv = freelist[k]))\n        freelist[k] = rv->next;\n    else {\n        x = 1 << k;\n        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)\n            /sizeof(double);\n        if (k <= Kmax && pmem_next - private_mem + len <= PRIVATE_mem) {\n            rv = (Bigint*)pmem_next;\n            pmem_next += len;\n        }\n        else {\n            rv = (Bigint*)MALLOC(len*sizeof(double));\n            if (rv == NULL)\n                return NULL;\n        }\n        rv->k = k;\n        rv->maxwds = x;\n    }\n    rv->sign = rv->wds = 0;\n    return rv;\n}\n\n/* Free a Bigint allocated with Balloc */\n\nstatic void\nBfree(Bigint *v)\n{\n    if (v) {\n        if (v->k > Kmax)\n            FREE((void*)v);\n        else {\n            v->next = freelist[v->k];\n            freelist[v->k] = v;\n        }\n    }\n}\n\n#else\n\n/* Alternative versions of Balloc and Bfree that use PyMem_Malloc and\n   PyMem_Free directly in place of the custom memory allocation scheme above.\n   These are provided for the benefit of memory debugging tools like\n   Valgrind. */\n\n/* Allocate space for a Bigint with up to 1<<k digits */\n\nstatic Bigint *\nBalloc(int k)\n{\n    int x;\n    Bigint *rv;\n    unsigned int len;\n\n    x = 1 << k;\n    len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)\n        /sizeof(double);\n\n    rv = (Bigint*)MALLOC(len*sizeof(double));\n    if (rv == NULL)\n        return NULL;\n\n    rv->k = k;\n    rv->maxwds = x;\n    rv->sign = rv->wds = 0;\n    return rv;\n}\n\n/* Free a Bigint allocated with Balloc */\n\nstatic void\nBfree(Bigint *v)\n{\n    if (v) {\n        FREE((void*)v);\n    }\n}\n\n#endif /* SPHINXBASE_USING_MEMORY_DEBUGGER */\n\n#define Bcopy(x,y) memcpy((char *)&x->sign, (char *)&y->sign,   \\\n                          y->wds*sizeof(Long) + 2*sizeof(int))\n\n/* Multiply a Bigint b by m and add a.  Either modifies b in place and returns\n   a pointer to the modified b, or Bfrees b and returns a pointer to a copy.\n   On failure, return NULL.  In this case, b will have been already freed. */\n\nstatic Bigint *\nmultadd(Bigint *b, int m, int a)       /* multiply by m and add a */\n{\n    int i, wds;\n#ifdef ULLong\n    ULong *x;\n    ULLong carry, y;\n#else\n    ULong carry, *x, y;\n    ULong xi, z;\n#endif\n    Bigint *b1;\n\n    wds = b->wds;\n    x = b->x;\n    i = 0;\n    carry = a;\n    do {\n#ifdef ULLong\n        y = *x * (ULLong)m + carry;\n        carry = y >> 32;\n        *x++ = (ULong)(y & FFFFFFFF);\n#else\n        xi = *x;\n        y = (xi & 0xffff) * m + carry;\n        z = (xi >> 16) * m + (y >> 16);\n        carry = z >> 16;\n        *x++ = (z << 16) + (y & 0xffff);\n#endif\n    }\n    while(++i < wds);\n    if (carry) {\n        if (wds >= b->maxwds) {\n            b1 = Balloc(b->k+1);\n            if (b1 == NULL){\n                Bfree(b);\n                return NULL;\n            }\n            Bcopy(b1, b);\n            Bfree(b);\n            b = b1;\n        }\n        b->x[wds++] = (ULong)carry;\n        b->wds = wds;\n    }\n    return b;\n}\n\n/* convert a string s containing nd decimal digits (possibly containing a\n   decimal separator at position nd0, which is ignored) to a Bigint.  This\n   function carries on where the parsing code in sb_strtod leaves off: on\n   entry, y9 contains the result of converting the first 9 digits.  Returns\n   NULL on failure. */\n\nstatic Bigint *\ns2b(const char *s, int nd0, int nd, ULong y9)\n{\n    Bigint *b;\n    int i, k;\n    Long x, y;\n\n    x = (nd + 8) / 9;\n    for(k = 0, y = 1; x > y; y <<= 1, k++) ;\n    b = Balloc(k);\n    if (b == NULL)\n        return NULL;\n    b->x[0] = y9;\n    b->wds = 1;\n\n    if (nd <= 9)\n      return b;\n\n    s += 9;\n    for (i = 9; i < nd0; i++) {\n        b = multadd(b, 10, *s++ - '0');\n        if (b == NULL)\n            return NULL;\n    }\n    s++;\n    for(; i < nd; i++) {\n        b = multadd(b, 10, *s++ - '0');\n        if (b == NULL)\n            return NULL;\n    }\n    return b;\n}\n\n/* count leading 0 bits in the 32-bit integer x. */\n\nstatic int\nhi0bits(ULong x)\n{\n    int k = 0;\n\n    if (!(x & 0xffff0000)) {\n        k = 16;\n        x <<= 16;\n    }\n    if (!(x & 0xff000000)) {\n        k += 8;\n        x <<= 8;\n    }\n    if (!(x & 0xf0000000)) {\n        k += 4;\n        x <<= 4;\n    }\n    if (!(x & 0xc0000000)) {\n        k += 2;\n        x <<= 2;\n    }\n    if (!(x & 0x80000000)) {\n        k++;\n        if (!(x & 0x40000000))\n            return 32;\n    }\n    return k;\n}\n\n/* count trailing 0 bits in the 32-bit integer y, and shift y right by that\n   number of bits. */\n\nstatic int\nlo0bits(ULong *y)\n{\n    int k;\n    ULong x = *y;\n\n    if (x & 7) {\n        if (x & 1)\n            return 0;\n        if (x & 2) {\n            *y = x >> 1;\n            return 1;\n        }\n        *y = x >> 2;\n        return 2;\n    }\n    k = 0;\n    if (!(x & 0xffff)) {\n        k = 16;\n        x >>= 16;\n    }\n    if (!(x & 0xff)) {\n        k += 8;\n        x >>= 8;\n    }\n    if (!(x & 0xf)) {\n        k += 4;\n        x >>= 4;\n    }\n    if (!(x & 0x3)) {\n        k += 2;\n        x >>= 2;\n    }\n    if (!(x & 1)) {\n        k++;\n        x >>= 1;\n        if (!x)\n            return 32;\n    }\n    *y = x;\n    return k;\n}\n\n/* convert a small nonnegative integer to a Bigint */\n\nstatic Bigint *\ni2b(int i)\n{\n    Bigint *b;\n\n    b = Balloc(1);\n    if (b == NULL)\n        return NULL;\n    b->x[0] = i;\n    b->wds = 1;\n    return b;\n}\n\n/* multiply two Bigints.  Returns a new Bigint, or NULL on failure.  Ignores\n   the signs of a and b. */\n\nstatic Bigint *\nmult(Bigint *a, Bigint *b)\n{\n    Bigint *c;\n    int k, wa, wb, wc;\n    ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;\n    ULong y;\n#ifdef ULLong\n    ULLong carry, z;\n#else\n    ULong carry, z;\n    ULong z2;\n#endif\n\n    if ((!a->x[0] && a->wds == 1) || (!b->x[0] && b->wds == 1)) {\n        c = Balloc(0);\n        if (c == NULL)\n            return NULL;\n        c->wds = 1;\n        c->x[0] = 0;\n        return c;\n    }\n\n    if (a->wds < b->wds) {\n        c = a;\n        a = b;\n        b = c;\n    }\n    k = a->k;\n    wa = a->wds;\n    wb = b->wds;\n    wc = wa + wb;\n    if (wc > a->maxwds)\n        k++;\n    c = Balloc(k);\n    if (c == NULL)\n        return NULL;\n    for(x = c->x, xa = x + wc; x < xa; x++)\n        *x = 0;\n    xa = a->x;\n    xae = xa + wa;\n    xb = b->x;\n    xbe = xb + wb;\n    xc0 = c->x;\n#ifdef ULLong\n    for(; xb < xbe; xc0++) {\n        if ((y = *xb++)) {\n            x = xa;\n            xc = xc0;\n            carry = 0;\n            do {\n                z = *x++ * (ULLong)y + *xc + carry;\n                carry = z >> 32;\n                *xc++ = (ULong)(z & FFFFFFFF);\n            }\n            while(x < xae);\n            *xc = (ULong)carry;\n        }\n    }\n#else\n    for(; xb < xbe; xb++, xc0++) {\n        if (y = *xb & 0xffff) {\n            x = xa;\n            xc = xc0;\n            carry = 0;\n            do {\n                z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;\n                carry = z >> 16;\n                z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;\n                carry = z2 >> 16;\n                Storeinc(xc, z2, z);\n            }\n            while(x < xae);\n            *xc = carry;\n        }\n        if (y = *xb >> 16) {\n            x = xa;\n            xc = xc0;\n            carry = 0;\n            z2 = *xc;\n            do {\n                z = (*x & 0xffff) * y + (*xc >> 16) + carry;\n                carry = z >> 16;\n                Storeinc(xc, z, z2);\n                z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;\n                carry = z2 >> 16;\n            }\n            while(x < xae);\n            *xc = z2;\n        }\n    }\n#endif\n    for(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;\n    c->wds = wc;\n    return c;\n}\n\n#ifndef SPHINXBASE_USING_MEMORY_DEBUGGER\n\n/* p5s is a linked list of powers of 5 of the form 5**(2**i), i >= 2 */\n\nstatic Bigint *p5s;\n\n/* multiply the Bigint b by 5**k.  Returns a pointer to the result, or NULL on\n   failure; if the returned pointer is distinct from b then the original\n   Bigint b will have been Bfree'd.   Ignores the sign of b. */\n\nstatic Bigint *\npow5mult(Bigint *b, int k)\n{\n    Bigint *b1, *p5, *p51;\n    int i;\n    static int p05[3] = { 5, 25, 125 };\n\n    if ((i = k & 3)) {\n        b = multadd(b, p05[i-1], 0);\n        if (b == NULL)\n            return NULL;\n    }\n\n    if (!(k >>= 2))\n        return b;\n    p5 = p5s;\n    if (!p5) {\n        /* first time */\n        p5 = i2b(625);\n        if (p5 == NULL) {\n            Bfree(b);\n            return NULL;\n        }\n        p5s = p5;\n        p5->next = 0;\n    }\n    for(;;) {\n        if (k & 1) {\n            b1 = mult(b, p5);\n            Bfree(b);\n            b = b1;\n            if (b == NULL)\n                return NULL;\n        }\n        if (!(k >>= 1))\n            break;\n        p51 = p5->next;\n        if (!p51) {\n            p51 = mult(p5,p5);\n            if (p51 == NULL) {\n                Bfree(b);\n                return NULL;\n            }\n            p51->next = 0;\n            p5->next = p51;\n        }\n        p5 = p51;\n    }\n    return b;\n}\n\n#else\n\n/* Version of pow5mult that doesn't cache powers of 5. Provided for\n   the benefit of memory debugging tools like Valgrind. */\n\nstatic Bigint *\npow5mult(Bigint *b, int k)\n{\n    Bigint *b1, *p5, *p51;\n    int i;\n    static int p05[3] = { 5, 25, 125 };\n\n    if ((i = k & 3)) {\n        b = multadd(b, p05[i-1], 0);\n        if (b == NULL)\n            return NULL;\n    }\n\n    if (!(k >>= 2))\n        return b;\n    p5 = i2b(625);\n    if (p5 == NULL) {\n        Bfree(b);\n        return NULL;\n    }\n\n    for(;;) {\n        if (k & 1) {\n            b1 = mult(b, p5);\n            Bfree(b);\n            b = b1;\n            if (b == NULL) {\n                Bfree(p5);\n                return NULL;\n            }\n        }\n        if (!(k >>= 1))\n            break;\n        p51 = mult(p5, p5);\n        Bfree(p5);\n        p5 = p51;\n        if (p5 == NULL) {\n            Bfree(b);\n            return NULL;\n        }\n    }\n    Bfree(p5);\n    return b;\n}\n\n#endif /* SPHINXBASE_USING_MEMORY_DEBUGGER */\n\n/* shift a Bigint b left by k bits.  Return a pointer to the shifted result,\n   or NULL on failure.  If the returned pointer is distinct from b then the\n   original b will have been Bfree'd.   Ignores the sign of b. */\n\nstatic Bigint *\nlshift(Bigint *b, int k)\n{\n    int i, k1, n, n1;\n    Bigint *b1;\n    ULong *x, *x1, *xe, z;\n\n    if (!k || (!b->x[0] && b->wds == 1))\n        return b;\n\n    n = k >> 5;\n    k1 = b->k;\n    n1 = n + b->wds + 1;\n    for(i = b->maxwds; n1 > i; i <<= 1)\n        k1++;\n    b1 = Balloc(k1);\n    if (b1 == NULL) {\n        Bfree(b);\n        return NULL;\n    }\n    x1 = b1->x;\n    for(i = 0; i < n; i++)\n        *x1++ = 0;\n    x = b->x;\n    xe = x + b->wds;\n    if (k &= 0x1f) {\n        k1 = 32 - k;\n        z = 0;\n        do {\n            *x1++ = *x << k | z;\n            z = *x++ >> k1;\n        }\n        while(x < xe);\n        if ((*x1 = z))\n            ++n1;\n    }\n    else do\n             *x1++ = *x++;\n        while(x < xe);\n    b1->wds = n1 - 1;\n    Bfree(b);\n    return b1;\n}\n\n/* Do a three-way compare of a and b, returning -1 if a < b, 0 if a == b and\n   1 if a > b.  Ignores signs of a and b. */\n\nstatic int\ncmp(Bigint *a, Bigint *b)\n{\n    ULong *xa, *xa0, *xb, *xb0;\n    int i, j;\n\n    i = a->wds;\n    j = b->wds;\n#ifdef DEBUG\n    if (i > 1 && !a->x[i-1])\n        Bug(\"cmp called with a->x[a->wds-1] == 0\");\n    if (j > 1 && !b->x[j-1])\n        Bug(\"cmp called with b->x[b->wds-1] == 0\");\n#endif\n    if (i -= j)\n        return i;\n    xa0 = a->x;\n    xa = xa0 + j;\n    xb0 = b->x;\n    xb = xb0 + j;\n    for(;;) {\n        if (*--xa != *--xb)\n            return *xa < *xb ? -1 : 1;\n        if (xa <= xa0)\n            break;\n    }\n    return 0;\n}\n\n/* Take the difference of Bigints a and b, returning a new Bigint.  Returns\n   NULL on failure.  The signs of a and b are ignored, but the sign of the\n   result is set appropriately. */\n\nstatic Bigint *\ndiff(Bigint *a, Bigint *b)\n{\n    Bigint *c;\n    int i, wa, wb;\n    ULong *xa, *xae, *xb, *xbe, *xc;\n#ifdef ULLong\n    ULLong borrow, y;\n#else\n    ULong borrow, y;\n    ULong z;\n#endif\n\n    i = cmp(a,b);\n    if (!i) {\n        c = Balloc(0);\n        if (c == NULL)\n            return NULL;\n        c->wds = 1;\n        c->x[0] = 0;\n        return c;\n    }\n    if (i < 0) {\n        c = a;\n        a = b;\n        b = c;\n        i = 1;\n    }\n    else\n        i = 0;\n    c = Balloc(a->k);\n    if (c == NULL)\n        return NULL;\n    c->sign = i;\n    wa = a->wds;\n    xa = a->x;\n    xae = xa + wa;\n    wb = b->wds;\n    xb = b->x;\n    xbe = xb + wb;\n    xc = c->x;\n    borrow = 0;\n#ifdef ULLong\n    do {\n        y = (ULLong)*xa++ - *xb++ - borrow;\n        borrow = y >> 32 & (ULong)1;\n        *xc++ = (ULong)(y & FFFFFFFF);\n    }\n    while(xb < xbe);\n    while(xa < xae) {\n        y = *xa++ - borrow;\n        borrow = y >> 32 & (ULong)1;\n        *xc++ = (ULong)(y & FFFFFFFF);\n    }\n#else\n    do {\n        y = (*xa & 0xffff) - (*xb & 0xffff) - borrow;\n        borrow = (y & 0x10000) >> 16;\n        z = (*xa++ >> 16) - (*xb++ >> 16) - borrow;\n        borrow = (z & 0x10000) >> 16;\n        Storeinc(xc, z, y);\n    }\n    while(xb < xbe);\n    while(xa < xae) {\n        y = (*xa & 0xffff) - borrow;\n        borrow = (y & 0x10000) >> 16;\n        z = (*xa++ >> 16) - borrow;\n        borrow = (z & 0x10000) >> 16;\n        Storeinc(xc, z, y);\n    }\n#endif\n    while(!*--xc)\n        wa--;\n    c->wds = wa;\n    return c;\n}\n\n/* Given a positive normal double x, return the difference between x and the\n   next double up.  Doesn't give correct results for subnormals. */\n\nstatic double\nulp(U *x)\n{\n    Long L;\n    U u;\n\n    L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;\n    word0(&u) = L;\n    word1(&u) = 0;\n    return dval(&u);\n}\n\n/* Convert a Bigint to a double plus an exponent */\n\nstatic double\nb2d(Bigint *a, int *e)\n{\n    ULong *xa, *xa0, w, y, z;\n    int k;\n    U d;\n\n    xa0 = a->x;\n    xa = xa0 + a->wds;\n    y = *--xa;\n#ifdef DEBUG\n    if (!y) Bug(\"zero y in b2d\");\n#endif\n    k = hi0bits(y);\n    *e = 32 - k;\n    if (k < Ebits) {\n        word0(&d) = Exp_1 | y >> (Ebits - k);\n        w = xa > xa0 ? *--xa : 0;\n        word1(&d) = y << ((32-Ebits) + k) | w >> (Ebits - k);\n        goto ret_d;\n    }\n    z = xa > xa0 ? *--xa : 0;\n    if (k -= Ebits) {\n        word0(&d) = Exp_1 | y << k | z >> (32 - k);\n        y = xa > xa0 ? *--xa : 0;\n        word1(&d) = z << k | y >> (32 - k);\n    }\n    else {\n        word0(&d) = Exp_1 | y;\n        word1(&d) = z;\n    }\n  ret_d:\n    return dval(&d);\n}\n\n/* Convert a scaled double to a Bigint plus an exponent.  Similar to d2b,\n   except that it accepts the scale parameter used in sb_strtod (which\n   should be either 0 or 2*P), and the normalization for the return value is\n   different (see below).  On input, d should be finite and nonnegative, and d\n   / 2**scale should be exactly representable as an IEEE 754 double.\n\n   Returns a Bigint b and an integer e such that\n\n     dval(d) / 2**scale = b * 2**e.\n\n   Unlike d2b, b is not necessarily odd: b and e are normalized so\n   that either 2**(P-1) <= b < 2**P and e >= Etiny, or b < 2**P\n   and e == Etiny.  This applies equally to an input of 0.0: in that\n   case the return values are b = 0 and e = Etiny.\n\n   The above normalization ensures that for all possible inputs d,\n   2**e gives ulp(d/2**scale).\n\n   Returns NULL on failure.\n*/\n\nstatic Bigint *\nsd2b(U *d, int scale, int *e)\n{\n    Bigint *b;\n\n    b = Balloc(1);\n    if (b == NULL)\n        return NULL;\n    \n    /* First construct b and e assuming that scale == 0. */\n    b->wds = 2;\n    b->x[0] = word1(d);\n    b->x[1] = word0(d) & Frac_mask;\n    *e = Etiny - 1 + (int)((word0(d) & Exp_mask) >> Exp_shift);\n    if (*e < Etiny)\n        *e = Etiny;\n    else\n        b->x[1] |= Exp_msk1;\n\n    /* Now adjust for scale, provided that b != 0. */\n    if (scale && (b->x[0] || b->x[1])) {\n        *e -= scale;\n        if (*e < Etiny) {\n            scale = Etiny - *e;\n            *e = Etiny;\n            /* We can't shift more than P-1 bits without shifting out a 1. */\n            assert(0 < scale && scale <= P - 1);\n            if (scale >= 32) {\n                /* The bits shifted out should all be zero. */\n                assert(b->x[0] == 0);\n                b->x[0] = b->x[1];\n                b->x[1] = 0;\n                scale -= 32;\n            }\n            if (scale) {\n                /* The bits shifted out should all be zero. */\n                assert(b->x[0] << (32 - scale) == 0);\n                b->x[0] = (b->x[0] >> scale) | (b->x[1] << (32 - scale));\n                b->x[1] >>= scale;\n            }\n        }\n    }\n    /* Ensure b is normalized. */\n    if (!b->x[1])\n        b->wds = 1;\n\n    return b;\n}\n\n/* Convert a double to a Bigint plus an exponent.  Return NULL on failure.\n\n   Given a finite nonzero double d, return an odd Bigint b and exponent *e\n   such that fabs(d) = b * 2**e.  On return, *bbits gives the number of\n   significant bits of b; that is, 2**(*bbits-1) <= b < 2**(*bbits).\n\n   If d is zero, then b == 0, *e == -1010, *bbits = 0.\n */\n\nstatic Bigint *\nd2b(U *d, int *e, int *bits)\n{\n    Bigint *b;\n    int de, k;\n    ULong *x, y, z;\n    int i;\n\n    b = Balloc(1);\n    if (b == NULL)\n        return NULL;\n    x = b->x;\n\n    z = word0(d) & Frac_mask;\n    word0(d) &= 0x7fffffff;   /* clear sign bit, which we ignore */\n    if ((de = (int)(word0(d) >> Exp_shift)))\n        z |= Exp_msk1;\n    if ((y = word1(d))) {\n        if ((k = lo0bits(&y))) {\n            x[0] = y | z << (32 - k);\n            z >>= k;\n        }\n        else\n            x[0] = y;\n        i =\n            b->wds = (x[1] = z) ? 2 : 1;\n    }\n    else {\n        k = lo0bits(&z);\n        x[0] = z;\n        i =\n            b->wds = 1;\n        k += 32;\n    }\n    if (de) {\n        *e = de - Bias - (P-1) + k;\n        *bits = P - k;\n    }\n    else {\n        *e = de - Bias - (P-1) + 1 + k;\n        *bits = 32*i - hi0bits(x[i-1]);\n    }\n    return b;\n}\n\n/* Compute the ratio of two Bigints, as a double.  The result may have an\n   error of up to 2.5 ulps. */\n\nstatic double\nratio(Bigint *a, Bigint *b)\n{\n    U da, db;\n    int k, ka, kb;\n\n    dval(&da) = b2d(a, &ka);\n    dval(&db) = b2d(b, &kb);\n    k = ka - kb + 32*(a->wds - b->wds);\n    if (k > 0)\n        word0(&da) += k*Exp_msk1;\n    else {\n        k = -k;\n        word0(&db) += k*Exp_msk1;\n    }\n    return dval(&da) / dval(&db);\n}\n\nstatic const double\ntens[] = {\n    1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n    1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n    1e20, 1e21, 1e22\n};\n\nstatic const double\nbigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };\nstatic const double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,\n                                   9007199254740992.*9007199254740992.e-256\n                                   /* = 2^106 * 1e-256 */\n};\n/* The factor of 2^53 in tinytens[4] helps us avoid setting the underflow */\n/* flag unnecessarily.  It leads to a song and dance at the end of strtod. */\n#define Scale_Bit 0x10\n#define n_bigtens 5\n\n#define ULbits 32\n#define kshift 5\n#define kmask 31\n\n\nstatic int\ndshift(Bigint *b, int p2)\n{\n    int rv = hi0bits(b->x[b->wds-1]) - 4;\n    if (p2 > 0)\n        rv -= p2;\n    return rv & kmask;\n}\n\n/* special case of Bigint division.  The quotient is always in the range 0 <=\n   quotient < 10, and on entry the divisor S is normalized so that its top 4\n   bits (28--31) are zero and bit 27 is set. */\n\nstatic int\nquorem(Bigint *b, Bigint *S)\n{\n    int n;\n    ULong *bx, *bxe, q, *sx, *sxe;\n#ifdef ULLong\n    ULLong borrow, carry, y, ys;\n#else\n    ULong borrow, carry, y, ys;\n    ULong si, z, zs;\n#endif\n\n    n = S->wds;\n#ifdef DEBUG\n    /*debug*/ if (b->wds > n)\n        /*debug*/       Bug(\"oversize b in quorem\");\n#endif\n    if (b->wds < n)\n        return 0;\n    sx = S->x;\n    sxe = sx + --n;\n    bx = b->x;\n    bxe = bx + n;\n    q = *bxe / (*sxe + 1);      /* ensure q <= true quotient */\n#ifdef DEBUG\n    /*debug*/ if (q > 9)\n        /*debug*/       Bug(\"oversized quotient in quorem\");\n#endif\n    if (q) {\n        borrow = 0;\n        carry = 0;\n        do {\n#ifdef ULLong\n            ys = *sx++ * (ULLong)q + carry;\n            carry = ys >> 32;\n            y = *bx - (ys & FFFFFFFF) - borrow;\n            borrow = y >> 32 & (ULong)1;\n            *bx++ = (ULong)(y & FFFFFFFF);\n#else\n            si = *sx++;\n            ys = (si & 0xffff) * q + carry;\n            zs = (si >> 16) * q + (ys >> 16);\n            carry = zs >> 16;\n            y = (*bx & 0xffff) - (ys & 0xffff) - borrow;\n            borrow = (y & 0x10000) >> 16;\n            z = (*bx >> 16) - (zs & 0xffff) - borrow;\n            borrow = (z & 0x10000) >> 16;\n            Storeinc(bx, z, y);\n#endif\n        }\n        while(sx <= sxe);\n        if (!*bxe) {\n            bx = b->x;\n            while(--bxe > bx && !*bxe)\n                --n;\n            b->wds = n;\n        }\n    }\n    if (cmp(b, S) >= 0) {\n        q++;\n        borrow = 0;\n        carry = 0;\n        bx = b->x;\n        sx = S->x;\n        do {\n#ifdef ULLong\n            ys = *sx++ + carry;\n            carry = ys >> 32;\n            y = *bx - (ys & FFFFFFFF) - borrow;\n            borrow = y >> 32 & (ULong)1;\n            *bx++ = (ULong)(y & FFFFFFFF);\n#else\n            si = *sx++;\n            ys = (si & 0xffff) + carry;\n            zs = (si >> 16) + (ys >> 16);\n            carry = zs >> 16;\n            y = (*bx & 0xffff) - (ys & 0xffff) - borrow;\n            borrow = (y & 0x10000) >> 16;\n            z = (*bx >> 16) - (zs & 0xffff) - borrow;\n            borrow = (z & 0x10000) >> 16;\n            Storeinc(bx, z, y);\n#endif\n        }\n        while(sx <= sxe);\n        bx = b->x;\n        bxe = bx + n;\n        if (!*bxe) {\n            while(--bxe > bx && !*bxe)\n                --n;\n            b->wds = n;\n        }\n    }\n    return q;\n}\n\n/* sulp(x) is a version of ulp(x) that takes bc.scale into account.\n\n   Assuming that x is finite and nonnegative (positive zero is fine\n   here) and x / 2^bc.scale is exactly representable as a double,\n   sulp(x) is equivalent to 2^bc.scale * ulp(x / 2^bc.scale). */\n\nstatic double\nsulp(U *x, BCinfo *bc)\n{\n    U u;\n\n    if (bc->scale && 2*P + 1 > (int)((word0(x) & Exp_mask) >> Exp_shift)) {\n        /* rv/2^bc->scale is subnormal */\n        word0(&u) = (P+2)*Exp_msk1;\n        word1(&u) = 0;\n        return u.d;\n    }\n    else {\n        assert(word0(x) || word1(x)); /* x != 0.0 */\n        return ulp(x);\n    }\n}\n\n/* The bigcomp function handles some hard cases for strtod, for inputs\n   with more than STRTOD_DIGLIM digits.  It's called once an initial\n   estimate for the double corresponding to the input string has\n   already been obtained by the code in sb_strtod.\n\n   The bigcomp function is only called after sb_strtod has found a\n   double value rv such that either rv or rv + 1ulp represents the\n   correctly rounded value corresponding to the original string.  It\n   determines which of these two values is the correct one by\n   computing the decimal digits of rv + 0.5ulp and comparing them with\n   the corresponding digits of s0.\n\n   In the following, write dv for the absolute value of the number represented\n   by the input string.\n\n   Inputs:\n\n     s0 points to the first significant digit of the input string.\n\n     rv is a (possibly scaled) estimate for the closest double value to the\n        value represented by the original input to sb_strtod.  If\n        bc->scale is nonzero, then rv/2^(bc->scale) is the approximation to\n        the input value.\n\n     bc is a struct containing information gathered during the parsing and\n        estimation steps of sb_strtod.  Description of fields follows:\n\n        bc->e0 gives the exponent of the input value, such that dv = (integer\n           given by the bd->nd digits of s0) * 10**e0\n\n        bc->nd gives the total number of significant digits of s0.  It will\n           be at least 1.\n\n        bc->nd0 gives the number of significant digits of s0 before the\n           decimal separator.  If there's no decimal separator, bc->nd0 ==\n           bc->nd.\n\n        bc->scale is the value used to scale rv to avoid doing arithmetic with\n           subnormal values.  It's either 0 or 2*P (=106).\n\n   Outputs:\n\n     On successful exit, rv/2^(bc->scale) is the closest double to dv.\n\n     Returns 0 on success, -1 on failure (e.g., due to a failed malloc call). */\n\nstatic int\nbigcomp(U *rv, const char *s0, BCinfo *bc)\n{\n    Bigint *b, *d;\n    int b2, d2, dd, i, nd, nd0, odd, p2, p5;\n\n    nd = bc->nd;\n    nd0 = bc->nd0;\n    p5 = nd + bc->e0;\n    b = sd2b(rv, bc->scale, &p2);\n    if (b == NULL)\n        return -1;\n\n    /* record whether the lsb of rv/2^(bc->scale) is odd:  in the exact halfway\n       case, this is used for round to even. */\n    odd = b->x[0] & 1;\n\n    /* left shift b by 1 bit and or a 1 into the least significant bit;\n       this gives us b * 2**p2 = rv/2^(bc->scale) + 0.5 ulp. */\n    b = lshift(b, 1);\n    if (b == NULL)\n        return -1;\n    b->x[0] |= 1;\n    p2--;\n\n    p2 -= p5;\n    d = i2b(1);\n    if (d == NULL) {\n        Bfree(b);\n        return -1;\n    }\n    /* Arrange for convenient computation of quotients:\n     * shift left if necessary so divisor has 4 leading 0 bits.\n     */\n    if (p5 > 0) {\n        d = pow5mult(d, p5);\n        if (d == NULL) {\n            Bfree(b);\n            return -1;\n        }\n    }\n    else if (p5 < 0) {\n        b = pow5mult(b, -p5);\n        if (b == NULL) {\n            Bfree(d);\n            return -1;\n        }\n    }\n    if (p2 > 0) {\n        b2 = p2;\n        d2 = 0;\n    }\n    else {\n        b2 = 0;\n        d2 = -p2;\n    }\n    i = dshift(d, d2);\n    if ((b2 += i) > 0) {\n        b = lshift(b, b2);\n        if (b == NULL) {\n            Bfree(d);\n            return -1;\n        }\n    }\n    if ((d2 += i) > 0) {\n        d = lshift(d, d2);\n        if (d == NULL) {\n            Bfree(b);\n            return -1;\n        }\n    }\n\n    /* Compare s0 with b/d: set dd to -1, 0, or 1 according as s0 < b/d, s0 ==\n     * b/d, or s0 > b/d.  Here the digits of s0 are thought of as representing\n     * a number in the range [0.1, 1). */\n    if (cmp(b, d) >= 0)\n        /* b/d >= 1 */\n        dd = -1;\n    else {\n        i = 0;\n        for(;;) {\n            b = multadd(b, 10, 0);\n            if (b == NULL) {\n                Bfree(d);\n                return -1;\n            }\n            dd = s0[i < nd0 ? i : i+1] - '0' - quorem(b, d);\n            i++;\n\n            if (dd)\n                break;\n            if (!b->x[0] && b->wds == 1) {\n                /* b/d == 0 */\n                dd = i < nd;\n                break;\n            }\n            if (!(i < nd)) {\n                /* b/d != 0, but digits of s0 exhausted */\n                dd = -1;\n                break;\n            }\n        }\n    }\n    Bfree(b);\n    Bfree(d);\n    if (dd > 0 || (dd == 0 && odd))\n        dval(rv) += sulp(rv, bc);\n    return 0;\n}\n\n/* Return a 'standard' NaN value.\n\n   There are exactly two quiet NaNs that don't arise by 'quieting' signaling\n   NaNs (see IEEE 754-2008, section 6.2.1).  If sign == 0, return the one whose\n   sign bit is cleared.  Otherwise, return the one whose sign bit is set.\n*/\n\ndouble\nsb_stdnan(int sign)\n{\n    U rv;\n    word0(&rv) = NAN_WORD0;\n    word1(&rv) = NAN_WORD1;\n    if (sign)\n        word0(&rv) |= Sign_bit;\n    return dval(&rv);\n}\n\n/* Return positive or negative infinity, according to the given sign (0 for\n * positive infinity, 1 for negative infinity). */\n\ndouble\nsb_infinity(int sign)\n{\n    U rv;\n    word0(&rv) = POSINF_WORD0;\n    word1(&rv) = POSINF_WORD1;\n    return sign ? -dval(&rv) : dval(&rv);\n}\n\ndouble\nsb_strtod(const char *s00, char **se)\n{\n    int bb2, bb5, bbe, bd2, bd5, bs2, c, dsign, e, e1, error;\n    int esign, i, j, k, lz, nd, nd0, odd, sign;\n    const char *s, *s0, *s1;\n    double aadj, aadj1;\n    U aadj2, adj, rv, rv0;\n    ULong y, z, abs_exp;\n    Long L;\n    BCinfo bc;\n    Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;\n    size_t ndigits, fraclen;\n\n    dval(&rv) = 0.;\n\n    /* Start parsing. */\n    c = *(s = s00);\n\n    /* Parse optional sign, if present. */\n    sign = 0;\n    switch (c) {\n    case '-':\n        sign = 1;\n        /* no break */\n    case '+':\n        c = *++s;\n    }\n\n    /* Skip leading zeros: lz is true iff there were leading zeros. */\n    s1 = s;\n    while (c == '0')\n        c = *++s;\n    lz = s != s1;\n\n    /* Point s0 at the first nonzero digit (if any).  fraclen will be the\n       number of digits between the decimal point and the end of the\n       digit string.  ndigits will be the total number of digits ignoring\n       leading zeros. */\n    s0 = s1 = s;\n    while ('0' <= c && c <= '9')\n        c = *++s;\n    ndigits = s - s1;\n    fraclen = 0;\n\n    /* Parse decimal point and following digits. */\n    if (c == '.') {\n        c = *++s;\n        if (!ndigits) {\n            s1 = s;\n            while (c == '0')\n                c = *++s;\n            lz = lz || s != s1;\n            fraclen += (s - s1);\n            s0 = s;\n        }\n        s1 = s;\n        while ('0' <= c && c <= '9')\n            c = *++s;\n        ndigits += s - s1;\n        fraclen += s - s1;\n    }\n\n    /* Now lz is true if and only if there were leading zero digits, and\n       ndigits gives the total number of digits ignoring leading zeros.  A\n       valid input must have at least one digit. */\n    if (!ndigits && !lz) {\n        if (se)\n            *se = (char *)s00;\n        goto parse_error;\n    }\n\n    /* Range check ndigits and fraclen to make sure that they, and values\n       computed with them, can safely fit in an int. */\n    if (ndigits > MAX_DIGITS || fraclen > MAX_DIGITS) {\n        if (se)\n            *se = (char *)s00;\n        goto parse_error;\n    }\n    nd = (int)ndigits;\n    nd0 = (int)ndigits - (int)fraclen;\n\n    /* Parse exponent. */\n    e = 0;\n    if (c == 'e' || c == 'E') {\n        s00 = s;\n        c = *++s;\n\n        /* Exponent sign. */\n        esign = 0;\n        switch (c) {\n        case '-':\n            esign = 1;\n            /* no break */\n        case '+':\n            c = *++s;\n        }\n\n        /* Skip zeros.  lz is true iff there are leading zeros. */\n        s1 = s;\n        while (c == '0')\n            c = *++s;\n        lz = s != s1;\n\n        /* Get absolute value of the exponent. */\n        s1 = s;\n        abs_exp = 0;\n        while ('0' <= c && c <= '9') {\n            abs_exp = 10*abs_exp + (c - '0');\n            c = *++s;\n        }\n\n        /* abs_exp will be correct modulo 2**32.  But 10**9 < 2**32, so if\n           there are at most 9 significant exponent digits then overflow is\n           impossible. */\n        if (s - s1 > 9 || abs_exp > MAX_ABS_EXP)\n            e = (int)MAX_ABS_EXP;\n        else\n            e = (int)abs_exp;\n        if (esign)\n            e = -e;\n\n        /* A valid exponent must have at least one digit. */\n        if (s == s1 && !lz)\n            s = s00;\n    }\n\n    /* Adjust exponent to take into account position of the point. */\n    e -= nd - nd0;\n    if (nd0 <= 0)\n        nd0 = nd;\n\n    /* Finished parsing.  Set se to indicate how far we parsed */\n    if (se)\n        *se = (char *)s;\n\n    /* If all digits were zero, exit with return value +-0.0.  Otherwise,\n       strip trailing zeros: scan back until we hit a nonzero digit. */\n    if (!nd)\n        goto ret;\n    for (i = nd; i > 0; ) {\n        --i;\n        if (s0[i < nd0 ? i : i+1] != '0') {\n            ++i;\n            break;\n        }\n    }\n    e += nd - i;\n    nd = i;\n    if (nd0 > nd)\n        nd0 = nd;\n\n    /* Summary of parsing results.  After parsing, and dealing with zero\n     * inputs, we have values s0, nd0, nd, e, sign, where:\n     *\n     *  - s0 points to the first significant digit of the input string\n     *\n     *  - nd is the total number of significant digits (here, and\n     *    below, 'significant digits' means the set of digits of the\n     *    significand of the input that remain after ignoring leading\n     *    and trailing zeros).\n     *\n     *  - nd0 indicates the position of the decimal point, if present; it\n     *    satisfies 1 <= nd0 <= nd.  The nd significant digits are in\n     *    s0[0:nd0] and s0[nd0+1:nd+1] using the usual Python half-open slice\n     *    notation.  (If nd0 < nd, then s0[nd0] contains a '.'  character; if\n     *    nd0 == nd, then s0[nd0] could be any non-digit character.)\n     *\n     *  - e is the adjusted exponent: the absolute value of the number\n     *    represented by the original input string is n * 10**e, where\n     *    n is the integer represented by the concatenation of\n     *    s0[0:nd0] and s0[nd0+1:nd+1]\n     *\n     *  - sign gives the sign of the input:  1 for negative, 0 for positive\n     *\n     *  - the first and last significant digits are nonzero\n     */\n\n    /* put first DBL_DIG+1 digits into integer y and z.\n     *\n     *  - y contains the value represented by the first min(9, nd)\n     *    significant digits\n     *\n     *  - if nd > 9, z contains the value represented by significant digits\n     *    with indices in [9, min(16, nd)).  So y * 10**(min(16, nd) - 9) + z\n     *    gives the value represented by the first min(16, nd) sig. digits.\n     */\n\n    bc.e0 = e1 = e;\n    y = z = 0;\n    for (i = 0; i < nd; i++) {\n        if (i < 9)\n            y = 10*y + s0[i < nd0 ? i : i+1] - '0';\n        else if (i < DBL_DIG+1)\n            z = 10*z + s0[i < nd0 ? i : i+1] - '0';\n        else\n            break;\n    }\n\n    k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;\n    dval(&rv) = y;\n    if (k > 9) {\n        dval(&rv) = tens[k - 9] * dval(&rv) + z;\n    }\n    bd0 = 0;\n    if (nd <= DBL_DIG\n        && Flt_Rounds == 1\n        ) {\n        if (!e)\n            goto ret;\n        if (e > 0) {\n            if (e <= Ten_pmax) {\n                dval(&rv) *= tens[e];\n                goto ret;\n            }\n            i = DBL_DIG - nd;\n            if (e <= Ten_pmax + i) {\n                /* A fancier test would sometimes let us do\n                 * this for larger i values.\n                 */\n                e -= i;\n                dval(&rv) *= tens[i];\n                dval(&rv) *= tens[e];\n                goto ret;\n            }\n        }\n        else if (e >= -Ten_pmax) {\n            dval(&rv) /= tens[-e];\n            goto ret;\n        }\n    }\n    e1 += nd - k;\n\n    bc.scale = 0;\n\n    /* Get starting approximation = rv * 10**e1 */\n\n    if (e1 > 0) {\n        if ((i = e1 & 15))\n            dval(&rv) *= tens[i];\n        if (e1 &= ~15) {\n            if (e1 > DBL_MAX_10_EXP)\n                goto ovfl;\n            e1 >>= 4;\n            for(j = 0; e1 > 1; j++, e1 >>= 1)\n                if (e1 & 1)\n                    dval(&rv) *= bigtens[j];\n            /* The last multiplication could overflow. */\n            word0(&rv) -= P*Exp_msk1;\n            dval(&rv) *= bigtens[j];\n            if ((z = word0(&rv) & Exp_mask)\n                > Exp_msk1*(DBL_MAX_EXP+Bias-P))\n                goto ovfl;\n            if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {\n                /* set to largest number */\n                /* (Can't trust DBL_MAX) */\n                word0(&rv) = Big0;\n                word1(&rv) = Big1;\n            }\n            else\n                word0(&rv) += P*Exp_msk1;\n        }\n    }\n    else if (e1 < 0) {\n        /* The input decimal value lies in [10**e1, 10**(e1+16)).\n\n           If e1 <= -512, underflow immediately.\n           If e1 <= -256, set bc.scale to 2*P.\n\n           So for input value < 1e-256, bc.scale is always set;\n           for input value >= 1e-240, bc.scale is never set.\n           For input values in [1e-256, 1e-240), bc.scale may or may\n           not be set. */\n\n        e1 = -e1;\n        if ((i = e1 & 15))\n            dval(&rv) /= tens[i];\n        if (e1 >>= 4) {\n            if (e1 >= 1 << n_bigtens)\n                goto undfl;\n            if (e1 & Scale_Bit)\n                bc.scale = 2*P;\n            for(j = 0; e1 > 0; j++, e1 >>= 1)\n                if (e1 & 1)\n                    dval(&rv) *= tinytens[j];\n            if (bc.scale && (j = 2*P + 1 - ((word0(&rv) & Exp_mask)\n                                            >> Exp_shift)) > 0) {\n                /* scaled rv is denormal; clear j low bits */\n                if (j >= 32) {\n                    word1(&rv) = 0;\n                    if (j >= 53)\n                        word0(&rv) = (P+2)*Exp_msk1;\n                    else\n                        word0(&rv) &= 0xffffffff << (j-32);\n                }\n                else\n                    word1(&rv) &= 0xffffffff << j;\n            }\n            if (!dval(&rv))\n                goto undfl;\n        }\n    }\n\n    /* Now the hard part -- adjusting rv to the correct value.*/\n\n    /* Put digits into bd: true value = bd * 10^e */\n\n    bc.nd = nd;\n    bc.nd0 = nd0;       /* Only needed if nd > STRTOD_DIGLIM, but done here */\n                        /* to silence an erroneous warning about bc.nd0 */\n                        /* possibly not being initialized. */\n    if (nd > STRTOD_DIGLIM) {\n        /* ASSERT(STRTOD_DIGLIM >= 18); 18 == one more than the */\n        /* minimum number of decimal digits to distinguish double values */\n        /* in IEEE arithmetic. */\n\n        /* Truncate input to 18 significant digits, then discard any trailing\n           zeros on the result by updating nd, nd0, e and y suitably. (There's\n           no need to update z; it's not reused beyond this point.) */\n        for (i = 18; i > 0; ) {\n            /* scan back until we hit a nonzero digit.  significant digit 'i'\n            is s0[i] if i < nd0, s0[i+1] if i >= nd0. */\n            --i;\n            if (s0[i < nd0 ? i : i+1] != '0') {\n                ++i;\n                break;\n            }\n        }\n        e += nd - i;\n        nd = i;\n        if (nd0 > nd)\n            nd0 = nd;\n        if (nd < 9) { /* must recompute y */\n            y = 0;\n            for(i = 0; i < nd0; ++i)\n                y = 10*y + s0[i] - '0';\n            for(; i < nd; ++i)\n                y = 10*y + s0[i+1] - '0';\n        }\n    }\n    bd0 = s2b(s0, nd0, nd, y);\n    if (bd0 == NULL)\n        goto failed_malloc;\n\n    /* Notation for the comments below.  Write:\n\n         - dv for the absolute value of the number represented by the original\n           decimal input string.\n\n         - if we've truncated dv, write tdv for the truncated value.\n           Otherwise, set tdv == dv.\n\n         - srv for the quantity rv/2^bc.scale; so srv is the current binary\n           approximation to tdv (and dv).  It should be exactly representable\n           in an IEEE 754 double.\n    */\n\n    for(;;) {\n\n        /* This is the main correction loop for sb_strtod.\n\n           We've got a decimal value tdv, and a floating-point approximation\n           srv=rv/2^bc.scale to tdv.  The aim is to determine whether srv is\n           close enough (i.e., within 0.5 ulps) to tdv, and to compute a new\n           approximation if not.\n\n           To determine whether srv is close enough to tdv, compute integers\n           bd, bb and bs proportional to tdv, srv and 0.5 ulp(srv)\n           respectively, and then use integer arithmetic to determine whether\n           |tdv - srv| is less than, equal to, or greater than 0.5 ulp(srv).\n        */\n\n        bd = Balloc(bd0->k);\n        if (bd == NULL) {\n            Bfree(bd0);\n            goto failed_malloc;\n        }\n        Bcopy(bd, bd0);\n        bb = sd2b(&rv, bc.scale, &bbe);   /* srv = bb * 2^bbe */\n        if (bb == NULL) {\n            Bfree(bd);\n            Bfree(bd0);\n            goto failed_malloc;\n        }\n        /* Record whether lsb of bb is odd, in case we need this\n           for the round-to-even step later. */\n        odd = bb->x[0] & 1;\n\n        /* tdv = bd * 10**e;  srv = bb * 2**bbe */\n        bs = i2b(1);\n        if (bs == NULL) {\n            Bfree(bb);\n            Bfree(bd);\n            Bfree(bd0);\n            goto failed_malloc;\n        }\n\n        if (e >= 0) {\n            bb2 = bb5 = 0;\n            bd2 = bd5 = e;\n        }\n        else {\n            bb2 = bb5 = -e;\n            bd2 = bd5 = 0;\n        }\n        if (bbe >= 0)\n            bb2 += bbe;\n        else\n            bd2 -= bbe;\n        bs2 = bb2;\n        bb2++;\n        bd2++;\n\n        /* At this stage bd5 - bb5 == e == bd2 - bb2 + bbe, bb2 - bs2 == 1,\n           and bs == 1, so:\n\n              tdv == bd * 10**e = bd * 2**(bbe - bb2 + bd2) * 5**(bd5 - bb5)\n              srv == bb * 2**bbe = bb * 2**(bbe - bb2 + bb2)\n              0.5 ulp(srv) == 2**(bbe-1) = bs * 2**(bbe - bb2 + bs2)\n\n           It follows that:\n\n              M * tdv = bd * 2**bd2 * 5**bd5\n              M * srv = bb * 2**bb2 * 5**bb5\n              M * 0.5 ulp(srv) = bs * 2**bs2 * 5**bb5\n\n           for some constant M.  (Actually, M == 2**(bb2 - bbe) * 5**bb5, but\n           this fact is not needed below.)\n        */\n\n        /* Remove factor of 2**i, where i = min(bb2, bd2, bs2). */\n        i = bb2 < bd2 ? bb2 : bd2;\n        if (i > bs2)\n            i = bs2;\n        if (i > 0) {\n            bb2 -= i;\n            bd2 -= i;\n            bs2 -= i;\n        }\n\n        /* Scale bb, bd, bs by the appropriate powers of 2 and 5. */\n        if (bb5 > 0) {\n            bs = pow5mult(bs, bb5);\n            if (bs == NULL) {\n                Bfree(bb);\n                Bfree(bd);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n            bb1 = mult(bs, bb);\n            Bfree(bb);\n            bb = bb1;\n            if (bb == NULL) {\n                Bfree(bs);\n                Bfree(bd);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n        }\n        if (bb2 > 0) {\n            bb = lshift(bb, bb2);\n            if (bb == NULL) {\n                Bfree(bs);\n                Bfree(bd);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n        }\n        if (bd5 > 0) {\n            bd = pow5mult(bd, bd5);\n            if (bd == NULL) {\n                Bfree(bb);\n                Bfree(bs);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n        }\n        if (bd2 > 0) {\n            bd = lshift(bd, bd2);\n            if (bd == NULL) {\n                Bfree(bb);\n                Bfree(bs);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n        }\n        if (bs2 > 0) {\n            bs = lshift(bs, bs2);\n            if (bs == NULL) {\n                Bfree(bb);\n                Bfree(bd);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n        }\n\n        /* Now bd, bb and bs are scaled versions of tdv, srv and 0.5 ulp(srv),\n           respectively.  Compute the difference |tdv - srv|, and compare\n           with 0.5 ulp(srv). */\n\n        delta = diff(bb, bd);\n        if (delta == NULL) {\n            Bfree(bb);\n            Bfree(bs);\n            Bfree(bd);\n            Bfree(bd0);\n            goto failed_malloc;\n        }\n        dsign = delta->sign;\n        delta->sign = 0;\n        i = cmp(delta, bs);\n        if (bc.nd > nd && i <= 0) {\n            if (dsign)\n                break;  /* Must use bigcomp(). */\n\n            /* Here rv overestimates the truncated decimal value by at most\n               0.5 ulp(rv).  Hence rv either overestimates the true decimal\n               value by <= 0.5 ulp(rv), or underestimates it by some small\n               amount (< 0.1 ulp(rv)); either way, rv is within 0.5 ulps of\n               the true decimal value, so it's possible to exit.\n\n               Exception: if scaled rv is a normal exact power of 2, but not\n               DBL_MIN, then rv - 0.5 ulp(rv) takes us all the way down to the\n               next double, so the correctly rounded result is either rv - 0.5\n               ulp(rv) or rv; in this case, use bigcomp to distinguish. */\n\n            if (!word1(&rv) && !(word0(&rv) & Bndry_mask)) {\n                /* rv can't be 0, since it's an overestimate for some\n                   nonzero value.  So rv is a normal power of 2. */\n                j = (int)(word0(&rv) & Exp_mask) >> Exp_shift;\n                /* rv / 2^bc.scale = 2^(j - 1023 - bc.scale); use bigcomp if\n                   rv / 2^bc.scale >= 2^-1021. */\n                if (j - bc.scale >= 2) {\n                    dval(&rv) -= 0.5 * sulp(&rv, &bc);\n                    break; /* Use bigcomp. */\n                }\n            }\n\n            {\n                bc.nd = nd;\n                i = -1; /* Discarded digits make delta smaller. */\n            }\n        }\n\n        if (i < 0) {\n            /* Error is less than half an ulp -- check for\n             * special case of mantissa a power of two.\n             */\n            if (dsign || word1(&rv) || word0(&rv) & Bndry_mask\n                || (word0(&rv) & Exp_mask) <= (2*P+1)*Exp_msk1\n                ) {\n                break;\n            }\n            if (!delta->x[0] && delta->wds <= 1) {\n                /* exact result */\n                break;\n            }\n            delta = lshift(delta,Log2P);\n            if (delta == NULL) {\n                Bfree(bb);\n                Bfree(bs);\n                Bfree(bd);\n                Bfree(bd0);\n                goto failed_malloc;\n            }\n            if (cmp(delta, bs) > 0)\n                goto drop_down;\n            break;\n        }\n        if (i == 0) {\n            /* exactly half-way between */\n            if (dsign) {\n                if ((word0(&rv) & Bndry_mask1) == Bndry_mask1\n                    &&  word1(&rv) == (\n                        (bc.scale &&\n                         (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1) ?\n                        (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :\n                        0xffffffff)) {\n                    /*boundary case -- increment exponent*/\n                    word0(&rv) = (word0(&rv) & Exp_mask)\n                        + Exp_msk1\n                        ;\n                    word1(&rv) = 0;\n                    /* dsign = 0; */\n                    break;\n                }\n            }\n            else if (!(word0(&rv) & Bndry_mask) && !word1(&rv)) {\n              drop_down:\n                /* boundary case -- decrement exponent */\n                if (bc.scale) {\n                    L = word0(&rv) & Exp_mask;\n                    if (L <= (2*P+1)*Exp_msk1) {\n                        if (L > (P+2)*Exp_msk1)\n                            /* round even ==> */\n                            /* accept rv */\n                            break;\n                        /* rv = smallest denormal */\n                        if (bc.nd > nd)\n                            break;\n                        goto undfl;\n                    }\n                }\n                L = (word0(&rv) & Exp_mask) - Exp_msk1;\n                word0(&rv) = L | Bndry_mask1;\n                word1(&rv) = 0xffffffff;\n                break;\n            }\n            if (!odd)\n                break;\n            if (dsign)\n                dval(&rv) += sulp(&rv, &bc);\n            else {\n                dval(&rv) -= sulp(&rv, &bc);\n                if (!dval(&rv)) {\n                    if (bc.nd >nd)\n                        break;\n                    goto undfl;\n                }\n            }\n            /* dsign = 1 - dsign; */\n            break;\n        }\n        if ((aadj = ratio(delta, bs)) <= 2.) {\n            if (dsign)\n                aadj = aadj1 = 1.;\n            else if (word1(&rv) || word0(&rv) & Bndry_mask) {\n                if (word1(&rv) == Tiny1 && !word0(&rv)) {\n                    if (bc.nd >nd)\n                        break;\n                    goto undfl;\n                }\n                aadj = 1.;\n                aadj1 = -1.;\n            }\n            else {\n                /* special case -- power of FLT_RADIX to be */\n                /* rounded down... */\n\n                if (aadj < 2./FLT_RADIX)\n                    aadj = 1./FLT_RADIX;\n                else\n                    aadj *= 0.5;\n                aadj1 = -aadj;\n            }\n        }\n        else {\n            aadj *= 0.5;\n            aadj1 = dsign ? aadj : -aadj;\n            if (Flt_Rounds == 0)\n                aadj1 += 0.5;\n        }\n        y = word0(&rv) & Exp_mask;\n\n        /* Check for overflow */\n\n        if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {\n            dval(&rv0) = dval(&rv);\n            word0(&rv) -= P*Exp_msk1;\n            adj.d = aadj1 * ulp(&rv);\n            dval(&rv) += adj.d;\n            if ((word0(&rv) & Exp_mask) >=\n                Exp_msk1*(DBL_MAX_EXP+Bias-P)) {\n                if (word0(&rv0) == Big0 && word1(&rv0) == Big1) {\n                    Bfree(bb);\n                    Bfree(bd);\n                    Bfree(bs);\n                    Bfree(bd0);\n                    Bfree(delta);\n                    goto ovfl;\n                }\n                word0(&rv) = Big0;\n                word1(&rv) = Big1;\n                goto cont;\n            }\n            else\n                word0(&rv) += P*Exp_msk1;\n        }\n        else {\n            if (bc.scale && y <= 2*P*Exp_msk1) {\n                if (aadj <= 0x7fffffff) {\n                    if ((z = (ULong)aadj) <= 0)\n                        z = 1;\n                    aadj = z;\n                    aadj1 = dsign ? aadj : -aadj;\n                }\n                dval(&aadj2) = aadj1;\n                word0(&aadj2) += (2*P+1)*Exp_msk1 - y;\n                aadj1 = dval(&aadj2);\n            }\n            adj.d = aadj1 * ulp(&rv);\n            dval(&rv) += adj.d;\n        }\n        z = word0(&rv) & Exp_mask;\n        if (bc.nd == nd) {\n            if (!bc.scale)\n                if (y == z) {\n                    /* Can we stop now? */\n                    L = (Long)aadj;\n                    aadj -= L;\n                    /* The tolerances below are conservative. */\n                    if (dsign || word1(&rv) || word0(&rv) & Bndry_mask) {\n                        if (aadj < .4999999 || aadj > .5000001)\n                            break;\n                    }\n                    else if (aadj < .4999999/FLT_RADIX)\n                        break;\n                }\n        }\n      cont:\n        Bfree(bb);\n        Bfree(bd);\n        Bfree(bs);\n        Bfree(delta);\n    }\n    Bfree(bb);\n    Bfree(bd);\n    Bfree(bs);\n    Bfree(bd0);\n    Bfree(delta);\n    if (bc.nd > nd) {\n        error = bigcomp(&rv, s0, &bc);\n        if (error)\n            goto failed_malloc;\n    }\n\n    if (bc.scale) {\n        word0(&rv0) = Exp_1 - 2*P*Exp_msk1;\n        word1(&rv0) = 0;\n        dval(&rv) *= dval(&rv0);\n    }\n\n  ret:\n    return sign ? -dval(&rv) : dval(&rv);\n\n  parse_error:\n    return 0.0;\n\n  failed_malloc:\n    errno = ENOMEM;\n    return -1.0;\n\n  undfl:\n    return sign ? -0.0 : 0.0;\n\n  ovfl:\n    errno = ERANGE;\n    /* Can't trust HUGE_VAL */\n    word0(&rv) = Exp_mask;\n    word1(&rv) = 0;\n    return sign ? -dval(&rv) : dval(&rv);\n\n}\n\nstatic char *\nrv_alloc(int i)\n{\n    int j, k, *r;\n\n    j = sizeof(ULong);\n    for(k = 0;\n        sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= (unsigned)i;\n        j <<= 1)\n        k++;\n    r = (int*)Balloc(k);\n    if (r == NULL)\n        return NULL;\n    *r = k;\n    return (char *)(r+1);\n}\n\nstatic char *\nnrv_alloc(char *s, char **rve, int n)\n{\n    char *rv, *t;\n\n    rv = rv_alloc(n);\n    if (rv == NULL)\n        return NULL;\n    t = rv;\n    while((*t = *s++)) t++;\n    if (rve)\n        *rve = t;\n    return rv;\n}\n\n/* freedtoa(s) must be used to free values s returned by dtoa\n * when MULTIPLE_THREADS is #defined.  It should be used in all cases,\n * but for consistency with earlier versions of dtoa, it is optional\n * when MULTIPLE_THREADS is not defined.\n */\n\nvoid\nsb_freedtoa(char *s)\n{\n    Bigint *b = (Bigint *)((int *)s - 1);\n    b->maxwds = 1 << (b->k = *(int*)b);\n    Bfree(b);\n}\n\n/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.\n *\n * Inspired by \"How to Print Floating-Point Numbers Accurately\" by\n * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 112-126].\n *\n * Modifications:\n *      1. Rather than iterating, we use a simple numeric overestimate\n *         to determine k = floor(log10(d)).  We scale relevant\n *         quantities using O(log2(k)) rather than O(k) multiplications.\n *      2. For some modes > 2 (corresponding to ecvt and fcvt), we don't\n *         try to generate digits strictly left to right.  Instead, we\n *         compute with fewer bits and propagate the carry if necessary\n *         when rounding the final digit up.  This is often faster.\n *      3. Under the assumption that input will be rounded nearest,\n *         mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.\n *         That is, we allow equality in stopping tests when the\n *         round-nearest rule will give the same floating-point value\n *         as would satisfaction of the stopping test with strict\n *         inequality.\n *      4. We remove common factors of powers of 2 from relevant\n *         quantities.\n *      5. When converting floating-point integers less than 1e16,\n *         we use floating-point arithmetic rather than resorting\n *         to multiple-precision integers.\n *      6. When asked to produce fewer than 15 digits, we first try\n *         to get by with floating-point arithmetic; we resort to\n *         multiple-precision integer arithmetic only if we cannot\n *         guarantee that the floating-point calculation has given\n *         the correctly rounded result.  For k requested digits and\n *         \"uniformly\" distributed input, the probability is\n *         something like 10^(k-15) that we must resort to the Long\n *         calculation.\n */\n\n/* Additional notes (METD): (1) returns NULL on failure.  (2) to avoid memory\n   leakage, a successful call to sb_dtoa should always be matched by a\n   call to sb_freedtoa. */\n\nchar *\nsb_dtoa(double dd, int mode, int ndigits,\n            int *decpt, int *sign, char **rve)\n{\n    /*  Arguments ndigits, decpt, sign are similar to those\n        of ecvt and fcvt; trailing zeros are suppressed from\n        the returned string.  If not null, *rve is set to point\n        to the end of the return value.  If d is +-Infinity or NaN,\n        then *decpt is set to 9999.\n\n        mode:\n        0 ==> shortest string that yields d when read in\n        and rounded to nearest.\n        1 ==> like 0, but with Steele & White stopping rule;\n        e.g. with IEEE P754 arithmetic , mode 0 gives\n        1e23 whereas mode 1 gives 9.999999999999999e22.\n        2 ==> max(1,ndigits) significant digits.  This gives a\n        return value similar to that of ecvt, except\n        that trailing zeros are suppressed.\n        3 ==> through ndigits past the decimal point.  This\n        gives a return value similar to that from fcvt,\n        except that trailing zeros are suppressed, and\n        ndigits can be negative.\n        4,5 ==> similar to 2 and 3, respectively, but (in\n        round-nearest mode) with the tests of mode 0 to\n        possibly return a shorter string that rounds to d.\n        With IEEE arithmetic and compilation with\n        -DHonor_FLT_ROUNDS, modes 4 and 5 behave the same\n        as modes 2 and 3 when FLT_ROUNDS != 1.\n        6-9 ==> Debugging modes similar to mode - 4:  don't try\n        fast floating-point estimate (if applicable).\n\n        Values of mode other than 0-9 are treated as mode 0.\n\n        Sufficient space is allocated to the return value\n        to hold the suppressed trailing zeros.\n    */\n\n    int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,\n        j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,\n        spec_case, try_quick;\n    Long L;\n    int denorm;\n    ULong x;\n    Bigint *b, *b1, *delta, *mlo, *mhi, *S;\n    U d2, eps, u;\n    double ds;\n    char *s, *s0;\n\n    /* set pointers to NULL, to silence gcc compiler warnings and make\n       cleanup easier on error */\n    mlo = mhi = S = 0;\n    s0 = 0;\n\n    u.d = dd;\n    if (word0(&u) & Sign_bit) {\n        /* set sign for everything, including 0's and NaNs */\n        *sign = 1;\n        word0(&u) &= ~Sign_bit; /* clear sign bit */\n    }\n    else\n        *sign = 0;\n\n    /* quick return for Infinities, NaNs and zeros */\n    if ((word0(&u) & Exp_mask) == Exp_mask)\n    {\n        /* Infinity or NaN */\n        *decpt = 9999;\n        if (!word1(&u) && !(word0(&u) & 0xfffff))\n            return nrv_alloc(\"Infinity\", rve, 8);\n        return nrv_alloc(\"NaN\", rve, 3);\n    }\n    if (!dval(&u)) {\n        *decpt = 1;\n        return nrv_alloc(\"0\", rve, 1);\n    }\n\n    /* compute k = floor(log10(d)).  The computation may leave k\n       one too large, but should never leave k too small. */\n    b = d2b(&u, &be, &bbits);\n    if (b == NULL)\n        goto failed_malloc;\n    if ((i = (int)(word0(&u) >> Exp_shift1 & (Exp_mask>>Exp_shift1)))) {\n        dval(&d2) = dval(&u);\n        word0(&d2) &= Frac_mask1;\n        word0(&d2) |= Exp_11;\n\n        /* log(x)       ~=~ log(1.5) + (x-1.5)/1.5\n         * log10(x)      =  log(x) / log(10)\n         *              ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))\n         * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)\n         *\n         * This suggests computing an approximation k to log10(d) by\n         *\n         * k = (i - Bias)*0.301029995663981\n         *      + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );\n         *\n         * We want k to be too large rather than too small.\n         * The error in the first-order Taylor series approximation\n         * is in our favor, so we just round up the constant enough\n         * to compensate for any error in the multiplication of\n         * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,\n         * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,\n         * adding 1e-13 to the constant term more than suffices.\n         * Hence we adjust the constant term to 0.1760912590558.\n         * (We could get a more accurate k by invoking log10,\n         *  but this is probably not worthwhile.)\n         */\n\n        i -= Bias;\n        denorm = 0;\n    }\n    else {\n        /* d is denormalized */\n\n        i = bbits + be + (Bias + (P-1) - 1);\n        x = i > 32  ? word0(&u) << (64 - i) | word1(&u) >> (i - 32)\n            : word1(&u) << (32 - i);\n        dval(&d2) = x;\n        word0(&d2) -= 31*Exp_msk1; /* adjust exponent */\n        i -= (Bias + (P-1) - 1) + 1;\n        denorm = 1;\n    }\n    ds = (dval(&d2)-1.5)*0.289529654602168 + 0.1760912590558 +\n        i*0.301029995663981;\n    k = (int)ds;\n    if (ds < 0. && ds != k)\n        k--;    /* want k = floor(ds) */\n    k_check = 1;\n    if (k >= 0 && k <= Ten_pmax) {\n        if (dval(&u) < tens[k])\n            k--;\n        k_check = 0;\n    }\n    j = bbits - i - 1;\n    if (j >= 0) {\n        b2 = 0;\n        s2 = j;\n    }\n    else {\n        b2 = -j;\n        s2 = 0;\n    }\n    if (k >= 0) {\n        b5 = 0;\n        s5 = k;\n        s2 += k;\n    }\n    else {\n        b2 -= k;\n        b5 = -k;\n        s5 = 0;\n    }\n    if (mode < 0 || mode > 9)\n        mode = 0;\n\n    try_quick = 1;\n\n    if (mode > 5) {\n        mode -= 4;\n        try_quick = 0;\n    }\n    leftright = 1;\n    ilim = ilim1 = -1;  /* Values for cases 0 and 1; done here to */\n    /* silence erroneous \"gcc -Wall\" warning. */\n    switch(mode) {\n    case 0:\n    case 1:\n        i = 18;\n        ndigits = 0;\n        break;\n    case 2:\n        leftright = 0;\n        /* no break */\n    case 4:\n        if (ndigits <= 0)\n            ndigits = 1;\n        ilim = ilim1 = i = ndigits;\n        break;\n    case 3:\n        leftright = 0;\n        /* no break */\n    case 5:\n        i = ndigits + k + 1;\n        ilim = i;\n        ilim1 = i - 1;\n        if (i <= 0)\n            i = 1;\n    }\n    s0 = rv_alloc(i);\n    if (s0 == NULL)\n        goto failed_malloc;\n    s = s0;\n\n\n    if (ilim >= 0 && ilim <= Quick_max && try_quick) {\n\n        /* Try to get by with floating-point arithmetic. */\n\n        i = 0;\n        dval(&d2) = dval(&u);\n        k0 = k;\n        ilim0 = ilim;\n        ieps = 2; /* conservative */\n        if (k > 0) {\n            ds = tens[k&0xf];\n            j = k >> 4;\n            if (j & Bletch) {\n                /* prevent overflows */\n                j &= Bletch - 1;\n                dval(&u) /= bigtens[n_bigtens-1];\n                ieps++;\n            }\n            for(; j; j >>= 1, i++)\n                if (j & 1) {\n                    ieps++;\n                    ds *= bigtens[i];\n                }\n            dval(&u) /= ds;\n        }\n        else if ((j1 = -k)) {\n            dval(&u) *= tens[j1 & 0xf];\n            for(j = j1 >> 4; j; j >>= 1, i++)\n                if (j & 1) {\n                    ieps++;\n                    dval(&u) *= bigtens[i];\n                }\n        }\n        if (k_check && dval(&u) < 1. && ilim > 0) {\n            if (ilim1 <= 0)\n                goto fast_failed;\n            ilim = ilim1;\n            k--;\n            dval(&u) *= 10.;\n            ieps++;\n        }\n        dval(&eps) = ieps*dval(&u) + 7.;\n        word0(&eps) -= (P-1)*Exp_msk1;\n        if (ilim == 0) {\n            S = mhi = 0;\n            dval(&u) -= 5.;\n            if (dval(&u) > dval(&eps))\n                goto one_digit;\n            if (dval(&u) < -dval(&eps))\n                goto no_digits;\n            goto fast_failed;\n        }\n        if (leftright) {\n            /* Use Steele & White method of only\n             * generating digits needed.\n             */\n            dval(&eps) = 0.5/tens[ilim-1] - dval(&eps);\n            for(i = 0;;) {\n                L = (Long)dval(&u);\n                dval(&u) -= L;\n                *s++ = '0' + (int)L;\n                if (dval(&u) < dval(&eps))\n                    goto ret1;\n                if (1. - dval(&u) < dval(&eps))\n                    goto bump_up;\n                if (++i >= ilim)\n                    break;\n                dval(&eps) *= 10.;\n                dval(&u) *= 10.;\n            }\n        }\n        else {\n            /* Generate ilim digits, then fix them up. */\n            dval(&eps) *= tens[ilim-1];\n            for(i = 1;; i++, dval(&u) *= 10.) {\n                L = (Long)(dval(&u));\n                if (!(dval(&u) -= L))\n                    ilim = i;\n                *s++ = '0' + (int)L;\n                if (i == ilim) {\n                    if (dval(&u) > 0.5 + dval(&eps))\n                        goto bump_up;\n                    else if (dval(&u) < 0.5 - dval(&eps)) {\n                        while(*--s == '0');\n                        s++;\n                        goto ret1;\n                    }\n                    break;\n                }\n            }\n        }\n      fast_failed:\n        s = s0;\n        dval(&u) = dval(&d2);\n        k = k0;\n        ilim = ilim0;\n    }\n\n    /* Do we have a \"small\" integer? */\n\n    if (be >= 0 && k <= Int_max) {\n        /* Yes. */\n        ds = tens[k];\n        if (ndigits < 0 && ilim <= 0) {\n            S = mhi = 0;\n            if (ilim < 0 || dval(&u) <= 5*ds)\n                goto no_digits;\n            goto one_digit;\n        }\n        for(i = 1;; i++, dval(&u) *= 10.) {\n            L = (Long)(dval(&u) / ds);\n            dval(&u) -= L*ds;\n            *s++ = '0' + (int)L;\n            if (!dval(&u)) {\n                break;\n            }\n            if (i == ilim) {\n                dval(&u) += dval(&u);\n                if (dval(&u) > ds || (dval(&u) == ds && L & 1)) {\n                  bump_up:\n                    while(*--s == '9')\n                        if (s == s0) {\n                            k++;\n                            *s = '0';\n                            break;\n                        }\n                    ++*s++;\n                }\n                break;\n            }\n        }\n        goto ret1;\n    }\n\n    m2 = b2;\n    m5 = b5;\n    if (leftright) {\n        i =\n            denorm ? be + (Bias + (P-1) - 1 + 1) :\n            1 + P - bbits;\n        b2 += i;\n        s2 += i;\n        mhi = i2b(1);\n        if (mhi == NULL)\n            goto failed_malloc;\n    }\n    if (m2 > 0 && s2 > 0) {\n        i = m2 < s2 ? m2 : s2;\n        b2 -= i;\n        m2 -= i;\n        s2 -= i;\n    }\n    if (b5 > 0) {\n        if (leftright) {\n            if (m5 > 0) {\n                mhi = pow5mult(mhi, m5);\n                if (mhi == NULL)\n                    goto failed_malloc;\n                b1 = mult(mhi, b);\n                Bfree(b);\n                b = b1;\n                if (b == NULL)\n                    goto failed_malloc;\n            }\n            if ((j = b5 - m5)) {\n                b = pow5mult(b, j);\n                if (b == NULL)\n                    goto failed_malloc;\n            }\n        }\n        else {\n            b = pow5mult(b, b5);\n            if (b == NULL)\n                goto failed_malloc;\n        }\n    }\n    S = i2b(1);\n    if (S == NULL)\n        goto failed_malloc;\n    if (s5 > 0) {\n        S = pow5mult(S, s5);\n        if (S == NULL)\n            goto failed_malloc;\n    }\n\n    /* Check for special case that d is a normalized power of 2. */\n\n    spec_case = 0;\n    if ((mode < 2 || leftright)\n        ) {\n        if (!word1(&u) && !(word0(&u) & Bndry_mask)\n            && word0(&u) & (Exp_mask & ~Exp_msk1)\n            ) {\n            /* The special case */\n            b2 += Log2P;\n            s2 += Log2P;\n            spec_case = 1;\n        }\n    }\n\n    /* Arrange for convenient computation of quotients:\n     * shift left if necessary so divisor has 4 leading 0 bits.\n     *\n     * Perhaps we should just compute leading 28 bits of S once\n     * and for all and pass them and a shift to quorem, so it\n     * can do shifts and ors to compute the numerator for q.\n     */\n#define iInc 28\n    i = dshift(S, s2);\n    b2 += i;\n    m2 += i;\n    s2 += i;\n    if (b2 > 0) {\n        b = lshift(b, b2);\n        if (b == NULL)\n            goto failed_malloc;\n    }\n    if (s2 > 0) {\n        S = lshift(S, s2);\n        if (S == NULL)\n            goto failed_malloc;\n    }\n    if (k_check) {\n        if (cmp(b,S) < 0) {\n            k--;\n            b = multadd(b, 10, 0);      /* we botched the k estimate */\n            if (b == NULL)\n                goto failed_malloc;\n            if (leftright) {\n                mhi = multadd(mhi, 10, 0);\n                if (mhi == NULL)\n                    goto failed_malloc;\n            }\n            ilim = ilim1;\n        }\n    }\n    if (ilim <= 0 && (mode == 3 || mode == 5)) {\n        if (ilim < 0) {\n            /* no digits, fcvt style */\n          no_digits:\n            k = -1 - ndigits;\n            goto ret;\n        }\n        else {\n            S = multadd(S, 5, 0);\n            if (S == NULL)\n                goto failed_malloc;\n            if (cmp(b, S) <= 0)\n                goto no_digits;\n        }\n      one_digit:\n        *s++ = '1';\n        k++;\n        goto ret;\n    }\n    if (leftright) {\n        if (m2 > 0) {\n            mhi = lshift(mhi, m2);\n            if (mhi == NULL)\n                goto failed_malloc;\n        }\n\n        /* Compute mlo -- check for special case\n         * that d is a normalized power of 2.\n         */\n\n        mlo = mhi;\n        if (spec_case) {\n            mhi = Balloc(mhi->k);\n            if (mhi == NULL)\n                goto failed_malloc;\n            Bcopy(mhi, mlo);\n            mhi = lshift(mhi, Log2P);\n            if (mhi == NULL)\n                goto failed_malloc;\n        }\n\n        for(i = 1;;i++) {\n            dig = quorem(b,S) + '0';\n            /* Do we yet have the shortest decimal string\n             * that will round to d?\n             */\n            j = cmp(b, mlo);\n            delta = diff(S, mhi);\n            if (delta == NULL)\n                goto failed_malloc;\n            j1 = delta->sign ? 1 : cmp(b, delta);\n            Bfree(delta);\n            if (j1 == 0 && mode != 1 && !(word1(&u) & 1)\n                ) {\n                if (dig == '9')\n                    goto round_9_up;\n                if (j > 0)\n                    dig++;\n                *s++ = dig;\n                goto ret;\n            }\n            if (j < 0 || (j == 0 && mode != 1\n                          && !(word1(&u) & 1)\n                    )) {\n                if (!b->x[0] && b->wds <= 1) {\n                    goto accept_dig;\n                }\n                if (j1 > 0) {\n                    b = lshift(b, 1);\n                    if (b == NULL)\n                        goto failed_malloc;\n                    j1 = cmp(b, S);\n                    if ((j1 > 0 || (j1 == 0 && dig & 1))\n                        && dig++ == '9')\n                        goto round_9_up;\n                }\n              accept_dig:\n                *s++ = dig;\n                goto ret;\n            }\n            if (j1 > 0) {\n                if (dig == '9') { /* possible if i == 1 */\n                  round_9_up:\n                    *s++ = '9';\n                    goto roundoff;\n                }\n                *s++ = dig + 1;\n                goto ret;\n            }\n            *s++ = dig;\n            if (i == ilim)\n                break;\n            b = multadd(b, 10, 0);\n            if (b == NULL)\n                goto failed_malloc;\n            if (mlo == mhi) {\n                mlo = mhi = multadd(mhi, 10, 0);\n                if (mlo == NULL)\n                    goto failed_malloc;\n            }\n            else {\n                mlo = multadd(mlo, 10, 0);\n                if (mlo == NULL)\n                    goto failed_malloc;\n                mhi = multadd(mhi, 10, 0);\n                if (mhi == NULL)\n                    goto failed_malloc;\n            }\n        }\n    }\n    else\n        for(i = 1;; i++) {\n            *s++ = dig = quorem(b,S) + '0';\n            if (!b->x[0] && b->wds <= 1) {\n                goto ret;\n            }\n            if (i >= ilim)\n                break;\n            b = multadd(b, 10, 0);\n            if (b == NULL)\n                goto failed_malloc;\n        }\n\n    /* Round off last digit */\n\n    b = lshift(b, 1);\n    if (b == NULL)\n        goto failed_malloc;\n    j = cmp(b, S);\n    if (j > 0 || (j == 0 && dig & 1)) {\n      roundoff:\n        while(*--s == '9')\n            if (s == s0) {\n                k++;\n                *s++ = '1';\n                goto ret;\n            }\n        ++*s++;\n    }\n    else {\n        while(*--s == '0');\n        s++;\n    }\n  ret:\n    Bfree(S);\n    if (mhi) {\n        if (mlo && mlo != mhi)\n            Bfree(mlo);\n        Bfree(mhi);\n    }\n  ret1:\n    Bfree(b);\n    *s = 0;\n    *decpt = k + 1;\n    if (rve)\n        *rve = s;\n    return s0;\n  failed_malloc:\n    if (S)\n        Bfree(S);\n    if (mlo && mlo != mhi)\n        Bfree(mlo);\n    if (mhi)\n        Bfree(mhi);\n    if (b)\n        Bfree(b);\n    if (s0)\n        sb_freedtoa(s0);\n    return NULL;\n}\n#ifdef __cplusplus\n}\n#endif\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced\n * Research Projects Agency and the National Science Foundation of the\n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/**\n * @file err.c\n * @brief Somewhat antiquated logging and error interface.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/filename.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\nstatic FILE*  logfp = NULL;\nstatic int    logfp_disabled = FALSE;\n\n#if defined(__ANDROID__)\n#include <android/log.h>\nstatic void\nerr_logcat_cb(void* user_data, err_lvl_t level, const char *fmt, ...);\n#elif defined(_WIN32_WCE)\n#include <windows.h>\n#define vsnprintf _vsnprintf\nstatic void\nerr_wince_cb(void* user_data, err_lvl_t level, const char *fmt, ...);\n#endif\n\n#if defined(__ANDROID__)\nstatic err_cb_f err_cb = err_logcat_cb;\n#elif defined(_WIN32_WCE)\nstatic err_cb_f err_cb = err_wince_cb;\n#else\nstatic err_cb_f err_cb = err_logfp_cb;\n#endif\nstatic void* err_user_data;\n\nvoid\nerr_msg(err_lvl_t lvl, const char *path, long ln, const char *fmt, ...)\n{\n    static const char *err_prefix[ERR_MAX] = {\n        \"DEBUG\", \"INFO\", \"INFOCONT\", \"WARN\", \"ERROR\", \"FATAL\"\n    };\n\n    char msg[1024];\n    va_list ap;\n\n    if (!err_cb)\n        return;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    if (path) {\n        const char *fname = path2basename(path);\n        if (lvl == ERR_INFOCONT)\n    \t    err_cb(err_user_data, lvl, \"%s(%ld): %s\", fname, ln, msg);\n        else if (lvl == ERR_INFO)\n            err_cb(err_user_data, lvl, \"%s: %s(%ld): %s\", err_prefix[lvl], fname, ln, msg);\n        else\n    \t    err_cb(err_user_data, lvl, \"%s: \\\"%s\\\", line %ld: %s\", err_prefix[lvl], fname, ln, msg);\n    } else {\n        err_cb(err_user_data, lvl, \"%s\", msg);\n    }\n}\n\n#ifdef _WIN32_WCE /* No strerror for WinCE, so a separate implementation */\nvoid\nerr_msg_system(err_lvl_t lvl, const char *path, long ln, const char *fmt, ...)\n{\n    static const char *err_prefix[ERR_MAX] = {\n        \"DEBUG\", \"INFO\", \"INFOCONT\", \"WARN\", \"ERROR\", \"FATAL\"\n    };\n\n    va_list ap;\n    LPVOID error_wstring;\n    DWORD error;\n    char msg[1024];\n    char error_string[1024];\n\n    if (!err_cb)\n        return;\n\n    error = GetLastError();\n    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | \n                  FORMAT_MESSAGE_FROM_SYSTEM | \n                  FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL,\n                  error,\n                  0, // Default language\n                  (LPTSTR) &error_wstring,\n                  0,\n                  NULL);\n    wcstombs(error_string, error_wstring, 1023);\n    LocalFree(error_wstring);\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    if (path) {\n        const char *fname = path2basename(path);\n        if (lvl == ERR_INFOCONT)\n    \t    err_cb(err_user_data, lvl, \"%s(%ld): %s: %s\\n\", fname, ln, msg, error_string);\n        else if (lvl == ERR_INFO)\n            err_cb(err_user_data, lvl, \"%s: %s(%ld): %s: %s\\n\", err_prefix[lvl], fname, ln, msg, error_string);\n        else\n    \t    err_cb(err_user_data, lvl, \"%s: \\\"%s\\\", line %ld: %s: %s\\n\", err_prefix[lvl], fname, ln, msg, error_string);\n    } else {\n        err_cb(err_user_data, lvl, \"%s: %s\\n\", msg, error_string);\n    }\n}\n#else\nvoid\nerr_msg_system(err_lvl_t lvl, const char *path, long ln, const char *fmt, ...)\n{\n    int local_errno = errno;\n    \n    static const char *err_prefix[ERR_MAX] = {\n        \"DEBUG\", \"INFO\", \"INFOCONT\", \"WARN\", \"ERROR\", \"FATAL\"\n    };\n\n    char msg[1024];\n    va_list ap;\n\n    if (!err_cb)\n        return;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    if (path) {\n        const char *fname = path2basename(path);\n        if (lvl == ERR_INFOCONT)\n    \t    err_cb(err_user_data, lvl, \"%s(%ld): %s: %s\\n\", fname, ln, msg, strerror(local_errno));\n        else if (lvl == ERR_INFO)\n            err_cb(err_user_data, lvl, \"%s: %s(%ld): %s: %s\\n\", err_prefix[lvl], fname, ln, msg, strerror(local_errno));\n        else\n    \t    err_cb(err_user_data, lvl, \"%s: \\\"%s\\\", line %ld: %s: %s\\n\", err_prefix[lvl], fname, ln, msg, strerror(local_errno));\n    } else {\n        err_cb(err_user_data, lvl, \"%s: %s\\n\", msg, strerror(local_errno));\n    }\n}\n#endif\n\n#if defined(__ANDROID__)\nstatic void\nerr_logcat_cb(void *user_data, err_lvl_t lvl, const char *fmt, ...)\n{\n    static const int android_level[ERR_MAX] = {ANDROID_LOG_DEBUG, ANDROID_LOG_INFO,\n         ANDROID_LOG_INFO, ANDROID_LOG_WARN, ANDROID_LOG_ERROR, ANDROID_LOG_ERROR};\n\n    va_list ap;\n    va_start(ap, fmt);\n    __android_log_vprint(android_level[lvl], \"cmusphinx\", fmt, ap);\n    va_end(ap);\n}\n#elif defined(_WIN32_WCE)\nstatic void\nerr_wince_cb(void *user_data, err_lvl_t lvl, const char *fmt, ...)\n{\n    char msg[1024];\n    WCHAR *wmsg;\n    size_t size;\n    va_list ap;\n\n    va_start(ap, fmt);\n    _vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    size = mbstowcs(NULL, msg, 0) + 1;\n    wmsg = ckd_calloc(size, sizeof(*wmsg));\n    mbstowcs(wmsg, msg, size);\n\n    OutputDebugStringW(wmsg);\n    ckd_free(wmsg);\n}\n#else\nvoid\nerr_logfp_cb(void *user_data, err_lvl_t lvl, const char *fmt, ...)\n{\n    va_list ap;\n    FILE *fp = err_get_logfp();\n\n    if (!fp)\n        return;\n    \n    va_start(ap, fmt);\n    vfprintf(fp, fmt, ap);\n    va_end(ap);\n    fflush(fp);\n}\n#endif\n\nint\nerr_set_logfile(const char *path)\n{\n    FILE *newfp, *oldfp;\n\n    if ((newfp = fopen(path, \"a\")) == NULL)\n        return -1;\n    oldfp = err_get_logfp();\n    err_set_logfp(newfp);\n    if (oldfp != NULL && oldfp != stdout && oldfp != stderr)\n        fclose(oldfp);\n    return 0;\n}\n\nvoid\nerr_set_logfp(FILE *stream)\n{\n    if (stream == NULL) {\n\tlogfp_disabled = TRUE;\n\tlogfp = NULL;\n\treturn;\n    }    \n    logfp_disabled = FALSE;\n    logfp = stream;\n    return;\n}\n\nFILE *\nerr_get_logfp(void)\n{\n    if (logfp_disabled)\n\treturn NULL;\n    if (logfp == NULL)\n\treturn stderr;\n\n    return logfp;\n}\n\nvoid\nerr_set_callback(err_cb_f cb, void* user_data)\n{\n    err_cb = cb;\n    err_user_data= user_data;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * filename.c -- File and path name operations.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"sphinxbase/filename.h\"\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\nconst char *\npath2basename(const char *path)\n{\n    const char *result;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n    result = strrchr(path, '\\\\');\n#else\n    result = strrchr(path, '/');\n#endif\n\n    return (result == NULL ? path : result + 1);\n}\n\n/* Return all leading pathname components */\nvoid\npath2dirname(const char *path, char *dir)\n{\n    size_t i, l;\n\n    l = strlen(path);\n#if defined(_WIN32) || defined(__CYGWIN__)\n    for (i = l - 1; (i > 0) && !(path[i] == '/' || path[i] == '\\\\'); --i);\n#else\n    for (i = l - 1; (i > 0) && !(path[i] == '/'); --i);\n#endif\n    if (i == 0) {\n        dir[0] = '.';\n        dir[1] = '\\0';\n    } else {\n        memcpy(dir, path, i);\n        dir[i] = '\\0';\n    }\n}\n\n\n/* Strip off the shortest trailing .xyz suffix */\nvoid\nstrip_fileext(const char *path, char *root)\n{\n    size_t i, l;\n\n    l = strlen(path);\n    for (i = l - 1; (i > 0) && (path[i] != '.'); --i);\n    if (i == 0) {\n        strcpy(root, path);     /* Didn't find a . */\n    } else {\n        strncpy(root, path, i);\n    }\n}\n\n/* Test if this path is absolute. */\nint\npath_is_absolute(const char *path)\n{\n#if defined(_WIN32) && !defined(_WIN32_WCE) /* FIXME: Also SymbianOS */\n    return /* Starts with drive letter : \\ or / */\n        (strlen(path) >= 3\n         &&\n         ((path[0] >= 'A' && path[0] <= 'Z')\n          || (path[0] >= 'a' && path[0] <= 'z'))\n         && path[1] == ':'\n         && (path[2] == '/' || path[2] == '\\\\'));\n#elif defined(_WIN32_WCE)\n    return path[0] == '\\\\' || path[0] == '/';\n#else /* Assume Unix */\n    return path[0] == '/';\n#endif\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n`        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.keio.ac.jp/matumoto/emt.html\n   email: matumoto@math.keio.ac.jp\n*/\n\n#include <stdio.h>\n\n#include \"sphinxbase/genrand.h\"\n\n/* Period parameters */\n#define N 624\n#define M 397\n#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n\nvoid init_genrand(unsigned long s);\n\nvoid\ngenrand_seed(unsigned long s)\n{\n    init_genrand(s);\n}\n\n\nstatic unsigned long mt[N];     /* the array for the state vector  */\nstatic int mti = N + 1;         /* mti==N+1 means mt[N] is not initialized */\n\n/* initializes mt[N] with a seed */\nvoid\ninit_genrand(unsigned long s)\n{\n    mt[0] = s & 0xffffffffUL;\n    for (mti = 1; mti < N; mti++) {\n        mt[mti] =\n            (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);\n        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n        /* In the previous versions, MSBs of the seed affect   */\n        /* only MSBs of the array mt[].                        */\n        /* 2002/01/09 modified by Makoto Matsumoto             */\n        mt[mti] &= 0xffffffffUL;\n        /* for >32 bit machines */\n    }\n}\n\n/* generates a random number on [0,0xffffffff]-interval */\nunsigned long\ngenrand_int32(void)\n{\n    unsigned long y;\n    static unsigned long mag01[2] = { 0x0UL, MATRIX_A };\n    /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n    if (mti >= N) {             /* generate N words at one time */\n        int kk;\n\n        if (mti == N + 1)       /* if init_genrand() has not been called, */\n            init_genrand(5489UL);       /* a default initial seed is used */\n\n        for (kk = 0; kk < N - M; kk++) {\n            y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);\n            mt[kk] = mt[kk + M] ^ (y >> 1) ^ mag01[y & 0x1UL];\n        }\n        for (; kk < N - 1; kk++) {\n            y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);\n            mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 0x1UL];\n        }\n        y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);\n        mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];\n\n        mti = 0;\n    }\n\n    y = mt[mti++];\n\n    /* Tempering */\n    y ^= (y >> 11);\n    y ^= (y << 7) & 0x9d2c5680UL;\n    y ^= (y << 15) & 0xefc60000UL;\n    y ^= (y >> 18);\n\n    return y;\n}\n\n/* generates a random number on [0,0x7fffffff]-interval */\nlong\ngenrand_int31(void)\n{\n    return (long) (genrand_int32() >> 1);\n}\n\n/* generates a random number on [0,1]-real-interval */\ndouble\ngenrand_real1(void)\n{\n    return genrand_int32() * (1.0 / 4294967295.0);\n    /* divided by 2^32-1 */\n}\n\n/* generates a random number on [0,1)-real-interval */\ndouble\ngenrand_real2(void)\n{\n    return genrand_int32() * (1.0 / 4294967296.0);\n    /* divided by 2^32 */\n}\n\n/* generates a random number on (0,1)-real-interval */\ndouble\ngenrand_real3(void)\n{\n    return (((double) genrand_int32()) + 0.5) * (1.0 / 4294967296.0);\n    /* divided by 2^32 */\n}\n\n/* generates a random number on [0,1) with 53-bit resolution*/\ndouble\ngenrand_res53(void)\n{\n    unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;\n    return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);\n}\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * glist.h -- Module for maintaining a generic, linear linked-list structure.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log: glist.c,v $\n * Revision 1.8  2005/06/22 03:02:51  arthchan2003\n * 1, Fixed doxygen documentation, 2, add  keyword.\n *\n * Revision 1.3  2005/03/30 01:22:48  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 09-Mar-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tAdded glist_chkdup_*().\n * \n * 13-Feb-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tCreated from earlier version.\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"sphinxbase/glist.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\n\nglist_t\nglist_add_ptr(glist_t g, void *ptr)\n{\n    gnode_t *gn;\n\n    gn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    gn->data.ptr = ptr;\n    gn->next = g;\n    return ((glist_t) gn);      /* Return the new head of the list */\n}\n\n\nglist_t\nglist_add_int32(glist_t g, int32 val)\n{\n    gnode_t *gn;\n\n    gn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    gn->data.i = (long)val;\n    gn->next = g;\n    return ((glist_t) gn);      /* Return the new head of the list */\n}\n\n\nglist_t\nglist_add_uint32(glist_t g, uint32 val)\n{\n    gnode_t *gn;\n\n    gn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    gn->data.ui = (unsigned long)val;\n    gn->next = g;\n    return ((glist_t) gn);      /* Return the new head of the list */\n}\n\n\nglist_t\nglist_add_float32(glist_t g, float32 val)\n{\n    gnode_t *gn;\n\n    gn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    gn->data.fl = (double)val;\n    gn->next = g;\n    return ((glist_t) gn);      /* Return the new head of the list */\n}\n\n\nglist_t\nglist_add_float64(glist_t g, float64 val)\n{\n    gnode_t *gn;\n\n    gn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    gn->data.fl = (double)val;\n    gn->next = g;\n    return ((glist_t) gn);      /* Return the new head of the list */\n}\n\nvoid\nglist_free(glist_t g)\n{\n    gnode_t *gn;\n\n    while (g) {\n        gn = g;\n        g = gn->next;\n        ckd_free((void *) gn);\n    }\n}\n\nint32\nglist_count(glist_t g)\n{\n    gnode_t *gn;\n    int32 n;\n\n    for (gn = g, n = 0; gn; gn = gn->next, n++);\n    return n;\n}\n\n\ngnode_t *\nglist_tail(glist_t g)\n{\n    gnode_t *gn;\n\n    if (!g)\n        return NULL;\n\n    for (gn = g; gn->next; gn = gn->next);\n    return gn;\n}\n\n\nglist_t\nglist_reverse(glist_t g)\n{\n    gnode_t *gn, *nextgn;\n    gnode_t *rev;\n\n    rev = NULL;\n    for (gn = g; gn; gn = nextgn) {\n        nextgn = gn->next;\n\n        gn->next = rev;\n        rev = gn;\n    }\n\n    return rev;\n}\n\n\ngnode_t *\nglist_insert_ptr(gnode_t * gn, void *ptr)\n{\n    gnode_t *newgn;\n\n    newgn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    newgn->data.ptr = ptr;\n    newgn->next = gn->next;\n    gn->next = newgn;\n\n    return newgn;\n}\n\n\ngnode_t *\nglist_insert_int32(gnode_t * gn, int32 val)\n{\n    gnode_t *newgn;\n\n    newgn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    newgn->data.i = val;\n    newgn->next = gn->next;\n    gn->next = newgn;\n\n    return newgn;\n}\n\n\ngnode_t *\nglist_insert_uint32(gnode_t * gn, uint32 val)\n{\n    gnode_t *newgn;\n\n    newgn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    newgn->data.ui = val;\n    newgn->next = gn->next;\n\n    gn->next = newgn;\n\n    return newgn;\n}\n\n\ngnode_t *\nglist_insert_float32(gnode_t * gn, float32 val)\n{\n    gnode_t *newgn;\n\n    newgn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    newgn->data.fl = (double)val;\n    newgn->next = gn->next;\n    gn->next = newgn;\n\n    return newgn;\n}\n\n\ngnode_t *\nglist_insert_float64(gnode_t * gn, float64 val)\n{\n    gnode_t *newgn;\n\n    newgn = (gnode_t *) ckd_calloc(1, sizeof(gnode_t));\n    newgn->data.fl = (double)val;\n    newgn->next = gn->next;\n    gn->next = newgn;\n\n    return newgn;\n}\n\ngnode_t *\ngnode_free(gnode_t * gn, gnode_t * pred)\n{\n    gnode_t *next;\n\n    next = gn->next;\n    if (pred) {\n        assert(pred->next == gn);\n\n        pred->next = next;\n    }\n\n    ckd_free((char *) gn);\n\n    return next;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * hash.c -- Hash table module.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log: hash.c,v $\n * Revision 1.5  2005/06/22 03:04:01  arthchan2003\n * 1, Implemented hash_delete and hash_display, 2, Fixed doxygen documentation, 3, Added  keyword.\n *\n * Revision 1.9  2005/05/25 06:17:53  archan\n * Delete the test code in cmd_ln.c and fixed platform specific code of hash.c\n *\n * Revision 1.8  2005/05/24 01:10:54  archan\n * Fix a bug when the value only appear in the hash but there is no chain.   Also make sure that prev was initialized to NULL. All success cases were tested, but not tested with the deletion is tested.\n *\n * Revision 1.6  2005/05/24 00:00:45  archan\n * Added basic functionalities to hash_t: 1, display and 2, delete a key from a hash. \\n\n *\n * Revision 1.5  2005/05/11 07:01:38  archan\n * Added comments on the usage of the current implementation of hash tables.\n *\n * Revision 1.4  2005/05/03 04:09:11  archan\n * Implemented the heart of word copy search. For every ci-phone, every word end, a tree will be allocated to preserve its pathscore.  This is different from 3.5 or below, only the best score for a particular ci-phone, regardless of the word-ends will be preserved at every frame.  The graph propagation will not collect unused word tree at this point. srch_WST_propagate_wd_lv2 is also as the most stupid in the century.  But well, after all, everything needs a start.  I will then really get the results from the search and see how it looks.\n *\n * Revision 1.3  2005/03/30 01:22:48  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 05-May-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tRemoved hash_key2hash().  Added hash_enter_bkey() and hash_lookup_bkey(),\n * \t\tand len attribute to hash_entry_t.\n * \n * 30-Apr-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tAdded hash_key2hash().\n * \n * 18-Jun-97\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tIncluded case sensitive/insensitive option.  Removed local, static\n * \t\tmaintenance of all hash tables.\n * \n * 31-Jul-95\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon\n * \t\tCreated.\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4018)\n#endif\n\n#include \"sphinxbase/hash_table.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/case.h\"\n\n\n#if 0\nstatic void\nprime_sieve(int32 max)\n{\n    char *notprime;\n    int32 p, pp;\n\n    notprime = (char *) ckd_calloc(max + 1, 1);\n    p = 2;\n    for (;;) {\n        printf(\"%d\\n\", p);\n        for (pp = p + p; pp <= max; pp += p)\n            notprime[pp] = 1;\n        for (++p; (p <= max) && notprime[p]; p++);\n        if (p > max)\n            break;\n    }\n}\n#endif\n\n\n/*\n * HACK!!  Initial hash table size is restricted by this set of primes.  (Of course,\n * collision resolution by chaining will accommodate more entries indefinitely, but\n * efficiency will drop.)\n */\nconst int32 prime[] = {\n    101, 211, 307, 401, 503, 601, 701, 809, 907,\n    1009, 1201, 1601, 2003, 2411, 3001, 4001, 5003, 6007, 7001, 8009,\n    9001,\n    10007, 12007, 16001, 20011, 24001, 30011, 40009, 50021, 60013,\n    70001, 80021, 90001,\n    100003, 120011, 160001, 200003, 240007, 300007, 400009, 500009,\n    600011, 700001, 800011, 900001,\n    -1\n};\n\n\n/**\n * This function returns a very large prime. \n */\nstatic int32\nprime_size(int32 size)\n{\n    int32 i;\n\n    for (i = 0; (prime[i] > 0) && (prime[i] < size); i++);\n    if (prime[i] <= 0) {\n        E_WARN(\"Very large hash table requested (%d entries)\\n\", size);\n        --i;\n    }\n    return (prime[i]);\n}\n\n\nhash_table_t *\nhash_table_new(int32 size, int32 casearg)\n{\n    hash_table_t *h;\n\n    h = (hash_table_t *) ckd_calloc(1, sizeof(hash_table_t));\n    h->size = prime_size(size + (size >> 1));\n    h->nocase = (casearg == HASH_CASE_NO);\n    h->table = (hash_entry_t *) ckd_calloc(h->size, sizeof(hash_entry_t));\n    /* The above calloc clears h->table[*].key and .next to NULL, i.e. an empty table */\n\n    return h;\n}\n\n\n/*\n * Compute hash value for given key string.\n * Somewhat tuned for English text word strings.\n */\nstatic uint32\nkey2hash(hash_table_t * h, const char *key)\n{\n\n    register const char *cp;\n\n    /* This is a hack because the best way to solve it is to make sure \n       all character representation is unsigned character in the first place.        \n       (or better unicode.) */\n    register unsigned char c;\n    register int32 s;\n    register uint32 hash;\n\n    hash = 0;\n    s = 0;\n\n    if (h->nocase) {\n        for (cp = key; *cp; cp++) {\n            c = *cp;\n            c = UPPER_CASE(c);\n            hash += c << s;\n            s += 5;\n            if (s >= 25)\n                s -= 24;\n        }\n    }\n    else {\n        for (cp = key; *cp; cp++) {\n            hash += (*cp) << s;\n            s += 5;\n            if (s >= 25)\n                s -= 24;\n        }\n    }\n\n    return (hash % h->size);\n}\n\n\nstatic char *\nmakekey(uint8 * data, size_t len, char *key)\n{\n    size_t i, j;\n\n    if (!key)\n        key = (char *) ckd_calloc(len * 2 + 1, sizeof(char));\n\n    for (i = 0, j = 0; i < len; i++, j += 2) {\n        key[j] = 'A' + (data[i] & 0x000f);\n        key[j + 1] = 'J' + ((data[i] >> 4) & 0x000f);\n    }\n    key[j] = '\\0';\n\n    return key;\n}\n\n\nstatic int32\nkeycmp_nocase(hash_entry_t * entry, const char *key)\n{\n    char c1, c2;\n    int32 i;\n    const char *str;\n\n    str = entry->key;\n    for (i = 0; i < entry->len; i++) {\n        c1 = *(str++);\n        c1 = UPPER_CASE(c1);\n        c2 = *(key++);\n        c2 = UPPER_CASE(c2);\n        if (c1 != c2)\n            return (c1 - c2);\n    }\n\n    return 0;\n}\n\n\nstatic int32\nkeycmp_case(hash_entry_t * entry, const char *key)\n{\n    char c1, c2;\n    int32 i;\n    const char *str;\n\n    str = entry->key;\n    for (i = 0; i < entry->len; i++) {\n        c1 = *(str++);\n        c2 = *(key++);\n        if (c1 != c2)\n            return (c1 - c2);\n    }\n\n    return 0;\n}\n\n\n/*\n * Lookup entry with hash-value hash in table h for given key\n * Return value: hash_entry_t for key\n */\nstatic hash_entry_t *\nlookup(hash_table_t * h, uint32 hash, const char *key, size_t len)\n{\n    hash_entry_t *entry;\n\n    entry = &(h->table[hash]);\n    if (entry->key == NULL)\n        return NULL;\n\n    if (h->nocase) {\n        while (entry && ((entry->len != len)\n                         || (keycmp_nocase(entry, key) != 0)))\n            entry = entry->next;\n    }\n    else {\n        while (entry && ((entry->len != len)\n                         || (keycmp_case(entry, key) != 0)))\n            entry = entry->next;\n    }\n\n    return entry;\n}\n\n\nint32\nhash_table_lookup(hash_table_t * h, const char *key, void ** val)\n{\n    hash_entry_t *entry;\n    uint32 hash;\n    size_t len;\n\n    hash = key2hash(h, key);\n    len = strlen(key);\n\n    entry = lookup(h, hash, key, len);\n    if (entry) {\n        if (val)\n            *val = entry->val;\n        return 0;\n    }\n    else\n        return -1;\n}\n\nint32\nhash_table_lookup_int32(hash_table_t * h, const char *key, int32 *val)\n{\n    void *vval;\n    int32 rv;\n\n    rv = hash_table_lookup(h, key, &vval);\n    if (rv != 0)\n        return rv;\n    if (val)\n        *val = (int32)(long)vval;\n    return 0;\n}\n\n\nint32\nhash_table_lookup_bkey(hash_table_t * h, const char *key, size_t len, void ** val)\n{\n    hash_entry_t *entry;\n    uint32 hash;\n    char *str;\n\n    str = makekey((uint8 *) key, len, NULL);\n    hash = key2hash(h, str);\n    ckd_free(str);\n\n    entry = lookup(h, hash, key, len);\n    if (entry) {\n        if (val)\n            *val = entry->val;\n        return 0;\n    }\n    else\n        return -1;\n}\n\nint32\nhash_table_lookup_bkey_int32(hash_table_t * h, const char *key, size_t len, int32 *val)\n{\n    void *vval;\n    int32 rv;\n\n    rv = hash_table_lookup_bkey(h, key, len, &vval);\n    if (rv != 0)\n        return rv;\n    if (val)\n        *val = (int32)(long)vval;\n    return 0;\n}\n\n\nstatic void *\nenter(hash_table_t * h, uint32 hash, const char *key, size_t len, void *val, int32 replace)\n{\n    hash_entry_t *cur, *new;\n\n    if ((cur = lookup(h, hash, key, len)) != NULL) {\n        void *oldval;\n        /* Key already exists. */\n        oldval = cur->val;\n        if (replace) {\n            /* Replace the pointer if replacement is requested,\n             * because this might be a different instance of the same\n             * string (this verges on magic, sorry) */\n            cur->key = key;\n            cur->val = val;\n        }\n        return oldval;\n    }\n\n    cur = &(h->table[hash]);\n    if (cur->key == NULL) {\n        /* Empty slot at hashed location; add this entry */\n        cur->key = key;\n        cur->len = len;\n        cur->val = val;\n\n        /* Added by ARCHAN at 20050515. This allows deletion could work. */\n        cur->next = NULL;\n\n    }\n    else {\n        /* Key collision; create new entry and link to hashed location */\n        new = (hash_entry_t *) ckd_calloc(1, sizeof(hash_entry_t));\n        new->key = key;\n        new->len = len;\n        new->val = val;\n        new->next = cur->next;\n        cur->next = new;\n    }\n    ++h->inuse;\n\n    return val;\n}\n\n/* 20050523 Added by ARCHAN  to delete a key from a hash table */\nstatic void *\ndelete(hash_table_t * h, uint32 hash, const char *key, size_t len)\n{\n    hash_entry_t *entry, *prev;\n    void *val;\n\n    prev = NULL;\n    entry = &(h->table[hash]);\n    if (entry->key == NULL)\n        return NULL;\n\n    if (h->nocase) {\n        while (entry && ((entry->len != len)\n                         || (keycmp_nocase(entry, key) != 0))) {\n            prev = entry;\n            entry = entry->next;\n        }\n    }\n    else {\n        while (entry && ((entry->len != len)\n                         || (keycmp_case(entry, key) != 0))) {\n            prev = entry;\n            entry = entry->next;\n        }\n    }\n\n    if (entry == NULL)\n        return NULL;\n\n    /* At this point, entry will be the one required to be deleted, prev\n       will contain the previous entry\n     */\n    val = entry->val;\n\n    if (prev == NULL) {\n        /* That is to say the entry in the hash table (not the chain) matched the key. */\n        /* We will then copy the things from the next entry to the hash table */\n        prev = entry;\n        if (entry->next) {      /* There is a next entry, great, copy it. */\n            entry = entry->next;\n            prev->key = entry->key;\n            prev->len = entry->len;\n            prev->val = entry->val;\n            prev->next = entry->next;\n            ckd_free(entry);\n        }\n        else {                  /* There is not a next entry, just set the key to null */\n            prev->key = NULL;\n            prev->len = 0;\n            prev->next = NULL;\n        }\n\n    }\n    else {                      /* This case is simple */\n        prev->next = entry->next;\n        ckd_free(entry);\n    }\n\n    /* Do wiring and free the entry */\n\n    --h->inuse;\n\n    return val;\n}\n\nvoid\nhash_table_empty(hash_table_t *h)\n{\n    hash_entry_t *e, *e2;\n    int32 i;\n\n    for (i = 0; i < h->size; i++) {\n        /* Free collision lists. */\n        for (e = h->table[i].next; e; e = e2) {\n            e2 = e->next;\n            ckd_free((void *) e);\n        }\n        memset(&h->table[i], 0, sizeof(h->table[i]));\n    }\n    h->inuse = 0;\n}\n\n\nvoid *\nhash_table_enter(hash_table_t * h, const char *key, void *val)\n{\n    uint32 hash;\n    size_t len;\n\n    hash = key2hash(h, key);\n    len = strlen(key);\n    return (enter(h, hash, key, len, val, 0));\n}\n\nvoid *\nhash_table_replace(hash_table_t * h, const char *key, void *val)\n{\n    uint32 hash;\n    size_t len;\n\n    hash = key2hash(h, key);\n    len = strlen(key);\n    return (enter(h, hash, key, len, val, 1));\n}\n\nvoid *\nhash_table_delete(hash_table_t * h, const char *key)\n{\n    uint32 hash;\n    size_t len;\n\n    hash = key2hash(h, key);\n    len = strlen(key);\n\n    return (delete(h, hash, key, len));\n}\n\nvoid *\nhash_table_enter_bkey(hash_table_t * h, const char *key, size_t len, void *val)\n{\n    uint32 hash;\n    char *str;\n\n    str = makekey((uint8 *) key, len, NULL);\n    hash = key2hash(h, str);\n    ckd_free(str);\n\n    return (enter(h, hash, key, len, val, 0));\n}\n\nvoid *\nhash_table_replace_bkey(hash_table_t * h, const char *key, size_t len, void *val)\n{\n    uint32 hash;\n    char *str;\n\n    str = makekey((uint8 *) key, len, NULL);\n    hash = key2hash(h, str);\n    ckd_free(str);\n\n    return (enter(h, hash, key, len, val, 1));\n}\n\nvoid *\nhash_table_delete_bkey(hash_table_t * h, const char *key, size_t len)\n{\n    uint32 hash;\n    char *str;\n\n    str = makekey((uint8 *) key, len, NULL);\n    hash = key2hash(h, str);\n    ckd_free(str);\n\n    return (delete(h, hash, key, len));\n}\n\nvoid\nhash_table_display(hash_table_t * h, int32 showdisplay)\n{\n    hash_entry_t *e;\n    int i, j;\n    j = 0;\n\n    printf(\"Hash with chaining representation of the hash table\\n\");\n\n    for (i = 0; i < h->size; i++) {\n        e = &(h->table[i]);\n        if (e->key != NULL) {\n            printf(\"|key:\");\n            if (showdisplay)\n                printf(\"%s\", e->key);\n            else\n                printf(\"%p\", e->key);\n\n            printf(\"|len:%zd|val=%ld|->\", e->len, (long)e->val);\n            if (e->next == NULL) {\n                printf(\"NULL\\n\");\n            }\n            j++;\n\n            for (e = e->next; e; e = e->next) {\n                printf(\"|key:\");\n                if (showdisplay)\n                    printf(\"%s\", e->key);\n\n                printf(\"|len:%zd|val=%ld|->\", e->len, (long)e->val);\n                if (e->next == NULL) {\n                    printf(\"NULL\\n\");\n                }\n                j++;\n            }\n        }\n    }\n\n    printf(\"The total number of keys =%d\\n\", j);\n}\n\n\nglist_t\nhash_table_tolist(hash_table_t * h, int32 * count)\n{\n    glist_t g;\n    hash_entry_t *e;\n    int32 i, j;\n\n    g = NULL;\n\n    j = 0;\n    for (i = 0; i < h->size; i++) {\n        e = &(h->table[i]);\n\n        if (e->key != NULL) {\n            g = glist_add_ptr(g, (void *) e);\n            j++;\n\n            for (e = e->next; e; e = e->next) {\n                g = glist_add_ptr(g, (void *) e);\n                j++;\n            }\n        }\n    }\n\n    if (count)\n        *count = j;\n\n    return g;\n}\n\nhash_iter_t *\nhash_table_iter(hash_table_t *h)\n{\n\thash_iter_t *itor;\n\n\titor = ckd_calloc(1, sizeof(*itor));\n\titor->ht = h;\n\treturn hash_table_iter_next(itor);\n}\n\nhash_iter_t *\nhash_table_iter_next(hash_iter_t *itor)\n{\n\t/* If there is an entry, walk down its list. */\n\tif (itor->ent)\n\t\titor->ent = itor->ent->next;\n\t/* If we got to the end of the chain, or we had no entry, scan\n\t * forward in the table to find the next non-empty bucket. */\n\tif (itor->ent == NULL) {\n\t\twhile (itor->idx < itor->ht->size\n\t\t       && itor->ht->table[itor->idx].key == NULL) \n\t\t\t++itor->idx;\n\t\t/* If we did not find one then delete the iterator and\n\t\t * return NULL. */\n\t\tif (itor->idx == itor->ht->size) {\n\t\t\thash_table_iter_free(itor);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* Otherwise use this next entry. */\n\t\titor->ent = itor->ht->table + itor->idx;\n\t\t/* Increase idx for the next time around. */\n\t\t++itor->idx;\n\t}\n\treturn itor;\n}\n\nvoid\nhash_table_iter_free(hash_iter_t *itor)\n{\n\tckd_free(itor);\n}\n\nvoid\nhash_table_free(hash_table_t * h)\n{\n    hash_entry_t *e, *e2;\n    int32 i;\n\n    if (h == NULL)\n        return;\n\n    /* Free additional entries created for key collision cases */\n    for (i = 0; i < h->size; i++) {\n        for (e = h->table[i].next; e; e = e2) {\n            e2 = e->next;\n            ckd_free((void *) e);\n        }\n    }\n\n    ckd_free((void *) h->table);\n    ckd_free((void *) h);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/listelem_alloc.h\"\n#include \"sphinxbase/glist.h\"\n\n/**\n * Fast linked list allocator.\n * \n * We keep a separate linked list for each element-size.  Element-size\n * must be a multiple of pointer-size.\n *\n * Initially a block of empty elements is allocated, where the first\n * machine word in each element points to the next available element.\n * To allocate, we use this pointer to move the freelist to the next\n * element, then return the current element.\n *\n * The last element in the list starts with a NULL pointer, which is\n * used as a signal to allocate a new block of elements.\n *\n * In order to be able to actually release the memory allocated, we\n * have to add a linked list of block pointers.  This shouldn't create\n * much overhead since we never access it except when freeing the\n * allocator.\n */\nstruct listelem_alloc_s {\n    char **freelist;            /**< ptr to first element in freelist */\n    glist_t blocks;             /**< Linked list of blocks allocated. */\n    glist_t blocksize;          /**< Number of elements in each block */\n    size_t elemsize;            /**< Number of (char *) in element */\n    size_t blk_alloc;           /**< Number of alloc operations before increasing blocksize */\n    size_t n_blocks;\n    size_t n_alloc;\n    size_t n_freed;\n};\n\n#define MIN_ALLOC\t50      /**< Minimum number of elements to allocate in one block */\n#define BLKID_SHIFT     16      /**< Bit position of block number in element ID */\n#define BLKID_MASK ((1<<BLKID_SHIFT)-1)\n\n/**\n * Allocate a new block of elements.\n */\nstatic void listelem_add_block(listelem_alloc_t *list,\n\t\t\t       char *caller_file, int caller_line);\n\nlistelem_alloc_t *\nlistelem_alloc_init(size_t elemsize)\n{\n    listelem_alloc_t *list;\n\n    if ((elemsize % sizeof(void *)) != 0) {\n        size_t rounded = (elemsize + sizeof(void *) - 1) & ~(sizeof(void *)-1);\n        E_WARN\n            (\"List item size (%lu) not multiple of sizeof(void *), rounding to %lu\\n\",\n             (unsigned long)elemsize,\n             (unsigned long)rounded);\n        elemsize = rounded;\n    }\n    list = ckd_calloc(1, sizeof(*list));\n    list->freelist = NULL;\n    list->blocks = NULL;\n    list->elemsize = elemsize;\n    /* Intent of this is to increase block size once we allocate\n     * 256KiB (i.e. 1<<18). If somehow the element size is big enough\n     * to overflow that, just fail, people should use malloc anyway. */\n    list->blk_alloc = (1 << 18) / (MIN_ALLOC * elemsize);\n    if (list->blk_alloc <= 0) {\n        E_ERROR(\"Element size * block size exceeds 256k, use malloc instead.\\n\");\n        ckd_free(list);\n        return NULL;\n    }\n    list->n_alloc = 0;\n    list->n_freed = 0;\n\n    /* Allocate an initial block to minimize latency. */\n    listelem_add_block(list, __FILE__, __LINE__);\n    return list;\n}\n\nvoid\nlistelem_alloc_free(listelem_alloc_t *list)\n{\n    gnode_t *gn;\n    if (list == NULL)\n\treturn;\n    for (gn = list->blocks; gn; gn = gnode_next(gn))\n\tckd_free(gnode_ptr(gn));\n    glist_free(list->blocks);\n    glist_free(list->blocksize);\n    ckd_free(list);\n}\n\nstatic void\nlistelem_add_block(listelem_alloc_t *list, char *caller_file, int caller_line)\n{\n    char **cpp, *cp;\n    size_t j;\n    int32 blocksize;\n\n    blocksize = list->blocksize ? gnode_int32(list->blocksize) : MIN_ALLOC;\n    /* Check if block size should be increased (if many requests for this size) */\n    if (list->blk_alloc == 0) {\n        /* See above.  No sense in allocating blocks bigger than\n         * 256KiB (well, actually, there might be, but we'll worry\n         * about that later). */\n\tblocksize <<= 1;\n        if (blocksize * list->elemsize > (1 << 18))\n            blocksize = (1 << 18) / list->elemsize;\n\tlist->blk_alloc = (1 << 18) / (blocksize * list->elemsize);\n    }\n\n    /* Allocate block */\n    cpp = list->freelist =\n\t(char **) __ckd_calloc__(blocksize, list->elemsize,\n\t\t\t\t caller_file, caller_line);\n    list->blocks = glist_add_ptr(list->blocks, cpp);\n    list->blocksize = glist_add_int32(list->blocksize, blocksize);\n    cp = (char *) cpp;\n    /* Link up the blocks via their first machine word. */\n    for (j = blocksize - 1; j > 0; --j) {\n\tcp += list->elemsize;\n\t*cpp = cp;\n\tcpp = (char **) cp;\n    }\n    /* Make sure the last element's forward pointer is NULL */\n    *cpp = NULL;\n    --list->blk_alloc;\n    ++list->n_blocks;\n}\n\n\nvoid *\n__listelem_malloc__(listelem_alloc_t *list, char *caller_file, int caller_line)\n{\n    char **ptr;\n\n    /* Allocate a new block if list empty */\n    if (list->freelist == NULL)\n\tlistelem_add_block(list, caller_file, caller_line);\n\n    /* Unlink and return first element in freelist */\n    ptr = list->freelist;\n    list->freelist = (char **) (*(list->freelist));\n    (list->n_alloc)++;\n\n    return (void *)ptr;\n}\n\nvoid *\n__listelem_malloc_id__(listelem_alloc_t *list, char *caller_file,\n                       int caller_line, int32 *out_id)\n{\n    char **ptr;\n\n    /* Allocate a new block if list empty */\n    if (list->freelist == NULL)\n\tlistelem_add_block(list, caller_file, caller_line);\n\n    /* Unlink and return first element in freelist */\n    ptr = list->freelist;\n    list->freelist = (char **) (*(list->freelist));\n    (list->n_alloc)++;\n\n    if (out_id) {\n        int32 blksize, blkidx, ptridx;\n        gnode_t *gn, *gn2;\n        char **block;\n\n        gn2 = list->blocksize;\n        block = NULL;\n        blkidx = 0;\n        for (gn = list->blocks; gn; gn = gnode_next(gn)) {\n            block = gnode_ptr(gn);\n            blksize = gnode_int32(gn2) * list->elemsize / sizeof(*block);\n            if (ptr >= block && ptr < block + blksize)\n                break;\n            gn2 = gnode_next(gn2);\n            ++blkidx;\n        }\n        if (gn == NULL) {\n            E_ERROR(\"Failed to find block index for pointer %p!\\n\", ptr);\n        }\n        ptridx = (ptr - block) / (list->elemsize / sizeof(*block));\n        E_DEBUG(\"ptr %p block %p blkidx %d ptridx %d\\n\",\n                ptr, block, list->n_blocks - blkidx - 1, ptridx);\n        *out_id = ((list->n_blocks - blkidx - 1) << BLKID_SHIFT) | ptridx;\n    }\n\n    return ptr;\n}\n\nvoid *\nlistelem_get_item(listelem_alloc_t *list, int32 id)\n{\n    int32 blkidx, ptridx, i;\n    gnode_t *gn;\n\n    blkidx = (id >> BLKID_SHIFT) & BLKID_MASK;\n    ptridx = id & BLKID_MASK;\n\n    i = 0;\n    blkidx = list->n_blocks - blkidx;\n    for (gn = list->blocks; gn; gn = gnode_next(gn)) {\n        if (++i == blkidx)\n            break;\n    }\n    if (gn == NULL) {\n        E_ERROR(\"Failed to find block index %d\\n\", blkidx);\n        return NULL;\n    }\n\n    return (void *)((char **)gnode_ptr(gn)\n                    + ptridx * (list->elemsize / sizeof(void *)));\n}\n\nvoid\n__listelem_free__(listelem_alloc_t *list, void *elem,\n                  char *caller_file, int caller_line)\n{\n    char **cpp;\n\n    /*\n     * Insert freed item at head of list.\n     */\n    cpp = (char **) elem;\n    *cpp = (char *) list->freelist;\n    list->freelist = cpp;\n    (list->n_freed)++;\n}\n\n\nvoid\nlistelem_stats(listelem_alloc_t *list)\n{\n    gnode_t *gn, *gn2;\n    char **cpp;\n    size_t n;\n\n    E_INFO(\"Linklist stats:\\n\");\n    for (n = 0, cpp = list->freelist; cpp;\n         cpp = (char **) (*cpp), n++);\n    E_INFO\n        (\"elemsize %lu, #alloc %lu, #freed %lu, #freelist %lu\\n\",\n         (unsigned long)list->elemsize,\n         (unsigned long)list->n_alloc,\n         (unsigned long)list->n_freed,\n         (unsigned long)n);\n    E_INFO(\"Allocated blocks:\\n\");\n    gn2 = list->blocksize;\n    for (gn = list->blocks; gn; gn = gnode_next(gn)) {\n\tE_INFO(\"%p (%d * %d bytes)\\n\", gnode_ptr(gn), gnode_int32(gn2), list->elemsize);\n        gn2 = gnode_next(gn2);\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2007 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#include <math.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"sphinxbase/logmath.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/mmio.h\"\n#include \"sphinxbase/bio.h\"\n#include \"sphinxbase/strfuncs.h\"\n\nstruct logmath_s {\n    logadd_t t;\n    int refcount;\n    mmio_file_t *filemap;\n    float64 base;\n    float64 log_of_base;\n    float64 log10_of_base;\n    float64 inv_log_of_base;\n    float64 inv_log10_of_base;\n    int32 zero;\n};\n\nlogmath_t *\nlogmath_init(float64 base, int shift, int use_table)\n{\n    logmath_t *lmath;\n    uint32 maxyx, i;\n    float64 byx;\n    int width;\n\n    /* Check that the base is correct. */\n    if (base <= 1.0) {\n        E_ERROR(\"Base must be greater than 1.0\\n\");\n        return NULL;\n    }\n    \n    /* Set up various necessary constants. */\n    lmath = ckd_calloc(1, sizeof(*lmath));\n    lmath->refcount = 1;\n    lmath->base = base;\n    lmath->log_of_base = log(base);\n    lmath->log10_of_base = log10(base);\n    lmath->inv_log_of_base = 1.0/lmath->log_of_base;\n    lmath->inv_log10_of_base = 1.0/lmath->log10_of_base;\n    lmath->t.shift = shift;\n    /* Shift this sufficiently that overflows can be avoided. */\n    lmath->zero = MAX_NEG_INT32 >> (shift + 2);\n\n    if (!use_table)\n        return lmath;\n\n    /* Create a logadd table with the appropriate width */\n    maxyx = (uint32) (log(2.0) / log(base) + 0.5) >> shift;\n    /* Poor man's log2 */\n    if (maxyx < 256) width = 1;\n    else if (maxyx < 65536) width = 2;\n    else width = 4;\n\n    lmath->t.width = width;\n    /* Figure out size of add table required. */\n    byx = 1.0; /* Maximum possible base^{y-x} value - note that this implies that y-x == 0 */\n    for (i = 0;; ++i) {\n        float64 lobyx = log(1.0 + byx) * lmath->inv_log_of_base; /* log_{base}(1 + base^{y-x}); */\n        int32 k = (int32) (lobyx + 0.5 * (1<<shift)) >> shift; /* Round to shift */\n\n        /* base^{y-x} has reached the smallest representable value. */\n        if (k <= 0)\n            break;\n\n        /* This table is indexed by -(y-x), so we multiply byx by\n         * base^{-1} here which is equivalent to subtracting one from\n         * (y-x). */\n        byx /= base;\n    }\n    i >>= shift;\n\n    /* Never produce a table smaller than 256 entries. */\n    if (i < 255) i = 255;\n\n    lmath->t.table = ckd_calloc(i+1, width);\n    lmath->t.table_size = i + 1;\n    /* Create the add table (see above). */\n    byx = 1.0;\n    for (i = 0;; ++i) {\n        float64 lobyx = log(1.0 + byx) * lmath->inv_log_of_base;\n        int32 k = (int32) (lobyx + 0.5 * (1<<shift)) >> shift; /* Round to shift */\n        uint32 prev = 0;\n\n        /* Check any previous value - if there is a shift, we want to\n         * only store the highest one. */\n        switch (width) {\n        case 1:\n            prev = ((uint8 *)lmath->t.table)[i >> shift];\n            break;\n        case 2:\n            prev = ((uint16 *)lmath->t.table)[i >> shift];\n            break;\n        case 4:\n            prev = ((uint32 *)lmath->t.table)[i >> shift];\n            break;\n        }\n        if (prev == 0) {\n            switch (width) {\n            case 1:\n                ((uint8 *)lmath->t.table)[i >> shift] = (uint8) k;\n                break;\n            case 2:\n                ((uint16 *)lmath->t.table)[i >> shift] = (uint16) k;\n                break;\n            case 4:\n                ((uint32 *)lmath->t.table)[i >> shift] = (uint32) k;\n                break;\n            }\n        }\n        if (k <= 0)\n            break;\n\n        /* Decay base^{y-x} exponentially according to base. */\n        byx /= base;\n    }\n\n    return lmath;\n}\n\nlogmath_t *\nlogmath_read(const char *file_name)\n{\n    logmath_t *lmath;\n    char **argname, **argval;\n    int32 byteswap, i;\n    int chksum_present, do_mmap;\n    uint32 chksum;\n    long pos;\n    FILE *fp;\n\n    E_INFO(\"Reading log table file '%s'\\n\", file_name);\n    if ((fp = fopen(file_name, \"rb\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open log table file '%s' for reading\", file_name);\n        return NULL;\n    }\n\n    /* Read header, including argument-value info and 32-bit byteorder magic */\n    if (bio_readhdr(fp, &argname, &argval, &byteswap) < 0) {\n        E_ERROR(\"Failed to read the header from the file '%s'\\n\", file_name);\n        fclose(fp);\n        return NULL;\n    }\n\n    lmath = ckd_calloc(1, sizeof(*lmath));\n    /* Default values. */\n    lmath->t.shift = 0;\n    lmath->t.width = 2;\n    lmath->base = 1.0001;\n\n    /* Parse argument-value list */\n    chksum_present = 0;\n    for (i = 0; argname[i]; i++) {\n        if (strcmp(argname[i], \"version\") == 0) {\n        }\n        else if (strcmp(argname[i], \"chksum0\") == 0) {\n            if (strcmp(argval[i], \"yes\") == 0)\n                chksum_present = 1;\n        }\n        else if (strcmp(argname[i], \"width\") == 0) {\n            lmath->t.width = atoi(argval[i]);\n        }\n        else if (strcmp(argname[i], \"shift\") == 0) {\n            lmath->t.shift = atoi(argval[i]);\n        }\n        else if (strcmp(argname[i], \"logbase\") == 0) {\n            lmath->base = atof_c(argval[i]);\n        }\n    }\n    bio_hdrarg_free(argname, argval);\n    chksum = 0;\n\n    /* Set up various necessary constants. */\n    lmath->log_of_base = log(lmath->base);\n    lmath->log10_of_base = log10(lmath->base);\n    lmath->inv_log_of_base = 1.0/lmath->log_of_base;\n    lmath->inv_log10_of_base = 1.0/lmath->log10_of_base;\n    /* Shift this sufficiently that overflows can be avoided. */\n    lmath->zero = MAX_NEG_INT32 >> (lmath->t.shift + 2);\n\n    /* #Values to follow */\n    if (bio_fread(&lmath->t.table_size, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {\n        E_ERROR(\"Failed to read values from the file '%s'\", file_name);\n        goto error_out;\n    }\n\n    /* Check alignment constraints for memory mapping */\n    do_mmap = 1;\n    pos = ftell(fp);\n    if (pos & ((long)lmath->t.width - 1)) {\n        E_WARN(\"%s: Data start %ld is not aligned on %d-byte boundary, will not memory map\\n\",\n                  file_name, pos, lmath->t.width);\n        do_mmap = 0;\n    }\n    /* Check byte order for memory mapping */\n    if (byteswap) {\n        E_WARN(\"%s: Data is wrong-endian, will not memory map\\n\", file_name);\n        do_mmap = 0;\n    }\n\n    if (do_mmap) {\n        lmath->filemap = mmio_file_read(file_name);\n        lmath->t.table = (char *)mmio_file_ptr(lmath->filemap) + pos;\n    }\n    else {\n        lmath->t.table = ckd_calloc(lmath->t.table_size, lmath->t.width);\n        if (bio_fread(lmath->t.table, lmath->t.width, lmath->t.table_size,\n                      fp, byteswap, &chksum) != lmath->t.table_size) {\n            E_ERROR(\"Failed to read data (%d x %d bytes) from the file '%s' failed\",\n                    lmath->t.table_size, lmath->t.width, file_name);\n            goto error_out;\n        }\n        if (chksum_present)\n            bio_verify_chksum(fp, byteswap, chksum);\n\n        if (fread(&i, 1, 1, fp) == 1) {\n            E_ERROR(\"%s: More data than expected\\n\", file_name);\n            goto error_out;\n        }\n    }\n    fclose(fp);\n\n    return lmath;\nerror_out:\n    logmath_free(lmath);\n    return NULL;\n}\n\nint32\nlogmath_write(logmath_t *lmath, const char *file_name)\n{\n    FILE *fp;\n    long pos;\n    uint32 chksum;\n\n    if (lmath->t.table == NULL) {\n        E_ERROR(\"No log table to write!\\n\");\n        return -1;\n    }\n\n    E_INFO(\"Writing log table file '%s'\\n\", file_name);\n    if ((fp = fopen(file_name, \"wb\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open logtable file '%s' for writing\", file_name);\n        return -1;\n    }\n\n    /* For whatever reason, we have to do this manually at the\n     * moment. */\n    fprintf(fp, \"s3\\nversion 1.0\\nchksum0 yes\\n\");\n    fprintf(fp, \"width %d\\n\", lmath->t.width);\n    fprintf(fp, \"shift %d\\n\", lmath->t.shift);\n    fprintf(fp, \"logbase %f\\n\", lmath->base);\n    /* Pad it out to ensure alignment. */\n    pos = ftell(fp) + strlen(\"endhdr\\n\");\n    if (pos & ((long)lmath->t.width - 1)) {\n        size_t align = lmath->t.width - (pos & ((long)lmath->t.width - 1));\n        assert(lmath->t.width <= 8);\n        fwrite(\"        \" /* 8 spaces */, 1, align, fp);\n    }\n    fprintf(fp, \"endhdr\\n\");\n\n    /* Now write the binary data. */\n    chksum = (uint32)BYTE_ORDER_MAGIC;\n    fwrite(&chksum, sizeof(uint32), 1, fp);\n    chksum = 0;\n    /* #Values to follow */\n    if (bio_fwrite(&lmath->t.table_size, sizeof(uint32),\n                   1, fp, 0, &chksum) != 1) {\n        E_ERROR(\"Failed to write data to a file '%s'\", file_name);\n        goto error_out;\n    }\n\n    if (bio_fwrite(lmath->t.table, lmath->t.width, lmath->t.table_size,\n                   fp, 0, &chksum) != lmath->t.table_size) {\n        E_ERROR(\"Failed to write data (%d x %d bytes) to the file '%s'\",\n                lmath->t.table_size, lmath->t.width, file_name);\n        goto error_out;\n    }\n    if (bio_fwrite(&chksum, sizeof(uint32), 1, fp, 0, NULL) != 1) {\n        E_ERROR(\"Failed to write checksum to the file '%s'\", file_name);\n        goto error_out;\n    }\n\n    fclose(fp);\n    return 0;\n\nerror_out:\n    fclose(fp);\n    return -1;\n}\n\nlogmath_t *\nlogmath_retain(logmath_t *lmath)\n{\n    ++lmath->refcount;\n    return lmath;\n}\n\nint\nlogmath_free(logmath_t *lmath)\n{\n    if (lmath == NULL)\n        return 0;\n    if (--lmath->refcount > 0)\n        return lmath->refcount;\n    if (lmath->filemap)\n        mmio_file_unmap(lmath->filemap);\n    else\n        ckd_free(lmath->t.table);\n    ckd_free(lmath);\n    return 0;\n}\n\nint32\nlogmath_get_table_shape(logmath_t *lmath, uint32 *out_size,\n                        uint32 *out_width, uint32 *out_shift)\n{\n    if (out_size) *out_size = lmath->t.table_size;\n    if (out_width) *out_width = lmath->t.width;\n    if (out_shift) *out_shift = lmath->t.shift;\n\n    return lmath->t.table_size * lmath->t.width;\n}\n\nfloat64\nlogmath_get_base(logmath_t *lmath)\n{\n    return lmath->base;\n}\n\nint\nlogmath_get_zero(logmath_t *lmath)\n{\n    return lmath->zero;\n}\n\nint\nlogmath_get_width(logmath_t *lmath)\n{\n    return lmath->t.width;\n}\n\nint\nlogmath_get_shift(logmath_t *lmath)\n{\n    return lmath->t.shift;\n}\n\nint\nlogmath_add(logmath_t *lmath, int logb_x, int logb_y)\n{\n    logadd_t *t = LOGMATH_TABLE(lmath);\n    int d, r;\n\n    /* handle 0 + x = x case. */\n    if (logb_x <= lmath->zero)\n        return logb_y;\n    if (logb_y <= lmath->zero)\n        return logb_x;\n\n    if (t->table == NULL)\n        return logmath_add_exact(lmath, logb_x, logb_y);\n\n    /* d must be positive, obviously. */\n    if (logb_x > logb_y) {\n        d = (logb_x - logb_y);\n        r = logb_x;\n    }\n    else {\n        d = (logb_y - logb_x);\n        r = logb_y;\n    }\n\n    if (d < 0) {\n        /* Some kind of overflow has occurred, fail gracefully. */\n        return r;\n    }\n    if ((size_t)d >= t->table_size) {\n        /* If this happens, it's not actually an error, because the\n         * last entry in the logadd table is guaranteed to be zero.\n         * Therefore we just return the larger of the two values. */\n        return r;\n    }\n\n    switch (t->width) {\n    case 1:\n        return r + (((uint8 *)t->table)[d]);\n    case 2:\n        return r + (((uint16 *)t->table)[d]);\n    case 4:\n        return r + (((uint32 *)t->table)[d]);\n    }\n    return r;\n}\n\nint\nlogmath_add_exact(logmath_t *lmath, int logb_p, int logb_q)\n{\n    return logmath_log(lmath,\n                       logmath_exp(lmath, logb_p)\n                       + logmath_exp(lmath, logb_q));\n}\n\nint\nlogmath_log(logmath_t *lmath, float64 p)\n{\n    if (p <= 0) {\n        return lmath->zero;\n    }\n    return (int)(log(p) * lmath->inv_log_of_base) >> lmath->t.shift;\n}\n\nfloat64\nlogmath_exp(logmath_t *lmath, int logb_p)\n{\n    return pow(lmath->base, (float64)(logb_p << lmath->t.shift));\n}\n\nint\nlogmath_ln_to_log(logmath_t *lmath, float64 log_p)\n{\n    return (int)(log_p * lmath->inv_log_of_base) >> lmath->t.shift;\n}\n\nfloat64\nlogmath_log_to_ln(logmath_t *lmath, int logb_p)\n{\n    return (float64)(logb_p << lmath->t.shift) * lmath->log_of_base;\n}\n\nint\nlogmath_log10_to_log(logmath_t *lmath, float64 log_p)\n{\n    return (int)(log_p * lmath->inv_log10_of_base) >> lmath->t.shift;\n}\n\nfloat \nlogmath_log10_to_log_float(logmath_t *lmath, float64 log_p)\n{\n    int i;\n    float res = (float)(log_p * lmath->inv_log10_of_base);\n    for (i = 0; i < lmath->t.shift; i++)\n        res /= 2.0f;\n    return res;\n}\n\nfloat64\nlogmath_log_to_log10(logmath_t *lmath, int logb_p)\n{\n    return (float64)(logb_p << lmath->t.shift) * lmath->log10_of_base;\n}\n\nfloat64\nlogmath_log_float_to_log10(logmath_t *lmath, float log_p)\n{\n    int i;\n    for (i = 0; i < lmath->t.shift; i++) {\n        log_p *= 2;\n    }\n    return log_p * lmath->log10_of_base;\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2005 Carnegie Mellon University.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*********************************************************************\n *\n * File: mmio.c\n * \n * Description: mmap() wrappers for Unix/Windows\n * \n * Author: David Huggins-Daines <dhuggins@cs.cmu.edu>\n * \n *********************************************************************/\n\n#include <string.h>\n#include <stdlib.h>\n\n\n#ifdef GNUWINCE\n# include <sys/wcebase.h>\n# include <sys/wcetypes.h>\n# include <sys/wcememory.h>\n# include <sys/wcefile.h>\n#elif defined(__SYMBIAN32__) /* SYMBIAN32 must be before WIN32 since Symbian SDK defines WIN32 as well */\n# include <unistd.h>\n# include <fcntl.h>\n# include <sys/stat.h>\n# include <sys/mman.h>\n#elif defined(_WIN32)\n# include <windows.h>\n#else\n# include <unistd.h>\n# include <fcntl.h>\n# include <sys/stat.h>\n# include <sys/file.h>\n# include <sys/mman.h>\n#endif\n\n#include \"sphinxbase/prim_type.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/mmio.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\n#if defined(_WIN32_WCE) || defined(GNUWINCE)\nstruct mmio_file_s {\n\tint dummy;\n};\n\nmmio_file_t *\nmmio_file_read(const char *filename)\n{\n    HANDLE ffm, fd;\n    WCHAR *wfilename;\n    void *rv;\n    int len;\n\n    len = mbstowcs(NULL, filename, 0) + 1;\n    wfilename = malloc(len * sizeof(WCHAR));\n    mbstowcs(wfilename, filename, len);\n\n    if ((ffm =\n         CreateFileForMappingW(wfilename, GENERIC_READ, FILE_SHARE_READ,\n                               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,\n                               NULL)) == INVALID_HANDLE_VALUE) {\n        E_ERROR(\"Failed to create mapping for the file '%s': %08x\\n\", filename,\n                GetLastError());\n        return NULL;\n    }\n    if ((fd =\n         CreateFileMappingW(ffm, NULL, PAGE_READONLY, 0, 0, NULL)) == NULL) {\n        E_ERROR(\"Failed to CreateFileMapping: %08x\\n\", GetLastError());\n        CloseHandle(ffm);\n        return NULL;\n    }\n    rv = MapViewOfFile(fd, FILE_MAP_READ, 0, 0, 0);\n    free(wfilename);\n    CloseHandle(ffm);\n    CloseHandle(fd);\n\n    return (mmio_file_t *) rv;\n}\n\nvoid\nmmio_file_unmap(mmio_file_t *mf)\n{\n    if (!UnmapViewOfFile((void *)mf)) {\n        E_ERROR(\"Failed to UnmapViewOfFile: %08x\\n\", GetLastError());\n    }\n}\n\nvoid *\nmmio_file_ptr(mmio_file_t *mf)\n{\n    return (void *)mf;\n}\n\n#elif defined(_WIN32) && !defined(_WIN32_WP) /* !WINCE */\nstruct mmio_file_s {\n\tint dummy;\n};\n\nmmio_file_t *\nmmio_file_read(const char *filename)\n{\n    HANDLE ffm, fd;\n    void *rv;\n\n    if ((ffm = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ,\n                         NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,\n                         NULL)) == INVALID_HANDLE_VALUE) {\n        E_ERROR(\"Failed to create file '%s': %08x\\n\",\n                filename, GetLastError());\n        return NULL;\n    }\n    if ((fd = CreateFileMapping(ffm, NULL,\n                                PAGE_READONLY, 0, 0, NULL)) == NULL) {\n        E_ERROR(\"Failed to CreateFileMapping: %08x\\n\", GetLastError());\n        CloseHandle(ffm);\n    }\n    rv = MapViewOfFile(fd, FILE_MAP_READ, 0, 0, 0);\n    CloseHandle(ffm);\n    CloseHandle(fd);\n\n    return (mmio_file_t *)rv;\n}\n\nvoid\nmmio_file_unmap(mmio_file_t *mf)\n{\n    if (!UnmapViewOfFile((void *)mf)) {\n        E_ERROR(\"Failed to UnmapViewOfFile: %08x\\n\", GetLastError());\n    }\n}\n\nvoid *\nmmio_file_ptr(mmio_file_t *mf)\n{\n    return (void *)mf;\n}\n\n#else /* !WIN32, !WINCE */\n#if defined(__ADSPBLACKFIN__) || defined(_WIN32_WP) \n\t\t\t\t/* This is true for both uClinux and VisualDSP++,\n                                 but actually we need a better way to detect it. */\nstruct mmio_file_s {\n    int dummy;\n};\n\nmmio_file_t *\nmmio_file_read(const char *filename)\n{\n    E_ERROR(\"mmio is not implemented on this platform!\");\n    return NULL;\n}\n\nvoid\nmmio_file_unmap(mmio_file_t *mf)\n{\n    E_ERROR(\"mmio is not implemented on this platform!\");\n}\n\nvoid *\nmmio_file_ptr(mmio_file_t *mf)\n{\n    E_ERROR(\"mmio is not implemented on this platform!\");\n    return NULL;\n}\n#else /* !__ADSPBLACKFIN__ */\nstruct mmio_file_s {\n    void *ptr;\n    size_t mapsize;\n};\n\nmmio_file_t *\nmmio_file_read(const char *filename)\n{\n    mmio_file_t *mf;\n    struct stat buf;\n    void *ptr;\n    int fd;\n    size_t pagesize;\n\n    if ((fd = open(filename, O_RDONLY)) == -1) {\n        E_ERROR_SYSTEM(\"Failed to open %s\", filename);\n        return NULL;\n    }\n    if (fstat(fd, &buf) == -1) {\n        E_ERROR_SYSTEM(\"Failed to stat %s\", filename);\n        close(fd);\n        return NULL;\n    }\n    ptr = mmap(NULL, buf.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (ptr == (void *)-1) {\n        E_ERROR_SYSTEM(\"Failed to mmap %lld bytes\", (unsigned long long)buf.st_size);\n        close(fd);\n        return NULL;\n    }\n    close(fd);\n    mf = ckd_calloc(1, sizeof(*mf));\n    mf->ptr = ptr;\n    /* Align map size to next page. */\n    pagesize = sysconf(_SC_PAGESIZE);\n    mf->mapsize = (buf.st_size + pagesize - 1) / pagesize * pagesize;\n\n    return mf;\n}\n\nvoid\nmmio_file_unmap(mmio_file_t *mf)\n{\n    if (mf == NULL)\n        return;\n    if (munmap(mf->ptr, mf->mapsize) < 0) {\n        E_ERROR_SYSTEM(\"Failed to unmap %ld bytes at %p\", mf->mapsize, mf->ptr);\n    }\n    ckd_free(mf);\n}\n\nvoid *\nmmio_file_ptr(mmio_file_t *mf)\n{\n    return mf->ptr;\n}\n#endif /* !__ADSPBLACKFIN__ */ \n#endif /* !(WINCE || WIN32) */\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n\n#if defined(_WIN32) && !defined(CYGWIN)\n#include <direct.h>\n#endif\n\n#include \"sphinxbase/pio.h\"\n#include \"sphinxbase/filename.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/strfuncs.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\n#ifndef EXEEXT\n#define EXEEXT \"\"\n#endif\n\nenum {\n    COMP_NONE,\n    COMP_COMPRESS,\n    COMP_GZIP,\n    COMP_BZIP2\n};\n\nstatic void\nguess_comptype(char const *file, int32 *ispipe, int32 *isgz)\n{\n    size_t k;\n\n    k = strlen(file);\n    *ispipe = 0;\n    *isgz = COMP_NONE;\n    if ((k > 2)\n        && ((strcmp(file + k - 2, \".Z\") == 0)\n            || (strcmp(file + k - 2, \".z\") == 0))) {\n        *ispipe = 1;\n        *isgz = COMP_COMPRESS;\n    }\n    else if ((k > 3) && ((strcmp(file + k - 3, \".gz\") == 0)\n                        || (strcmp(file + k - 3, \".GZ\") == 0))) {\n        *ispipe = 1;\n        *isgz = COMP_GZIP;\n    }\n    else if ((k > 4) && ((strcmp(file + k - 4, \".bz2\") == 0)\n                        || (strcmp(file + k - 4, \".BZ2\") == 0))) {\n        *ispipe = 1;\n        *isgz = COMP_BZIP2;\n    }\n}\n\nFILE *\nfopen_comp(const char *file, const char *mode, int32 * ispipe)\n{\n    FILE *fp;\n\n#ifndef HAVE_POPEN\n    *ispipe = 0; /* No popen() on WinCE */\n#else /* HAVE_POPEN */\n    int32 isgz;\n    guess_comptype(file, ispipe, &isgz);\n#endif /* HAVE_POPEN */\n\n    if (*ispipe) {\n#ifndef HAVE_POPEN\n        /* Shouldn't get here, anyway */\n        E_FATAL(\"No popen() on WinCE\\n\");\n#else\n        if (strcmp(mode, \"r\") == 0) {\n            char *command;\n            switch (isgz) {\n            case COMP_GZIP:\n                command = string_join(\"gunzip\" EXEEXT, \" -c \", file, NULL);\n                break;\n            case COMP_COMPRESS:\n                command = string_join(\"zcat\" EXEEXT, \" \", file, NULL);\n                break;\n            case COMP_BZIP2:\n                command = string_join(\"bunzip2\" EXEEXT, \" -c \", file, NULL);\n                break;\n            default:\n                command = NULL; /* Make compiler happy. */\n                E_FATAL(\"Unknown  compression type %d\\n\", isgz);\n            }\n            if ((fp = popen(command, mode)) == NULL) {\n                E_ERROR_SYSTEM(\"Failed to open a pipe for a command '%s' mode '%s'\", command, mode);\n                ckd_free(command);\n                return NULL;\n            }\n            ckd_free(command);\n        }\n        else if (strcmp(mode, \"w\") == 0) {\n            char *command;\n            switch (isgz) {\n            case COMP_GZIP:\n                command = string_join(\"gzip\" EXEEXT, \" > \", file, NULL);\n                break;\n            case COMP_COMPRESS:\n                command = string_join(\"compress\" EXEEXT, \" -c > \", file, NULL);\n                break;\n            case COMP_BZIP2:\n                command = string_join(\"bzip2\" EXEEXT, \" > \", file, NULL);\n                break;\n            default:\n                command = NULL; /* Make compiler happy. */\n                E_FATAL(\"Unknown compression type %d\\n\", isgz);\n            }\n            if ((fp = popen(command, mode)) == NULL) {\n                E_ERROR_SYSTEM(\"Failed to open a pipe for a command '%s' mode '%s'\", command, mode);\n                ckd_free(command);\n                return NULL;\n            }\n            ckd_free(command);\n        }\n        else {\n            E_ERROR(\"Compressed file operation for mode %s is not supported\\n\", mode);\n            return NULL;\n        }\n#endif /* HAVE_POPEN */\n    }\n    else {\n        fp = fopen(file, mode);\n    }\n\n    return (fp);\n}\n\n\nvoid\nfclose_comp(FILE * fp, int32 ispipe)\n{\n    if (ispipe) {\n#ifdef HAVE_POPEN\n#if defined(_WIN32) && (!defined(__SYMBIAN32__))\n        _pclose(fp);\n#else\n        pclose(fp);\n#endif\n#endif\n    }\n    else\n        fclose(fp);\n}\n\n\nFILE *\nfopen_compchk(const char *file, int32 * ispipe)\n{\n#ifndef HAVE_POPEN\n    *ispipe = 0; /* No popen() on WinCE */\n    /* And therefore the rest of this function is useless. */\n    return (fopen_comp(file, \"r\", ispipe));\n#else /* HAVE_POPEN */\n    int32 isgz;\n    FILE *fh;\n\n    /* First just try to fopen_comp() it */\n    if ((fh = fopen_comp(file, \"r\", ispipe)) != NULL)\n        return fh;\n    else {\n        char *tmpfile;\n        size_t k;\n\n        /* File doesn't exist; try other compressed/uncompressed form, as appropriate */\n        guess_comptype(file, ispipe, &isgz);\n        k = strlen(file);\n        tmpfile = ckd_calloc(k+5, 1);\n        strcpy(tmpfile, file);\n        switch (isgz) {\n        case COMP_GZIP:\n            tmpfile[k - 3] = '\\0';\n            break;\n        case COMP_BZIP2:\n            tmpfile[k - 4] = '\\0';\n            break;\n        case COMP_COMPRESS:\n            tmpfile[k - 2] = '\\0';\n            break;\n        case COMP_NONE:\n            strcpy(tmpfile + k, \".gz\");\n            if ((fh = fopen_comp(tmpfile, \"r\", ispipe)) != NULL) {\n                E_WARN(\"Using %s instead of %s\\n\", tmpfile, file);\n                ckd_free(tmpfile);\n                return fh;\n            }\n            strcpy(tmpfile + k, \".bz2\");\n            if ((fh = fopen_comp(tmpfile, \"r\", ispipe)) != NULL) {\n                E_WARN(\"Using %s instead of %s\\n\", tmpfile, file);\n                ckd_free(tmpfile);\n                return fh;\n            }\n            strcpy(tmpfile + k, \".Z\");\n            if ((fh = fopen_comp(tmpfile, \"r\", ispipe)) != NULL) {\n                E_WARN(\"Using %s instead of %s\\n\", tmpfile, file);\n                ckd_free(tmpfile);\n                return fh;\n            }\n            ckd_free(tmpfile);\n            return NULL;\n        }\n        E_WARN(\"Using %s instead of %s\\n\", tmpfile, file);\n        fh = fopen_comp(tmpfile, \"r\", ispipe);\n        ckd_free(tmpfile);\n        return NULL;\n    }\n#endif /* HAVE_POPEN */\n}\n\nlineiter_t *\nlineiter_start(FILE *fh)\n{\n    lineiter_t *li;\n\n    li = (lineiter_t *)ckd_calloc(1, sizeof(*li));\n    li->buf = (char *)ckd_malloc(128);\n    li->buf[0] = '\\0';\n    li->bsiz = 128;\n    li->len = 0;\n    li->fh = fh;\n\n    li = lineiter_next(li);\n    \n    /* Strip the UTF-8 BOM */\n    \n    if (li && 0 == strncmp(li->buf, \"\\xef\\xbb\\xbf\", 3)) {\n\tmemmove(li->buf, li->buf + 3, strlen(li->buf + 1));\n\tli->len -= 3;\n    }\n    \n    return li;\n}\n\nlineiter_t *\nlineiter_start_clean(FILE *fh)\n{\n    lineiter_t *li;\n    \n    li = lineiter_start(fh);\n    \n    if (li == NULL)\n\treturn li;\n    \n    li->clean = TRUE;\n    \n    if (li->buf && li->buf[0] == '#') {\n\tli = lineiter_next(li);\n    } else {\n\tstring_trim(li->buf, STRING_BOTH);\n    }\n    \n    return li;\n}\n\n\nstatic lineiter_t *\nlineiter_next_plain(lineiter_t *li)\n{\n    /* We are reading the next line */\n    li->lineno++;\n    \n    /* Read a line and check for EOF. */\n    if (fgets(li->buf, li->bsiz, li->fh) == NULL) {\n        lineiter_free(li);\n        return NULL;\n    }\n    /* If we managed to read the whole thing, then we are done\n     * (this will be by far the most common result). */\n    li->len = (int32)strlen(li->buf);\n    if (li->len < li->bsiz - 1 || li->buf[li->len - 1] == '\\n')\n        return li;\n\n    /* Otherwise we have to reallocate and keep going. */\n    while (1) {\n        li->bsiz *= 2;\n        li->buf = (char *)ckd_realloc(li->buf, li->bsiz);\n        /* If we get an EOF, we are obviously done. */\n        if (fgets(li->buf + li->len, li->bsiz - li->len, li->fh) == NULL) {\n            li->len += strlen(li->buf + li->len);\n            return li;\n        }\n        li->len += strlen(li->buf + li->len);\n        /* If we managed to read the whole thing, then we are done. */\n        if (li->len < li->bsiz - 1 || li->buf[li->len - 1] == '\\n')\n            return li;\n    }\n\n    /* Shouldn't get here. */\n    return li;\n}\n\n\nlineiter_t *\nlineiter_next(lineiter_t *li)\n{\n    if (!li->clean)\n\treturn lineiter_next_plain(li);\n    \n    for (li = lineiter_next_plain(li); li; li = lineiter_next_plain(li)) {\n\tif (li->buf) {\n\t    li->buf = string_trim(li->buf, STRING_BOTH);\n\t    if (li->buf[0] != 0 && li->buf[0] != '#')\n\t\tbreak;\n\t}\n    }\n    return li;\n}\n\nint lineiter_lineno(lineiter_t *li)\n{\n    return li->lineno;\n}\n\nvoid\nlineiter_free(lineiter_t *li)\n{\n    if (li == NULL)\n        return;\n    ckd_free(li->buf);\n    ckd_free(li);\n}\n\nchar *\nfread_line(FILE *stream, size_t *out_len)\n{\n    char *output, *outptr;\n    char buf[128];\n\n    output = outptr = NULL;\n    while (fgets(buf, sizeof(buf), stream)) {\n        size_t len = strlen(buf);\n        /* Append this data to the buffer. */\n        if (output == NULL) {\n            output = (char *)ckd_malloc(len + 1);\n            outptr = output;\n        }\n        else {\n            size_t cur = outptr - output;\n            output = (char *)ckd_realloc(output, cur + len + 1);\n            outptr = output + cur;\n        }\n        memcpy(outptr, buf, len + 1);\n        outptr += len;\n        /* Stop on a short read or end of line. */\n        if (len < sizeof(buf)-1 || buf[len-1] == '\\n')\n            break;\n    }\n    if (out_len) *out_len = outptr - output;\n    return output;\n}\n\n#define FREAD_RETRY_COUNT\t60\n\nint32\nfread_retry(void *pointer, int32 size, int32 num_items, FILE * stream)\n{\n    char *data;\n    size_t n_items_read;\n    size_t n_items_rem;\n    uint32 n_retry_rem;\n    int32 loc;\n\n    n_retry_rem = FREAD_RETRY_COUNT;\n\n    data = (char *)pointer;\n    loc = 0;\n    n_items_rem = num_items;\n\n    do {\n        n_items_read = fread(&data[loc], size, n_items_rem, stream);\n\n        n_items_rem -= n_items_read;\n\n        if (n_items_rem > 0) {\n            /* an incomplete read occurred */\n\n            if (n_retry_rem == 0)\n                return -1;\n\n            if (n_retry_rem == FREAD_RETRY_COUNT) {\n                E_ERROR_SYSTEM(\"fread() failed; retrying...\\n\");\n            }\n\n            --n_retry_rem;\n\n            loc += n_items_read * size;\n#if !defined(_WIN32) && defined(HAVE_UNISTD_H)\n            sleep(1);\n#endif\n        }\n    } while (n_items_rem > 0);\n\n    return num_items;\n}\n\n\n#ifdef _WIN32_WCE /* No stat() on WinCE */\nint32\nstat_retry(const char *file, struct stat * statbuf)\n{\n    WIN32_FIND_DATAW file_data;\n    HANDLE *h;\n    wchar_t *wfile;\n    size_t len;\n\n    len = mbstowcs(NULL, file, 0) + 1;\n    wfile = ckd_calloc(len, sizeof(*wfile));\n    mbstowcs(wfile, file, len);\n    if ((h = FindFirstFileW(wfile, &file_data)) == INVALID_HANDLE_VALUE) {\n        ckd_free(wfile);\n        return -1;\n    }\n    ckd_free(wfile);\n    memset(statbuf, 0, sizeof(*statbuf));\n    statbuf->st_mtime = file_data.ftLastWriteTime.dwLowDateTime;\n    statbuf->st_size = file_data.nFileSizeLow;\n    FindClose(h);\n\n    return 0;\n}\n\n\nint32\nstat_mtime(const char *file)\n{\n    struct stat statbuf;\n\n    if (stat_retry(file, &statbuf) != 0)\n        return -1;\n\n    return ((int32) statbuf.st_mtime);\n}\n#else\n#define STAT_RETRY_COUNT\t10\nint32\nstat_retry(const char *file, struct stat * statbuf)\n{\n    int32 i;\n\n    for (i = 0; i < STAT_RETRY_COUNT; i++) {\n#ifndef HAVE_SYS_STAT_H\n\tFILE *fp;\n\n\tif ((fp = (FILE *)fopen(file, \"r\")) != 0) {\n\t    fseek(fp, 0, SEEK_END);\n\t    statbuf->st_size = ftell(fp);\n\t    fclose(fp);\n\t    return 0;\n\t}\n#else /* HAVE_SYS_STAT_H */\n        if (stat(file, statbuf) == 0)\n            return 0;\n#endif\n        if (i == 0) {\n            E_ERROR_SYSTEM(\"Failed to stat file '%s'; retrying...\", file);\n        }\n#ifdef HAVE_UNISTD_H\n        sleep(1);\n#endif\n    }\n\n    return -1;\n}\n\nint32\nstat_mtime(const char *file)\n{\n    struct stat statbuf;\n\n#ifdef HAVE_SYS_STAT_H\n    if (stat(file, &statbuf) != 0)\n        return -1;\n#else /* HAVE_SYS_STAT_H */\n    if (stat_retry(file, &statbuf) != 0)\n        return -1;\n#endif /* HAVE_SYS_STAT_H */\n\n    return ((int32) statbuf.st_mtime);\n}\n#endif /* !_WIN32_WCE */\n\nstruct bit_encode_s {\n    FILE *fh;\n    unsigned char buf, bbits;\n    int16 refcount;\n};\n\nbit_encode_t *\nbit_encode_attach(FILE *outfh)\n{\n    bit_encode_t *be;\n\n    be = (bit_encode_t *)ckd_calloc(1, sizeof(*be));\n    be->refcount = 1;\n    be->fh = outfh;\n    return be;\n}\n\nbit_encode_t *\nbit_encode_retain(bit_encode_t *be)\n{\n    ++be->refcount;\n    return be;\n}\n\nint\nbit_encode_free(bit_encode_t *be)\n{\n    if (be == NULL)\n        return 0;\n    if (--be->refcount > 0)\n        return be->refcount;\n    ckd_free(be);\n\n    return 0;\n}\n\nint\nbit_encode_write(bit_encode_t *be, unsigned char const *bits, int nbits)\n{\n    int tbits;\n\n    tbits = nbits + be->bbits;\n    if (tbits < 8)  {\n        /* Append to buffer. */\n        be->buf |= ((bits[0] >> (8 - nbits)) << (8 - tbits));\n    }\n    else {\n        int i = 0;\n        while (tbits >= 8) {\n            /* Shift bits out of the buffer and splice with high-order bits */\n            fputc(be->buf | ((bits[i]) >> be->bbits), be->fh);\n            /* Put low-order bits back into buffer */\n            be->buf = (bits[i] << (8 - be->bbits)) & 0xff;\n            tbits -= 8;\n            ++i;\n        }\n    }\n    /* tbits contains remaining number of  bits. */\n    be->bbits = tbits;\n\n    return nbits;\n}\n\nint\nbit_encode_write_cw(bit_encode_t *be, uint32 codeword, int nbits)\n{\n    unsigned char bits[4];\n    codeword <<= (32 - nbits);\n    bits[0] = (codeword >> 24) & 0xff;\n    bits[1] = (codeword >> 16) & 0xff;\n    bits[2] = (codeword >> 8) & 0xff;\n    bits[3] = codeword & 0xff;\n    return bit_encode_write(be, bits, nbits);\n}\n\nint\nbit_encode_flush(bit_encode_t *be)\n{\n    if (be->bbits) {\n        fputc(be->buf, be->fh);\n        be->bbits = 0;\n    }\n    return 0;\n}\n\nint\nbuild_directory(const char *path)\n{\n    int rv;\n\n    /* Utterly failed... */\n    if (strlen(path) == 0)\n        return -1;\n\n#if defined(_WIN32) && !defined(CYGWIN)\n    else if ((rv = _mkdir(path)) == 0)\n        return 0;\n#elif defined(HAVE_SYS_STAT_H) /* Unix, Cygwin, doesn't work on MINGW */\n    else if ((rv = mkdir(path, 0777)) == 0)\n        return 0;\n#endif\n\n    /* Or, it already exists... */\n    else if (errno == EEXIST)\n        return 0;\n    else if (errno != ENOENT) {\n        E_ERROR_SYSTEM(\"Failed to create %s\", path);\n        return -1;\n    }\n    else {\n        char *dirname = ckd_salloc(path);\n        path2dirname(path, dirname);\n        build_directory(dirname);\n        ckd_free(dirname);\n\n#if defined(_WIN32) && !defined(CYGWIN)\n\treturn _mkdir(path);\n#elif defined(HAVE_SYS_STAT_H) /* Unix, Cygwin, doesn't work on MINGW */\n        return mkdir(path, 0777);\n#endif\n    }\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2001 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * profile.c -- For timing and event counting.\n *\n * **********************************************\n * CMU ARPA Speech Project\n *\n * Copyright (c) 1999 Carnegie Mellon University.\n * ALL RIGHTS RESERVED.\n * **********************************************\n * \n * HISTORY\n * $Log: profile.c,v $\n * Revision 1.7  2005/06/22 03:10:59  arthchan2003\n * 1, Fixed doxygen documentation, 2, Added  keyword.\n *\n * Revision 1.3  2005/03/30 01:22:48  archan\n * Fixed mistakes in last updates. Add\n *\n * \n * 11-Mar-1999\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tAdded ptmr_init().\n * \n * 19-Jun-97\tM K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon University\n * \t\tCreated.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n# include <windows.h>\n# ifndef _WIN32_WCE\n#  include <time.h>\n# endif\n#elif defined(HAVE_UNISTD_H) /* I know this, this is Unix... */\n# include <unistd.h>\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (disable: 4996)\n#endif\n\n#include \"sphinxbase/profile.h\"\n#include \"sphinxbase/err.h\"\n#include \"sphinxbase/ckd_alloc.h\"\n\n#if defined(_WIN32_WCE) || defined(_WIN32_WP)\nDWORD unlink(const char *filename)\n{\n\tWCHAR *wfilename;\n\tDWORD rv;\n\tsize_t len;\n\n\tlen = mbstowcs(NULL, filename, 0);\n\twfilename = ckd_calloc(len+1, sizeof(*wfilename));\n\tmbstowcs(wfilename, filename, len);\n\trv = DeleteFileW(wfilename);\n\tckd_free(wfilename);\n\n\treturn rv;\n}\n#endif\n\npctr_t *\npctr_new(char *nm)\n{\n    pctr_t *pc;\n\n    pc = ckd_calloc(1, sizeof(pctr_t));\n    pc->name = ckd_salloc(nm);\n    pc->count = 0;\n\n    return pc;\n}\n\nvoid\npctr_reset(pctr_t * ctr)\n{\n    ctr->count = 0;\n}\n\n\nvoid\npctr_increment(pctr_t * ctr, int32 inc)\n{\n    ctr->count += inc;\n    /*   E_INFO(\"Name %s, Count %d, inc %d\\n\",ctr->name, ctr->count, inc); */\n}\n\nvoid\npctr_print(FILE * fp, pctr_t * ctr)\n{\n    fprintf(fp, \"CTR:\");\n    fprintf(fp, \"[%d %s]\", ctr->count, ctr->name);\n}\n\nvoid\npctr_free(pctr_t * pc)\n{\n    if (pc) {\n        if (pc->name)\n            ckd_free(pc->name);\n    }\n    ckd_free(pc);\n}\n\n\n#if defined(_WIN32) && !defined(GNUWINCE) && !defined(__SYMBIAN32__)\n\n#define TM_LOWSCALE\t1e-7\n#define TM_HIGHSCALE\t(4294967296.0 * TM_LOWSCALE);\n\nstatic float64\nmake_sec(FILETIME * tm)\n{\n    float64 dt;\n\n    dt = tm->dwLowDateTime * TM_LOWSCALE;\n    dt += tm->dwHighDateTime * TM_HIGHSCALE;\n\n    return (dt);\n}\n\n#else /* NOT WINDOWS */\n\nstatic float64\nmake_sec(struct timeval *s)\n{\n    return (s->tv_sec + s->tv_usec * 0.000001);\n}\n\n#endif\n\n\nvoid\nptmr_start(ptmr_t * tm)\n{\n#if (! defined(_WIN32)) || defined(GNUWINCE) || defined(__SYMBIAN32__)\n    struct timeval e_start;     /* Elapsed time */\n\n#if (! defined(_HPUX_SOURCE))  && (! defined(__SYMBIAN32__))\n    struct rusage start;        /* CPU time */\n\n    /* Unix but not HPUX */\n    getrusage(RUSAGE_SELF, &start);\n    tm->start_cpu = make_sec(&start.ru_utime) + make_sec(&start.ru_stime);\n#endif\n    /* Unix + HP */\n    gettimeofday(&e_start, 0);\n    tm->start_elapsed = make_sec(&e_start);\n#elif defined(_WIN32_WP)\n    tm->start_cpu = GetTickCount64() / 1000;\n    tm->start_elapsed = GetTickCount64() / 1000;\n#elif defined(_WIN32_WCE)\n    /* No GetProcessTimes() on WinCE.  (Note CPU time will be bogus) */\n    tm->start_cpu = GetTickCount() / 1000;\n    tm->start_elapsed = GetTickCount() / 1000;\n#else\n    HANDLE pid;\n    FILETIME t_create, t_exit, kst, ust;\n\n    /* PC */\n    pid = GetCurrentProcess();\n    GetProcessTimes(pid, &t_create, &t_exit, &kst, &ust);\n    tm->start_cpu = make_sec(&ust) + make_sec(&kst);\n\n    tm->start_elapsed = (float64) clock() / CLOCKS_PER_SEC;\n#endif\n}\n\n\nvoid\nptmr_stop(ptmr_t * tm)\n{\n    float64 dt_cpu, dt_elapsed;\n\n#if (! defined(_WIN32)) || defined(GNUWINCE) || defined(__SYMBIAN32__)\n    struct timeval e_stop;      /* Elapsed time */\n\n#if (! defined(_HPUX_SOURCE))  && (! defined(__SYMBIAN32__))\n    struct rusage stop;         /* CPU time */\n\n    /* Unix but not HPUX */\n    getrusage(RUSAGE_SELF, &stop);\n    dt_cpu =\n        make_sec(&stop.ru_utime) + make_sec(&stop.ru_stime) -\n        tm->start_cpu;\n#else\n    dt_cpu = 0.0;\n#endif\n    /* Unix + HP */\n    gettimeofday(&e_stop, 0);\n    dt_elapsed = (make_sec(&e_stop) - tm->start_elapsed);\n#elif defined(_WIN32_WP)\n    dt_cpu = GetTickCount64() / 1000 - tm->start_cpu;\n    dt_elapsed = GetTickCount64() / 1000 - tm->start_elapsed;\n#elif defined(_WIN32_WCE)\n    /* No GetProcessTimes() on WinCE.  (Note CPU time will be bogus) */\n    dt_cpu = GetTickCount() / 1000 - tm->start_cpu;\n    dt_elapsed = GetTickCount() / 1000 - tm->start_elapsed;\n#else\n    HANDLE pid;\n    FILETIME t_create, t_exit, kst, ust;\n\n    /* PC */\n    pid = GetCurrentProcess();\n    GetProcessTimes(pid, &t_create, &t_exit, &kst, &ust);\n    dt_cpu = make_sec(&ust) + make_sec(&kst) - tm->start_cpu;\n    dt_elapsed = ((float64) clock() / CLOCKS_PER_SEC) - tm->start_elapsed;\n#endif\n\n    tm->t_cpu += dt_cpu;\n    tm->t_elapsed += dt_elapsed;\n\n    tm->t_tot_cpu += dt_cpu;\n    tm->t_tot_elapsed += dt_elapsed;\n}\n\n\nvoid\nptmr_reset(ptmr_t * tm)\n{\n    tm->t_cpu = 0.0;\n    tm->t_elapsed = 0.0;\n}\n\n\nvoid\nptmr_init(ptmr_t * tm)\n{\n    tm->t_cpu = 0.0;\n    tm->t_elapsed = 0.0;\n    tm->t_tot_cpu = 0.0;\n    tm->t_tot_elapsed = 0.0;\n}\n\n\nvoid\nptmr_reset_all(ptmr_t * tm)\n{\n    for (; tm->name; tm++)\n        ptmr_reset(tm);\n}\n\n\nvoid\nptmr_print_all(FILE * fp, ptmr_t * tm, float64 norm)\n{\n    if (norm != 0.0) {\n        norm = 1.0 / norm;\n        for (; tm->name; tm++)\n            fprintf(fp, \"  %6.2fx %s\", tm->t_cpu * norm, tm->name);\n    }\n}\n\n\nint32\nhost_endian(void)\n{\n    FILE *fp;\n    int32 BYTE_ORDER_MAGIC;\n    char *file;\n    char buf[8];\n    int32 k, endian;\n\n    file = \"/tmp/__EnDiAn_TeSt__\";\n\n    if ((fp = fopen(file, \"wb\")) == NULL) {\n        E_ERROR(\"Failed to open file '%s' for writing\", file);\n        return -1;\n    }\n\n    BYTE_ORDER_MAGIC = (int32) 0x11223344;\n\n    k = (int32) BYTE_ORDER_MAGIC;\n    if (fwrite(&k, sizeof(int32), 1, fp) != 1) {\n        E_ERROR(\"Failed to write to file '%s'\\n\", file);\n        fclose(fp);\n        unlink(file);\n        return -1;\n    }\n\n    fclose(fp);\n    if ((fp = fopen(file, \"rb\")) == NULL) {\n        E_ERROR_SYSTEM(\"Failed to open file '%s' for reading\", file);\n        unlink(file);\n        return -1;\n    }\n    if (fread(buf, 1, sizeof(int32), fp) != sizeof(int32)) {\n        E_ERROR(\"Failed to read from file '%s'\\n\", file);\n        fclose(fp);\n        unlink(file);\n        return -1;\n    }\n    fclose(fp);\n    unlink(file);\n\n    /* If buf[0] == lsB of BYTE_ORDER_MAGIC, we are little-endian */\n    endian = (buf[0] == (BYTE_ORDER_MAGIC & 0x000000ff)) ? 1 : 0;\n\n    return (endian);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 1999-2006 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n/*\n * strfuncs.c -- String functions\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdarg.h>\n\n#include \"sphinxbase/ckd_alloc.h\"\n#include \"sphinxbase/strfuncs.h\"\n\n/* Defined in dtoa.c */\ndouble sb_strtod(const char *s00, char **se);\n\ndouble\natof_c(char const *str)\n{\n    return sb_strtod(str, NULL);\n}\n\n/* Locale-independent isspace to avoid different incompatibilities */\nstatic int\nisspace_c(char ch)\n{\n    if (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r')\n\treturn 1;\n    return 0;\n}\n\nchar *\nstring_join(const char *base, ...)\n{\n    va_list args;\n    size_t len;\n    const char *c;\n    char *out;\n\n    va_start(args, base);\n    len = strlen(base);\n    while ((c = va_arg(args, const char *)) != NULL) {\n        len += strlen(c);\n    }\n    len++;\n    va_end(args);\n\n    out = ckd_calloc(len, 1);\n    va_start(args, base);\n    strcpy(out, base);\n    while ((c = va_arg(args, const char *)) != NULL) {\n        strcat(out, c);\n    }\n    va_end(args);\n\n    return out;\n}\n\nchar *\nstring_trim(char *string, enum string_edge_e which)\n{\n    size_t len;\n\n    len = strlen(string);\n    if (which == STRING_START || which == STRING_BOTH) {\n        size_t sub = strspn(string, \" \\t\\n\\r\\f\");\n        if (sub > 0) {\n            memmove(string, string + sub, len + 1 - sub);\n            len -= sub;\n        }\n    }\n    if (which == STRING_END || which == STRING_BOTH) {\n        long sub = len;\n        while (--sub >= 0)\n            if (strchr(\" \\t\\n\\r\\f\", string[sub]) == NULL)\n                break;\n        if (sub == -1)\n            string[0] = '\\0';\n        else\n            string[sub+1] = '\\0';\n    }\n    return string;\n}\n\nint32\nstr2words(char *line, char **ptr, int32 max_ptr)\n{\n    int32 i, n;\n\n    n = 0;                      /* #words found so far */\n    i = 0;                      /* For scanning through the input string */\n    while (1) {\n        /* Skip whitespace before next word */\n        while (line[i] && isspace_c(line[i]))\n            ++i;\n        if (!line[i])\n            break;\n\n        if (ptr != NULL && n >= max_ptr) {\n            /*\n             * Pointer array size insufficient.  Restore NULL chars inserted so far\n             * to space chars.  Not a perfect restoration, but better than nothing.\n             */\n            for (; i >= 0; --i)\n                if (line[i] == '\\0')\n                    line[i] = ' ';\n\n            return -1;\n        }\n\n        /* Scan to end of word */\n        if (ptr != NULL)\n            ptr[n] = line + i;\n        ++n;\n        while (line[i] && !isspace_c(line[i]))\n            ++i;\n        if (!line[i])\n            break;\n        if (ptr != NULL)\n            line[i] = '\\0';\n        ++i;\n    }\n\n    return n;\n}\n\n\nint32\nnextword(char *line, const char *delim, char **word, char *delimfound)\n{\n    const char *d;\n    char *w;\n\n    /* Skip past any preceding delimiters */\n    for (w = line; *w; w++) {\n        for (d = delim; *d && (*d != *w); d++);\n        if (!*d)\n            break;\n    }\n    if (!*w)\n        return -1;\n\n    *word = w;                  /* Beginning of word */\n\n    /* Skip until first delimiter char */\n    for (w++; *w; w++) {\n        for (d = delim; *d && (*d != *w); d++);\n        if (*d)\n            break;\n    }\n\n    /* Replace delimiter with NULL char, but return the original first */\n    *delimfound = *w;\n    *w = '\\0';\n\n    return (w - *word);\n}\n","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2015 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n/*\n * bitarr.c -- Bit array manipulations implementation.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n#include \"sphinxbase/bitarr.h\"\n\n#define SIGN_BIT (0x80000000)\n\n/**\n * Shift bits depending on byte order in system.\n * Fun fact: __BYTE_ORDER is wrong on Solaris Sparc, but the version without __ is correct.\n * @param bit is an offset last byte\n * @param length - amount of bits for required for digit that is going to be read\n * @return shift forgiven architecture\n */\nstatic uint8 get_shift(uint8 bit, uint8 length)\n{\n#ifdef WORDS_BIGENDIAN\n    return 64 - length - bit;\n#else\n    return bit;\n#endif\n}\n\n/**\n * Read uint64 value from the given address\n * @param address to read from\n * @return uint64 value that was read\n */\nstatic uint64 read_off(bitarr_address_t address)\n{\n#if defined(__arm) || defined(__arm__)\n    uint64 value64;\n    const uint8 *base_off = (const uint8 *)(address.base) + (address.offset >> 3);\n    memcpy(&value64, base_off, sizeof(value64));\n    return value64;\n#else\n    return *(const uint64*)((const uint8 *)(address.base) + (address.offset >> 3));\n#endif\n}\n\nuint64 bitarr_read_int57(bitarr_address_t address, uint8 length, uint64 mask)\n{\n    return (read_off(address) >> get_shift(address.offset & 7, length)) & mask;\n}\n\nvoid bitarr_write_int57(bitarr_address_t address, uint8 length, uint64 value) \n{\n#if defined(__arm) || defined(__arm__)\n    uint64 value64;\n    uint8 *base_off = (uint8 *)(address.base) + (address.offset >> 3);\n    memcpy(&value64, base_off, sizeof(value64));\n    value64 |= (value << get_shift(address.offset & 7, length));\n    memcpy(base_off, &value64, sizeof(value64));\n#else\n    *(uint64 *)((uint8 *)(address.base) + (address.offset >> 3)) |= (value << get_shift(address.offset & 7, length));\n#endif\n}\n\nuint32 bitarr_read_int25(bitarr_address_t address, uint8 length, uint32 mask) \n{\n#if defined(__arm) || defined(__arm__)\n    uint32 value32;\n    const uint8 *base_off = (const uint8*)(address.base) + (address.offset >> 3);\n    memcpy(&value32, base_off, sizeof(value32));\n    return (value32 >> get_shift(address.offset & 7, length)) & mask;\n#else\n    return (*(const uint32*)((const uint8*)(address.base) + (address.offset >> 3)) >> get_shift(address.offset & 7, length)) & mask;\n#endif\n}\n\nvoid bitarr_write_int25(bitarr_address_t address, uint8 length, uint32 value)\n{\n#if defined(__arm) || defined(__arm__)\n    uint32 value32;\n    uint8 *base_off = (uint8 *)(address.base) + (address.offset >> 3);\n    memcpy(&value32, base_off, sizeof(value32));\n    value32 |= (value << get_shift(address.offset & 7, length));\n    memcpy(base_off, &value32, sizeof(value32));\n#else\n    *(uint32 *)((uint8 *)(address.base) + (address.offset >> 3)) |= (value << get_shift(address.offset & 7, length));\n#endif\n}\n\nvoid bitarr_mask_from_max(bitarr_mask_t *bit_mask, uint32 max_value)\n{\n    bit_mask->bits = bitarr_required_bits(max_value);\n    bit_mask->mask = (uint32)((1ULL << bit_mask->bits) - 1);\n}\n\nuint8 bitarr_required_bits(uint32 max_value)\n{\n    uint8 res;\n\n    if (!max_value) return 0;\n    res = 1;\n    while (max_value >>= 1) res++;\n    return res;\n}","/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* ====================================================================\n * Copyright (c) 2015 Carnegie Mellon University.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * This work was supported in part by funding from the Defense Advanced \n * Research Projects Agency and the National Science Foundation of the \n * United States of America, and the CMU Sphinx Speech Consortium.\n *\n * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND \n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY\n * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ====================================================================\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <sphinxbase/priority_queue.h>\n#include <sphinxbase/ckd_alloc.h>\n#include <sphinxbase/err.h>\n\nstruct priority_queue_s {\n    void **pointers;\n    size_t alloc_size;\n    size_t size;\n    void *max_element;\n    int (*compare)(const void *a, const void *b);\n};\n\npriority_queue_t* priority_queue_create(size_t len, int (*compare)(const void *a, const void *b))\n{\n    priority_queue_t* queue;\n\n    queue = (priority_queue_t *)ckd_calloc(1, sizeof(*queue));\n    queue->alloc_size = len;\n    queue->pointers = (void **)ckd_calloc(len, sizeof(*queue->pointers));\n    queue->size = 0;\n    queue->max_element = NULL;\n    queue->compare = compare;\n\n    return queue;\n}\n\nvoid* priority_queue_poll(priority_queue_t *queue)\n{\n    \n    size_t i;\n    void *res;\n\n    if (queue->size == 0) {\n        E_WARN(\"Trying to poll from empty queue\\n\");\n        return NULL;\n    }\n    if (queue->max_element == NULL) {\n        E_ERROR(\"Trying to poll from queue and max element is undefined\\n\");\n        return NULL;\n    }\n    res = queue->max_element;\n    for (i = 0; i < queue->alloc_size; i++) {\n        if (queue->pointers[i] == queue->max_element) {\n            queue->pointers[i] = NULL;\n            break;\n        }\n    }\n    queue->max_element = NULL;\n    for (i = 0; i < queue->alloc_size; i++) {\n        if (queue->pointers[i] == 0)\n            continue;\n        if (queue->max_element == NULL) {\n            queue->max_element = queue->pointers[i];\n        } else {\n            if (queue->compare(queue->pointers[i], queue->max_element) < 0)\n                queue->max_element = queue->pointers[i];\n        }\n    }\n    queue->size--;\n    return res;\n}\n\nvoid priority_queue_add(priority_queue_t *queue, void *element)\n{\n    size_t i;\n    if (queue->size == queue->alloc_size) {\n        E_ERROR(\"Trying to add element into full queue\\n\");\n        return;\n    }\n    for (i = 0; i < queue->alloc_size; i++) {\n        if (queue->pointers[i] == NULL) {\n            queue->pointers[i] = element;\n            break;\n        }\n    }\n\n    if (queue->max_element == NULL || queue->compare(element, queue->max_element) < 0) {\n        queue->max_element = element;\n    }\n    queue->size++;\n}\n\nsize_t priority_queue_size(priority_queue_t *queue)\n{\n    return queue->size;\n}\n\nvoid priority_queue_free(priority_queue_t *queue, void (*free_ptr)(void *a))\n{\n    size_t i;\n\n    for (i = 0; i < queue->alloc_size; i++) {\n        if (queue->pointers[i] != NULL) {\n            if (free_ptr == NULL) {\n                ckd_free(queue->pointers[i]);\n            } else {\n                free_ptr(queue->pointers[i]);\n            }\n        }\n    }\n    ckd_free(queue->pointers);\n    ckd_free(queue);\n}\n","#include <emscripten/bind.h>\n#ifdef USE_CXA_DEMANGLE\n#include <../lib/libcxxabi/include/cxxabi.h>\n#endif\n#include <list>\n#include <vector>\n#include <typeinfo>\n#include <algorithm>\n#include <emscripten/emscripten.h>\n#include <emscripten/wire.h>\n#include <climits>\n#include <limits>\n\nusing namespace emscripten;\n\nextern \"C\" {\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\n        if (has_unbound_type_names) {\n#ifdef USE_CXA_DEMANGLE\n            int stat;\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\n            if (stat == 0 && demangled) {\n                return demangled;\n            }\n\n            switch (stat) {\n                case -1:\n                    return strdup(\"<allocation failure>\");\n                case -2:\n                    return strdup(\"<invalid C++ symbol>\");\n                case -3:\n                    return strdup(\"<invalid argument>\");\n                default:\n                    return strdup(\"<unknown error>\");\n            }\n#else\n            return strdup(ti->name());\n#endif\n        } else {\n            char str[80];\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\n            return strdup(str);\n        }\n    }\n}\n\nnamespace {\n    template<typename T>\n    static void register_integer(const char* name) {\n        using namespace internal;\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\n    }\n\n    template<typename T>\n    static void register_float(const char* name) {\n        using namespace internal;\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\n    }\n\n\n    // matches typeMapping in embind.js\n    enum TypedArrayIndex {\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n    };\n\n    template<typename T>\n    constexpr TypedArrayIndex getTypedArrayIndex() {\n        static_assert(internal::typeSupportsMemoryView<T>(),\n            \"type does not map to a typed array\");\n        return std::is_floating_point<T>::value\n            ? (sizeof(T) == 4\n               ? Float32Array\n               : Float64Array)\n            : (sizeof(T) == 1\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\n               : (sizeof(T) == 2\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\n    }\n\n    template<typename T>\n    static void register_memory_view(const char* name) {\n        using namespace internal;\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\n    }\n}\n\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\n    using namespace emscripten::internal;\n\n    _embind_register_void(TypeID<void>::get(), \"void\");\n\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\n\n    register_integer<char>(\"char\");\n    register_integer<signed char>(\"signed char\");\n    register_integer<unsigned char>(\"unsigned char\");\n    register_integer<signed short>(\"short\");\n    register_integer<unsigned short>(\"unsigned short\");\n    register_integer<signed int>(\"int\");\n    register_integer<unsigned int>(\"unsigned int\");\n    register_integer<signed long>(\"long\");\n    register_integer<unsigned long>(\"unsigned long\");\n\n    register_float<float>(\"float\");\n    register_float<double>(\"double\");\n\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\n\n    // Some of these types are aliases for each other. Luckily,\n    // embind.js's _embind_register_memory_view ignores duplicate\n    // registrations rather than asserting, so the first\n    // register_memory_view call for a particular type will take\n    // precedence.\n\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\n\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\n\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\n\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\n#if __SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n    const char* __type_name;\n#else\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        : __type_name(__n) {}\n#else\n        : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name;}\n#else\n        {return reinterpret_cast<const char*>(__type_name & ~_LIBCPP_NONUNIQUE_RTTI_BIT);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name < __arg.__type_name;}\n#else\n        {if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return __type_name < __arg.__type_name;\n         return __compare_nonunique_names(__arg) < 0;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n#else\n        {if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT)) return __type_name;\n         const char *__ptr = name();\n         size_t __hash = 5381;\n         while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n           __hash = (__hash * 33) ^ __c;\n         return __hash;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name == __arg.__type_name;}\n#else\n        {if (__type_name == __arg.__type_name) return true;\n         if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return false;\n         return __compare_nonunique_names(__arg) == 0;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n#ifdef _LIBCPP_NONUNIQUE_RTTI_BIT\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n        {return __builtin_strcmp(name(), __arg.name());}\n#endif\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n"]}